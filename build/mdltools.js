var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target2, all) => {
  for (var name in all)
    __defProp(target2, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/cbor-x/decode.js
function checkedRead() {
  try {
    let result = read();
    if (bundledStrings) {
      if (position >= bundledStrings.postBundlePosition) {
        let error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position == srcEnd) {
      currentStructures = null;
      src = null;
      if (referenceMap)
        referenceMap = null;
    } else if (position > srcEnd) {
      let error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read() {
  let token = src[position++];
  let majorType = token >> 5;
  token = token & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        if (majorType == 7) {
          return getFloat16();
        }
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        if (majorType == 7) {
          let value = dataView.getFloat32(position);
          if (currentDecoder.useFloat32 > 2) {
            let multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];
            position += 4;
            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position += 4;
          return value;
        }
        token = dataView.getUint32(position);
        position += 4;
        break;
      case 27:
        if (majorType == 7) {
          let value = dataView.getFloat64(position);
          position += 8;
          return value;
        }
        if (majorType > 1) {
          if (dataView.getUint32(position) > 0)
            throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          token = dataView.getUint32(position + 4);
        } else if (currentDecoder.int64AsNumber) {
          token = dataView.getUint32(position) * 4294967296;
          token += dataView.getUint32(position + 4);
        } else
          token = dataView.getBigUint64(position);
        position += 8;
        break;
      case 31:
        switch (majorType) {
          case 2:
          case 3:
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4:
            let array = [];
            let value, i = 0;
            while ((value = read()) != STOP_CODE) {
              array[i++] = value;
            }
            return majorType == 4 ? array : majorType == 3 ? array.join("") : Buffer.concat(array);
          case 5:
            let key;
            if (currentDecoder.mapsAsObjects) {
              let object = {};
              if (currentDecoder.keyMap)
                while ((key = read()) != STOP_CODE)
                  object[safeKey(currentDecoder.decodeKey(key))] = read();
              else
                while ((key = read()) != STOP_CODE)
                  object[safeKey(key)] = read();
              return object;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = /* @__PURE__ */ new Map();
              if (currentDecoder.keyMap)
                while ((key = read()) != STOP_CODE)
                  map.set(currentDecoder.decodeKey(key), read());
              else
                while ((key = read()) != STOP_CODE)
                  map.set(key, read());
              return map;
            }
          case 7:
            return STOP_CODE;
          default:
            throw new Error("Invalid major type for indefinite length " + majorType);
        }
      default:
        throw new Error("Unknown token " + token);
    }
  }
  switch (majorType) {
    case 0:
      return token;
    case 1:
      return ~token;
    case 2:
      return readBin(token);
    case 3:
      if (srcStringEnd >= position) {
        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string != null)
          return string;
      }
      return readFixedString(token);
    case 4:
      let array = new Array(token);
      for (let i = 0; i < token; i++)
        array[i] = read();
      return array;
    case 5:
      if (currentDecoder.mapsAsObjects) {
        let object = {};
        if (currentDecoder.keyMap)
          for (let i = 0; i < token; i++)
            object[safeKey(currentDecoder.decodeKey(read()))] = read();
        else
          for (let i = 0; i < token; i++)
            object[safeKey(read())] = read();
        return object;
      } else {
        if (restoreMapsAsObject) {
          currentDecoder.mapsAsObjects = true;
          restoreMapsAsObject = false;
        }
        let map = /* @__PURE__ */ new Map();
        if (currentDecoder.keyMap)
          for (let i = 0; i < token; i++)
            map.set(currentDecoder.decodeKey(read()), read());
        else
          for (let i = 0; i < token; i++)
            map.set(read(), read());
        return map;
      }
    case 6:
      if (token >= BUNDLED_STRINGS_ID) {
        let structure = currentStructures[token & 8191];
        if (structure) {
          if (!structure.read)
            structure.read = createStructureReader(structure);
          return structure.read();
        }
        if (token < 65536) {
          if (token == RECORD_INLINE_ID) {
            let length = readJustLength();
            let id = read();
            let structure2 = read();
            recordDefinition(id, structure2);
            let object = {};
            if (currentDecoder.keyMap)
              for (let i = 2; i < length; i++) {
                let key = currentDecoder.decodeKey(structure2[i - 2]);
                object[safeKey(key)] = read();
              }
            else
              for (let i = 2; i < length; i++) {
                let key = structure2[i - 2];
                object[safeKey(key)] = read();
              }
            return object;
          } else if (token == RECORD_DEFINITIONS_ID) {
            let length = readJustLength();
            let id = read();
            for (let i = 2; i < length; i++) {
              recordDefinition(id++, read());
            }
            return read();
          } else if (token == BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            structure = currentStructures[token & 8191];
            if (structure) {
              if (!structure.read)
                structure.read = createStructureReader(structure);
              return structure.read();
            }
          }
        }
      }
      let extension = currentExtensions[token];
      if (extension) {
        if (extension.handlesRead)
          return extension(read);
        else
          return extension(read());
      } else {
        let input = read();
        for (let i = 0; i < currentExtensionRanges.length; i++) {
          let value = currentExtensionRanges[i](token, input);
          if (value !== void 0)
            return value;
        }
        return new Tag(input, token);
      }
    case 7:
      switch (token) {
        case 20:
          return false;
        case 21:
          return true;
        case 22:
          return null;
        case 23:
          return;
        case 31:
        default:
          let packedValue = (packedValues || getPackedValues())[token];
          if (packedValue !== void 0)
            return packedValue;
          throw new Error("Unknown token " + token);
      }
    default:
      if (isNaN(token)) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error("Unknown CBOR token " + token);
  }
}
function createStructureReader(structure) {
  function readObject() {
    let length = src[position++];
    length = length & 31;
    if (length > 23) {
      switch (length) {
        case 24:
          length = src[position++];
          break;
        case 25:
          length = dataView.getUint16(position);
          position += 2;
          break;
        case 26:
          length = dataView.getUint32(position);
          position += 4;
          break;
        default:
          throw new Error("Expected array header, but got " + src[position - 1]);
      }
    }
    let compiledReader = this.compiledReader;
    while (compiledReader) {
      if (compiledReader.propertyCount === length)
        return compiledReader(read);
      compiledReader = compiledReader.next;
    }
    if (this.slowReads++ >= inlineObjectReadThreshold) {
      let array = this.length == length ? this : this.slice(0, length);
      compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map((key) => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
      if (this.compiledReader)
        compiledReader.next = this.compiledReader;
      compiledReader.propertyCount = length;
      this.compiledReader = compiledReader;
      return compiledReader(read);
    }
    let object = {};
    if (currentDecoder.keyMap)
      for (let i = 0; i < length; i++)
        object[safeKey(currentDecoder.decodeKey(this[i]))] = read();
    else
      for (let i = 0; i < length; i++) {
        object[safeKey(this[i])] = read();
      }
    return object;
  }
  structure.slowReads = 0;
  return readObject;
}
function safeKey(key) {
  return key === "__proto__" ? "__proto_" : key;
}
function readStringJS(length) {
  let result;
  if (length < 16) {
    if (result = shortStringInJS(length))
      return result;
  }
  if (length > 64 && decoder)
    return decoder.decode(src.subarray(position, position += length));
  const end = position + length;
  const units = [];
  result = "";
  while (position < end) {
    const byte1 = src[position++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      const byte4 = src[position++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
function longStringInJS(length) {
  let start = position;
  let bytes = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0)
        return "";
      else {
        let a = src[position++];
        if ((a & 128) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position -= 2;
        return;
      }
      if (length < 3)
        return fromCharCode(a, b);
      let c = src[position++];
      if ((c & 128) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src[position++];
    let b = src[position++];
    let c = src[position++];
    let d = src[position++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
      position -= 4;
      return;
    }
    if (length < 6) {
      if (length === 4)
        return fromCharCode(a, b, c, d);
      else {
        let e = src[position++];
        if ((e & 128) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length < 8) {
      let e = src[position++];
      let f = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0) {
        position -= 6;
        return;
      }
      if (length < 7)
        return fromCharCode(a, b, c, d, e, f);
      let g = src[position++];
      if ((g & 128) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f, g);
    } else {
      let e = src[position++];
      let f = src[position++];
      let g = src[position++];
      let h = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
        position -= 8;
        return;
      }
      if (length < 10) {
        if (length === 8)
          return fromCharCode(a, b, c, d, e, f, g, h);
        else {
          let i = src[position++];
          if ((i & 128) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i);
        }
      } else if (length < 12) {
        let i = src[position++];
        let j = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position -= 10;
          return;
        }
        if (length < 11)
          return fromCharCode(a, b, c, d, e, f, g, h, i, j);
        let k = src[position++];
        if ((k & 128) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
      } else {
        let i = src[position++];
        let j = src[position++];
        let k = src[position++];
        let l = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position -= 12;
          return;
        }
        if (length < 14) {
          if (length === 12)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
          else {
            let m = src[position++];
            if ((m & 128) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
          }
        } else {
          let m = src[position++];
          let n = src[position++];
          if ((m & 128) > 0 || (n & 128) > 0) {
            position -= 14;
            return;
          }
          if (length < 15)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
          let o = src[position++];
          if ((o & 128) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
function readBin(length) {
  return currentDecoder.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position, position += length)
  ) : src.subarray(position, position += length);
}
function getFloat16() {
  let byte0 = src[position++];
  let byte1 = src[position++];
  let exponent = (byte0 & 127) >> 2;
  if (exponent === 31) {
    if (byte1 || byte0 & 3)
      return NaN;
    return byte0 & 128 ? -Infinity : Infinity;
  }
  if (exponent === 0) {
    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
    return byte0 & 128 ? -abs : abs;
  }
  u8Array[3] = byte0 & 128 | // sign bit
  (exponent >> 1) + 56;
  u8Array[2] = (byte0 & 7) << 5 | // last exponent bit and first two mantissa bits
  byte1 >> 3;
  u8Array[1] = byte1 << 5;
  u8Array[0] = 0;
  return f32Array[0];
}
function combine(a, b) {
  if (typeof a === "string")
    return a + b;
  if (a instanceof Array)
    return a.concat(b);
  return Object.assign({}, a, b);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared)
      loadShared();
    else
      throw new Error("No packed values available");
  }
  return packedValues;
}
function registerTypedArray(TypedArray, tag) {
  let dvMethod = "get" + TypedArray.name.slice(0, -5);
  let bytesPerElement;
  if (typeof TypedArray === "function")
    bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
  else
    TypedArray = null;
  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
    if (!littleEndian && bytesPerElement == 1)
      continue;
    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer) => {
      if (!TypedArray)
        throw new Error("Could not find typed array for code " + tag);
      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
    } : (buffer) => {
      if (!TypedArray)
        throw new Error("Could not find typed array for code " + tag);
      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      let elements = buffer.length >> sizeShift;
      let ta = new TypedArray(elements);
      let method = dv[dvMethod];
      for (let i = 0; i < elements; i++) {
        ta[i] = method.call(dv, i << sizeShift, littleEndian);
      }
      return ta;
    };
  }
}
function readBundleExt() {
  let length = readJustLength();
  let bundlePosition = position + read();
  for (let i = 2; i < length; i++) {
    let bundleLength = readJustLength();
    position += bundleLength;
  }
  let dataPosition = position;
  position = bundlePosition;
  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read();
}
function readJustLength() {
  let token = src[position++] & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      case 25:
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 26:
        token = dataView.getUint32(position);
        position += 4;
        break;
    }
  }
  return token;
}
function loadShared() {
  if (currentDecoder.getShared) {
    let sharedData = saveState(() => {
      src = null;
      return currentDecoder.getShared();
    }) || {};
    let updatedStructures = sharedData.structures || [];
    currentDecoder.sharedVersion = sharedData.version;
    packedValues = currentDecoder.sharedValues = sharedData.packedValues;
    if (currentStructures === true)
      currentDecoder.structures = currentStructures = updatedStructures;
    else
      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
  }
}
function saveState(callback) {
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedStringPosition = stringPosition;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedStrings = strings;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;
  let savedSrc = new Uint8Array(src.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedDecoder = currentDecoder;
  let savedSequentialMode = sequentialMode;
  let value = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  stringPosition = savedStringPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  strings = savedStrings;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentDecoder = savedDecoder;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
function addExtension(extension) {
  currentExtensions[extension.tag] = extension.decode;
}
function roundFloat32(float32Number) {
  f32Array[0] = float32Number;
  let multiplier = mult10[(u8Array[3] & 127) << 1 | u8Array[2] >> 7];
  return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;
}
var decoder, src, srcEnd, position, EMPTY_ARRAY, LEGACY_RECORD_INLINE_ID, RECORD_DEFINITIONS_ID, RECORD_INLINE_ID, BUNDLED_STRINGS_ID, PACKED_REFERENCE_TAG_ID, STOP_CODE, strings, stringPosition, currentDecoder, currentStructures, srcString, srcStringStart, srcStringEnd, bundledStrings, referenceMap, currentExtensions, currentExtensionRanges, packedValues, dataView, restoreMapsAsObject, defaultOptions, sequentialMode, inlineObjectReadThreshold, Decoder, validName, readFixedString, isNativeAccelerationEnabled, fromCharCode, f32Array, u8Array, keyCache, Tag, recordDefinition, glbl, packedTable, SHARED_DATA_TAG_ID, isLittleEndianMachine, typedArrays, typedArrayTags, mult10, defaultDecoder, decode, decodeMultiple, FLOAT32_OPTIONS;
var init_decode = __esm({
  "node_modules/cbor-x/decode.js"() {
    try {
      decoder = new TextDecoder();
    } catch (error) {
    }
    position = 0;
    EMPTY_ARRAY = [];
    LEGACY_RECORD_INLINE_ID = 105;
    RECORD_DEFINITIONS_ID = 57342;
    RECORD_INLINE_ID = 57343;
    BUNDLED_STRINGS_ID = 57337;
    PACKED_REFERENCE_TAG_ID = 6;
    STOP_CODE = {};
    strings = EMPTY_ARRAY;
    stringPosition = 0;
    currentDecoder = {};
    srcStringStart = 0;
    srcStringEnd = 0;
    currentExtensions = [];
    currentExtensionRanges = [];
    defaultOptions = {
      useRecords: false,
      mapsAsObjects: true
    };
    sequentialMode = false;
    inlineObjectReadThreshold = 2;
    try {
      new Function("");
    } catch (error) {
      inlineObjectReadThreshold = Infinity;
    }
    Decoder = class _Decoder {
      constructor(options) {
        if (options) {
          if ((options.keyMap || options._keyMap) && !options.useRecords) {
            options.useRecords = false;
            options.mapsAsObjects = true;
          }
          if (options.useRecords === false && options.mapsAsObjects === void 0)
            options.mapsAsObjects = true;
          if (options.getStructures)
            options.getShared = options.getStructures;
          if (options.getShared && !options.structures)
            (options.structures = []).uninitialized = true;
          if (options.keyMap) {
            this.mapKey = /* @__PURE__ */ new Map();
            for (let [k, v] of Object.entries(options.keyMap))
              this.mapKey.set(v, k);
          }
        }
        Object.assign(this, options);
      }
      /*
      decodeKey(key) {
      	return this.keyMap
      		? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
      		: key
      }
      */
      decodeKey(key) {
        return this.keyMap ? this.mapKey.get(key) || key : key;
      }
      encodeKey(key) {
        return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;
      }
      encodeKeys(rec) {
        if (!this._keyMap)
          return rec;
        let map = /* @__PURE__ */ new Map();
        for (let [k, v] of Object.entries(rec))
          map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
        return map;
      }
      decodeKeys(map) {
        if (!this._keyMap || map.constructor.name != "Map")
          return map;
        if (!this._mapKey) {
          this._mapKey = /* @__PURE__ */ new Map();
          for (let [k, v] of Object.entries(this._keyMap))
            this._mapKey.set(v, k);
        }
        let res = {};
        map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);
        return res;
      }
      mapDecode(source, end) {
        let res = this.decode(source);
        if (this._keyMap) {
          switch (res.constructor.name) {
            case "Array":
              return res.map((r) => this.decodeKeys(r));
          }
        }
        return res;
      }
      decode(source, end) {
        if (src) {
          return saveState(() => {
            clearSource();
            return this ? this.decode(source, end) : _Decoder.prototype.decode.call(defaultOptions, source, end);
          });
        }
        srcEnd = end > -1 ? end : source.length;
        position = 0;
        stringPosition = 0;
        srcStringEnd = 0;
        srcString = null;
        strings = EMPTY_ARRAY;
        bundledStrings = null;
        src = source;
        try {
          dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
        } catch (error) {
          src = null;
          if (source instanceof Uint8Array)
            throw error;
          throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
        }
        if (this instanceof _Decoder) {
          currentDecoder = this;
          packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
          if (this.structures) {
            currentStructures = this.structures;
            return checkedRead();
          } else if (!currentStructures || currentStructures.length > 0) {
            currentStructures = [];
          }
        } else {
          currentDecoder = defaultOptions;
          if (!currentStructures || currentStructures.length > 0)
            currentStructures = [];
          packedValues = null;
        }
        return checkedRead();
      }
      decodeMultiple(source, forEach) {
        let values, lastPosition = 0;
        try {
          let size = source.length;
          sequentialMode = true;
          let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
          if (forEach) {
            if (forEach(value) === false) {
              return;
            }
            while (position < size) {
              lastPosition = position;
              if (forEach(checkedRead()) === false) {
                return;
              }
            }
          } else {
            values = [value];
            while (position < size) {
              lastPosition = position;
              values.push(checkedRead());
            }
            return values;
          }
        } catch (error) {
          error.lastPosition = lastPosition;
          error.values = values;
          throw error;
        } finally {
          sequentialMode = false;
          clearSource();
        }
      }
    };
    validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
    readFixedString = readStringJS;
    isNativeAccelerationEnabled = false;
    fromCharCode = String.fromCharCode;
    f32Array = new Float32Array(1);
    u8Array = new Uint8Array(f32Array.buffer, 0, 4);
    keyCache = new Array(4096);
    Tag = class {
      constructor(value, tag) {
        this.value = value;
        this.tag = tag;
      }
    };
    currentExtensions[0] = (dateString) => {
      return new Date(dateString);
    };
    currentExtensions[1] = (epochSec) => {
      return new Date(Math.round(epochSec * 1e3));
    };
    currentExtensions[2] = (buffer) => {
      let value = BigInt(0);
      for (let i = 0, l = buffer.byteLength; i < l; i++) {
        value = BigInt(buffer[i]) + value << BigInt(8);
      }
      return value;
    };
    currentExtensions[3] = (buffer) => {
      return BigInt(-1) - currentExtensions[2](buffer);
    };
    currentExtensions[4] = (fraction) => {
      return +(fraction[1] + "e" + fraction[0]);
    };
    currentExtensions[5] = (fraction) => {
      return fraction[1] * Math.exp(fraction[0] * Math.log(2));
    };
    recordDefinition = (id, structure) => {
      id = id - 57344;
      let existingStructure = currentStructures[id];
      if (existingStructure && existingStructure.isShared) {
        (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
      }
      currentStructures[id] = structure;
      structure.read = createStructureReader(structure);
    };
    currentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {
      let length = data.length;
      let structure = data[1];
      recordDefinition(data[0], structure);
      let object = {};
      for (let i = 2; i < length; i++) {
        let key = structure[i - 2];
        object[safeKey(key)] = data[i];
      }
      return object;
    };
    currentExtensions[14] = (value) => {
      if (bundledStrings)
        return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
      return new Tag(value, 14);
    };
    currentExtensions[15] = (value) => {
      if (bundledStrings)
        return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
      return new Tag(value, 15);
    };
    glbl = { Error, RegExp };
    currentExtensions[27] = (data) => {
      return (glbl[data[0]] || Error)(data[1], data[2]);
    };
    packedTable = (read2) => {
      if (src[position++] != 132)
        throw new Error("Packed values structure must be followed by a 4 element array");
      let newPackedValues = read2();
      packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
      packedValues.prefixes = read2();
      packedValues.suffixes = read2();
      return read2();
    };
    packedTable.handlesRead = true;
    currentExtensions[51] = packedTable;
    currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
      if (!packedValues) {
        if (currentDecoder.getShared)
          loadShared();
        else
          return new Tag(data, PACKED_REFERENCE_TAG_ID);
      }
      if (typeof data == "number")
        return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
      throw new Error("No support for non-integer packed references yet");
    };
    currentExtensions[28] = (read2) => {
      if (!referenceMap) {
        referenceMap = /* @__PURE__ */ new Map();
        referenceMap.id = 0;
      }
      let id = referenceMap.id++;
      let token = src[position];
      let target2;
      if (token >> 5 == 4)
        target2 = [];
      else
        target2 = {};
      let refEntry = { target: target2 };
      referenceMap.set(id, refEntry);
      let targetProperties = read2();
      if (refEntry.used)
        return Object.assign(target2, targetProperties);
      refEntry.target = targetProperties;
      return targetProperties;
    };
    currentExtensions[28].handlesRead = true;
    currentExtensions[29] = (id) => {
      let refEntry = referenceMap.get(id);
      refEntry.used = true;
      return refEntry.target;
    };
    currentExtensions[258] = (array) => new Set(array);
    (currentExtensions[259] = (read2) => {
      if (currentDecoder.mapsAsObjects) {
        currentDecoder.mapsAsObjects = false;
        restoreMapsAsObject = true;
      }
      return read2();
    }).handlesRead = true;
    SHARED_DATA_TAG_ID = 1399353956;
    currentExtensionRanges.push((tag, input) => {
      if (tag >= 225 && tag <= 255)
        return combine(getPackedValues().prefixes[tag - 224], input);
      if (tag >= 28704 && tag <= 32767)
        return combine(getPackedValues().prefixes[tag - 28672], input);
      if (tag >= 1879052288 && tag <= 2147483647)
        return combine(getPackedValues().prefixes[tag - 1879048192], input);
      if (tag >= 216 && tag <= 223)
        return combine(input, getPackedValues().suffixes[tag - 216]);
      if (tag >= 27647 && tag <= 28671)
        return combine(input, getPackedValues().suffixes[tag - 27639]);
      if (tag >= 1811940352 && tag <= 1879048191)
        return combine(input, getPackedValues().suffixes[tag - 1811939328]);
      if (tag == SHARED_DATA_TAG_ID) {
        return {
          packedValues,
          structures: currentStructures.slice(0),
          version: input
        };
      }
      if (tag == 55799)
        return input;
    });
    isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
    typedArrays = [
      Uint8Array,
      Uint8ClampedArray,
      Uint16Array,
      Uint32Array,
      typeof BigUint64Array == "undefined" ? { name: "BigUint64Array" } : BigUint64Array,
      Int8Array,
      Int16Array,
      Int32Array,
      typeof BigInt64Array == "undefined" ? { name: "BigInt64Array" } : BigInt64Array,
      Float32Array,
      Float64Array
    ];
    typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
    for (let i = 0; i < typedArrays.length; i++) {
      registerTypedArray(typedArrays[i], typedArrayTags[i]);
    }
    mult10 = new Array(147);
    for (let i = 0; i < 256; i++) {
      mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
    }
    defaultDecoder = new Decoder({ useRecords: false });
    decode = defaultDecoder.decode;
    decodeMultiple = defaultDecoder.decodeMultiple;
    FLOAT32_OPTIONS = {
      NEVER: 0,
      ALWAYS: 1,
      DECIMAL_ROUND: 3,
      DECIMAL_FIT: 4
    };
  }
});

// node_modules/cbor-x/encode.js
function writeEntityLength(length, majorValue) {
  if (length < 24)
    target[position2++] = majorValue | length;
  else if (length < 256) {
    target[position2++] = majorValue | 24;
    target[position2++] = length;
  } else if (length < 65536) {
    target[position2++] = majorValue | 25;
    target[position2++] = length >> 8;
    target[position2++] = length & 255;
  } else {
    target[position2++] = majorValue | 26;
    targetView.setUint32(position2, length);
    position2 += 4;
  }
}
function writeArrayHeader(length) {
  if (length < 24)
    target[position2++] = 128 | length;
  else if (length < 256) {
    target[position2++] = 152;
    target[position2++] = length;
  } else if (length < 65536) {
    target[position2++] = 153;
    target[position2++] = length >> 8;
    target[position2++] = length & 255;
  } else {
    target[position2++] = 154;
    targetView.setUint32(position2, length);
    position2 += 4;
  }
}
function isBlob(object) {
  if (object instanceof BlobConstructor)
    return true;
  let tag = object[Symbol.toStringTag];
  return tag === "Blob" || tag === "File";
}
function findRepetitiveStrings(value, packedValues2) {
  switch (typeof value) {
    case "string":
      if (value.length > 3) {
        if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues)
          return;
        let packedStatus = packedValues2.get(value);
        if (packedStatus) {
          if (++packedStatus.count == 2) {
            packedValues2.values.push(value);
          }
        } else {
          packedValues2.set(value, {
            count: 1
          });
          if (packedValues2.samplingPackedValues) {
            let status = packedValues2.samplingPackedValues.get(value);
            if (status)
              status.count++;
            else
              packedValues2.samplingPackedValues.set(value, {
                count: 1
              });
          }
        }
      }
      break;
    case "object":
      if (value) {
        if (value instanceof Array) {
          for (let i = 0, l = value.length; i < l; i++) {
            findRepetitiveStrings(value[i], packedValues2);
          }
        } else {
          let includeKeys = !packedValues2.encoder.useRecords;
          for (var key in value) {
            if (value.hasOwnProperty(key)) {
              if (includeKeys)
                findRepetitiveStrings(key, packedValues2);
              findRepetitiveStrings(value[key], packedValues2);
            }
          }
        }
      }
      break;
    case "function":
      console.log(value);
  }
}
function typedArrayEncoder(tag, size) {
  if (!isLittleEndianMachine2 && size > 1)
    tag -= 4;
  return {
    tag,
    encode: function writeExtBuffer(typedArray, encode4) {
      let length = typedArray.byteLength;
      let offset = typedArray.byteOffset || 0;
      let buffer = typedArray.buffer || typedArray;
      encode4(hasNodeBuffer ? Buffer2.from(buffer, offset, length) : new Uint8Array(buffer, offset, length));
    }
  };
}
function writeBuffer(buffer, makeRoom) {
  let length = buffer.byteLength;
  if (length < 24) {
    target[position2++] = 64 + length;
  } else if (length < 256) {
    target[position2++] = 88;
    target[position2++] = length;
  } else if (length < 65536) {
    target[position2++] = 89;
    target[position2++] = length >> 8;
    target[position2++] = length & 255;
  } else {
    target[position2++] = 90;
    targetView.setUint32(position2, length);
    position2 += 4;
  }
  if (position2 + length >= target.length) {
    makeRoom(position2 + length);
  }
  target.set(buffer.buffer ? buffer : new Uint8Array(buffer), position2);
  position2 += length;
}
function insertIds(serialized, idsToInsert) {
  let nextId;
  let distanceToMove = idsToInsert.length * 2;
  let lastEnd = serialized.length - distanceToMove;
  idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
  for (let id = 0; id < idsToInsert.length; id++) {
    let referee = idsToInsert[id];
    referee.id = id;
    for (let position3 of referee.references) {
      serialized[position3++] = id >> 8;
      serialized[position3] = id & 255;
    }
  }
  while (nextId = idsToInsert.pop()) {
    let offset = nextId.offset;
    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
    distanceToMove -= 2;
    let position3 = offset + distanceToMove;
    serialized[position3++] = 216;
    serialized[position3++] = 28;
    lastEnd = offset;
  }
  return serialized;
}
function writeBundles(start, encode4) {
  targetView.setUint32(bundledStrings2.position + start, position2 - bundledStrings2.position - start + 1);
  let writeStrings = bundledStrings2;
  bundledStrings2 = null;
  encode4(writeStrings[0]);
  encode4(writeStrings[1]);
}
function addExtension2(extension) {
  if (extension.Class) {
    if (!extension.encode)
      throw new Error("Extension has no encode function");
    extensionClasses.unshift(extension.Class);
    extensions.unshift(extension);
  }
  addExtension(extension);
}
var textEncoder, extensions, extensionClasses, Buffer2, hasNodeBuffer, ByteArrayAllocate, ByteArray, MAX_STRUCTURES, MAX_BUFFER_SIZE, throwOnIterable, target, targetView, position2, safeEnd, bundledStrings2, MAX_BUNDLE_SIZE, hasNonLatin, RECORD_SYMBOL, Encoder, SharedData, BlobConstructor, isLittleEndianMachine2, defaultEncoder, encode, encodeAsIterable, encodeAsAsyncIterable, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT, REUSE_BUFFER_MODE, RESET_BUFFER_MODE, THROW_ON_ITERABLE;
var init_encode = __esm({
  "node_modules/cbor-x/encode.js"() {
    init_decode();
    init_decode();
    init_decode();
    try {
      textEncoder = new TextEncoder();
    } catch (error) {
    }
    Buffer2 = typeof globalThis === "object" && globalThis.Buffer;
    hasNodeBuffer = typeof Buffer2 !== "undefined";
    ByteArrayAllocate = hasNodeBuffer ? Buffer2.allocUnsafeSlow : Uint8Array;
    ByteArray = hasNodeBuffer ? Buffer2 : Uint8Array;
    MAX_STRUCTURES = 256;
    MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
    position2 = 0;
    bundledStrings2 = null;
    MAX_BUNDLE_SIZE = 61440;
    hasNonLatin = /[\u0080-\uFFFF]/;
    RECORD_SYMBOL = Symbol("record-id");
    Encoder = class extends Decoder {
      constructor(options) {
        super(options);
        this.offset = 0;
        let typeBuffer;
        let start;
        let sharedStructures;
        let hasSharedUpdate;
        let structures;
        let referenceMap2;
        options = options || {};
        let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position3, maxBytes) {
          return target.utf8Write(string, position3, maxBytes);
        } : textEncoder && textEncoder.encodeInto ? function(string, position3) {
          return textEncoder.encodeInto(string, target.subarray(position3)).written;
        } : false;
        let encoder4 = this;
        let hasSharedStructures = options.structures || options.saveStructures;
        let maxSharedStructures = options.maxSharedStructures;
        if (maxSharedStructures == null)
          maxSharedStructures = hasSharedStructures ? 128 : 0;
        if (maxSharedStructures > 8190)
          throw new Error("Maximum maxSharedStructure is 8190");
        let isSequential = options.sequential;
        if (isSequential) {
          maxSharedStructures = 0;
        }
        if (!this.structures)
          this.structures = [];
        if (this.saveStructures)
          this.saveShared = this.saveStructures;
        let samplingPackedValues, packedObjectMap2, sharedValues = options.sharedValues;
        let sharedPackedObjectMap2;
        if (sharedValues) {
          sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
          for (let i = 0, l = sharedValues.length; i < l; i++) {
            sharedPackedObjectMap2[sharedValues[i]] = i;
          }
        }
        let recordIdsToRemove = [];
        let transitionsCount = 0;
        let serializationsSinceTransitionRebuild = 0;
        this.mapEncode = function(value, encodeOptions) {
          if (this._keyMap && !this._mapped) {
            switch (value.constructor.name) {
              case "Array":
                value = value.map((r) => this.encodeKeys(r));
                break;
            }
          }
          return this.encode(value, encodeOptions);
        };
        this.encode = function(value, encodeOptions) {
          if (!target) {
            target = new ByteArrayAllocate(8192);
            targetView = new DataView(target.buffer, 0, 8192);
            position2 = 0;
          }
          safeEnd = target.length - 10;
          if (safeEnd - position2 < 2048) {
            target = new ByteArrayAllocate(target.length);
            targetView = new DataView(target.buffer, 0, target.length);
            safeEnd = target.length - 10;
            position2 = 0;
          } else if (encodeOptions === REUSE_BUFFER_MODE)
            position2 = position2 + 7 & 2147483640;
          start = position2;
          if (encoder4.useSelfDescribedHeader) {
            targetView.setUint32(position2, 3654940416);
            position2 += 3;
          }
          referenceMap2 = encoder4.structuredClone ? /* @__PURE__ */ new Map() : null;
          if (encoder4.bundleStrings && typeof value !== "string") {
            bundledStrings2 = [];
            bundledStrings2.size = Infinity;
          } else
            bundledStrings2 = null;
          sharedStructures = encoder4.structures;
          if (sharedStructures) {
            if (sharedStructures.uninitialized) {
              let sharedData = encoder4.getShared() || {};
              encoder4.structures = sharedStructures = sharedData.structures || [];
              encoder4.sharedVersion = sharedData.version;
              let sharedValues2 = encoder4.sharedValues = sharedData.packedValues;
              if (sharedValues2) {
                sharedPackedObjectMap2 = {};
                for (let i = 0, l = sharedValues2.length; i < l; i++)
                  sharedPackedObjectMap2[sharedValues2[i]] = i;
              }
            }
            let sharedStructuresLength = sharedStructures.length;
            if (sharedStructuresLength > maxSharedStructures && !isSequential)
              sharedStructuresLength = maxSharedStructures;
            if (!sharedStructures.transitions) {
              sharedStructures.transitions = /* @__PURE__ */ Object.create(null);
              for (let i = 0; i < sharedStructuresLength; i++) {
                let keys = sharedStructures[i];
                if (!keys)
                  continue;
                let nextTransition, transition = sharedStructures.transitions;
                for (let j = 0, l = keys.length; j < l; j++) {
                  if (transition[RECORD_SYMBOL] === void 0)
                    transition[RECORD_SYMBOL] = i;
                  let key = keys[j];
                  nextTransition = transition[key];
                  if (!nextTransition) {
                    nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                  }
                  transition = nextTransition;
                }
                transition[RECORD_SYMBOL] = i | 1048576;
              }
            }
            if (!isSequential)
              sharedStructures.nextId = sharedStructuresLength;
          }
          if (hasSharedUpdate)
            hasSharedUpdate = false;
          structures = sharedStructures || [];
          packedObjectMap2 = sharedPackedObjectMap2;
          if (options.pack) {
            let packedValues2 = /* @__PURE__ */ new Map();
            packedValues2.values = [];
            packedValues2.encoder = encoder4;
            packedValues2.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap2 ? 16 : Infinity);
            packedValues2.objectMap = sharedPackedObjectMap2 || false;
            packedValues2.samplingPackedValues = samplingPackedValues;
            findRepetitiveStrings(value, packedValues2);
            if (packedValues2.values.length > 0) {
              target[position2++] = 216;
              target[position2++] = 51;
              writeArrayHeader(4);
              let valuesArray = packedValues2.values;
              encode4(valuesArray);
              writeArrayHeader(0);
              writeArrayHeader(0);
              packedObjectMap2 = Object.create(sharedPackedObjectMap2 || null);
              for (let i = 0, l = valuesArray.length; i < l; i++) {
                packedObjectMap2[valuesArray[i]] = i;
              }
            }
          }
          throwOnIterable = encodeOptions & THROW_ON_ITERABLE;
          try {
            if (throwOnIterable)
              return;
            encode4(value);
            if (bundledStrings2) {
              writeBundles(start, encode4);
            }
            encoder4.offset = position2;
            if (referenceMap2 && referenceMap2.idsToInsert) {
              position2 += referenceMap2.idsToInsert.length * 2;
              if (position2 > safeEnd)
                makeRoom(position2);
              encoder4.offset = position2;
              let serialized = insertIds(target.subarray(start, position2), referenceMap2.idsToInsert);
              referenceMap2 = null;
              return serialized;
            }
            if (encodeOptions & REUSE_BUFFER_MODE) {
              target.start = start;
              target.end = position2;
              return target;
            }
            return target.subarray(start, position2);
          } finally {
            if (sharedStructures) {
              if (serializationsSinceTransitionRebuild < 10)
                serializationsSinceTransitionRebuild++;
              if (sharedStructures.length > maxSharedStructures)
                sharedStructures.length = maxSharedStructures;
              if (transitionsCount > 1e4) {
                sharedStructures.transitions = null;
                serializationsSinceTransitionRebuild = 0;
                transitionsCount = 0;
                if (recordIdsToRemove.length > 0)
                  recordIdsToRemove = [];
              } else if (recordIdsToRemove.length > 0 && !isSequential) {
                for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
                  recordIdsToRemove[i][RECORD_SYMBOL] = void 0;
                }
                recordIdsToRemove = [];
              }
            }
            if (hasSharedUpdate && encoder4.saveShared) {
              if (encoder4.structures.length > maxSharedStructures) {
                encoder4.structures = encoder4.structures.slice(0, maxSharedStructures);
              }
              let returnBuffer = target.subarray(start, position2);
              if (encoder4.updateSharedData() === false)
                return encoder4.encode(value);
              return returnBuffer;
            }
            if (encodeOptions & RESET_BUFFER_MODE)
              position2 = start;
          }
        };
        this.findCommonStringsToPack = () => {
          samplingPackedValues = /* @__PURE__ */ new Map();
          if (!sharedPackedObjectMap2)
            sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
          return (options2) => {
            let threshold = options2 && options2.threshold || 4;
            let position3 = this.pack ? options2.maxPrivatePackedValues || 16 : 0;
            if (!sharedValues)
              sharedValues = this.sharedValues = [];
            for (let [key, status] of samplingPackedValues) {
              if (status.count > threshold) {
                sharedPackedObjectMap2[key] = position3++;
                sharedValues.push(key);
                hasSharedUpdate = true;
              }
            }
            while (this.saveShared && this.updateSharedData() === false) {
            }
            samplingPackedValues = null;
          };
        };
        const encode4 = (value) => {
          if (position2 > safeEnd)
            target = makeRoom(position2);
          var type = typeof value;
          var length;
          if (type === "string") {
            if (packedObjectMap2) {
              let packedPosition = packedObjectMap2[value];
              if (packedPosition >= 0) {
                if (packedPosition < 16)
                  target[position2++] = packedPosition + 224;
                else {
                  target[position2++] = 198;
                  if (packedPosition & 1)
                    encode4(15 - packedPosition >> 1);
                  else
                    encode4(packedPosition - 16 >> 1);
                }
                return;
              } else if (samplingPackedValues && !options.pack) {
                let status = samplingPackedValues.get(value);
                if (status)
                  status.count++;
                else
                  samplingPackedValues.set(value, {
                    count: 1
                  });
              }
            }
            let strLength = value.length;
            if (bundledStrings2 && strLength >= 4 && strLength < 1024) {
              if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
                let extStart;
                let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
                if (position2 + maxBytes2 > safeEnd)
                  target = makeRoom(position2 + maxBytes2);
                target[position2++] = 217;
                target[position2++] = 223;
                target[position2++] = 249;
                target[position2++] = bundledStrings2.position ? 132 : 130;
                target[position2++] = 26;
                extStart = position2 - start;
                position2 += 4;
                if (bundledStrings2.position) {
                  writeBundles(start, encode4);
                }
                bundledStrings2 = ["", ""];
                bundledStrings2.size = 0;
                bundledStrings2.position = extStart;
              }
              let twoByte = hasNonLatin.test(value);
              bundledStrings2[twoByte ? 0 : 1] += value;
              target[position2++] = twoByte ? 206 : 207;
              encode4(strLength);
              return;
            }
            let headerSize;
            if (strLength < 32) {
              headerSize = 1;
            } else if (strLength < 256) {
              headerSize = 2;
            } else if (strLength < 65536) {
              headerSize = 3;
            } else {
              headerSize = 5;
            }
            let maxBytes = strLength * 3;
            if (position2 + maxBytes > safeEnd)
              target = makeRoom(position2 + maxBytes);
            if (strLength < 64 || !encodeUtf8) {
              let i, c1, c2, strPosition = position2 + headerSize;
              for (i = 0; i < strLength; i++) {
                c1 = value.charCodeAt(i);
                if (c1 < 128) {
                  target[strPosition++] = c1;
                } else if (c1 < 2048) {
                  target[strPosition++] = c1 >> 6 | 192;
                  target[strPosition++] = c1 & 63 | 128;
                } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {
                  c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
                  i++;
                  target[strPosition++] = c1 >> 18 | 240;
                  target[strPosition++] = c1 >> 12 & 63 | 128;
                  target[strPosition++] = c1 >> 6 & 63 | 128;
                  target[strPosition++] = c1 & 63 | 128;
                } else {
                  target[strPosition++] = c1 >> 12 | 224;
                  target[strPosition++] = c1 >> 6 & 63 | 128;
                  target[strPosition++] = c1 & 63 | 128;
                }
              }
              length = strPosition - position2 - headerSize;
            } else {
              length = encodeUtf8(value, position2 + headerSize, maxBytes);
            }
            if (length < 24) {
              target[position2++] = 96 | length;
            } else if (length < 256) {
              if (headerSize < 2) {
                target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length);
              }
              target[position2++] = 120;
              target[position2++] = length;
            } else if (length < 65536) {
              if (headerSize < 3) {
                target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length);
              }
              target[position2++] = 121;
              target[position2++] = length >> 8;
              target[position2++] = length & 255;
            } else {
              if (headerSize < 5) {
                target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length);
              }
              target[position2++] = 122;
              targetView.setUint32(position2, length);
              position2 += 4;
            }
            position2 += length;
          } else if (type === "number") {
            if (!this.alwaysUseFloat && value >>> 0 === value) {
              if (value < 24) {
                target[position2++] = value;
              } else if (value < 256) {
                target[position2++] = 24;
                target[position2++] = value;
              } else if (value < 65536) {
                target[position2++] = 25;
                target[position2++] = value >> 8;
                target[position2++] = value & 255;
              } else {
                target[position2++] = 26;
                targetView.setUint32(position2, value);
                position2 += 4;
              }
            } else if (!this.alwaysUseFloat && value >> 0 === value) {
              if (value >= -24) {
                target[position2++] = 31 - value;
              } else if (value >= -256) {
                target[position2++] = 56;
                target[position2++] = ~value;
              } else if (value >= -65536) {
                target[position2++] = 57;
                targetView.setUint16(position2, ~value);
                position2 += 2;
              } else {
                target[position2++] = 58;
                targetView.setUint32(position2, ~value);
                position2 += 4;
              }
            } else {
              let useFloat32;
              if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
                target[position2++] = 250;
                targetView.setFloat32(position2, value);
                let xShifted;
                if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
                (xShifted = value * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
                  position2 += 4;
                  return;
                } else
                  position2--;
              }
              target[position2++] = 251;
              targetView.setFloat64(position2, value);
              position2 += 8;
            }
          } else if (type === "object") {
            if (!value)
              target[position2++] = 246;
            else {
              if (referenceMap2) {
                let referee = referenceMap2.get(value);
                if (referee) {
                  target[position2++] = 216;
                  target[position2++] = 29;
                  target[position2++] = 25;
                  if (!referee.references) {
                    let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                    referee.references = [];
                    idsToInsert.push(referee);
                  }
                  referee.references.push(position2 - start);
                  position2 += 2;
                  return;
                } else
                  referenceMap2.set(value, { offset: position2 - start });
              }
              let constructor = value.constructor;
              if (constructor === Object) {
                writeObject(value, true);
              } else if (constructor === Array) {
                length = value.length;
                if (length < 24) {
                  target[position2++] = 128 | length;
                } else {
                  writeArrayHeader(length);
                }
                for (let i = 0; i < length; i++) {
                  encode4(value[i]);
                }
              } else if (constructor === Map) {
                if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
                  target[position2++] = 217;
                  target[position2++] = 1;
                  target[position2++] = 3;
                }
                length = value.size;
                if (length < 24) {
                  target[position2++] = 160 | length;
                } else if (length < 256) {
                  target[position2++] = 184;
                  target[position2++] = length;
                } else if (length < 65536) {
                  target[position2++] = 185;
                  target[position2++] = length >> 8;
                  target[position2++] = length & 255;
                } else {
                  target[position2++] = 186;
                  targetView.setUint32(position2, length);
                  position2 += 4;
                }
                if (encoder4.keyMap) {
                  for (let [key, entryValue] of value) {
                    encode4(encoder4.encodeKey(key));
                    encode4(entryValue);
                  }
                } else {
                  for (let [key, entryValue] of value) {
                    encode4(key);
                    encode4(entryValue);
                  }
                }
              } else {
                for (let i = 0, l = extensions.length; i < l; i++) {
                  let extensionClass = extensionClasses[i];
                  if (value instanceof extensionClass) {
                    let extension = extensions[i];
                    let tag = extension.tag;
                    if (tag == void 0)
                      tag = extension.getTag && extension.getTag.call(this, value);
                    if (tag < 24) {
                      target[position2++] = 192 | tag;
                    } else if (tag < 256) {
                      target[position2++] = 216;
                      target[position2++] = tag;
                    } else if (tag < 65536) {
                      target[position2++] = 217;
                      target[position2++] = tag >> 8;
                      target[position2++] = tag & 255;
                    } else if (tag > -1) {
                      target[position2++] = 218;
                      targetView.setUint32(position2, tag);
                      position2 += 4;
                    }
                    extension.encode.call(this, value, encode4, makeRoom);
                    return;
                  }
                }
                if (value[Symbol.iterator]) {
                  if (throwOnIterable) {
                    let error = new Error("Iterable should be serialized as iterator");
                    error.iteratorNotHandled = true;
                    throw error;
                  }
                  target[position2++] = 159;
                  for (let entry of value) {
                    encode4(entry);
                  }
                  target[position2++] = 255;
                  return;
                }
                if (value[Symbol.asyncIterator] || isBlob(value)) {
                  let error = new Error("Iterable/blob should be serialized as iterator");
                  error.iteratorNotHandled = true;
                  throw error;
                }
                if (this.useToJSON && value.toJSON) {
                  const json = value.toJSON();
                  if (json !== value)
                    return encode4(json);
                }
                writeObject(value, !value.hasOwnProperty);
              }
            }
          } else if (type === "boolean") {
            target[position2++] = value ? 245 : 244;
          } else if (type === "bigint") {
            if (value < BigInt(1) << BigInt(64) && value >= 0) {
              target[position2++] = 27;
              targetView.setBigUint64(position2, value);
            } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
              target[position2++] = 59;
              targetView.setBigUint64(position2, -value - BigInt(1));
            } else {
              if (this.largeBigIntToFloat) {
                target[position2++] = 251;
                targetView.setFloat64(position2, Number(value));
              } else {
                throw new RangeError(value + " was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");
              }
            }
            position2 += 8;
          } else if (type === "undefined") {
            target[position2++] = 247;
          } else {
            throw new Error("Unknown type: " + type);
          }
        };
        const writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {
          let keys = Object.keys(object);
          let vals = Object.values(object);
          let length = keys.length;
          if (length < 24) {
            target[position2++] = 160 | length;
          } else if (length < 256) {
            target[position2++] = 184;
            target[position2++] = length;
          } else if (length < 65536) {
            target[position2++] = 185;
            target[position2++] = length >> 8;
            target[position2++] = length & 255;
          } else {
            target[position2++] = 186;
            targetView.setUint32(position2, length);
            position2 += 4;
          }
          let key;
          if (encoder4.keyMap) {
            for (let i = 0; i < length; i++) {
              encode4(encoder4.encodeKey(keys[i]));
              encode4(vals[i]);
            }
          } else {
            for (let i = 0; i < length; i++) {
              encode4(keys[i]);
              encode4(vals[i]);
            }
          }
        } : (object, safePrototype) => {
          target[position2++] = 185;
          let objectOffset = position2 - start;
          position2 += 2;
          let size = 0;
          if (encoder4.keyMap) {
            for (let key in object)
              if (safePrototype || object.hasOwnProperty(key)) {
                encode4(encoder4.encodeKey(key));
                encode4(object[key]);
                size++;
              }
          } else {
            for (let key in object)
              if (safePrototype || object.hasOwnProperty(key)) {
                encode4(key);
                encode4(object[key]);
                size++;
              }
          }
          target[objectOffset++ + start] = size >> 8;
          target[objectOffset + start] = size & 255;
        } : (object, safePrototype) => {
          let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
          let newTransitions = 0;
          let length = 0;
          let parentRecordId;
          let keys;
          if (this.keyMap) {
            keys = Object.keys(object).map((k) => this.encodeKey(k));
            length = keys.length;
            for (let i = 0; i < length; i++) {
              let key = keys[i];
              nextTransition = transition[key];
              if (!nextTransition) {
                nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                newTransitions++;
              }
              transition = nextTransition;
            }
          } else {
            for (let key in object)
              if (safePrototype || object.hasOwnProperty(key)) {
                nextTransition = transition[key];
                if (!nextTransition) {
                  if (transition[RECORD_SYMBOL] & 1048576) {
                    parentRecordId = transition[RECORD_SYMBOL] & 65535;
                  }
                  nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                  newTransitions++;
                }
                transition = nextTransition;
                length++;
              }
          }
          let recordId = transition[RECORD_SYMBOL];
          if (recordId !== void 0) {
            recordId &= 65535;
            target[position2++] = 217;
            target[position2++] = recordId >> 8 | 224;
            target[position2++] = recordId & 255;
          } else {
            if (!keys)
              keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));
            if (parentRecordId === void 0) {
              recordId = structures.nextId++;
              if (!recordId) {
                recordId = 0;
                structures.nextId = 1;
              }
              if (recordId >= MAX_STRUCTURES) {
                structures.nextId = (recordId = maxSharedStructures) + 1;
              }
            } else {
              recordId = parentRecordId;
            }
            structures[recordId] = keys;
            if (recordId < maxSharedStructures) {
              target[position2++] = 217;
              target[position2++] = recordId >> 8 | 224;
              target[position2++] = recordId & 255;
              transition = structures.transitions;
              for (let i = 0; i < length; i++) {
                if (transition[RECORD_SYMBOL] === void 0 || transition[RECORD_SYMBOL] & 1048576)
                  transition[RECORD_SYMBOL] = recordId;
                transition = transition[keys[i]];
              }
              transition[RECORD_SYMBOL] = recordId | 1048576;
              hasSharedUpdate = true;
            } else {
              transition[RECORD_SYMBOL] = recordId;
              targetView.setUint32(position2, 3655335680);
              position2 += 3;
              if (newTransitions)
                transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
              if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)
                recordIdsToRemove.shift()[RECORD_SYMBOL] = void 0;
              recordIdsToRemove.push(transition);
              writeArrayHeader(length + 2);
              encode4(57344 + recordId);
              encode4(keys);
              if (safePrototype === null)
                return;
              for (let key in object)
                if (safePrototype || object.hasOwnProperty(key))
                  encode4(object[key]);
              return;
            }
          }
          if (length < 24) {
            target[position2++] = 128 | length;
          } else {
            writeArrayHeader(length);
          }
          if (safePrototype === null)
            return;
          for (let key in object)
            if (safePrototype || object.hasOwnProperty(key))
              encode4(object[key]);
        };
        const makeRoom = (end) => {
          let newSize;
          if (end > 16777216) {
            if (end - start > MAX_BUFFER_SIZE)
              throw new Error("Encoded buffer would be larger than maximum buffer size");
            newSize = Math.min(
              MAX_BUFFER_SIZE,
              Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
            );
          } else
            newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
          let newBuffer = new ByteArrayAllocate(newSize);
          targetView = new DataView(newBuffer.buffer, 0, newSize);
          if (target.copy)
            target.copy(newBuffer, 0, start, end);
          else
            newBuffer.set(target.slice(start, end));
          position2 -= start;
          start = 0;
          safeEnd = newBuffer.length - 10;
          return target = newBuffer;
        };
        let chunkThreshold = 100;
        let continuedChunkThreshold = 1e3;
        this.encodeAsIterable = function(value, options2) {
          return startEncoding(value, options2, encodeObjectAsIterable);
        };
        this.encodeAsAsyncIterable = function(value, options2) {
          return startEncoding(value, options2, encodeObjectAsAsyncIterable);
        };
        function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {
          let constructor = object.constructor;
          if (constructor === Object) {
            let useRecords = encoder4.useRecords !== false;
            if (useRecords)
              writeObject(object, null);
            else
              writeEntityLength(Object.keys(object).length, 160);
            for (let key in object) {
              let value = object[key];
              if (!useRecords)
                encode4(key);
              if (value && typeof value === "object") {
                if (iterateProperties[key])
                  yield* encodeObjectAsIterable(value, iterateProperties[key]);
                else
                  yield* tryEncode(value, iterateProperties, key);
              } else
                encode4(value);
            }
          } else if (constructor === Array) {
            let length = object.length;
            writeArrayHeader(length);
            for (let i = 0; i < length; i++) {
              let value = object[i];
              if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
                if (iterateProperties.element)
                  yield* encodeObjectAsIterable(value, iterateProperties.element);
                else
                  yield* tryEncode(value, iterateProperties, "element");
              } else
                encode4(value);
            }
          } else if (object[Symbol.iterator]) {
            target[position2++] = 159;
            for (let value of object) {
              if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
                if (iterateProperties.element)
                  yield* encodeObjectAsIterable(value, iterateProperties.element);
                else
                  yield* tryEncode(value, iterateProperties, "element");
              } else
                encode4(value);
            }
            target[position2++] = 255;
          } else if (isBlob(object)) {
            writeEntityLength(object.size, 64);
            yield target.subarray(start, position2);
            yield object;
            restartEncoding();
          } else if (object[Symbol.asyncIterator]) {
            target[position2++] = 159;
            yield target.subarray(start, position2);
            yield object;
            restartEncoding();
            target[position2++] = 255;
          } else {
            encode4(object);
          }
          if (finalIterable && position2 > start)
            yield target.subarray(start, position2);
          else if (position2 - start > chunkThreshold) {
            yield target.subarray(start, position2);
            restartEncoding();
          }
        }
        function* tryEncode(value, iterateProperties, key) {
          let restart = position2 - start;
          try {
            encode4(value);
            if (position2 - start > chunkThreshold) {
              yield target.subarray(start, position2);
              restartEncoding();
            }
          } catch (error) {
            if (error.iteratorNotHandled) {
              iterateProperties[key] = {};
              position2 = start + restart;
              yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);
            } else
              throw error;
          }
        }
        function restartEncoding() {
          chunkThreshold = continuedChunkThreshold;
          encoder4.encode(null, THROW_ON_ITERABLE);
        }
        function startEncoding(value, options2, encodeIterable) {
          if (options2 && options2.chunkThreshold)
            chunkThreshold = continuedChunkThreshold = options2.chunkThreshold;
          else
            chunkThreshold = 100;
          if (value && typeof value === "object") {
            encoder4.encode(null, THROW_ON_ITERABLE);
            return encodeIterable(value, encoder4.iterateProperties || (encoder4.iterateProperties = {}), true);
          }
          return [encoder4.encode(value)];
        }
        async function* encodeObjectAsAsyncIterable(value, iterateProperties) {
          for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
            let constructor = encodedValue.constructor;
            if (constructor === ByteArray || constructor === Uint8Array)
              yield encodedValue;
            else if (isBlob(encodedValue)) {
              let reader = encodedValue.stream().getReader();
              let next;
              while (!(next = await reader.read()).done) {
                yield next.value;
              }
            } else if (encodedValue[Symbol.asyncIterator]) {
              for await (let asyncValue of encodedValue) {
                restartEncoding();
                if (asyncValue)
                  yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));
                else
                  yield encoder4.encode(asyncValue);
              }
            } else {
              yield encodedValue;
            }
          }
        }
      }
      useBuffer(buffer) {
        target = buffer;
        targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
        position2 = 0;
      }
      clearSharedData() {
        if (this.structures)
          this.structures = [];
        if (this.sharedValues)
          this.sharedValues = void 0;
      }
      updateSharedData() {
        let lastVersion = this.sharedVersion || 0;
        this.sharedVersion = lastVersion + 1;
        let structuresCopy = this.structures.slice(0);
        let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
        let saveResults = this.saveShared(
          sharedData,
          (existingShared) => (existingShared && existingShared.version || 0) == lastVersion
        );
        if (saveResults === false) {
          sharedData = this.getShared() || {};
          this.structures = sharedData.structures || [];
          this.sharedValues = sharedData.packedValues;
          this.sharedVersion = sharedData.version;
          this.structures.nextId = this.structures.length;
        } else {
          structuresCopy.forEach((structure, i) => this.structures[i] = structure);
        }
        return saveResults;
      }
    };
    SharedData = class {
      constructor(structures, values, version) {
        this.structures = structures;
        this.packedValues = values;
        this.version = version;
      }
    };
    BlobConstructor = typeof Blob === "undefined" ? function() {
    } : Blob;
    isLittleEndianMachine2 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
    extensionClasses = [
      Date,
      Set,
      Error,
      RegExp,
      Tag,
      ArrayBuffer,
      Uint8Array,
      Uint8ClampedArray,
      Uint16Array,
      Uint32Array,
      typeof BigUint64Array == "undefined" ? function() {
      } : BigUint64Array,
      Int8Array,
      Int16Array,
      Int32Array,
      typeof BigInt64Array == "undefined" ? function() {
      } : BigInt64Array,
      Float32Array,
      Float64Array,
      SharedData
    ];
    extensions = [
      {
        // Date
        tag: 1,
        encode(date, encode4) {
          let seconds = date.getTime() / 1e3;
          if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
            target[position2++] = 26;
            targetView.setUint32(position2, seconds);
            position2 += 4;
          } else {
            target[position2++] = 251;
            targetView.setFloat64(position2, seconds);
            position2 += 8;
          }
        }
      },
      {
        // Set
        tag: 258,
        // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
        encode(set, encode4) {
          let array = Array.from(set);
          encode4(array);
        }
      },
      {
        // Error
        tag: 27,
        // http://cbor.schmorp.de/generic-object
        encode(error, encode4) {
          encode4([error.name, error.message]);
        }
      },
      {
        // RegExp
        tag: 27,
        // http://cbor.schmorp.de/generic-object
        encode(regex, encode4) {
          encode4(["RegExp", regex.source, regex.flags]);
        }
      },
      {
        // Tag
        getTag(tag) {
          return tag.tag;
        },
        encode(tag, encode4) {
          encode4(tag.value);
        }
      },
      {
        // ArrayBuffer
        encode(arrayBuffer, encode4, makeRoom) {
          writeBuffer(arrayBuffer, makeRoom);
        }
      },
      {
        // Uint8Array
        getTag(typedArray) {
          if (typedArray.constructor === Uint8Array) {
            if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)
              return 64;
          }
        },
        encode(typedArray, encode4, makeRoom) {
          writeBuffer(typedArray, makeRoom);
        }
      },
      typedArrayEncoder(68, 1),
      typedArrayEncoder(69, 2),
      typedArrayEncoder(70, 4),
      typedArrayEncoder(71, 8),
      typedArrayEncoder(72, 1),
      typedArrayEncoder(77, 2),
      typedArrayEncoder(78, 4),
      typedArrayEncoder(79, 8),
      typedArrayEncoder(85, 4),
      typedArrayEncoder(86, 8),
      {
        encode(sharedData, encode4) {
          let packedValues2 = sharedData.packedValues || [];
          let sharedStructures = sharedData.structures || [];
          if (packedValues2.values.length > 0) {
            target[position2++] = 216;
            target[position2++] = 51;
            writeArrayHeader(4);
            let valuesArray = packedValues2.values;
            encode4(valuesArray);
            writeArrayHeader(0);
            writeArrayHeader(0);
            packedObjectMap = Object.create(sharedPackedObjectMap || null);
            for (let i = 0, l = valuesArray.length; i < l; i++) {
              packedObjectMap[valuesArray[i]] = i;
            }
          }
          if (sharedStructures) {
            targetView.setUint32(position2, 3655335424);
            position2 += 3;
            let definitions = sharedStructures.slice(0);
            definitions.unshift(57344);
            definitions.push(new Tag(sharedData.version, 1399353956));
            encode4(definitions);
          } else
            encode4(new Tag(sharedData.version, 1399353956));
        }
      }
    ];
    defaultEncoder = new Encoder({ useRecords: false });
    encode = defaultEncoder.encode;
    encodeAsIterable = defaultEncoder.encodeAsIterable;
    encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;
    ({ NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS);
    REUSE_BUFFER_MODE = 512;
    RESET_BUFFER_MODE = 1024;
    THROW_ON_ITERABLE = 2048;
  }
});

// node_modules/cbor-x/iterators.js
function encodeIter(objectIterator, options = {}) {
  if (!objectIterator || typeof objectIterator !== "object") {
    throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");
  } else if (typeof objectIterator[Symbol.iterator] === "function") {
    return encodeIterSync(objectIterator, options);
  } else if (typeof objectIterator.then === "function" || typeof objectIterator[Symbol.asyncIterator] === "function") {
    return encodeIterAsync(objectIterator, options);
  } else {
    throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise");
  }
}
function* encodeIterSync(objectIterator, options) {
  const encoder4 = new Encoder(options);
  for (const value of objectIterator) {
    yield encoder4.encode(value);
  }
}
async function* encodeIterAsync(objectIterator, options) {
  const encoder4 = new Encoder(options);
  for await (const value of objectIterator) {
    yield encoder4.encode(value);
  }
}
function decodeIter(bufferIterator, options = {}) {
  if (!bufferIterator || typeof bufferIterator !== "object") {
    throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");
  }
  const decoder4 = new Decoder(options);
  let incomplete;
  const parser = (chunk) => {
    let yields;
    if (incomplete) {
      chunk = Buffer.concat([incomplete, chunk]);
      incomplete = void 0;
    }
    try {
      yields = decoder4.decodeMultiple(chunk);
    } catch (err) {
      if (err.incomplete) {
        incomplete = chunk.slice(err.lastPosition);
        yields = err.values;
      } else {
        throw err;
      }
    }
    return yields;
  };
  if (typeof bufferIterator[Symbol.iterator] === "function") {
    return function* iter() {
      for (const value of bufferIterator) {
        yield* parser(value);
      }
    }();
  } else if (typeof bufferIterator[Symbol.asyncIterator] === "function") {
    return async function* iter() {
      for await (const value of bufferIterator) {
        yield* parser(value);
      }
    }();
  }
}
var init_iterators = __esm({
  "node_modules/cbor-x/iterators.js"() {
    init_encode();
    init_decode();
  }
});

// node_modules/cbor-x/index.js
var cbor_x_exports = {};
__export(cbor_x_exports, {
  ALWAYS: () => ALWAYS,
  DECIMAL_FIT: () => DECIMAL_FIT,
  DECIMAL_ROUND: () => DECIMAL_ROUND,
  Decoder: () => Decoder,
  Encoder: () => Encoder,
  FLOAT32_OPTIONS: () => FLOAT32_OPTIONS,
  NEVER: () => NEVER,
  REUSE_BUFFER_MODE: () => REUSE_BUFFER_MODE,
  Tag: () => Tag,
  addExtension: () => addExtension2,
  clearSource: () => clearSource,
  decode: () => decode,
  decodeIter: () => decodeIter,
  decodeMultiple: () => decodeMultiple,
  encode: () => encode,
  encodeAsAsyncIterable: () => encodeAsAsyncIterable,
  encodeAsIterable: () => encodeAsIterable,
  encodeIter: () => encodeIter,
  isNativeAccelerationEnabled: () => isNativeAccelerationEnabled,
  roundFloat32: () => roundFloat32
});
var init_cbor_x = __esm({
  "node_modules/cbor-x/index.js"() {
    init_encode();
    init_decode();
    init_iterators();
  }
});

// node_modules/compare-versions/lib/umd/index.js
var require_umd = __commonJS({
  "node_modules/compare-versions/lib/umd/index.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.compareVersions = {}));
    })(exports, function(exports2) {
      "use strict";
      const semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
      const validateAndParse = (version) => {
        if (typeof version !== "string") {
          throw new TypeError("Invalid argument expected string");
        }
        const match = version.match(semver);
        if (!match) {
          throw new Error(`Invalid argument not valid semver ('${version}' received)`);
        }
        match.shift();
        return match;
      };
      const isWildcard = (s) => s === "*" || s === "x" || s === "X";
      const tryParse = (v) => {
        const n = parseInt(v, 10);
        return isNaN(n) ? v : n;
      };
      const forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];
      const compareStrings = (a, b) => {
        if (isWildcard(a) || isWildcard(b))
          return 0;
        const [ap, bp] = forceType(tryParse(a), tryParse(b));
        if (ap > bp)
          return 1;
        if (ap < bp)
          return -1;
        return 0;
      };
      const compareSegments = (a, b) => {
        for (let i = 0; i < Math.max(a.length, b.length); i++) {
          const r = compareStrings(a[i] || "0", b[i] || "0");
          if (r !== 0)
            return r;
        }
        return 0;
      };
      const compareVersions = (v1, v2) => {
        const n1 = validateAndParse(v1);
        const n2 = validateAndParse(v2);
        const p1 = n1.pop();
        const p2 = n2.pop();
        const r = compareSegments(n1, n2);
        if (r !== 0)
          return r;
        if (p1 && p2) {
          return compareSegments(p1.split("."), p2.split("."));
        } else if (p1 || p2) {
          return p1 ? -1 : 1;
        }
        return 0;
      };
      const compare = (v1, v2, operator) => {
        assertValidOperator(operator);
        const res = compareVersions(v1, v2);
        return operatorResMap[operator].includes(res);
      };
      const operatorResMap = {
        ">": [1],
        ">=": [0, 1],
        "=": [0],
        "<=": [-1, 0],
        "<": [-1],
        "!=": [-1, 1]
      };
      const allowedOperators = Object.keys(operatorResMap);
      const assertValidOperator = (op) => {
        if (typeof op !== "string") {
          throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);
        }
        if (allowedOperators.indexOf(op) === -1) {
          throw new Error(`Invalid operator, expected one of ${allowedOperators.join("|")}`);
        }
      };
      const satisfies = (version, range) => {
        range = range.replace(/([><=]+)\s+/g, "$1");
        if (range.includes("||")) {
          return range.split("||").some((r4) => satisfies(version, r4));
        } else if (range.includes(" - ")) {
          const [a, b] = range.split(" - ", 2);
          return satisfies(version, `>=${a} <=${b}`);
        } else if (range.includes(" ")) {
          return range.trim().replace(/\s{2,}/g, " ").split(" ").every((r4) => satisfies(version, r4));
        }
        const m = range.match(/^([<>=~^]+)/);
        const op = m ? m[1] : "=";
        if (op !== "^" && op !== "~")
          return compare(version, range, op);
        const [v1, v2, v3, , vp] = validateAndParse(version);
        const [r1, r2, r3, , rp] = validateAndParse(range);
        const v = [v1, v2, v3];
        const r = [r1, r2 !== null && r2 !== void 0 ? r2 : "x", r3 !== null && r3 !== void 0 ? r3 : "x"];
        if (rp) {
          if (!vp)
            return false;
          if (compareSegments(v, r) !== 0)
            return false;
          if (compareSegments(vp.split("."), rp.split(".")) === -1)
            return false;
        }
        const nonZero = r.findIndex((v4) => v4 !== "0") + 1;
        const i = op === "~" ? 2 : nonZero > 1 ? nonZero : 1;
        if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0)
          return false;
        if (compareSegments(v.slice(i), r.slice(i)) === -1)
          return false;
        return true;
      };
      const validate = (version) => typeof version === "string" && /^[v\d]/.test(version) && semver.test(version);
      const validateStrict = (version) => typeof version === "string" && /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/.test(version);
      exports2.compare = compare;
      exports2.compareVersions = compareVersions;
      exports2.satisfies = satisfies;
      exports2.validate = validate;
      exports2.validateStrict = validateStrict;
    });
  }
});

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS({
  "node_modules/reflect-metadata/Reflect.js"() {
    var Reflect2;
    (function(Reflect3) {
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
        var exporter = makeExporter(Reflect3);
        if (typeof root.Reflect === "undefined") {
          root.Reflect = Reflect3;
        } else {
          exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target2, previous) {
          return function(key, value) {
            if (typeof target2[key] !== "function") {
              Object.defineProperty(target2, key, { configurable: true, writable: true, value });
            }
            if (previous)
              previous(key, value);
          };
        }
      })(function(exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          // create an object in dictionary mode (a.k.a. "slow" mode in v8)
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map, key) {
            return hasOwn.call(map, key);
          } : function(map, key) {
            return key in map;
          },
          get: downLevel ? function(map, key) {
            return hasOwn.call(map, key) ? map[key] : void 0;
          } : function(map, key) {
            return map[key];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var Metadata = new _WeakMap();
        function decorate(decorators, target2, propertyKey, attributes) {
          if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsObject(target2))
              throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
              throw new TypeError();
            if (IsNull(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target2, propertyKey, attributes);
          } else {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsConstructor(target2))
              throw new TypeError();
            return DecorateConstructor(decorators, target2);
          }
        }
        exporter("decorate", decorate);
        function metadata(metadataKey, metadataValue) {
          function decorator(target2, propertyKey) {
            if (!IsObject(target2))
              throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target2, propertyKey);
          }
          return decorator;
        }
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target2, propertyKey) {
          if (!IsObject(target2))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target2, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target2, propertyKey) {
          if (!IsObject(target2))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target2, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target2, propertyKey) {
          if (!IsObject(target2))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target2, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target2, propertyKey) {
          if (!IsObject(target2))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target2, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target2, propertyKey) {
          if (!IsObject(target2))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target2, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target2, propertyKey) {
          if (!IsObject(target2))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target2, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target2, propertyKey) {
          if (!IsObject(target2))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target2, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target2, propertyKey) {
          if (!IsObject(target2))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var metadataMap = GetOrCreateMetadataMap(
            target2,
            propertyKey,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return false;
          if (!metadataMap.delete(metadataKey))
            return false;
          if (metadataMap.size > 0)
            return true;
          var targetMetadata = Metadata.get(target2);
          targetMetadata.delete(propertyKey);
          if (targetMetadata.size > 0)
            return true;
          Metadata.delete(target2);
          return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target2) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target2);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsConstructor(decorated))
                throw new TypeError();
              target2 = decorated;
            }
          }
          return target2;
        }
        function DecorateProperty(decorators, target2, propertyKey, descriptor) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target2, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsObject(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
          var targetMetadata = Metadata.get(O);
          if (IsUndefined(targetMetadata)) {
            if (!Create)
              return void 0;
            targetMetadata = new _Map();
            Metadata.set(O, targetMetadata);
          }
          var metadataMap = targetMetadata.get(P);
          if (IsUndefined(metadataMap)) {
            if (!Create)
              return void 0;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
          }
          return metadataMap;
        }
        function OrdinaryHasMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return true;
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
          return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
          return void 0;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return void 0;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            true
          );
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryMetadataKeys(O, P) {
          var ownKeys = OrdinaryOwnMetadataKeys(O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (parent === null)
            return ownKeys;
          var parentKeys = OrdinaryMetadataKeys(parent, P);
          if (parentKeys.length <= 0)
            return ownKeys;
          if (ownKeys.length <= 0)
            return parentKeys;
          var set = new _Set();
          var keys = [];
          for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
            var key = parentKeys_1[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          return keys;
        }
        function OrdinaryOwnMetadataKeys(O, P) {
          var keys = [];
          var metadataMap = GetOrCreateMetadataMap(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(metadataMap))
            return keys;
          var keysObj = metadataMap.keys();
          var iterator = GetIterator(keysObj);
          var k = 0;
          while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
              keys.length = k;
              return keys;
            }
            var nextValue = IteratorValue(next);
            try {
              keys[k] = nextValue;
            } catch (e) {
              try {
                IteratorClose(iterator);
              } finally {
                throw e;
              }
            }
            k++;
          }
        }
        function Type(x) {
          if (x === null)
            return 1;
          switch (typeof x) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined(x) {
          return x === void 0;
        }
        function IsNull(x) {
          return x === null;
        }
        function IsSymbol(x) {
          return typeof x === "symbol";
        }
        function IsObject(x) {
          return typeof x === "object" ? x !== null : typeof x === "function";
        }
        function ToPrimitive(input, PreferredType) {
          switch (Type(input)) {
            case 0:
              return input;
            case 1:
              return input;
            case 2:
              return input;
            case 3:
              return input;
            case 4:
              return input;
            case 5:
              return input;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
              throw new TypeError();
            return result;
          }
          return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        function OrdinaryToPrimitive(O, hint) {
          if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
              var result = toString_1.call(O);
              if (!IsObject(result))
                return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
          } else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
              var result = toString_2.call(O);
              if (!IsObject(result))
                return result;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          var key = ToPrimitive(
            argument,
            3
            /* String */
          );
          if (IsSymbol(key))
            return key;
          return ToString(key);
        }
        function IsArray(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        function IsConstructor(argument) {
          return typeof argument === "function";
        }
        function IsPropertyKey(argument) {
          switch (Type(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function GetMethod(V, P) {
          var func = V[P];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject(iterator))
            throw new TypeError();
          return iterator;
        }
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        function IteratorStep(iterator) {
          var result = iterator.next();
          return result.done ? false : result;
        }
        function IteratorClose(iterator) {
          var f = iterator["return"];
          if (f)
            f.call(iterator);
        }
        function OrdinaryGetPrototypeOf(O) {
          var proto = Object.getPrototypeOf(O);
          if (typeof O !== "function" || O === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O)
            return proto;
          return constructor;
        }
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = (
            /** @class */
            function() {
              function MapIterator2(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
              }
              MapIterator2.prototype["@@iterator"] = function() {
                return this;
              };
              MapIterator2.prototype[iteratorSymbol] = function() {
                return this;
              };
              MapIterator2.prototype.next = function() {
                var index = this._index;
                if (index >= 0 && index < this._keys.length) {
                  var result = this._selector(this._keys[index], this._values[index]);
                  if (index + 1 >= this._keys.length) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  } else {
                    this._index++;
                  }
                  return { value: result, done: false };
                }
                return { value: void 0, done: true };
              };
              MapIterator2.prototype.throw = function(error) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                throw error;
              };
              MapIterator2.prototype.return = function(value) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                return { value, done: true };
              };
              return MapIterator2;
            }()
          );
          return (
            /** @class */
            function() {
              function Map2() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              Object.defineProperty(Map2.prototype, "size", {
                get: function() {
                  return this._keys.length;
                },
                enumerable: true,
                configurable: true
              });
              Map2.prototype.has = function(key) {
                return this._find(
                  key,
                  /*insert*/
                  false
                ) >= 0;
              };
              Map2.prototype.get = function(key) {
                var index = this._find(
                  key,
                  /*insert*/
                  false
                );
                return index >= 0 ? this._values[index] : void 0;
              };
              Map2.prototype.set = function(key, value) {
                var index = this._find(
                  key,
                  /*insert*/
                  true
                );
                this._values[index] = value;
                return this;
              };
              Map2.prototype.delete = function(key) {
                var index = this._find(
                  key,
                  /*insert*/
                  false
                );
                if (index >= 0) {
                  var size = this._keys.length;
                  for (var i = index + 1; i < size; i++) {
                    this._keys[i - 1] = this._keys[i];
                    this._values[i - 1] = this._values[i];
                  }
                  this._keys.length--;
                  this._values.length--;
                  if (key === this._cacheKey) {
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                  }
                  return true;
                }
                return false;
              };
              Map2.prototype.clear = function() {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              };
              Map2.prototype.keys = function() {
                return new MapIterator(this._keys, this._values, getKey);
              };
              Map2.prototype.values = function() {
                return new MapIterator(this._keys, this._values, getValue);
              };
              Map2.prototype.entries = function() {
                return new MapIterator(this._keys, this._values, getEntry);
              };
              Map2.prototype["@@iterator"] = function() {
                return this.entries();
              };
              Map2.prototype[iteratorSymbol] = function() {
                return this.entries();
              };
              Map2.prototype._find = function(key, insert) {
                if (this._cacheKey !== key) {
                  this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                }
                if (this._cacheIndex < 0 && insert) {
                  this._cacheIndex = this._keys.length;
                  this._keys.push(key);
                  this._values.push(void 0);
                }
                return this._cacheIndex;
              };
              return Map2;
            }()
          );
          function getKey(key, _) {
            return key;
          }
          function getValue(_, value) {
            return value;
          }
          function getEntry(key, value) {
            return [key, value];
          }
        }
        function CreateSetPolyfill() {
          return (
            /** @class */
            function() {
              function Set2() {
                this._map = new _Map();
              }
              Object.defineProperty(Set2.prototype, "size", {
                get: function() {
                  return this._map.size;
                },
                enumerable: true,
                configurable: true
              });
              Set2.prototype.has = function(value) {
                return this._map.has(value);
              };
              Set2.prototype.add = function(value) {
                return this._map.set(value, value), this;
              };
              Set2.prototype.delete = function(value) {
                return this._map.delete(value);
              };
              Set2.prototype.clear = function() {
                this._map.clear();
              };
              Set2.prototype.keys = function() {
                return this._map.keys();
              };
              Set2.prototype.values = function() {
                return this._map.values();
              };
              Set2.prototype.entries = function() {
                return this._map.entries();
              };
              Set2.prototype["@@iterator"] = function() {
                return this.keys();
              };
              Set2.prototype[iteratorSymbol] = function() {
                return this.keys();
              };
              return Set2;
            }()
          );
        }
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys = HashMap.create();
          var rootKey = CreateUniqueKey();
          return (
            /** @class */
            function() {
              function WeakMap2() {
                this._key = CreateUniqueKey();
              }
              WeakMap2.prototype.has = function(target2) {
                var table2 = GetOrCreateWeakMapTable(
                  target2,
                  /*create*/
                  false
                );
                return table2 !== void 0 ? HashMap.has(table2, this._key) : false;
              };
              WeakMap2.prototype.get = function(target2) {
                var table2 = GetOrCreateWeakMapTable(
                  target2,
                  /*create*/
                  false
                );
                return table2 !== void 0 ? HashMap.get(table2, this._key) : void 0;
              };
              WeakMap2.prototype.set = function(target2, value) {
                var table2 = GetOrCreateWeakMapTable(
                  target2,
                  /*create*/
                  true
                );
                table2[this._key] = value;
                return this;
              };
              WeakMap2.prototype.delete = function(target2) {
                var table2 = GetOrCreateWeakMapTable(
                  target2,
                  /*create*/
                  false
                );
                return table2 !== void 0 ? delete table2[this._key] : false;
              };
              WeakMap2.prototype.clear = function() {
                this._key = CreateUniqueKey();
              };
              return WeakMap2;
            }()
          );
          function CreateUniqueKey() {
            var key;
            do
              key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
          }
          function GetOrCreateWeakMapTable(target2, create) {
            if (!hasOwn.call(target2, rootKey)) {
              if (!create)
                return void 0;
              Object.defineProperty(target2, rootKey, { value: HashMap.create() });
            }
            return target2[rootKey];
          }
          function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i)
              buffer[i] = Math.random() * 255 | 0;
            return buffer;
          }
          function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
              if (typeof crypto !== "undefined")
                return crypto.getRandomValues(new Uint8Array(size));
              if (typeof msCrypto !== "undefined")
                return msCrypto.getRandomValues(new Uint8Array(size));
              return FillRandomBytes(new Uint8Array(size), size);
            }
            return FillRandomBytes(new Array(size), size);
          }
          function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            data[6] = data[6] & 79 | 64;
            data[8] = data[8] & 191 | 128;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte = data[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result += "-";
              if (byte < 16)
                result += "0";
              result += byte.toString(16).toLowerCase();
            }
            return result;
          }
        }
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target2, key) {
    decorator(target2, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target2 = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target2 ? Object.getOwnPropertyDescriptor(target2, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target2)
    Object.defineProperty(target2, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
      } catch (e) {
        fail(e);
      }
    }
    if (env.hasError)
      throw env.error;
  }
  return next();
}
var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign3(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message3) {
      var e = new Error(message3);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// node_modules/pvtsutils/build/index.js
var require_build = __commonJS({
  "node_modules/pvtsutils/build/index.js"(exports) {
    "use strict";
    var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
    var BufferSourceConverter = class _BufferSourceConverter {
      static isArrayBuffer(data) {
        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
      }
      static toArrayBuffer(data) {
        if (this.isArrayBuffer(data)) {
          return data;
        }
        if (data.byteLength === data.buffer.byteLength) {
          return data.buffer;
        }
        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
          return data.buffer;
        }
        return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
      }
      static toUint8Array(data) {
        return this.toView(data, Uint8Array);
      }
      static toView(data, type) {
        if (data.constructor === type) {
          return data;
        }
        if (this.isArrayBuffer(data)) {
          return new type(data);
        }
        if (this.isArrayBufferView(data)) {
          return new type(data.buffer, data.byteOffset, data.byteLength);
        }
        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
      }
      static isBufferSource(data) {
        return this.isArrayBufferView(data) || this.isArrayBuffer(data);
      }
      static isArrayBufferView(data) {
        return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
      }
      static isEqual(a, b) {
        const aView = _BufferSourceConverter.toUint8Array(a);
        const bView = _BufferSourceConverter.toUint8Array(b);
        if (aView.length !== bView.byteLength) {
          return false;
        }
        for (let i = 0; i < aView.length; i++) {
          if (aView[i] !== bView[i]) {
            return false;
          }
        }
        return true;
      }
      static concat(...args) {
        let buffers;
        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
          buffers = args[0];
        } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
          buffers = args[0];
        } else {
          if (args[args.length - 1] instanceof Function) {
            buffers = args.slice(0, args.length - 1);
          } else {
            buffers = args;
          }
        }
        let size = 0;
        for (const buffer of buffers) {
          size += buffer.byteLength;
        }
        const res = new Uint8Array(size);
        let offset = 0;
        for (const buffer of buffers) {
          const view = this.toUint8Array(buffer);
          res.set(view, offset);
          offset += view.length;
        }
        if (args[args.length - 1] instanceof Function) {
          return this.toView(res, args[args.length - 1]);
        }
        return res.buffer;
      }
    };
    var STRING_TYPE = "string";
    var HEX_REGEX = /^[0-9a-f]+$/i;
    var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
    var BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
    var Utf8Converter = class {
      static fromString(text) {
        const s = unescape(encodeURIComponent(text));
        const uintArray = new Uint8Array(s.length);
        for (let i = 0; i < s.length; i++) {
          uintArray[i] = s.charCodeAt(i);
        }
        return uintArray.buffer;
      }
      static toString(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let encodedString = "";
        for (let i = 0; i < buf.length; i++) {
          encodedString += String.fromCharCode(buf[i]);
        }
        const decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
      }
    };
    var Utf16Converter = class {
      static toString(buffer, littleEndian = false) {
        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
        const dataView2 = new DataView(arrayBuffer);
        let res = "";
        for (let i = 0; i < arrayBuffer.byteLength; i += 2) {
          const code = dataView2.getUint16(i, littleEndian);
          res += String.fromCharCode(code);
        }
        return res;
      }
      static fromString(text, littleEndian = false) {
        const res = new ArrayBuffer(text.length * 2);
        const dataView2 = new DataView(res);
        for (let i = 0; i < text.length; i++) {
          dataView2.setUint16(i * 2, text.charCodeAt(i), littleEndian);
        }
        return res;
      }
    };
    var Convert = class _Convert {
      static isHex(data) {
        return typeof data === STRING_TYPE && HEX_REGEX.test(data);
      }
      static isBase64(data) {
        return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
      }
      static isBase64Url(data) {
        return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
      }
      static ToString(buffer, enc = "utf8") {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.ToUtf8String(buf);
          case "binary":
            return this.ToBinary(buf);
          case "hex":
            return this.ToHex(buf);
          case "base64":
            return this.ToBase64(buf);
          case "base64url":
            return this.ToBase64Url(buf);
          case "utf16le":
            return Utf16Converter.toString(buf, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buf);
          default:
            throw new Error(`Unknown type of encoding '${enc}'`);
        }
      }
      static FromString(str, enc = "utf8") {
        if (!str) {
          return new ArrayBuffer(0);
        }
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.FromUtf8String(str);
          case "binary":
            return this.FromBinary(str);
          case "hex":
            return this.FromHex(str);
          case "base64":
            return this.FromBase64(str);
          case "base64url":
            return this.FromBase64Url(str);
          case "utf16le":
            return Utf16Converter.fromString(str, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(str);
          default:
            throw new Error(`Unknown type of encoding '${enc}'`);
        }
      }
      static ToBase64(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        if (typeof btoa !== "undefined") {
          const binary = this.ToString(buf, "binary");
          return btoa(binary);
        } else {
          return Buffer.from(buf).toString("base64");
        }
      }
      static FromBase64(base64) {
        const formatted = this.formatString(base64);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isBase64(formatted)) {
          throw new TypeError("Argument 'base64Text' is not Base64 encoded");
        }
        if (typeof atob !== "undefined") {
          return this.FromBinary(atob(formatted));
        } else {
          return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
        }
      }
      static FromBase64Url(base64url) {
        const formatted = this.formatString(base64url);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isBase64Url(formatted)) {
          throw new TypeError("Argument 'base64url' is not Base64Url encoded");
        }
        return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
      }
      static ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      }
      static FromUtf8String(text, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
          case "ascii":
            return this.FromBinary(text);
          case "utf8":
            return Utf8Converter.fromString(text);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(text);
          case "utf16le":
          case "usc2":
            return Utf16Converter.fromString(text, true);
          default:
            throw new Error(`Unknown type of encoding '${encoding}'`);
        }
      }
      static ToUtf8String(buffer, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
          case "ascii":
            return this.ToBinary(buffer);
          case "utf8":
            return Utf8Converter.toString(buffer);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buffer);
          case "utf16le":
          case "usc2":
            return Utf16Converter.toString(buffer, true);
          default:
            throw new Error(`Unknown type of encoding '${encoding}'`);
        }
      }
      static FromBinary(text) {
        const stringLength = text.length;
        const resultView = new Uint8Array(stringLength);
        for (let i = 0; i < stringLength; i++) {
          resultView[i] = text.charCodeAt(i);
        }
        return resultView.buffer;
      }
      static ToBinary(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let res = "";
        for (let i = 0; i < buf.length; i++) {
          res += String.fromCharCode(buf[i]);
        }
        return res;
      }
      static ToHex(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let result = "";
        const len = buf.length;
        for (let i = 0; i < len; i++) {
          const byte = buf[i];
          if (byte < 16) {
            result += "0";
          }
          result += byte.toString(16);
        }
        return result;
      }
      static FromHex(hexString) {
        let formatted = this.formatString(hexString);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isHex(formatted)) {
          throw new TypeError("Argument 'hexString' is not HEX encoded");
        }
        if (formatted.length % 2) {
          formatted = `0${formatted}`;
        }
        const res = new Uint8Array(formatted.length / 2);
        for (let i = 0; i < formatted.length; i = i + 2) {
          const c = formatted.slice(i, i + 2);
          res[i / 2] = parseInt(c, 16);
        }
        return res.buffer;
      }
      static ToUtf16String(buffer, littleEndian = false) {
        return Utf16Converter.toString(buffer, littleEndian);
      }
      static FromUtf16String(text, littleEndian = false) {
        return Utf16Converter.fromString(text, littleEndian);
      }
      static Base64Padding(base64) {
        const padCount = 4 - base64.length % 4;
        if (padCount < 4) {
          for (let i = 0; i < padCount; i++) {
            base64 += "=";
          }
        }
        return base64;
      }
      static formatString(data) {
        return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
      }
    };
    Convert.DEFAULT_UTF8_ENCODING = "utf8";
    function assign(target2, ...sources) {
      const res = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        const obj = arguments[i];
        for (const prop in obj) {
          res[prop] = obj[prop];
        }
      }
      return res;
    }
    function combine2(...buf) {
      const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);
      const res = new Uint8Array(totalByteLength);
      let currentPos = 0;
      buf.map((item) => new Uint8Array(item)).forEach((arr) => {
        for (const item2 of arr) {
          res[currentPos++] = item2;
        }
      });
      return res.buffer;
    }
    function isEqual(bytes1, bytes2) {
      if (!(bytes1 && bytes2)) {
        return false;
      }
      if (bytes1.byteLength !== bytes2.byteLength) {
        return false;
      }
      const b1 = new Uint8Array(bytes1);
      const b2 = new Uint8Array(bytes2);
      for (let i = 0; i < bytes1.byteLength; i++) {
        if (b1[i] !== b2[i]) {
          return false;
        }
      }
      return true;
    }
    exports.BufferSourceConverter = BufferSourceConverter;
    exports.Convert = Convert;
    exports.assign = assign;
    exports.combine = combine2;
    exports.isEqual = isEqual;
  }
});

// node_modules/pvutils/build/utils.js
var require_utils = __commonJS({
  "node_modules/pvutils/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getUTCDate(date) {
      return new Date(date.getTime() + date.getTimezoneOffset() * 6e4);
    }
    function getParametersValue(parameters, name, defaultValue) {
      var _a;
      if (parameters instanceof Object === false) {
        return defaultValue;
      }
      return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;
    }
    function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = inputBuffer.byteLength - inputOffset, insertSpace = false) {
      let result = "";
      for (const item of new Uint8Array(inputBuffer, inputOffset, inputLength)) {
        const str = item.toString(16).toUpperCase();
        if (str.length === 1) {
          result += "0";
        }
        result += str;
        if (insertSpace) {
          result += " ";
        }
      }
      return result.trim();
    }
    function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
      if (!(inputBuffer instanceof ArrayBuffer)) {
        baseBlock.error = 'Wrong parameter: inputBuffer must be "ArrayBuffer"';
        return false;
      }
      if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
      }
      if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
      }
      if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
      }
      if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
      }
      return true;
    }
    function utilFromBase(inputBuffer, inputBase) {
      let result = 0;
      if (inputBuffer.length === 1) {
        return inputBuffer[0];
      }
      for (let i = inputBuffer.length - 1; i >= 0; i--) {
        result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
      }
      return result;
    }
    function utilToBase(value, base, reserved = -1) {
      const internalReserved = reserved;
      let internalValue = value;
      let result = 0;
      let biggest = Math.pow(2, base);
      for (let i = 1; i < 8; i++) {
        if (value < biggest) {
          let retBuf;
          if (internalReserved < 0) {
            retBuf = new ArrayBuffer(i);
            result = i;
          } else {
            if (internalReserved < i) {
              return new ArrayBuffer(0);
            }
            retBuf = new ArrayBuffer(internalReserved);
            result = internalReserved;
          }
          const retView = new Uint8Array(retBuf);
          for (let j = i - 1; j >= 0; j--) {
            const basis = Math.pow(2, j * base);
            retView[result - j - 1] = Math.floor(internalValue / basis);
            internalValue -= retView[result - j - 1] * basis;
          }
          return retBuf;
        }
        biggest *= Math.pow(2, base);
      }
      return new ArrayBuffer(0);
    }
    function utilConcatBuf(...buffers) {
      let outputLength = 0;
      let prevLength = 0;
      for (const buffer of buffers) {
        outputLength += buffer.byteLength;
      }
      const retBuf = new ArrayBuffer(outputLength);
      const retView = new Uint8Array(retBuf);
      for (const buffer of buffers) {
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
      }
      return retBuf;
    }
    function utilConcatView(...views) {
      let outputLength = 0;
      let prevLength = 0;
      for (const view of views) {
        outputLength += view.length;
      }
      const retBuf = new ArrayBuffer(outputLength);
      const retView = new Uint8Array(retBuf);
      for (const view of views) {
        retView.set(view, prevLength);
        prevLength += view.length;
      }
      return retView;
    }
    function utilDecodeTC() {
      const buf = new Uint8Array(this.valueHex);
      if (this.valueHex.byteLength >= 2) {
        const condition1 = buf[0] === 255 && buf[1] & 128;
        const condition2 = buf[0] === 0 && (buf[1] & 128) === 0;
        if (condition1 || condition2) {
          this.warnings.push("Needlessly long format");
        }
      }
      const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
      const bigIntView = new Uint8Array(bigIntBuffer);
      for (let i = 0; i < this.valueHex.byteLength; i++) {
        bigIntView[i] = 0;
      }
      bigIntView[0] = buf[0] & 128;
      const bigInt = utilFromBase(bigIntView, 8);
      const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
      const smallIntView = new Uint8Array(smallIntBuffer);
      for (let j = 0; j < this.valueHex.byteLength; j++) {
        smallIntView[j] = buf[j];
      }
      smallIntView[0] &= 127;
      const smallInt = utilFromBase(smallIntView, 8);
      return smallInt - bigInt;
    }
    function utilEncodeTC(value) {
      const modValue = value < 0 ? value * -1 : value;
      let bigInt = 128;
      for (let i = 1; i < 8; i++) {
        if (modValue <= bigInt) {
          if (value < 0) {
            const smallInt = bigInt - modValue;
            const retBuf2 = utilToBase(smallInt, 8, i);
            const retView2 = new Uint8Array(retBuf2);
            retView2[0] |= 128;
            return retBuf2;
          }
          let retBuf = utilToBase(modValue, 8, i);
          let retView = new Uint8Array(retBuf);
          if (retView[0] & 128) {
            const tempBuf = retBuf.slice(0);
            const tempView = new Uint8Array(tempBuf);
            retBuf = new ArrayBuffer(retBuf.byteLength + 1);
            retView = new Uint8Array(retBuf);
            for (let k = 0; k < tempBuf.byteLength; k++) {
              retView[k + 1] = tempView[k];
            }
            retView[0] = 0;
          }
          return retBuf;
        }
        bigInt *= Math.pow(2, 8);
      }
      return new ArrayBuffer(0);
    }
    function isEqualBuffer(inputBuffer1, inputBuffer2) {
      if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
        return false;
      }
      const view1 = new Uint8Array(inputBuffer1);
      const view2 = new Uint8Array(inputBuffer2);
      for (let i = 0; i < view1.length; i++) {
        if (view1[i] !== view2[i]) {
          return false;
        }
      }
      return true;
    }
    function padNumber(inputNumber, fullLength) {
      const str = inputNumber.toString(10);
      if (fullLength < str.length) {
        return "";
      }
      const dif = fullLength - str.length;
      const padding = new Array(dif);
      for (let i = 0; i < dif; i++) {
        padding[i] = "0";
      }
      const paddingString = padding.join("");
      return paddingString.concat(str);
    }
    var base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
    function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {
      let i = 0;
      let flag1 = 0;
      let flag2 = 0;
      let output = "";
      const template = useUrlTemplate ? base64UrlTemplate : base64Template;
      if (skipLeadingZeros) {
        let nonZeroPosition = 0;
        for (let i2 = 0; i2 < input.length; i2++) {
          if (input.charCodeAt(i2) !== 0) {
            nonZeroPosition = i2;
            break;
          }
        }
        input = input.slice(nonZeroPosition);
      }
      while (i < input.length) {
        const chr1 = input.charCodeAt(i++);
        if (i >= input.length) {
          flag1 = 1;
        }
        const chr2 = input.charCodeAt(i++);
        if (i >= input.length) {
          flag2 = 1;
        }
        const chr3 = input.charCodeAt(i++);
        const enc1 = chr1 >> 2;
        const enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        let enc3 = (chr2 & 15) << 2 | chr3 >> 6;
        let enc4 = chr3 & 63;
        if (flag1 === 1) {
          enc3 = enc4 = 64;
        } else {
          if (flag2 === 1) {
            enc4 = 64;
          }
        }
        if (skipPadding) {
          if (enc3 === 64) {
            output += `${template.charAt(enc1)}${template.charAt(enc2)}`;
          } else {
            if (enc4 === 64) {
              output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
            } else {
              output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
            }
          }
        } else {
          output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
        }
      }
      return output;
    }
    function fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {
      const template = useUrlTemplate ? base64UrlTemplate : base64Template;
      function indexOf(toSearch) {
        for (let i2 = 0; i2 < 64; i2++) {
          if (template.charAt(i2) === toSearch)
            return i2;
        }
        return 64;
      }
      function test(incoming) {
        return incoming === 64 ? 0 : incoming;
      }
      let i = 0;
      let output = "";
      while (i < input.length) {
        const enc1 = indexOf(input.charAt(i++));
        const enc2 = i >= input.length ? 0 : indexOf(input.charAt(i++));
        const enc3 = i >= input.length ? 0 : indexOf(input.charAt(i++));
        const enc4 = i >= input.length ? 0 : indexOf(input.charAt(i++));
        const chr1 = test(enc1) << 2 | test(enc2) >> 4;
        const chr2 = (test(enc2) & 15) << 4 | test(enc3) >> 2;
        const chr3 = (test(enc3) & 3) << 6 | test(enc4);
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
          output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
          output += String.fromCharCode(chr3);
        }
      }
      if (cutTailZeros) {
        const outputLength = output.length;
        let nonZeroStart = -1;
        for (let i2 = outputLength - 1; i2 >= 0; i2--) {
          if (output.charCodeAt(i2) !== 0) {
            nonZeroStart = i2;
            break;
          }
        }
        if (nonZeroStart !== -1) {
          output = output.slice(0, nonZeroStart + 1);
        } else {
          output = "";
        }
      }
      return output;
    }
    function arrayBufferToString(buffer) {
      let resultString = "";
      const view = new Uint8Array(buffer);
      for (const element of view) {
        resultString += String.fromCharCode(element);
      }
      return resultString;
    }
    function stringToArrayBuffer(str) {
      const stringLength = str.length;
      const resultBuffer = new ArrayBuffer(stringLength);
      const resultView = new Uint8Array(resultBuffer);
      for (let i = 0; i < stringLength; i++) {
        resultView[i] = str.charCodeAt(i);
      }
      return resultBuffer;
    }
    var log2 = Math.log(2);
    function nearestPowerOf2(length) {
      const base = Math.log(length) / log2;
      const floor = Math.floor(base);
      const round = Math.round(base);
      return floor === round ? floor : round;
    }
    function clearProps(object, propsArray) {
      for (const prop of propsArray) {
        delete object[prop];
      }
    }
    exports.arrayBufferToString = arrayBufferToString;
    exports.bufferToHexCodes = bufferToHexCodes;
    exports.checkBufferParams = checkBufferParams;
    exports.clearProps = clearProps;
    exports.fromBase64 = fromBase64;
    exports.getParametersValue = getParametersValue;
    exports.getUTCDate = getUTCDate;
    exports.isEqualBuffer = isEqualBuffer;
    exports.nearestPowerOf2 = nearestPowerOf2;
    exports.padNumber = padNumber;
    exports.stringToArrayBuffer = stringToArrayBuffer;
    exports.toBase64 = toBase64;
    exports.utilConcatBuf = utilConcatBuf;
    exports.utilConcatView = utilConcatView;
    exports.utilDecodeTC = utilDecodeTC;
    exports.utilEncodeTC = utilEncodeTC;
    exports.utilFromBase = utilFromBase;
    exports.utilToBase = utilToBase;
  }
});

// node_modules/asn1js/build/index.js
var require_build2 = __commonJS({
  "node_modules/asn1js/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pvtsutils = require_build();
    var pvutils = require_utils();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var pvtsutils__namespace = /* @__PURE__ */ _interopNamespace(pvtsutils);
    var pvutils__namespace = /* @__PURE__ */ _interopNamespace(pvutils);
    function assertBigInt() {
      if (typeof BigInt === "undefined") {
        throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
      }
    }
    function concat2(buffers) {
      let outputLength = 0;
      let prevLength = 0;
      for (let i = 0; i < buffers.length; i++) {
        const buffer = buffers[i];
        outputLength += buffer.byteLength;
      }
      const retView = new Uint8Array(outputLength);
      for (let i = 0; i < buffers.length; i++) {
        const buffer = buffers[i];
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
      }
      return retView.buffer;
    }
    function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
      if (!(inputBuffer instanceof Uint8Array)) {
        baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
        return false;
      }
      if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
      }
      if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
      }
      if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
      }
      if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
      }
      return true;
    }
    var ViewWriter = class {
      constructor() {
        this.items = [];
      }
      write(buf) {
        this.items.push(buf);
      }
      final() {
        return concat2(this.items);
      }
    };
    var powers2 = [new Uint8Array([1])];
    var digitsString = "0123456789";
    var NAME = "name";
    var VALUE_HEX_VIEW = "valueHexView";
    var IS_HEX_ONLY = "isHexOnly";
    var ID_BLOCK = "idBlock";
    var TAG_CLASS = "tagClass";
    var TAG_NUMBER = "tagNumber";
    var IS_CONSTRUCTED = "isConstructed";
    var FROM_BER = "fromBER";
    var TO_BER = "toBER";
    var LOCAL = "local";
    var EMPTY_STRING = "";
    var EMPTY_BUFFER = new ArrayBuffer(0);
    var EMPTY_VIEW = new Uint8Array(0);
    var END_OF_CONTENT_NAME = "EndOfContent";
    var OCTET_STRING_NAME = "OCTET STRING";
    var BIT_STRING_NAME = "BIT STRING";
    function HexBlock(BaseClass) {
      var _a2;
      return _a2 = class Some extends BaseClass {
        constructor(...args) {
          var _a3;
          super(...args);
          const params = args[0] || {};
          this.isHexOnly = (_a3 = params.isHexOnly) !== null && _a3 !== void 0 ? _a3 : false;
          this.valueHexView = params.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
        }
        get valueHex() {
          return this.valueHexView.slice().buffer;
        }
        set valueHex(value) {
          this.valueHexView = new Uint8Array(value);
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
          const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
          if (!checkBufferParams(this, view, inputOffset, inputLength)) {
            return -1;
          }
          const endLength = inputOffset + inputLength;
          this.valueHexView = view.subarray(inputOffset, endLength);
          if (!this.valueHexView.length) {
            this.warnings.push("Zero buffer length");
            return inputOffset;
          }
          this.blockLength = inputLength;
          return endLength;
        }
        toBER(sizeOnly = false) {
          if (!this.isHexOnly) {
            this.error = "Flag 'isHexOnly' is not set, abort";
            return EMPTY_BUFFER;
          }
          if (sizeOnly) {
            return new ArrayBuffer(this.valueHexView.byteLength);
          }
          return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
        }
        toJSON() {
          return {
            ...super.toJSON(),
            isHexOnly: this.isHexOnly,
            valueHex: pvtsutils__namespace.Convert.ToHex(this.valueHexView)
          };
        }
      }, _a2.NAME = "hexBlock", _a2;
    }
    var LocalBaseBlock = class {
      constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
        this.blockLength = blockLength;
        this.error = error;
        this.warnings = warnings;
        this.valueBeforeDecodeView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(valueBeforeDecode);
      }
      static blockName() {
        return this.NAME;
      }
      get valueBeforeDecode() {
        return this.valueBeforeDecodeView.slice().buffer;
      }
      set valueBeforeDecode(value) {
        this.valueBeforeDecodeView = new Uint8Array(value);
      }
      toJSON() {
        return {
          blockName: this.constructor.NAME,
          blockLength: this.blockLength,
          error: this.error,
          warnings: this.warnings,
          valueBeforeDecode: pvtsutils__namespace.Convert.ToHex(this.valueBeforeDecodeView)
        };
      }
    };
    LocalBaseBlock.NAME = "baseBlock";
    var ValueBlock = class extends LocalBaseBlock {
      fromBER(inputBuffer, inputOffset, inputLength) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
      toBER(sizeOnly, writer) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
    };
    ValueBlock.NAME = "valueBlock";
    var LocalIdentificationBlock = class extends HexBlock(LocalBaseBlock) {
      constructor({ idBlock = {} } = {}) {
        var _a2, _b, _c, _d;
        super();
        if (idBlock) {
          this.isHexOnly = (_a2 = idBlock.isHexOnly) !== null && _a2 !== void 0 ? _a2 : false;
          this.valueHexView = idBlock.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
          this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
          this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
          this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
        } else {
          this.tagClass = -1;
          this.tagNumber = -1;
          this.isConstructed = false;
        }
      }
      toBER(sizeOnly = false) {
        let firstOctet = 0;
        switch (this.tagClass) {
          case 1:
            firstOctet |= 0;
            break;
          case 2:
            firstOctet |= 64;
            break;
          case 3:
            firstOctet |= 128;
            break;
          case 4:
            firstOctet |= 192;
            break;
          default:
            this.error = "Unknown tag class";
            return EMPTY_BUFFER;
        }
        if (this.isConstructed)
          firstOctet |= 32;
        if (this.tagNumber < 31 && !this.isHexOnly) {
          const retView2 = new Uint8Array(1);
          if (!sizeOnly) {
            let number = this.tagNumber;
            number &= 31;
            firstOctet |= number;
            retView2[0] = firstOctet;
          }
          return retView2.buffer;
        }
        if (!this.isHexOnly) {
          const encodedBuf = pvutils__namespace.utilToBase(this.tagNumber, 7);
          const encodedView = new Uint8Array(encodedBuf);
          const size = encodedBuf.byteLength;
          const retView2 = new Uint8Array(size + 1);
          retView2[0] = firstOctet | 31;
          if (!sizeOnly) {
            for (let i = 0; i < size - 1; i++)
              retView2[i + 1] = encodedView[i] | 128;
            retView2[size] = encodedView[size - 1];
          }
          return retView2.buffer;
        }
        const retView = new Uint8Array(this.valueHexView.byteLength + 1);
        retView[0] = firstOctet | 31;
        if (!sizeOnly) {
          const curView = this.valueHexView;
          for (let i = 0; i < curView.length - 1; i++)
            retView[i + 1] = curView[i] | 128;
          retView[this.valueHexView.byteLength] = curView[curView.length - 1];
        }
        return retView.buffer;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
          this.error = "Zero buffer length";
          return -1;
        }
        const tagClassMask = intBuffer[0] & 192;
        switch (tagClassMask) {
          case 0:
            this.tagClass = 1;
            break;
          case 64:
            this.tagClass = 2;
            break;
          case 128:
            this.tagClass = 3;
            break;
          case 192:
            this.tagClass = 4;
            break;
          default:
            this.error = "Unknown tag class";
            return -1;
        }
        this.isConstructed = (intBuffer[0] & 32) === 32;
        this.isHexOnly = false;
        const tagNumberMask = intBuffer[0] & 31;
        if (tagNumberMask !== 31) {
          this.tagNumber = tagNumberMask;
          this.blockLength = 1;
        } else {
          let count = 1;
          let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
          let tagNumberBufferMaxLength = 255;
          while (intBuffer[count] & 128) {
            intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
            count++;
            if (count >= intBuffer.length) {
              this.error = "End of input reached before message was fully decoded";
              return -1;
            }
            if (count === tagNumberBufferMaxLength) {
              tagNumberBufferMaxLength += 255;
              const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
              for (let i = 0; i < intTagNumberBuffer.length; i++)
                tempBufferView2[i] = intTagNumberBuffer[i];
              intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
            }
          }
          this.blockLength = count + 1;
          intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
          const tempBufferView = new Uint8Array(count);
          for (let i = 0; i < count; i++)
            tempBufferView[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
          intTagNumberBuffer.set(tempBufferView);
          if (this.blockLength <= 9)
            this.tagNumber = pvutils__namespace.utilFromBase(intTagNumberBuffer, 7);
          else {
            this.isHexOnly = true;
            this.warnings.push("Tag too long, represented as hex-coded");
          }
        }
        if (this.tagClass === 1 && this.isConstructed) {
          switch (this.tagNumber) {
            case 1:
            case 2:
            case 5:
            case 6:
            case 9:
            case 13:
            case 14:
            case 23:
            case 24:
            case 31:
            case 32:
            case 33:
            case 34:
              this.error = "Constructed encoding used for primitive type";
              return -1;
          }
        }
        return inputOffset + this.blockLength;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          tagClass: this.tagClass,
          tagNumber: this.tagNumber,
          isConstructed: this.isConstructed
        };
      }
    };
    LocalIdentificationBlock.NAME = "identificationBlock";
    var LocalLengthBlock = class extends LocalBaseBlock {
      constructor({ lenBlock = {} } = {}) {
        var _a2, _b, _c;
        super();
        this.isIndefiniteForm = (_a2 = lenBlock.isIndefiniteForm) !== null && _a2 !== void 0 ? _a2 : false;
        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
          this.error = "Zero buffer length";
          return -1;
        }
        if (intBuffer[0] === 255) {
          this.error = "Length block 0xFF is reserved by standard";
          return -1;
        }
        this.isIndefiniteForm = intBuffer[0] === 128;
        if (this.isIndefiniteForm) {
          this.blockLength = 1;
          return inputOffset + this.blockLength;
        }
        this.longFormUsed = !!(intBuffer[0] & 128);
        if (this.longFormUsed === false) {
          this.length = intBuffer[0];
          this.blockLength = 1;
          return inputOffset + this.blockLength;
        }
        const count = intBuffer[0] & 127;
        if (count > 8) {
          this.error = "Too big integer";
          return -1;
        }
        if (count + 1 > intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        const lenOffset = inputOffset + 1;
        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
        if (lengthBufferView[count - 1] === 0)
          this.warnings.push("Needlessly long encoded length");
        this.length = pvutils__namespace.utilFromBase(lengthBufferView, 8);
        if (this.longFormUsed && this.length <= 127)
          this.warnings.push("Unnecessary usage of long length form");
        this.blockLength = count + 1;
        return inputOffset + this.blockLength;
      }
      toBER(sizeOnly = false) {
        let retBuf;
        let retView;
        if (this.length > 127)
          this.longFormUsed = true;
        if (this.isIndefiniteForm) {
          retBuf = new ArrayBuffer(1);
          if (sizeOnly === false) {
            retView = new Uint8Array(retBuf);
            retView[0] = 128;
          }
          return retBuf;
        }
        if (this.longFormUsed) {
          const encodedBuf = pvutils__namespace.utilToBase(this.length, 8);
          if (encodedBuf.byteLength > 127) {
            this.error = "Too big length";
            return EMPTY_BUFFER;
          }
          retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
          if (sizeOnly)
            return retBuf;
          const encodedView = new Uint8Array(encodedBuf);
          retView = new Uint8Array(retBuf);
          retView[0] = encodedBuf.byteLength | 128;
          for (let i = 0; i < encodedBuf.byteLength; i++)
            retView[i + 1] = encodedView[i];
          return retBuf;
        }
        retBuf = new ArrayBuffer(1);
        if (sizeOnly === false) {
          retView = new Uint8Array(retBuf);
          retView[0] = this.length;
        }
        return retBuf;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          isIndefiniteForm: this.isIndefiniteForm,
          longFormUsed: this.longFormUsed,
          length: this.length
        };
      }
    };
    LocalLengthBlock.NAME = "lengthBlock";
    var typeStore = {};
    var BaseBlock = class extends LocalBaseBlock {
      constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
        super(parameters);
        this.name = name;
        this.optional = optional;
        if (primitiveSchema) {
          this.primitiveSchema = primitiveSchema;
        }
        this.idBlock = new LocalIdentificationBlock(parameters);
        this.lenBlock = new LocalLengthBlock(parameters);
        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        if (!writer) {
          prepareIndefiniteForm(this);
        }
        const idBlockBuf = this.idBlock.toBER(sizeOnly);
        _writer.write(idBlockBuf);
        if (this.lenBlock.isIndefiniteForm) {
          _writer.write(new Uint8Array([128]).buffer);
          this.valueBlock.toBER(sizeOnly, _writer);
          _writer.write(new ArrayBuffer(2));
        } else {
          const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
          this.lenBlock.length = valueBlockBuf.byteLength;
          const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
          _writer.write(lenBlockBuf);
          _writer.write(valueBlockBuf);
        }
        if (!writer) {
          return _writer.final();
        }
        return EMPTY_BUFFER;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          idBlock: this.idBlock.toJSON(),
          lenBlock: this.lenBlock.toJSON(),
          valueBlock: this.valueBlock.toJSON(),
          name: this.name,
          optional: this.optional
        };
        if (this.primitiveSchema)
          object.primitiveSchema = this.primitiveSchema.toJSON();
        return object;
      }
      toString(encoding = "ascii") {
        if (encoding === "ascii") {
          return this.onAsciiEncoding();
        }
        return pvtsutils__namespace.Convert.ToHex(this.toBER());
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;
      }
      isEqual(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof this.constructor)) {
          return false;
        }
        const thisRaw = this.toBER();
        const otherRaw = other.toBER();
        return pvutils__namespace.isEqualBuffer(thisRaw, otherRaw);
      }
    };
    BaseBlock.NAME = "BaseBlock";
    function prepareIndefiniteForm(baseBlock) {
      if (baseBlock instanceof typeStore.Constructed) {
        for (const value of baseBlock.valueBlock.value) {
          if (prepareIndefiniteForm(value)) {
            baseBlock.lenBlock.isIndefiniteForm = true;
          }
        }
      }
      return !!baseBlock.lenBlock.isIndefiniteForm;
    }
    var BaseStringBlock = class extends BaseBlock {
      constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
        super(parameters, stringValueBlockType);
        if (value) {
          this.fromString(value);
        }
      }
      getValue() {
        return this.valueBlock.value;
      }
      setValue(value) {
        this.valueBlock.value = value;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHexView);
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
      }
    };
    BaseStringBlock.NAME = "BaseStringBlock";
    var LocalPrimitiveValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ isHexOnly = true, ...parameters } = {}) {
        super(parameters);
        this.isHexOnly = isHexOnly;
      }
    };
    LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
    var _a$w;
    var Primitive = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalPrimitiveValueBlock);
        this.idBlock.isConstructed = false;
      }
    };
    _a$w = Primitive;
    (() => {
      typeStore.Primitive = _a$w;
    })();
    Primitive.NAME = "PRIMITIVE";
    function localChangeType(inputObject, newType) {
      if (inputObject instanceof newType) {
        return inputObject;
      }
      const newObject = new newType();
      newObject.idBlock = inputObject.idBlock;
      newObject.lenBlock = inputObject.lenBlock;
      newObject.warnings = inputObject.warnings;
      newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
      return newObject;
    }
    function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
      const incomingOffset = inputOffset;
      let returnObject = new BaseBlock({}, ValueBlock);
      const baseBlock = new LocalBaseBlock();
      if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
        returnObject.error = baseBlock.error;
        return {
          offset: -1,
          result: returnObject
        };
      }
      const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
      if (!intBuffer.length) {
        returnObject.error = "Zero buffer length";
        return {
          offset: -1,
          result: returnObject
        };
      }
      let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
      if (returnObject.idBlock.warnings.length) {
        returnObject.warnings.concat(returnObject.idBlock.warnings);
      }
      if (resultOffset === -1) {
        returnObject.error = returnObject.idBlock.error;
        return {
          offset: -1,
          result: returnObject
        };
      }
      inputOffset = resultOffset;
      inputLength -= returnObject.idBlock.blockLength;
      resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
      if (returnObject.lenBlock.warnings.length) {
        returnObject.warnings.concat(returnObject.lenBlock.warnings);
      }
      if (resultOffset === -1) {
        returnObject.error = returnObject.lenBlock.error;
        return {
          offset: -1,
          result: returnObject
        };
      }
      inputOffset = resultOffset;
      inputLength -= returnObject.lenBlock.blockLength;
      if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
        returnObject.error = "Indefinite length form used for primitive encoding form";
        return {
          offset: -1,
          result: returnObject
        };
      }
      let newASN1Type = BaseBlock;
      switch (returnObject.idBlock.tagClass) {
        case 1:
          if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
            returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
            return {
              offset: -1,
              result: returnObject
            };
          }
          switch (returnObject.idBlock.tagNumber) {
            case 0:
              if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
                returnObject.error = "Type [UNIVERSAL 0] is reserved";
                return {
                  offset: -1,
                  result: returnObject
                };
              }
              newASN1Type = typeStore.EndOfContent;
              break;
            case 1:
              newASN1Type = typeStore.Boolean;
              break;
            case 2:
              newASN1Type = typeStore.Integer;
              break;
            case 3:
              newASN1Type = typeStore.BitString;
              break;
            case 4:
              newASN1Type = typeStore.OctetString;
              break;
            case 5:
              newASN1Type = typeStore.Null;
              break;
            case 6:
              newASN1Type = typeStore.ObjectIdentifier;
              break;
            case 10:
              newASN1Type = typeStore.Enumerated;
              break;
            case 12:
              newASN1Type = typeStore.Utf8String;
              break;
            case 13:
              newASN1Type = typeStore.RelativeObjectIdentifier;
              break;
            case 14:
              newASN1Type = typeStore.TIME;
              break;
            case 15:
              returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
              return {
                offset: -1,
                result: returnObject
              };
            case 16:
              newASN1Type = typeStore.Sequence;
              break;
            case 17:
              newASN1Type = typeStore.Set;
              break;
            case 18:
              newASN1Type = typeStore.NumericString;
              break;
            case 19:
              newASN1Type = typeStore.PrintableString;
              break;
            case 20:
              newASN1Type = typeStore.TeletexString;
              break;
            case 21:
              newASN1Type = typeStore.VideotexString;
              break;
            case 22:
              newASN1Type = typeStore.IA5String;
              break;
            case 23:
              newASN1Type = typeStore.UTCTime;
              break;
            case 24:
              newASN1Type = typeStore.GeneralizedTime;
              break;
            case 25:
              newASN1Type = typeStore.GraphicString;
              break;
            case 26:
              newASN1Type = typeStore.VisibleString;
              break;
            case 27:
              newASN1Type = typeStore.GeneralString;
              break;
            case 28:
              newASN1Type = typeStore.UniversalString;
              break;
            case 29:
              newASN1Type = typeStore.CharacterString;
              break;
            case 30:
              newASN1Type = typeStore.BmpString;
              break;
            case 31:
              newASN1Type = typeStore.DATE;
              break;
            case 32:
              newASN1Type = typeStore.TimeOfDay;
              break;
            case 33:
              newASN1Type = typeStore.DateTime;
              break;
            case 34:
              newASN1Type = typeStore.Duration;
              break;
            default: {
              const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
              newObject.idBlock = returnObject.idBlock;
              newObject.lenBlock = returnObject.lenBlock;
              newObject.warnings = returnObject.warnings;
              returnObject = newObject;
            }
          }
          break;
        case 2:
        case 3:
        case 4:
        default: {
          newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
        }
      }
      returnObject = localChangeType(returnObject, newASN1Type);
      resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
      returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
      return {
        offset: resultOffset,
        result: returnObject
      };
    }
    function fromBER(inputBuffer) {
      if (!inputBuffer.byteLength) {
        const result = new BaseBlock({}, ValueBlock);
        result.error = "Input buffer has zero length";
        return {
          offset: -1,
          result
        };
      }
      return localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
    }
    function checkLen(indefiniteLength, length) {
      if (indefiniteLength) {
        return 1;
      }
      return length;
    }
    var LocalConstructedValueBlock = class extends ValueBlock {
      constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
        super(parameters);
        this.value = value;
        this.isIndefiniteForm = isIndefiniteForm;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
          return -1;
        }
        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
        if (this.valueBeforeDecodeView.length === 0) {
          this.warnings.push("Zero buffer length");
          return inputOffset;
        }
        let currentOffset = inputOffset;
        while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
          const returnObject = localFromBER(view, currentOffset, inputLength);
          if (returnObject.offset === -1) {
            this.error = returnObject.result.error;
            this.warnings.concat(returnObject.result.warnings);
            return -1;
          }
          currentOffset = returnObject.offset;
          this.blockLength += returnObject.result.blockLength;
          inputLength -= returnObject.result.blockLength;
          this.value.push(returnObject.result);
          if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
            break;
          }
        }
        if (this.isIndefiniteForm) {
          if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
            this.value.pop();
          } else {
            this.warnings.push("No EndOfContent block encoded");
          }
        }
        return currentOffset;
      }
      toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        for (let i = 0; i < this.value.length; i++) {
          this.value[i].toBER(sizeOnly, _writer);
        }
        if (!writer) {
          return _writer.final();
        }
        return EMPTY_BUFFER;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          isIndefiniteForm: this.isIndefiniteForm,
          value: []
        };
        for (const value of this.value) {
          object.value.push(value.toJSON());
        }
        return object;
      }
    };
    LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
    var _a$v;
    var Constructed = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalConstructedValueBlock);
        this.idBlock.isConstructed = true;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      onAsciiEncoding() {
        const values = [];
        for (const value of this.valueBlock.value) {
          values.push(value.toString("ascii").split("\n").map((o) => `  ${o}`).join("\n"));
        }
        const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
        return values.length ? `${blockName} :
${values.join("\n")}` : `${blockName} :`;
      }
    };
    _a$v = Constructed;
    (() => {
      typeStore.Constructed = _a$v;
    })();
    Constructed.NAME = "CONSTRUCTED";
    var LocalEndOfContentValueBlock = class extends ValueBlock {
      fromBER(inputBuffer, inputOffset, inputLength) {
        return inputOffset;
      }
      toBER(sizeOnly) {
        return EMPTY_BUFFER;
      }
    };
    LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
    var _a$u;
    var EndOfContent = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalEndOfContentValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 0;
      }
    };
    _a$u = EndOfContent;
    (() => {
      typeStore.EndOfContent = _a$u;
    })();
    EndOfContent.NAME = END_OF_CONTENT_NAME;
    var _a$t;
    var Null = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, ValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 5;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (this.lenBlock.length > 0)
          this.warnings.push("Non-zero length of value block for Null type");
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        this.blockLength += inputLength;
        if (inputOffset + inputLength > inputBuffer.byteLength) {
          this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
          return -1;
        }
        return inputOffset + inputLength;
      }
      toBER(sizeOnly, writer) {
        const retBuf = new ArrayBuffer(2);
        if (!sizeOnly) {
          const retView = new Uint8Array(retBuf);
          retView[0] = 5;
          retView[1] = 0;
        }
        if (writer) {
          writer.write(retBuf);
        }
        return retBuf;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME}`;
      }
    };
    _a$t = Null;
    (() => {
      typeStore.Null = _a$t;
    })();
    Null.NAME = "NULL";
    var LocalBooleanValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ value, ...parameters } = {}) {
        super(parameters);
        if (parameters.valueHex) {
          this.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(parameters.valueHex);
        } else {
          this.valueHexView = new Uint8Array(1);
        }
        if (value) {
          this.value = value;
        }
      }
      get value() {
        for (const octet of this.valueHexView) {
          if (octet > 0) {
            return true;
          }
        }
        return false;
      }
      set value(value) {
        this.valueHexView[0] = value ? 255 : 0;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (inputLength > 1)
          this.warnings.push("Boolean value encoded in more then 1 octet");
        this.isHexOnly = true;
        pvutils__namespace.utilDecodeTC.call(this);
        this.blockLength = inputLength;
        return inputOffset + inputLength;
      }
      toBER() {
        return this.valueHexView.slice();
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.value
        };
      }
    };
    LocalBooleanValueBlock.NAME = "BooleanValueBlock";
    var _a$s;
    var Boolean2 = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalBooleanValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 1;
      }
      getValue() {
        return this.valueBlock.value;
      }
      setValue(value) {
        this.valueBlock.value = value;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.getValue}`;
      }
    };
    _a$s = Boolean2;
    (() => {
      typeStore.Boolean = _a$s;
    })();
    Boolean2.NAME = "BOOLEAN";
    var LocalOctetStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
      constructor({ isConstructed = false, ...parameters } = {}) {
        super(parameters);
        this.isConstructed = isConstructed;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = 0;
        if (this.isConstructed) {
          this.isHexOnly = false;
          resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
          if (resultOffset === -1)
            return resultOffset;
          for (let i = 0; i < this.value.length; i++) {
            const currentBlockName = this.value[i].constructor.NAME;
            if (currentBlockName === END_OF_CONTENT_NAME) {
              if (this.isIndefiniteForm)
                break;
              else {
                this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
                return -1;
              }
            }
            if (currentBlockName !== OCTET_STRING_NAME) {
              this.error = "OCTET STRING may consists of OCTET STRINGs only";
              return -1;
            }
          }
        } else {
          this.isHexOnly = true;
          resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
          this.blockLength = inputLength;
        }
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        if (this.isConstructed)
          return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          isConstructed: this.isConstructed
        };
      }
    };
    LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
    var _a$r;
    var OctetString = class _OctetString extends BaseBlock {
      constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
          idBlock: {
            isConstructed: parameters.isConstructed,
            ...idBlock
          },
          lenBlock: {
            ...lenBlock,
            isIndefiniteForm: !!parameters.isIndefiniteForm
          },
          ...parameters
        }, LocalOctetStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 4;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        if (inputLength === 0) {
          if (this.idBlock.error.length === 0)
            this.blockLength += this.idBlock.blockLength;
          if (this.lenBlock.error.length === 0)
            this.blockLength += this.lenBlock.blockLength;
          return inputOffset;
        }
        if (!this.valueBlock.isConstructed) {
          const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
          const buf = view.subarray(inputOffset, inputOffset + inputLength);
          try {
            if (buf.byteLength) {
              const asn = localFromBER(buf, 0, buf.byteLength);
              if (asn.offset !== -1 && asn.offset === inputLength) {
                this.valueBlock.value = [asn.result];
              }
            }
          } catch (e) {
          }
        }
        return super.fromBER(inputBuffer, inputOffset, inputLength);
      }
      onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
          return Constructed.prototype.onAsciiEncoding.call(this);
        }
        return `${this.constructor.NAME} : ${pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueHexView)}`;
      }
      getValue() {
        if (!this.idBlock.isConstructed) {
          return this.valueBlock.valueHexView.slice().buffer;
        }
        const array = [];
        for (const content of this.valueBlock.value) {
          if (content instanceof _OctetString) {
            array.push(content.valueBlock.valueHexView);
          }
        }
        return pvtsutils__namespace.BufferSourceConverter.concat(array);
      }
    };
    _a$r = OctetString;
    (() => {
      typeStore.OctetString = _a$r;
    })();
    OctetString.NAME = OCTET_STRING_NAME;
    var LocalBitStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
      constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
        super(parameters);
        this.unusedBits = unusedBits;
        this.isConstructed = isConstructed;
        this.blockLength = this.valueHexView.byteLength;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
          return inputOffset;
        }
        let resultOffset = -1;
        if (this.isConstructed) {
          resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
          if (resultOffset === -1)
            return resultOffset;
          for (const value of this.value) {
            const currentBlockName = value.constructor.NAME;
            if (currentBlockName === END_OF_CONTENT_NAME) {
              if (this.isIndefiniteForm)
                break;
              else {
                this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
                return -1;
              }
            }
            if (currentBlockName !== BIT_STRING_NAME) {
              this.error = "BIT STRING may consists of BIT STRINGs only";
              return -1;
            }
            const valueBlock = value.valueBlock;
            if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
              this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
              return -1;
            }
            this.unusedBits = valueBlock.unusedBits;
          }
          return resultOffset;
        }
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.unusedBits = intBuffer[0];
        if (this.unusedBits > 7) {
          this.error = "Unused bits for BitString must be in range 0-7";
          return -1;
        }
        if (!this.unusedBits) {
          const buf = intBuffer.subarray(1);
          try {
            if (buf.byteLength) {
              const asn = localFromBER(buf, 0, buf.byteLength);
              if (asn.offset !== -1 && asn.offset === inputLength - 1) {
                this.value = [asn.result];
              }
            }
          } catch (e) {
          }
        }
        this.valueHexView = intBuffer.subarray(1);
        this.blockLength = intBuffer.length;
        return inputOffset + inputLength;
      }
      toBER(sizeOnly, writer) {
        if (this.isConstructed) {
          return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        }
        if (sizeOnly) {
          return new ArrayBuffer(this.valueHexView.byteLength + 1);
        }
        if (!this.valueHexView.byteLength) {
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(this.valueHexView.length + 1);
        retView[0] = this.unusedBits;
        retView.set(this.valueHexView, 1);
        return retView.buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          unusedBits: this.unusedBits,
          isConstructed: this.isConstructed
        };
      }
    };
    LocalBitStringValueBlock.NAME = "BitStringValueBlock";
    var _a$q;
    var BitString = class extends BaseBlock {
      constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
          idBlock: {
            isConstructed: parameters.isConstructed,
            ...idBlock
          },
          lenBlock: {
            ...lenBlock,
            isIndefiniteForm: !!parameters.isIndefiniteForm
          },
          ...parameters
        }, LocalBitStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 3;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        return super.fromBER(inputBuffer, inputOffset, inputLength);
      }
      onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
          return Constructed.prototype.onAsciiEncoding.call(this);
        } else {
          const bits = [];
          const valueHex = this.valueBlock.valueHexView;
          for (const byte of valueHex) {
            bits.push(byte.toString(2).padStart(8, "0"));
          }
          const bitsStr = bits.join("");
          return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;
        }
      }
    };
    _a$q = BitString;
    (() => {
      typeStore.BitString = _a$q;
    })();
    BitString.NAME = BIT_STRING_NAME;
    var _a$p;
    function viewAdd(first, second) {
      const c = new Uint8Array([0]);
      const firstView = new Uint8Array(first);
      const secondView = new Uint8Array(second);
      let firstViewCopy = firstView.slice(0);
      const firstViewCopyLength = firstViewCopy.length - 1;
      const secondViewCopy = secondView.slice(0);
      const secondViewCopyLength = secondViewCopy.length - 1;
      let value = 0;
      const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
      let counter = 0;
      for (let i = max; i >= 0; i--, counter++) {
        switch (true) {
          case counter < secondViewCopy.length:
            value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
            break;
          default:
            value = firstViewCopy[firstViewCopyLength - counter] + c[0];
        }
        c[0] = value / 10;
        switch (true) {
          case counter >= firstViewCopy.length:
            firstViewCopy = pvutils__namespace.utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
            break;
          default:
            firstViewCopy[firstViewCopyLength - counter] = value % 10;
        }
      }
      if (c[0] > 0)
        firstViewCopy = pvutils__namespace.utilConcatView(c, firstViewCopy);
      return firstViewCopy;
    }
    function power2(n) {
      if (n >= powers2.length) {
        for (let p = powers2.length; p <= n; p++) {
          const c = new Uint8Array([0]);
          let digits = powers2[p - 1].slice(0);
          for (let i = digits.length - 1; i >= 0; i--) {
            const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
            c[0] = newValue[0] / 10;
            digits[i] = newValue[0] % 10;
          }
          if (c[0] > 0)
            digits = pvutils__namespace.utilConcatView(c, digits);
          powers2.push(digits);
        }
      }
      return powers2[n];
    }
    function viewSub(first, second) {
      let b = 0;
      const firstView = new Uint8Array(first);
      const secondView = new Uint8Array(second);
      const firstViewCopy = firstView.slice(0);
      const firstViewCopyLength = firstViewCopy.length - 1;
      const secondViewCopy = secondView.slice(0);
      const secondViewCopyLength = secondViewCopy.length - 1;
      let value;
      let counter = 0;
      for (let i = secondViewCopyLength; i >= 0; i--, counter++) {
        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
        switch (true) {
          case value < 0:
            b = 1;
            firstViewCopy[firstViewCopyLength - counter] = value + 10;
            break;
          default:
            b = 0;
            firstViewCopy[firstViewCopyLength - counter] = value;
        }
      }
      if (b > 0) {
        for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {
          value = firstViewCopy[firstViewCopyLength - counter] - b;
          if (value < 0) {
            b = 1;
            firstViewCopy[firstViewCopyLength - counter] = value + 10;
          } else {
            b = 0;
            firstViewCopy[firstViewCopyLength - counter] = value;
            break;
          }
        }
      }
      return firstViewCopy.slice();
    }
    var LocalIntegerValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ value, ...parameters } = {}) {
        super(parameters);
        this._valueDec = 0;
        if (parameters.valueHex) {
          this.setValueHex();
        }
        if (value !== void 0) {
          this.valueDec = value;
        }
      }
      setValueHex() {
        if (this.valueHexView.length >= 4) {
          this.warnings.push("Too big Integer for decoding, hex only");
          this.isHexOnly = true;
          this._valueDec = 0;
        } else {
          this.isHexOnly = false;
          if (this.valueHexView.length > 0) {
            this._valueDec = pvutils__namespace.utilDecodeTC.call(this);
          }
        }
      }
      set valueDec(v) {
        this._valueDec = v;
        this.isHexOnly = false;
        this.valueHexView = new Uint8Array(pvutils__namespace.utilEncodeTC(v));
      }
      get valueDec() {
        return this._valueDec;
      }
      fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
        if (offset === -1)
          return offset;
        const view = this.valueHexView;
        if (view[0] === 0 && (view[1] & 128) !== 0) {
          this.valueHexView = view.subarray(1);
        } else {
          if (expectedLength !== 0) {
            if (view.length < expectedLength) {
              if (expectedLength - view.length > 1)
                expectedLength = view.length + 1;
              this.valueHexView = view.subarray(expectedLength - view.length);
            }
          }
        }
        return offset;
      }
      toDER(sizeOnly = false) {
        const view = this.valueHexView;
        switch (true) {
          case (view[0] & 128) !== 0:
            {
              const updatedView = new Uint8Array(this.valueHexView.length + 1);
              updatedView[0] = 0;
              updatedView.set(view, 1);
              this.valueHexView = updatedView;
            }
            break;
          case (view[0] === 0 && (view[1] & 128) === 0):
            {
              this.valueHexView = this.valueHexView.subarray(1);
            }
            break;
        }
        return this.toBER(sizeOnly);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1) {
          return resultOffset;
        }
        this.setValueHex();
        return resultOffset;
      }
      toBER(sizeOnly) {
        return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec
        };
      }
      toString() {
        const firstBit = this.valueHexView.length * 8 - 1;
        let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
        let bitNumber = 0;
        let currentByte;
        const asn1View = this.valueHexView;
        let result = "";
        let flag = false;
        for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {
          currentByte = asn1View[byteNumber];
          for (let i = 0; i < 8; i++) {
            if ((currentByte & 1) === 1) {
              switch (bitNumber) {
                case firstBit:
                  digits = viewSub(power2(bitNumber), digits);
                  result = "-";
                  break;
                default:
                  digits = viewAdd(digits, power2(bitNumber));
              }
            }
            bitNumber++;
            currentByte >>= 1;
          }
        }
        for (let i = 0; i < digits.length; i++) {
          if (digits[i])
            flag = true;
          if (flag)
            result += digitsString.charAt(digits[i]);
        }
        if (flag === false)
          result += digitsString.charAt(0);
        return result;
      }
    };
    _a$p = LocalIntegerValueBlock;
    LocalIntegerValueBlock.NAME = "IntegerValueBlock";
    (() => {
      Object.defineProperty(_a$p.prototype, "valueHex", {
        set: function(v) {
          this.valueHexView = new Uint8Array(v);
          this.setValueHex();
        },
        get: function() {
          return this.valueHexView.slice().buffer;
        }
      });
    })();
    var _a$o;
    var Integer = class _Integer extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalIntegerValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 2;
      }
      toBigInt() {
        assertBigInt();
        return BigInt(this.valueBlock.toString());
      }
      static fromBigInt(value) {
        assertBigInt();
        const bigIntValue = BigInt(value);
        const writer = new ViewWriter();
        const hex = bigIntValue.toString(16).replace(/^-/, "");
        const view = new Uint8Array(pvtsutils__namespace.Convert.FromHex(hex));
        if (bigIntValue < 0) {
          const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
          first[0] |= 128;
          const firstInt = BigInt(`0x${pvtsutils__namespace.Convert.ToHex(first)}`);
          const secondInt = firstInt + bigIntValue;
          const second = pvtsutils__namespace.BufferSourceConverter.toUint8Array(pvtsutils__namespace.Convert.FromHex(secondInt.toString(16)));
          second[0] |= 128;
          writer.write(second);
        } else {
          if (view[0] & 128) {
            writer.write(new Uint8Array([0]));
          }
          writer.write(view);
        }
        const res = new _Integer({
          valueHex: writer.final()
        });
        return res;
      }
      convertToDER() {
        const integer = new _Integer({ valueHex: this.valueBlock.valueHexView });
        integer.valueBlock.toDER();
        return integer;
      }
      convertFromDER() {
        return new _Integer({
          valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
        });
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
      }
    };
    _a$o = Integer;
    (() => {
      typeStore.Integer = _a$o;
    })();
    Integer.NAME = "INTEGER";
    var _a$n;
    var Enumerated = class extends Integer {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 10;
      }
    };
    _a$n = Enumerated;
    (() => {
      typeStore.Enumerated = _a$n;
    })();
    Enumerated.NAME = "ENUMERATED";
    var LocalSidValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
        super(parameters);
        this.valueDec = valueDec;
        this.isFirstSid = isFirstSid;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
          return inputOffset;
        }
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (let i = 0; i < inputLength; i++) {
          this.valueHexView[i] = intBuffer[i] & 127;
          this.blockLength++;
          if ((intBuffer[i] & 128) === 0)
            break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for (let i = 0; i < this.blockLength; i++) {
          tempView[i] = this.valueHexView[i];
        }
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (this.valueHexView[0] === 0)
          this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8)
          this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);
        else {
          this.isHexOnly = true;
          this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
      }
      set valueBigInt(value) {
        assertBigInt();
        let bits = BigInt(value).toString(2);
        while (bits.length % 7) {
          bits = "0" + bits;
        }
        const bytes = new Uint8Array(bits.length / 7);
        for (let i = 0; i < bytes.length; i++) {
          bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);
        }
        this.fromBER(bytes.buffer, 0, bytes.length);
      }
      toBER(sizeOnly) {
        if (this.isHexOnly) {
          if (sizeOnly)
            return new ArrayBuffer(this.valueHexView.byteLength);
          const curView = this.valueHexView;
          const retView2 = new Uint8Array(this.blockLength);
          for (let i = 0; i < this.blockLength - 1; i++)
            retView2[i] = curView[i] | 128;
          retView2[this.blockLength - 1] = curView[this.blockLength - 1];
          return retView2.buffer;
        }
        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
          this.error = "Error during encoding SID value";
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
          const encodedView = new Uint8Array(encodedBuf);
          const len = encodedBuf.byteLength - 1;
          for (let i = 0; i < len; i++)
            retView[i] = encodedView[i] | 128;
          retView[len] = encodedView[len];
        }
        return retView;
      }
      toString() {
        let result = "";
        if (this.isHexOnly)
          result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);
        else {
          if (this.isFirstSid) {
            let sidValue = this.valueDec;
            if (this.valueDec <= 39)
              result = "0.";
            else {
              if (this.valueDec <= 79) {
                result = "1.";
                sidValue -= 40;
              } else {
                result = "2.";
                sidValue -= 80;
              }
            }
            result += sidValue.toString();
          } else
            result = this.valueDec.toString();
        }
        return result;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec,
          isFirstSid: this.isFirstSid
        };
      }
    };
    LocalSidValueBlock.NAME = "sidBlock";
    var LocalObjectIdentifierValueBlock = class extends ValueBlock {
      constructor({ value = EMPTY_STRING, ...parameters } = {}) {
        super(parameters);
        this.value = [];
        if (value) {
          this.fromString(value);
        }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while (inputLength > 0) {
          const sidBlock = new LocalSidValueBlock();
          resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
          if (resultOffset === -1) {
            this.blockLength = 0;
            this.error = sidBlock.error;
            return resultOffset;
          }
          if (this.value.length === 0)
            sidBlock.isFirstSid = true;
          this.blockLength += sidBlock.blockLength;
          inputLength -= sidBlock.blockLength;
          this.value.push(sidBlock);
        }
        return resultOffset;
      }
      toBER(sizeOnly) {
        const retBuffers = [];
        for (let i = 0; i < this.value.length; i++) {
          const valueBuf = this.value[i].toBER(sizeOnly);
          if (valueBuf.byteLength === 0) {
            this.error = this.value[i].error;
            return EMPTY_BUFFER;
          }
          retBuffers.push(valueBuf);
        }
        return concat2(retBuffers);
      }
      fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        let flag = false;
        do {
          pos2 = string.indexOf(".", pos1);
          if (pos2 === -1)
            sid = string.substring(pos1);
          else
            sid = string.substring(pos1, pos2);
          pos1 = pos2 + 1;
          if (flag) {
            const sidBlock = this.value[0];
            let plus = 0;
            switch (sidBlock.valueDec) {
              case 0:
                break;
              case 1:
                plus = 40;
                break;
              case 2:
                plus = 80;
                break;
              default:
                this.value = [];
                return;
            }
            const parsedSID = parseInt(sid, 10);
            if (isNaN(parsedSID))
              return;
            sidBlock.valueDec = parsedSID + plus;
            flag = false;
          } else {
            const sidBlock = new LocalSidValueBlock();
            if (sid > Number.MAX_SAFE_INTEGER) {
              assertBigInt();
              const sidValue = BigInt(sid);
              sidBlock.valueBigInt = sidValue;
            } else {
              sidBlock.valueDec = parseInt(sid, 10);
              if (isNaN(sidBlock.valueDec))
                return;
            }
            if (!this.value.length) {
              sidBlock.isFirstSid = true;
              flag = true;
            }
            this.value.push(sidBlock);
          }
        } while (pos2 !== -1);
      }
      toString() {
        let result = "";
        let isHexOnly = false;
        for (let i = 0; i < this.value.length; i++) {
          isHexOnly = this.value[i].isHexOnly;
          let sidStr = this.value[i].toString();
          if (i !== 0)
            result = `${result}.`;
          if (isHexOnly) {
            sidStr = `{${sidStr}}`;
            if (this.value[i].isFirstSid)
              result = `2.{${sidStr} - 80}`;
            else
              result += sidStr;
          } else
            result += sidStr;
        }
        return result;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          value: this.toString(),
          sidArray: []
        };
        for (let i = 0; i < this.value.length; i++) {
          object.sidArray.push(this.value[i].toJSON());
        }
        return object;
      }
    };
    LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
    var _a$m;
    var ObjectIdentifier = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 6;
      }
      getValue() {
        return this.valueBlock.toString();
      }
      setValue(value) {
        this.valueBlock.fromString(value);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.getValue()
        };
      }
    };
    _a$m = ObjectIdentifier;
    (() => {
      typeStore.ObjectIdentifier = _a$m;
    })();
    ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
    var LocalRelativeSidValueBlock = class extends HexBlock(LocalBaseBlock) {
      constructor({ valueDec = 0, ...parameters } = {}) {
        super(parameters);
        this.valueDec = valueDec;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0)
          return inputOffset;
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength))
          return -1;
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (let i = 0; i < inputLength; i++) {
          this.valueHexView[i] = intBuffer[i] & 127;
          this.blockLength++;
          if ((intBuffer[i] & 128) === 0)
            break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for (let i = 0; i < this.blockLength; i++)
          tempView[i] = this.valueHexView[i];
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (this.valueHexView[0] === 0)
          this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8)
          this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);
        else {
          this.isHexOnly = true;
          this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
      }
      toBER(sizeOnly) {
        if (this.isHexOnly) {
          if (sizeOnly)
            return new ArrayBuffer(this.valueHexView.byteLength);
          const curView = this.valueHexView;
          const retView2 = new Uint8Array(this.blockLength);
          for (let i = 0; i < this.blockLength - 1; i++)
            retView2[i] = curView[i] | 128;
          retView2[this.blockLength - 1] = curView[this.blockLength - 1];
          return retView2.buffer;
        }
        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
          this.error = "Error during encoding SID value";
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
          const encodedView = new Uint8Array(encodedBuf);
          const len = encodedBuf.byteLength - 1;
          for (let i = 0; i < len; i++)
            retView[i] = encodedView[i] | 128;
          retView[len] = encodedView[len];
        }
        return retView.buffer;
      }
      toString() {
        let result = "";
        if (this.isHexOnly)
          result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);
        else {
          result = this.valueDec.toString();
        }
        return result;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec
        };
      }
    };
    LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
    var LocalRelativeObjectIdentifierValueBlock = class extends ValueBlock {
      constructor({ value = EMPTY_STRING, ...parameters } = {}) {
        super(parameters);
        this.value = [];
        if (value) {
          this.fromString(value);
        }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while (inputLength > 0) {
          const sidBlock = new LocalRelativeSidValueBlock();
          resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
          if (resultOffset === -1) {
            this.blockLength = 0;
            this.error = sidBlock.error;
            return resultOffset;
          }
          this.blockLength += sidBlock.blockLength;
          inputLength -= sidBlock.blockLength;
          this.value.push(sidBlock);
        }
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        const retBuffers = [];
        for (let i = 0; i < this.value.length; i++) {
          const valueBuf = this.value[i].toBER(sizeOnly);
          if (valueBuf.byteLength === 0) {
            this.error = this.value[i].error;
            return EMPTY_BUFFER;
          }
          retBuffers.push(valueBuf);
        }
        return concat2(retBuffers);
      }
      fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        do {
          pos2 = string.indexOf(".", pos1);
          if (pos2 === -1)
            sid = string.substring(pos1);
          else
            sid = string.substring(pos1, pos2);
          pos1 = pos2 + 1;
          const sidBlock = new LocalRelativeSidValueBlock();
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return true;
          this.value.push(sidBlock);
        } while (pos2 !== -1);
        return true;
      }
      toString() {
        let result = "";
        let isHexOnly = false;
        for (let i = 0; i < this.value.length; i++) {
          isHexOnly = this.value[i].isHexOnly;
          let sidStr = this.value[i].toString();
          if (i !== 0)
            result = `${result}.`;
          if (isHexOnly) {
            sidStr = `{${sidStr}}`;
            result += sidStr;
          } else
            result += sidStr;
        }
        return result;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          value: this.toString(),
          sidArray: []
        };
        for (let i = 0; i < this.value.length; i++)
          object.sidArray.push(this.value[i].toJSON());
        return object;
      }
    };
    LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
    var _a$l;
    var RelativeObjectIdentifier = class extends BaseBlock {
      constructor(parameters = {}) {
        super(parameters, LocalRelativeObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 13;
      }
      getValue() {
        return this.valueBlock.toString();
      }
      setValue(value) {
        this.valueBlock.fromString(value);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.getValue()
        };
      }
    };
    _a$l = RelativeObjectIdentifier;
    (() => {
      typeStore.RelativeObjectIdentifier = _a$l;
    })();
    RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
    var _a$k;
    var Sequence = class extends Constructed {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 16;
      }
    };
    _a$k = Sequence;
    (() => {
      typeStore.Sequence = _a$k;
    })();
    Sequence.NAME = "SEQUENCE";
    var _a$j;
    var Set2 = class extends Constructed {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 17;
      }
    };
    _a$j = Set2;
    (() => {
      typeStore.Set = _a$j;
    })();
    Set2.NAME = "SET";
    var LocalStringValueBlock = class extends HexBlock(ValueBlock) {
      constructor({ ...parameters } = {}) {
        super(parameters);
        this.isHexOnly = true;
        this.value = EMPTY_STRING;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.value
        };
      }
    };
    LocalStringValueBlock.NAME = "StringValueBlock";
    var LocalSimpleStringValueBlock = class extends LocalStringValueBlock {
    };
    LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
    var LocalSimpleStringBlock = class extends BaseStringBlock {
      constructor({ ...parameters } = {}) {
        super(parameters, LocalSimpleStringValueBlock);
      }
      fromBuffer(inputBuffer) {
        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));
      }
      fromString(inputString) {
        const strLen = inputString.length;
        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
        for (let i = 0; i < strLen; i++)
          view[i] = inputString.charCodeAt(i);
        this.valueBlock.value = inputString;
      }
    };
    LocalSimpleStringBlock.NAME = "SIMPLE STRING";
    var LocalUtf8StringValueBlock = class extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        try {
          this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf8String(inputBuffer);
        } catch (ex) {
          this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
          this.valueBlock.value = pvtsutils__namespace.Convert.ToBinary(inputBuffer);
        }
      }
      fromString(inputString) {
        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf8String(inputString));
        this.valueBlock.value = inputString;
      }
    };
    LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
    var _a$i;
    var Utf8String = class extends LocalUtf8StringValueBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 12;
      }
    };
    _a$i = Utf8String;
    (() => {
      typeStore.Utf8String = _a$i;
    })();
    Utf8String.NAME = "UTF8String";
    var LocalBmpStringValueBlock = class extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
        this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf16String(inputBuffer);
        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
      }
      fromString(inputString) {
        this.valueBlock.value = inputString;
        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf16String(inputString));
      }
    };
    LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
    var _a$h;
    var BmpString = class extends LocalBmpStringValueBlock {
      constructor({ ...parameters } = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 30;
      }
    };
    _a$h = BmpString;
    (() => {
      typeStore.BmpString = _a$h;
    })();
    BmpString.NAME = "BMPString";
    var LocalUniversalStringValueBlock = class extends LocalSimpleStringBlock {
      fromBuffer(inputBuffer) {
        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
        const valueView = new Uint8Array(copyBuffer);
        for (let i = 0; i < valueView.length; i += 4) {
          valueView[i] = valueView[i + 3];
          valueView[i + 1] = valueView[i + 2];
          valueView[i + 2] = 0;
          valueView[i + 3] = 0;
        }
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
      }
      fromString(inputString) {
        const strLength = inputString.length;
        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
        for (let i = 0; i < strLength; i++) {
          const codeBuf = pvutils__namespace.utilToBase(inputString.charCodeAt(i), 8);
          const codeView = new Uint8Array(codeBuf);
          if (codeView.length > 4)
            continue;
          const dif = 4 - codeView.length;
          for (let j = codeView.length - 1; j >= 0; j--)
            valueHexView[i * 4 + j + dif] = codeView[j];
        }
        this.valueBlock.value = inputString;
      }
    };
    LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
    var _a$g;
    var UniversalString = class extends LocalUniversalStringValueBlock {
      constructor({ ...parameters } = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 28;
      }
    };
    _a$g = UniversalString;
    (() => {
      typeStore.UniversalString = _a$g;
    })();
    UniversalString.NAME = "UniversalString";
    var _a$f;
    var NumericString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 18;
      }
    };
    _a$f = NumericString;
    (() => {
      typeStore.NumericString = _a$f;
    })();
    NumericString.NAME = "NumericString";
    var _a$e;
    var PrintableString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 19;
      }
    };
    _a$e = PrintableString;
    (() => {
      typeStore.PrintableString = _a$e;
    })();
    PrintableString.NAME = "PrintableString";
    var _a$d;
    var TeletexString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 20;
      }
    };
    _a$d = TeletexString;
    (() => {
      typeStore.TeletexString = _a$d;
    })();
    TeletexString.NAME = "TeletexString";
    var _a$c;
    var VideotexString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 21;
      }
    };
    _a$c = VideotexString;
    (() => {
      typeStore.VideotexString = _a$c;
    })();
    VideotexString.NAME = "VideotexString";
    var _a$b;
    var IA5String = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 22;
      }
    };
    _a$b = IA5String;
    (() => {
      typeStore.IA5String = _a$b;
    })();
    IA5String.NAME = "IA5String";
    var _a$a;
    var GraphicString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 25;
      }
    };
    _a$a = GraphicString;
    (() => {
      typeStore.GraphicString = _a$a;
    })();
    GraphicString.NAME = "GraphicString";
    var _a$9;
    var VisibleString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 26;
      }
    };
    _a$9 = VisibleString;
    (() => {
      typeStore.VisibleString = _a$9;
    })();
    VisibleString.NAME = "VisibleString";
    var _a$8;
    var GeneralString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 27;
      }
    };
    _a$8 = GeneralString;
    (() => {
      typeStore.GeneralString = _a$8;
    })();
    GeneralString.NAME = "GeneralString";
    var _a$7;
    var CharacterString = class extends LocalSimpleStringBlock {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 29;
      }
    };
    _a$7 = CharacterString;
    (() => {
      typeStore.CharacterString = _a$7;
    })();
    CharacterString.NAME = "CharacterString";
    var _a$6;
    var UTCTime = class extends VisibleString {
      constructor({ value, valueDate, ...parameters } = {}) {
        super(parameters);
        this.year = 0;
        this.month = 0;
        this.day = 0;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        if (value) {
          this.fromString(value);
          this.valueBlock.valueHexView = new Uint8Array(value.length);
          for (let i = 0; i < value.length; i++)
            this.valueBlock.valueHexView[i] = value.charCodeAt(i);
        }
        if (valueDate) {
          this.fromDate(valueDate);
          this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
        }
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 23;
      }
      fromBuffer(inputBuffer) {
        this.fromString(String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer)));
      }
      toBuffer() {
        const str = this.toString();
        const buffer = new ArrayBuffer(str.length);
        const view = new Uint8Array(buffer);
        for (let i = 0; i < str.length; i++)
          view[i] = str.charCodeAt(i);
        return buffer;
      }
      fromDate(inputDate) {
        this.year = inputDate.getUTCFullYear();
        this.month = inputDate.getUTCMonth() + 1;
        this.day = inputDate.getUTCDate();
        this.hour = inputDate.getUTCHours();
        this.minute = inputDate.getUTCMinutes();
        this.second = inputDate.getUTCSeconds();
      }
      toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
      }
      fromString(inputString) {
        const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
        const parserArray = parser.exec(inputString);
        if (parserArray === null) {
          this.error = "Wrong input string for conversion";
          return;
        }
        const year2 = parseInt(parserArray[1], 10);
        if (year2 >= 50)
          this.year = 1900 + year2;
        else
          this.year = 2e3 + year2;
        this.month = parseInt(parserArray[2], 10);
        this.day = parseInt(parserArray[3], 10);
        this.hour = parseInt(parserArray[4], 10);
        this.minute = parseInt(parserArray[5], 10);
        this.second = parseInt(parserArray[6], 10);
      }
      toString(encoding = "iso") {
        if (encoding === "iso") {
          const outputArray = new Array(7);
          outputArray[0] = pvutils__namespace.padNumber(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2);
          outputArray[1] = pvutils__namespace.padNumber(this.month, 2);
          outputArray[2] = pvutils__namespace.padNumber(this.day, 2);
          outputArray[3] = pvutils__namespace.padNumber(this.hour, 2);
          outputArray[4] = pvutils__namespace.padNumber(this.minute, 2);
          outputArray[5] = pvutils__namespace.padNumber(this.second, 2);
          outputArray[6] = "Z";
          return outputArray.join("");
        }
        return super.toString(encoding);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          year: this.year,
          month: this.month,
          day: this.day,
          hour: this.hour,
          minute: this.minute,
          second: this.second
        };
      }
    };
    _a$6 = UTCTime;
    (() => {
      typeStore.UTCTime = _a$6;
    })();
    UTCTime.NAME = "UTCTime";
    var _a$5;
    var GeneralizedTime = class extends UTCTime {
      constructor(parameters = {}) {
        var _b;
        super(parameters);
        (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 24;
      }
      fromDate(inputDate) {
        super.fromDate(inputDate);
        this.millisecond = inputDate.getUTCMilliseconds();
      }
      toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
      }
      fromString(inputString) {
        let isUTC = false;
        let timeString = "";
        let dateTimeString = "";
        let fractionPart = 0;
        let parser;
        let hourDifference = 0;
        let minuteDifference = 0;
        if (inputString[inputString.length - 1] === "Z") {
          timeString = inputString.substring(0, inputString.length - 1);
          isUTC = true;
        } else {
          const number = new Number(inputString[inputString.length - 1]);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          timeString = inputString;
        }
        if (isUTC) {
          if (timeString.indexOf("+") !== -1)
            throw new Error("Wrong input string for conversion");
          if (timeString.indexOf("-") !== -1)
            throw new Error("Wrong input string for conversion");
        } else {
          let multiplier = 1;
          let differencePosition = timeString.indexOf("+");
          let differenceString = "";
          if (differencePosition === -1) {
            differencePosition = timeString.indexOf("-");
            multiplier = -1;
          }
          if (differencePosition !== -1) {
            differenceString = timeString.substring(differencePosition + 1);
            timeString = timeString.substring(0, differencePosition);
            if (differenceString.length !== 2 && differenceString.length !== 4)
              throw new Error("Wrong input string for conversion");
            let number = parseInt(differenceString.substring(0, 2), 10);
            if (isNaN(number.valueOf()))
              throw new Error("Wrong input string for conversion");
            hourDifference = multiplier * number;
            if (differenceString.length === 4) {
              number = parseInt(differenceString.substring(2, 4), 10);
              if (isNaN(number.valueOf()))
                throw new Error("Wrong input string for conversion");
              minuteDifference = multiplier * number;
            }
          }
        }
        let fractionPointPosition = timeString.indexOf(".");
        if (fractionPointPosition === -1)
          fractionPointPosition = timeString.indexOf(",");
        if (fractionPointPosition !== -1) {
          const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
          if (isNaN(fractionPartCheck.valueOf()))
            throw new Error("Wrong input string for conversion");
          fractionPart = fractionPartCheck.valueOf();
          dateTimeString = timeString.substring(0, fractionPointPosition);
        } else
          dateTimeString = timeString;
        switch (true) {
          case dateTimeString.length === 8:
            parser = /(\d{4})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1)
              throw new Error("Wrong input string for conversion");
            break;
          case dateTimeString.length === 10:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              let fractionResult = 60 * fractionPart;
              this.minute = Math.floor(fractionResult);
              fractionResult = 60 * (fractionResult - this.minute);
              this.second = Math.floor(fractionResult);
              fractionResult = 1e3 * (fractionResult - this.second);
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          case dateTimeString.length === 12:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              let fractionResult = 60 * fractionPart;
              this.second = Math.floor(fractionResult);
              fractionResult = 1e3 * (fractionResult - this.second);
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          case dateTimeString.length === 14:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              const fractionResult = 1e3 * fractionPart;
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          default:
            throw new Error("Wrong input string for conversion");
        }
        const parserArray = parser.exec(dateTimeString);
        if (parserArray === null)
          throw new Error("Wrong input string for conversion");
        for (let j = 1; j < parserArray.length; j++) {
          switch (j) {
            case 1:
              this.year = parseInt(parserArray[j], 10);
              break;
            case 2:
              this.month = parseInt(parserArray[j], 10);
              break;
            case 3:
              this.day = parseInt(parserArray[j], 10);
              break;
            case 4:
              this.hour = parseInt(parserArray[j], 10) + hourDifference;
              break;
            case 5:
              this.minute = parseInt(parserArray[j], 10) + minuteDifference;
              break;
            case 6:
              this.second = parseInt(parserArray[j], 10);
              break;
            default:
              throw new Error("Wrong input string for conversion");
          }
        }
        if (isUTC === false) {
          const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
          this.year = tempDate.getUTCFullYear();
          this.month = tempDate.getUTCMonth();
          this.day = tempDate.getUTCDay();
          this.hour = tempDate.getUTCHours();
          this.minute = tempDate.getUTCMinutes();
          this.second = tempDate.getUTCSeconds();
          this.millisecond = tempDate.getUTCMilliseconds();
        }
      }
      toString(encoding = "iso") {
        if (encoding === "iso") {
          const outputArray = [];
          outputArray.push(pvutils__namespace.padNumber(this.year, 4));
          outputArray.push(pvutils__namespace.padNumber(this.month, 2));
          outputArray.push(pvutils__namespace.padNumber(this.day, 2));
          outputArray.push(pvutils__namespace.padNumber(this.hour, 2));
          outputArray.push(pvutils__namespace.padNumber(this.minute, 2));
          outputArray.push(pvutils__namespace.padNumber(this.second, 2));
          if (this.millisecond !== 0) {
            outputArray.push(".");
            outputArray.push(pvutils__namespace.padNumber(this.millisecond, 3));
          }
          outputArray.push("Z");
          return outputArray.join("");
        }
        return super.toString(encoding);
      }
      toJSON() {
        return {
          ...super.toJSON(),
          millisecond: this.millisecond
        };
      }
    };
    _a$5 = GeneralizedTime;
    (() => {
      typeStore.GeneralizedTime = _a$5;
    })();
    GeneralizedTime.NAME = "GeneralizedTime";
    var _a$4;
    var DATE = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 31;
      }
    };
    _a$4 = DATE;
    (() => {
      typeStore.DATE = _a$4;
    })();
    DATE.NAME = "DATE";
    var _a$3;
    var TimeOfDay = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 32;
      }
    };
    _a$3 = TimeOfDay;
    (() => {
      typeStore.TimeOfDay = _a$3;
    })();
    TimeOfDay.NAME = "TimeOfDay";
    var _a$2;
    var DateTime = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 33;
      }
    };
    _a$2 = DateTime;
    (() => {
      typeStore.DateTime = _a$2;
    })();
    DateTime.NAME = "DateTime";
    var _a$1;
    var Duration = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 34;
      }
    };
    _a$1 = Duration;
    (() => {
      typeStore.Duration = _a$1;
    })();
    Duration.NAME = "Duration";
    var _a;
    var TIME = class extends Utf8String {
      constructor(parameters = {}) {
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 14;
      }
    };
    _a = TIME;
    (() => {
      typeStore.TIME = _a;
    })();
    TIME.NAME = "TIME";
    var Any = class {
      constructor({ name = EMPTY_STRING, optional = false } = {}) {
        this.name = name;
        this.optional = optional;
      }
    };
    var Choice = class extends Any {
      constructor({ value = [], ...parameters } = {}) {
        super(parameters);
        this.value = value;
      }
    };
    var Repeated = class extends Any {
      constructor({ value = new Any(), local = false, ...parameters } = {}) {
        super(parameters);
        this.value = value;
        this.local = local;
      }
    };
    var RawData = class {
      constructor({ data = EMPTY_VIEW } = {}) {
        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(data);
      }
      get data() {
        return this.dataView.slice().buffer;
      }
      set data(value) {
        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(value);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const endLength = inputOffset + inputLength;
        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
        return endLength;
      }
      toBER(sizeOnly) {
        return this.dataView.slice().buffer;
      }
    };
    function compareSchema(root, inputData, inputSchema) {
      if (inputSchema instanceof Choice) {
        for (let j = 0; j < inputSchema.value.length; j++) {
          const result = compareSchema(root, inputData, inputSchema.value[j]);
          if (result.verified) {
            return {
              verified: true,
              result: root
            };
          }
        }
        {
          const _result = {
            verified: false,
            result: {
              error: "Wrong values for Choice type"
            }
          };
          if (inputSchema.hasOwnProperty(NAME))
            _result.name = inputSchema.name;
          return _result;
        }
      }
      if (inputSchema instanceof Any) {
        if (inputSchema.hasOwnProperty(NAME))
          root[inputSchema.name] = inputData;
        return {
          verified: true,
          result: root
        };
      }
      if (root instanceof Object === false) {
        return {
          verified: false,
          result: { error: "Wrong root object" }
        };
      }
      if (inputData instanceof Object === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 data" }
        };
      }
      if (inputSchema instanceof Object === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (ID_BLOCK in inputSchema === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (FROM_BER in inputSchema.idBlock === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (TO_BER in inputSchema.idBlock === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      const encodedId = inputSchema.idBlock.toBER(false);
      if (encodedId.byteLength === 0) {
        return {
          verified: false,
          result: { error: "Error encoding idBlock for ASN.1 schema" }
        };
      }
      const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
      if (decodedOffset === -1) {
        return {
          verified: false,
          result: { error: "Error decoding idBlock for ASN.1 schema" }
        };
      }
      if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
        return {
          verified: false,
          result: root
        };
      }
      if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
        return {
          verified: false,
          result: root
        };
      }
      if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
        return {
          verified: false,
          result: root
        };
      }
      if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema" }
        };
      }
      if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
        return {
          verified: false,
          result: root
        };
      }
      if (inputSchema.idBlock.isHexOnly) {
        if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {
          return {
            verified: false,
            result: { error: "Wrong ASN.1 schema" }
          };
        }
        const schemaView = inputSchema.idBlock.valueHexView;
        const asn1View = inputData.idBlock.valueHexView;
        if (schemaView.length !== asn1View.length) {
          return {
            verified: false,
            result: root
          };
        }
        for (let i = 0; i < schemaView.length; i++) {
          if (schemaView[i] !== asn1View[1]) {
            return {
              verified: false,
              result: root
            };
          }
        }
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name)
          root[inputSchema.name] = inputData;
      }
      if (inputSchema instanceof typeStore.Constructed) {
        let admission = 0;
        let result = {
          verified: false,
          result: {
            error: "Unknown error"
          }
        };
        let maxLength = inputSchema.valueBlock.value.length;
        if (maxLength > 0) {
          if (inputSchema.valueBlock.value[0] instanceof Repeated) {
            maxLength = inputData.valueBlock.value.length;
          }
        }
        if (maxLength === 0) {
          return {
            verified: true,
            result: root
          };
        }
        if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
          let _optional = true;
          for (let i = 0; i < inputSchema.valueBlock.value.length; i++)
            _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
          if (_optional) {
            return {
              verified: true,
              result: root
            };
          }
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
            if (inputSchema.name)
              delete root[inputSchema.name];
          }
          root.error = "Inconsistent object length";
          return {
            verified: false,
            result: root
          };
        }
        for (let i = 0; i < maxLength; i++) {
          if (i - admission >= inputData.valueBlock.value.length) {
            if (inputSchema.valueBlock.value[i].optional === false) {
              const _result = {
                verified: false,
                result: root
              };
              root.error = "Inconsistent length between ASN.1 data and schema";
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name) {
                  delete root[inputSchema.name];
                  _result.name = inputSchema.name;
                }
              }
              return _result;
            }
          } else {
            if (inputSchema.valueBlock.value[0] instanceof Repeated) {
              result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
              if (result.verified === false) {
                if (inputSchema.valueBlock.value[0].optional)
                  admission++;
                else {
                  if (inputSchema.name) {
                    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                    if (inputSchema.name)
                      delete root[inputSchema.name];
                  }
                  return result;
                }
              }
              if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
                let arrayRoot = {};
                if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
                  arrayRoot = inputData;
                else
                  arrayRoot = root;
                if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
                  arrayRoot[inputSchema.valueBlock.value[0].name] = [];
                arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
              }
            } else {
              result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
              if (result.verified === false) {
                if (inputSchema.valueBlock.value[i].optional)
                  admission++;
                else {
                  if (inputSchema.name) {
                    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                    if (inputSchema.name)
                      delete root[inputSchema.name];
                  }
                  return result;
                }
              }
            }
          }
        }
        if (result.verified === false) {
          const _result = {
            verified: false,
            result: root
          };
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {
        const asn1 = localFromBER(inputData.valueBlock.valueHexView);
        if (asn1.offset === -1) {
          const _result = {
            verified: false,
            result: asn1.result
          };
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
      }
      return {
        verified: true,
        result: root
      };
    }
    function verifySchema(inputBuffer, inputSchema) {
      if (inputSchema instanceof Object === false) {
        return {
          verified: false,
          result: { error: "Wrong ASN.1 schema type" }
        };
      }
      const asn1 = localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));
      if (asn1.offset === -1) {
        return {
          verified: false,
          result: asn1.result
        };
      }
      return compareSchema(asn1.result, asn1.result, inputSchema);
    }
    exports.Any = Any;
    exports.BaseBlock = BaseBlock;
    exports.BaseStringBlock = BaseStringBlock;
    exports.BitString = BitString;
    exports.BmpString = BmpString;
    exports.Boolean = Boolean2;
    exports.CharacterString = CharacterString;
    exports.Choice = Choice;
    exports.Constructed = Constructed;
    exports.DATE = DATE;
    exports.DateTime = DateTime;
    exports.Duration = Duration;
    exports.EndOfContent = EndOfContent;
    exports.Enumerated = Enumerated;
    exports.GeneralString = GeneralString;
    exports.GeneralizedTime = GeneralizedTime;
    exports.GraphicString = GraphicString;
    exports.HexBlock = HexBlock;
    exports.IA5String = IA5String;
    exports.Integer = Integer;
    exports.Null = Null;
    exports.NumericString = NumericString;
    exports.ObjectIdentifier = ObjectIdentifier;
    exports.OctetString = OctetString;
    exports.Primitive = Primitive;
    exports.PrintableString = PrintableString;
    exports.RawData = RawData;
    exports.RelativeObjectIdentifier = RelativeObjectIdentifier;
    exports.Repeated = Repeated;
    exports.Sequence = Sequence;
    exports.Set = Set2;
    exports.TIME = TIME;
    exports.TeletexString = TeletexString;
    exports.TimeOfDay = TimeOfDay;
    exports.UTCTime = UTCTime;
    exports.UniversalString = UniversalString;
    exports.Utf8String = Utf8String;
    exports.ValueBlock = ValueBlock;
    exports.VideotexString = VideotexString;
    exports.ViewWriter = ViewWriter;
    exports.VisibleString = VisibleString;
    exports.compareSchema = compareSchema;
    exports.fromBER = fromBER;
    exports.verifySchema = verifySchema;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/enums.js
var require_enums = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/enums.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnPropTypes = exports.AsnTypeTypes = void 0;
    var AsnTypeTypes;
    (function(AsnTypeTypes2) {
      AsnTypeTypes2[AsnTypeTypes2["Sequence"] = 0] = "Sequence";
      AsnTypeTypes2[AsnTypeTypes2["Set"] = 1] = "Set";
      AsnTypeTypes2[AsnTypeTypes2["Choice"] = 2] = "Choice";
    })(AsnTypeTypes = exports.AsnTypeTypes || (exports.AsnTypeTypes = {}));
    var AsnPropTypes;
    (function(AsnPropTypes2) {
      AsnPropTypes2[AsnPropTypes2["Any"] = 1] = "Any";
      AsnPropTypes2[AsnPropTypes2["Boolean"] = 2] = "Boolean";
      AsnPropTypes2[AsnPropTypes2["OctetString"] = 3] = "OctetString";
      AsnPropTypes2[AsnPropTypes2["BitString"] = 4] = "BitString";
      AsnPropTypes2[AsnPropTypes2["Integer"] = 5] = "Integer";
      AsnPropTypes2[AsnPropTypes2["Enumerated"] = 6] = "Enumerated";
      AsnPropTypes2[AsnPropTypes2["ObjectIdentifier"] = 7] = "ObjectIdentifier";
      AsnPropTypes2[AsnPropTypes2["Utf8String"] = 8] = "Utf8String";
      AsnPropTypes2[AsnPropTypes2["BmpString"] = 9] = "BmpString";
      AsnPropTypes2[AsnPropTypes2["UniversalString"] = 10] = "UniversalString";
      AsnPropTypes2[AsnPropTypes2["NumericString"] = 11] = "NumericString";
      AsnPropTypes2[AsnPropTypes2["PrintableString"] = 12] = "PrintableString";
      AsnPropTypes2[AsnPropTypes2["TeletexString"] = 13] = "TeletexString";
      AsnPropTypes2[AsnPropTypes2["VideotexString"] = 14] = "VideotexString";
      AsnPropTypes2[AsnPropTypes2["IA5String"] = 15] = "IA5String";
      AsnPropTypes2[AsnPropTypes2["GraphicString"] = 16] = "GraphicString";
      AsnPropTypes2[AsnPropTypes2["VisibleString"] = 17] = "VisibleString";
      AsnPropTypes2[AsnPropTypes2["GeneralString"] = 18] = "GeneralString";
      AsnPropTypes2[AsnPropTypes2["CharacterString"] = 19] = "CharacterString";
      AsnPropTypes2[AsnPropTypes2["UTCTime"] = 20] = "UTCTime";
      AsnPropTypes2[AsnPropTypes2["GeneralizedTime"] = 21] = "GeneralizedTime";
      AsnPropTypes2[AsnPropTypes2["DATE"] = 22] = "DATE";
      AsnPropTypes2[AsnPropTypes2["TimeOfDay"] = 23] = "TimeOfDay";
      AsnPropTypes2[AsnPropTypes2["DateTime"] = 24] = "DateTime";
      AsnPropTypes2[AsnPropTypes2["Duration"] = 25] = "Duration";
      AsnPropTypes2[AsnPropTypes2["TIME"] = 26] = "TIME";
      AsnPropTypes2[AsnPropTypes2["Null"] = 27] = "Null";
    })(AsnPropTypes = exports.AsnPropTypes || (exports.AsnPropTypes = {}));
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js
var require_bit_string = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitString = void 0;
    var asn1js = require_build2();
    var pvtsutils_1 = require_build();
    var BitString = class {
      constructor(params, unusedBits = 0) {
        this.unusedBits = 0;
        this.value = new ArrayBuffer(0);
        if (params) {
          if (typeof params === "number") {
            this.fromNumber(params);
          } else if (pvtsutils_1.BufferSourceConverter.isBufferSource(params)) {
            this.unusedBits = unusedBits;
            this.value = pvtsutils_1.BufferSourceConverter.toArrayBuffer(params);
          } else {
            throw TypeError("Unsupported type of 'params' argument for BitString");
          }
        }
      }
      fromASN(asn) {
        if (!(asn instanceof asn1js.BitString)) {
          throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
        }
        this.unusedBits = asn.valueBlock.unusedBits;
        this.value = asn.valueBlock.valueHex;
        return this;
      }
      toASN() {
        return new asn1js.BitString({ unusedBits: this.unusedBits, valueHex: this.value });
      }
      toSchema(name) {
        return new asn1js.BitString({ name });
      }
      toNumber() {
        let res = "";
        const uintArray = new Uint8Array(this.value);
        for (const octet of uintArray) {
          res += octet.toString(2).padStart(8, "0");
        }
        res = res.split("").reverse().join("");
        if (this.unusedBits) {
          res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
        }
        return parseInt(res, 2);
      }
      fromNumber(value) {
        let bits = value.toString(2);
        const octetSize = bits.length + 7 >> 3;
        this.unusedBits = (octetSize << 3) - bits.length;
        const octets = new Uint8Array(octetSize);
        bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
        let index = 0;
        while (index < octetSize) {
          octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
          index++;
        }
        this.value = octets.buffer;
      }
    };
    exports.BitString = BitString;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js
var require_octet_string = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OctetString = void 0;
    var asn1js = require_build2();
    var pvtsutils_1 = require_build();
    var OctetString = class {
      constructor(param) {
        if (typeof param === "number") {
          this.buffer = new ArrayBuffer(param);
        } else {
          if (pvtsutils_1.BufferSourceConverter.isBufferSource(param)) {
            this.buffer = pvtsutils_1.BufferSourceConverter.toArrayBuffer(param);
          } else if (Array.isArray(param)) {
            this.buffer = new Uint8Array(param);
          } else {
            this.buffer = new ArrayBuffer(0);
          }
        }
      }
      get byteLength() {
        return this.buffer.byteLength;
      }
      get byteOffset() {
        return 0;
      }
      fromASN(asn) {
        if (!(asn instanceof asn1js.OctetString)) {
          throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
        }
        this.buffer = asn.valueBlock.valueHex;
        return this;
      }
      toASN() {
        return new asn1js.OctetString({ valueHex: this.buffer });
      }
      toSchema(name) {
        return new asn1js.OctetString({ name });
      }
    };
    exports.OctetString = OctetString;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/types/index.js
var require_types = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_bit_string(), exports);
    tslib_1.__exportStar(require_octet_string(), exports);
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/converters.js
var require_converters = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/converters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultConverter = exports.AsnNullConverter = exports.AsnGeneralizedTimeConverter = exports.AsnUTCTimeConverter = exports.AsnCharacterStringConverter = exports.AsnGeneralStringConverter = exports.AsnVisibleStringConverter = exports.AsnGraphicStringConverter = exports.AsnIA5StringConverter = exports.AsnVideotexStringConverter = exports.AsnTeletexStringConverter = exports.AsnPrintableStringConverter = exports.AsnNumericStringConverter = exports.AsnUniversalStringConverter = exports.AsnBmpStringConverter = exports.AsnUtf8StringConverter = exports.AsnConstructedOctetStringConverter = exports.AsnOctetStringConverter = exports.AsnBooleanConverter = exports.AsnObjectIdentifierConverter = exports.AsnBitStringConverter = exports.AsnIntegerBigIntConverter = exports.AsnIntegerArrayBufferConverter = exports.AsnEnumeratedConverter = exports.AsnIntegerConverter = exports.AsnAnyConverter = void 0;
    var asn1js = require_build2();
    var enums_1 = require_enums();
    var index_1 = require_types();
    exports.AsnAnyConverter = {
      fromASN: (value) => value instanceof asn1js.Null ? null : value.valueBeforeDecodeView,
      toASN: (value) => {
        if (value === null) {
          return new asn1js.Null();
        }
        const schema = asn1js.fromBER(value);
        if (schema.result.error) {
          throw new Error(schema.result.error);
        }
        return schema.result;
      }
    };
    exports.AsnIntegerConverter = {
      fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
      toASN: (value) => new asn1js.Integer({ value: +value })
    };
    exports.AsnEnumeratedConverter = {
      fromASN: (value) => value.valueBlock.valueDec,
      toASN: (value) => new asn1js.Enumerated({ value })
    };
    exports.AsnIntegerArrayBufferConverter = {
      fromASN: (value) => value.valueBlock.valueHexView,
      toASN: (value) => new asn1js.Integer({ valueHex: value })
    };
    exports.AsnIntegerBigIntConverter = {
      fromASN: (value) => value.toBigInt(),
      toASN: (value) => asn1js.Integer.fromBigInt(value)
    };
    exports.AsnBitStringConverter = {
      fromASN: (value) => value.valueBlock.valueHexView,
      toASN: (value) => new asn1js.BitString({ valueHex: value })
    };
    exports.AsnObjectIdentifierConverter = {
      fromASN: (value) => value.valueBlock.toString(),
      toASN: (value) => new asn1js.ObjectIdentifier({ value })
    };
    exports.AsnBooleanConverter = {
      fromASN: (value) => value.valueBlock.value,
      toASN: (value) => new asn1js.Boolean({ value })
    };
    exports.AsnOctetStringConverter = {
      fromASN: (value) => value.valueBlock.valueHexView,
      toASN: (value) => new asn1js.OctetString({ valueHex: value })
    };
    exports.AsnConstructedOctetStringConverter = {
      fromASN: (value) => new index_1.OctetString(value.getValue()),
      toASN: (value) => value.toASN()
    };
    function createStringConverter(Asn1Type) {
      return {
        fromASN: (value) => value.valueBlock.value,
        toASN: (value) => new Asn1Type({ value })
      };
    }
    exports.AsnUtf8StringConverter = createStringConverter(asn1js.Utf8String);
    exports.AsnBmpStringConverter = createStringConverter(asn1js.BmpString);
    exports.AsnUniversalStringConverter = createStringConverter(asn1js.UniversalString);
    exports.AsnNumericStringConverter = createStringConverter(asn1js.NumericString);
    exports.AsnPrintableStringConverter = createStringConverter(asn1js.PrintableString);
    exports.AsnTeletexStringConverter = createStringConverter(asn1js.TeletexString);
    exports.AsnVideotexStringConverter = createStringConverter(asn1js.VideotexString);
    exports.AsnIA5StringConverter = createStringConverter(asn1js.IA5String);
    exports.AsnGraphicStringConverter = createStringConverter(asn1js.GraphicString);
    exports.AsnVisibleStringConverter = createStringConverter(asn1js.VisibleString);
    exports.AsnGeneralStringConverter = createStringConverter(asn1js.GeneralString);
    exports.AsnCharacterStringConverter = createStringConverter(asn1js.CharacterString);
    exports.AsnUTCTimeConverter = {
      fromASN: (value) => value.toDate(),
      toASN: (value) => new asn1js.UTCTime({ valueDate: value })
    };
    exports.AsnGeneralizedTimeConverter = {
      fromASN: (value) => value.toDate(),
      toASN: (value) => new asn1js.GeneralizedTime({ valueDate: value })
    };
    exports.AsnNullConverter = {
      fromASN: () => null,
      toASN: () => {
        return new asn1js.Null();
      }
    };
    function defaultConverter(type) {
      switch (type) {
        case enums_1.AsnPropTypes.Any:
          return exports.AsnAnyConverter;
        case enums_1.AsnPropTypes.BitString:
          return exports.AsnBitStringConverter;
        case enums_1.AsnPropTypes.BmpString:
          return exports.AsnBmpStringConverter;
        case enums_1.AsnPropTypes.Boolean:
          return exports.AsnBooleanConverter;
        case enums_1.AsnPropTypes.CharacterString:
          return exports.AsnCharacterStringConverter;
        case enums_1.AsnPropTypes.Enumerated:
          return exports.AsnEnumeratedConverter;
        case enums_1.AsnPropTypes.GeneralString:
          return exports.AsnGeneralStringConverter;
        case enums_1.AsnPropTypes.GeneralizedTime:
          return exports.AsnGeneralizedTimeConverter;
        case enums_1.AsnPropTypes.GraphicString:
          return exports.AsnGraphicStringConverter;
        case enums_1.AsnPropTypes.IA5String:
          return exports.AsnIA5StringConverter;
        case enums_1.AsnPropTypes.Integer:
          return exports.AsnIntegerConverter;
        case enums_1.AsnPropTypes.Null:
          return exports.AsnNullConverter;
        case enums_1.AsnPropTypes.NumericString:
          return exports.AsnNumericStringConverter;
        case enums_1.AsnPropTypes.ObjectIdentifier:
          return exports.AsnObjectIdentifierConverter;
        case enums_1.AsnPropTypes.OctetString:
          return exports.AsnOctetStringConverter;
        case enums_1.AsnPropTypes.PrintableString:
          return exports.AsnPrintableStringConverter;
        case enums_1.AsnPropTypes.TeletexString:
          return exports.AsnTeletexStringConverter;
        case enums_1.AsnPropTypes.UTCTime:
          return exports.AsnUTCTimeConverter;
        case enums_1.AsnPropTypes.UniversalString:
          return exports.AsnUniversalStringConverter;
        case enums_1.AsnPropTypes.Utf8String:
          return exports.AsnUtf8StringConverter;
        case enums_1.AsnPropTypes.VideotexString:
          return exports.AsnVideotexStringConverter;
        case enums_1.AsnPropTypes.VisibleString:
          return exports.AsnVisibleStringConverter;
        default:
          return null;
      }
    }
    exports.defaultConverter = defaultConverter;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/helper.js
var require_helper = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArrayEqual = exports.isTypeOfArray = exports.isConvertible = void 0;
    function isConvertible(target2) {
      if (typeof target2 === "function" && target2.prototype) {
        if (target2.prototype.toASN && target2.prototype.fromASN) {
          return true;
        } else {
          return isConvertible(target2.prototype);
        }
      } else {
        return !!(target2 && typeof target2 === "object" && "toASN" in target2 && "fromASN" in target2);
      }
    }
    exports.isConvertible = isConvertible;
    function isTypeOfArray(target2) {
      var _a;
      if (target2) {
        const proto = Object.getPrototypeOf(target2);
        if (((_a = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === Array) {
          return true;
        }
        return isTypeOfArray(proto);
      }
      return false;
    }
    exports.isTypeOfArray = isTypeOfArray;
    function isArrayEqual(bytes1, bytes2) {
      if (!(bytes1 && bytes2)) {
        return false;
      }
      if (bytes1.byteLength !== bytes2.byteLength) {
        return false;
      }
      const b1 = new Uint8Array(bytes1);
      const b2 = new Uint8Array(bytes2);
      for (let i = 0; i < bytes1.byteLength; i++) {
        if (b1[i] !== b2[i]) {
          return false;
        }
      }
      return true;
    }
    exports.isArrayEqual = isArrayEqual;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/schema.js
var require_schema = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnSchemaStorage = void 0;
    var asn1js = require_build2();
    var enums_1 = require_enums();
    var helper_1 = require_helper();
    var AsnSchemaStorage = class {
      constructor() {
        this.items = /* @__PURE__ */ new WeakMap();
      }
      has(target2) {
        return this.items.has(target2);
      }
      get(target2, checkSchema = false) {
        const schema = this.items.get(target2);
        if (!schema) {
          throw new Error(`Cannot get schema for '${target2.prototype.constructor.name}' target`);
        }
        if (checkSchema && !schema.schema) {
          throw new Error(`Schema '${target2.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
        }
        return schema;
      }
      cache(target2) {
        const schema = this.get(target2);
        if (!schema.schema) {
          schema.schema = this.create(target2, true);
        }
      }
      createDefault(target2) {
        const schema = {
          type: enums_1.AsnTypeTypes.Sequence,
          items: {}
        };
        const parentSchema = this.findParentSchema(target2);
        if (parentSchema) {
          Object.assign(schema, parentSchema);
          schema.items = Object.assign({}, schema.items, parentSchema.items);
        }
        return schema;
      }
      create(target2, useNames) {
        const schema = this.items.get(target2) || this.createDefault(target2);
        const asn1Value = [];
        for (const key in schema.items) {
          const item = schema.items[key];
          const name = useNames ? key : "";
          let asn1Item;
          if (typeof item.type === "number") {
            const Asn1TypeName = enums_1.AsnPropTypes[item.type];
            const Asn1Type = asn1js[Asn1TypeName];
            if (!Asn1Type) {
              throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
            }
            asn1Item = new Asn1Type({ name });
          } else if ((0, helper_1.isConvertible)(item.type)) {
            const instance = new item.type();
            asn1Item = instance.toSchema(name);
          } else if (item.optional) {
            const itemSchema = this.get(item.type);
            if (itemSchema.type === enums_1.AsnTypeTypes.Choice) {
              asn1Item = new asn1js.Any({ name });
            } else {
              asn1Item = this.create(item.type, false);
              asn1Item.name = name;
            }
          } else {
            asn1Item = new asn1js.Any({ name });
          }
          const optional = !!item.optional || item.defaultValue !== void 0;
          if (item.repeated) {
            asn1Item.name = "";
            const Container = item.repeated === "set" ? asn1js.Set : asn1js.Sequence;
            asn1Item = new Container({
              name: "",
              value: [
                new asn1js.Repeated({
                  name,
                  value: asn1Item
                })
              ]
            });
          }
          if (item.context !== null && item.context !== void 0) {
            if (item.implicit) {
              if (typeof item.type === "number" || (0, helper_1.isConvertible)(item.type)) {
                const Container = item.repeated ? asn1js.Constructed : asn1js.Primitive;
                asn1Value.push(new Container({
                  name,
                  optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: item.context
                  }
                }));
              } else {
                this.cache(item.type);
                const isRepeated = !!item.repeated;
                let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
                value = "valueBlock" in value ? value.valueBlock.value : value.value;
                asn1Value.push(new asn1js.Constructed({
                  name: !isRepeated ? name : "",
                  optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: item.context
                  },
                  value
                }));
              }
            } else {
              asn1Value.push(new asn1js.Constructed({
                optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: item.context
                },
                value: [asn1Item]
              }));
            }
          } else {
            asn1Item.optional = optional;
            asn1Value.push(asn1Item);
          }
        }
        switch (schema.type) {
          case enums_1.AsnTypeTypes.Sequence:
            return new asn1js.Sequence({ value: asn1Value, name: "" });
          case enums_1.AsnTypeTypes.Set:
            return new asn1js.Set({ value: asn1Value, name: "" });
          case enums_1.AsnTypeTypes.Choice:
            return new asn1js.Choice({ value: asn1Value, name: "" });
          default:
            throw new Error(`Unsupported ASN1 type in use`);
        }
      }
      set(target2, schema) {
        this.items.set(target2, schema);
        return this;
      }
      findParentSchema(target2) {
        const parent = Object.getPrototypeOf(target2);
        if (parent) {
          const schema = this.items.get(parent);
          return schema || this.findParentSchema(parent);
        }
        return null;
      }
    };
    exports.AsnSchemaStorage = AsnSchemaStorage;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/storage.js
var require_storage = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/storage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schemaStorage = void 0;
    var schema_1 = require_schema();
    exports.schemaStorage = new schema_1.AsnSchemaStorage();
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/decorators.js
var require_decorators = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/decorators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnProp = exports.AsnSequenceType = exports.AsnSetType = exports.AsnChoiceType = exports.AsnType = void 0;
    var converters = require_converters();
    var enums_1 = require_enums();
    var storage_1 = require_storage();
    var AsnType = (options) => (target2) => {
      let schema;
      if (!storage_1.schemaStorage.has(target2)) {
        schema = storage_1.schemaStorage.createDefault(target2);
        storage_1.schemaStorage.set(target2, schema);
      } else {
        schema = storage_1.schemaStorage.get(target2);
      }
      Object.assign(schema, options);
    };
    exports.AsnType = AsnType;
    var AsnChoiceType = () => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Choice });
    exports.AsnChoiceType = AsnChoiceType;
    var AsnSetType = (options) => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Set, ...options });
    exports.AsnSetType = AsnSetType;
    var AsnSequenceType = (options) => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Sequence, ...options });
    exports.AsnSequenceType = AsnSequenceType;
    var AsnProp = (options) => (target2, propertyKey) => {
      let schema;
      if (!storage_1.schemaStorage.has(target2.constructor)) {
        schema = storage_1.schemaStorage.createDefault(target2.constructor);
        storage_1.schemaStorage.set(target2.constructor, schema);
      } else {
        schema = storage_1.schemaStorage.get(target2.constructor);
      }
      const copyOptions = Object.assign({}, options);
      if (typeof copyOptions.type === "number" && !copyOptions.converter) {
        const defaultConverter = converters.defaultConverter(options.type);
        if (!defaultConverter) {
          throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target2.constructor.name}`);
        }
        copyOptions.converter = defaultConverter;
      }
      schema.items[propertyKey] = copyOptions;
    };
    exports.AsnProp = AsnProp;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js
var require_schema_validation = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnSchemaValidationError = void 0;
    var AsnSchemaValidationError = class extends Error {
      constructor() {
        super(...arguments);
        this.schemas = [];
      }
    };
    exports.AsnSchemaValidationError = AsnSchemaValidationError;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js
var require_errors = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_schema_validation(), exports);
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/parser.js
var require_parser = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnParser = void 0;
    var asn1js = require_build2();
    var enums_1 = require_enums();
    var converters = require_converters();
    var errors_1 = require_errors();
    var helper_1 = require_helper();
    var storage_1 = require_storage();
    var AsnParser = class {
      static parse(data, target2) {
        const asn1Parsed = asn1js.fromBER(data);
        if (asn1Parsed.result.error) {
          throw new Error(asn1Parsed.result.error);
        }
        const res = this.fromASN(asn1Parsed.result, target2);
        return res;
      }
      static fromASN(asn1Schema, target2) {
        var _a;
        try {
          if ((0, helper_1.isConvertible)(target2)) {
            const value = new target2();
            return value.fromASN(asn1Schema);
          }
          const schema = storage_1.schemaStorage.get(target2);
          storage_1.schemaStorage.cache(target2);
          let targetSchema = schema.schema;
          if (asn1Schema.constructor === asn1js.Constructed && schema.type !== enums_1.AsnTypeTypes.Choice) {
            targetSchema = new asn1js.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: asn1Schema.idBlock.tagNumber
              },
              value: schema.schema.valueBlock.value
            });
            for (const key in schema.items) {
              delete asn1Schema[key];
            }
          }
          const asn1ComparedSchema = asn1js.compareSchema({}, asn1Schema, targetSchema);
          if (!asn1ComparedSchema.verified) {
            throw new errors_1.AsnSchemaValidationError(`Data does not match to ${target2.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);
          }
          const res = new target2();
          if ((0, helper_1.isTypeOfArray)(target2)) {
            if (!("value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {
              throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);
            }
            const itemType = schema.itemType;
            if (typeof itemType === "number") {
              const converter = converters.defaultConverter(itemType);
              if (!converter) {
                throw new Error(`Cannot get default converter for array item of ${target2.name} ASN1 schema`);
              }
              return target2.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));
            } else {
              return target2.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));
            }
          }
          for (const key in schema.items) {
            const asn1SchemaValue = asn1ComparedSchema.result[key];
            if (!asn1SchemaValue) {
              continue;
            }
            const schemaItem = schema.items[key];
            const schemaItemType = schemaItem.type;
            if (typeof schemaItemType === "number" || (0, helper_1.isConvertible)(schemaItemType)) {
              const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : (0, helper_1.isConvertible)(schemaItemType) ? new schemaItemType() : null;
              if (!converter) {
                throw new Error("Converter is empty");
              }
              if (schemaItem.repeated) {
                if (schemaItem.implicit) {
                  const Container = schemaItem.repeated === "sequence" ? asn1js.Sequence : asn1js.Set;
                  const newItem = new Container();
                  newItem.valueBlock = asn1SchemaValue.valueBlock;
                  const newItemAsn = asn1js.fromBER(newItem.toBER(false));
                  if (newItemAsn.offset === -1) {
                    throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);
                  }
                  if (!("value" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {
                    throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");
                  }
                  const value = newItemAsn.result.valueBlock.value;
                  res[key] = Array.from(value, (element) => converter.fromASN(element));
                } else {
                  res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));
                }
              } else {
                let value = asn1SchemaValue;
                if (schemaItem.implicit) {
                  let newItem;
                  if ((0, helper_1.isConvertible)(schemaItemType)) {
                    newItem = new schemaItemType().toSchema("");
                  } else {
                    const Asn1TypeName = enums_1.AsnPropTypes[schemaItemType];
                    const Asn1Type = asn1js[Asn1TypeName];
                    if (!Asn1Type) {
                      throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
                    }
                    newItem = new Asn1Type();
                  }
                  newItem.valueBlock = value.valueBlock;
                  value = asn1js.fromBER(newItem.toBER(false)).result;
                }
                res[key] = converter.fromASN(value);
              }
            } else {
              if (schemaItem.repeated) {
                if (!Array.isArray(asn1SchemaValue)) {
                  throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");
                }
                res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));
              } else {
                res[key] = this.fromASN(asn1SchemaValue, schemaItemType);
              }
            }
          }
          return res;
        } catch (error) {
          if (error instanceof errors_1.AsnSchemaValidationError) {
            error.schemas.push(target2.name);
          }
          throw error;
        }
      }
    };
    exports.AsnParser = AsnParser;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/serializer.js
var require_serializer = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/serializer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnSerializer = void 0;
    var asn1js = require_build2();
    var converters = require_converters();
    var enums_1 = require_enums();
    var helper_1 = require_helper();
    var storage_1 = require_storage();
    var AsnSerializer = class _AsnSerializer {
      static serialize(obj) {
        if (obj instanceof asn1js.BaseBlock) {
          return obj.toBER(false);
        }
        return this.toASN(obj).toBER(false);
      }
      static toASN(obj) {
        if (obj && typeof obj === "object" && (0, helper_1.isConvertible)(obj)) {
          return obj.toASN();
        }
        if (!(obj && typeof obj === "object")) {
          throw new TypeError("Parameter 1 should be type of Object.");
        }
        const target2 = obj.constructor;
        const schema = storage_1.schemaStorage.get(target2);
        storage_1.schemaStorage.cache(target2);
        let asn1Value = [];
        if (schema.itemType) {
          if (!Array.isArray(obj)) {
            throw new TypeError("Parameter 1 should be type of Array.");
          }
          if (typeof schema.itemType === "number") {
            const converter = converters.defaultConverter(schema.itemType);
            if (!converter) {
              throw new Error(`Cannot get default converter for array item of ${target2.name} ASN1 schema`);
            }
            asn1Value = obj.map((o) => converter.toASN(o));
          } else {
            asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, "[]", target2, o));
          }
        } else {
          for (const key in schema.items) {
            const schemaItem = schema.items[key];
            const objProp = obj[key];
            if (objProp === void 0 || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && (0, helper_1.isArrayEqual)(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {
              continue;
            }
            const asn1Item = _AsnSerializer.toAsnItem(schemaItem, key, target2, objProp);
            if (typeof schemaItem.context === "number") {
              if (schemaItem.implicit) {
                if (!schemaItem.repeated && (typeof schemaItem.type === "number" || (0, helper_1.isConvertible)(schemaItem.type))) {
                  const value = {};
                  value.valueHex = asn1Item instanceof asn1js.Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();
                  asn1Value.push(new asn1js.Primitive({
                    optional: schemaItem.optional,
                    idBlock: {
                      tagClass: 3,
                      tagNumber: schemaItem.context
                    },
                    ...value
                  }));
                } else {
                  asn1Value.push(new asn1js.Constructed({
                    optional: schemaItem.optional,
                    idBlock: {
                      tagClass: 3,
                      tagNumber: schemaItem.context
                    },
                    value: asn1Item.valueBlock.value
                  }));
                }
              } else {
                asn1Value.push(new asn1js.Constructed({
                  optional: schemaItem.optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: schemaItem.context
                  },
                  value: [asn1Item]
                }));
              }
            } else if (schemaItem.repeated) {
              asn1Value = asn1Value.concat(asn1Item);
            } else {
              asn1Value.push(asn1Item);
            }
          }
        }
        let asnSchema;
        switch (schema.type) {
          case enums_1.AsnTypeTypes.Sequence:
            asnSchema = new asn1js.Sequence({ value: asn1Value });
            break;
          case enums_1.AsnTypeTypes.Set:
            asnSchema = new asn1js.Set({ value: asn1Value });
            break;
          case enums_1.AsnTypeTypes.Choice:
            if (!asn1Value[0]) {
              throw new Error(`Schema '${target2.name}' has wrong data. Choice cannot be empty.`);
            }
            asnSchema = asn1Value[0];
            break;
        }
        return asnSchema;
      }
      static toAsnItem(schemaItem, key, target2, objProp) {
        let asn1Item;
        if (typeof schemaItem.type === "number") {
          const converter = schemaItem.converter;
          if (!converter) {
            throw new Error(`Property '${key}' doesn't have converter for type ${enums_1.AsnPropTypes[schemaItem.type]} in schema '${target2.name}'`);
          }
          if (schemaItem.repeated) {
            if (!Array.isArray(objProp)) {
              throw new TypeError("Parameter 'objProp' should be type of Array.");
            }
            const items = Array.from(objProp, (element) => converter.toASN(element));
            const Container = schemaItem.repeated === "sequence" ? asn1js.Sequence : asn1js.Set;
            asn1Item = new Container({
              value: items
            });
          } else {
            asn1Item = converter.toASN(objProp);
          }
        } else {
          if (schemaItem.repeated) {
            if (!Array.isArray(objProp)) {
              throw new TypeError("Parameter 'objProp' should be type of Array.");
            }
            const items = Array.from(objProp, (element) => this.toASN(element));
            const Container = schemaItem.repeated === "sequence" ? asn1js.Sequence : asn1js.Set;
            asn1Item = new Container({
              value: items
            });
          } else {
            asn1Item = this.toASN(objProp);
          }
        }
        return asn1Item;
      }
    };
    exports.AsnSerializer = AsnSerializer;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/objects.js
var require_objects = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/objects.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnArray = void 0;
    var AsnArray = class extends Array {
      constructor(items = []) {
        if (typeof items === "number") {
          super(items);
        } else {
          super();
          for (const item of items) {
            this.push(item);
          }
        }
      }
    };
    exports.AsnArray = AsnArray;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/convert.js
var require_convert = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/convert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnConvert = void 0;
    var asn1js = require_build2();
    var pvtsutils_1 = require_build();
    var parser_1 = require_parser();
    var serializer_1 = require_serializer();
    var AsnConvert = class _AsnConvert {
      static serialize(obj) {
        return serializer_1.AsnSerializer.serialize(obj);
      }
      static parse(data, target2) {
        return parser_1.AsnParser.parse(data, target2);
      }
      static toString(data) {
        const buf = pvtsutils_1.BufferSourceConverter.isBufferSource(data) ? pvtsutils_1.BufferSourceConverter.toArrayBuffer(data) : _AsnConvert.serialize(data);
        const asn = asn1js.fromBER(buf);
        if (asn.offset === -1) {
          throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
        }
        return asn.result.toString();
      }
    };
    exports.AsnConvert = AsnConvert;
  }
});

// node_modules/@peculiar/asn1-schema/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@peculiar/asn1-schema/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsnSerializer = exports.AsnParser = exports.AsnPropTypes = exports.AsnTypeTypes = exports.AsnSetType = exports.AsnSequenceType = exports.AsnChoiceType = exports.AsnType = exports.AsnProp = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_converters(), exports);
    tslib_1.__exportStar(require_types(), exports);
    var decorators_1 = require_decorators();
    Object.defineProperty(exports, "AsnProp", { enumerable: true, get: function() {
      return decorators_1.AsnProp;
    } });
    Object.defineProperty(exports, "AsnType", { enumerable: true, get: function() {
      return decorators_1.AsnType;
    } });
    Object.defineProperty(exports, "AsnChoiceType", { enumerable: true, get: function() {
      return decorators_1.AsnChoiceType;
    } });
    Object.defineProperty(exports, "AsnSequenceType", { enumerable: true, get: function() {
      return decorators_1.AsnSequenceType;
    } });
    Object.defineProperty(exports, "AsnSetType", { enumerable: true, get: function() {
      return decorators_1.AsnSetType;
    } });
    var enums_1 = require_enums();
    Object.defineProperty(exports, "AsnTypeTypes", { enumerable: true, get: function() {
      return enums_1.AsnTypeTypes;
    } });
    Object.defineProperty(exports, "AsnPropTypes", { enumerable: true, get: function() {
      return enums_1.AsnPropTypes;
    } });
    var parser_1 = require_parser();
    Object.defineProperty(exports, "AsnParser", { enumerable: true, get: function() {
      return parser_1.AsnParser;
    } });
    var serializer_1 = require_serializer();
    Object.defineProperty(exports, "AsnSerializer", { enumerable: true, get: function() {
      return serializer_1.AsnSerializer;
    } });
    tslib_1.__exportStar(require_errors(), exports);
    tslib_1.__exportStar(require_objects(), exports);
    tslib_1.__exportStar(require_convert(), exports);
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports, module) {
    (function(root) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string, parts) {
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          const ref = string.split(":");
          const results = [];
          for (let i = 0; i < ref.length; i++) {
            results.push(parseInt(ref[i], 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      }
      function matchCIDR(first, second, partSize, cidrBits) {
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string) {
        if (hexRegex.test(string)) {
          return parseInt(string, 16);
        }
        if (string[0] === "0" && !isNaN(parseInt(string[1], 10))) {
          if (octalRegex.test(string)) {
            return parseInt(string, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string} as octal`);
        }
        return parseInt(string, 10);
      }
      function padPart(part, length) {
        while (part.length < length) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr = {};
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          // RFC3171
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          // RFC3927
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          // RFC5735
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          // RFC6598
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          // RFC1918
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 18, 0, 0]), 15],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3; i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
        try {
          const cidr = this.parseCIDR(string);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.isIPv4 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = function(string) {
        try {
          new this(this.parser(string));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.parse = function(string) {
        const parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr.IPv4.parseCIDR = function(string) {
        let match;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.parser = function(string) {
        let match, part, value;
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i = 0; i < ref.length; i++) {
              part = ref[i];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0; i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0; i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          // RFC4291, here and after
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          // RFC6145
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          // RFC6052
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          // RFC3056
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          // RFC6052, RFC6146
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          // RFC4291
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]],
          benchmarking: [new IPv6([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
          amt: [new IPv6([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
          as112v6: [new IPv6([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
          deprecated: [new IPv6([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
          orchid2: [new IPv6([8193, 32, 0, 0, 0, 0, 0, 0]), 28]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7; i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes = [];
          const ref = this.parts;
          for (let i = 0; i < ref.length; i++) {
            part = ref[i];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toRFC5952String();
        };
        return IPv6;
      }();
      ipaddr.IPv6.broadcastAddressFromCIDR = function(string) {
        try {
          const cidr = this.parseCIDR(string);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv6.isValid = function(string) {
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv6.networkAddressFromCIDR = function(string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.parse = function(string) {
        const addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv6.parseCIDR = function(string) {
        let maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.IPv6.parser = function(string) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string)) {
          return expandIPv6(string, 8);
        }
        if (match = string.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.fromByteArray = function(bytes) {
        const length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string) {
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (e) {
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.process = function(string) {
        const addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0; i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = ipaddr;
      } else {
        root.ipaddr = ipaddr;
      }
    })(exports);
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/ip_converter.js
var require_ip_converter = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/ip_converter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IpConverter = void 0;
    var ip = require_ipaddr();
    var pvtsutils_1 = require_build();
    var IpConverter = class {
      static decodeIP(value) {
        if (value.length === 64 && parseInt(value, 16) === 0) {
          return "::/0";
        }
        if (value.length !== 16) {
          return value;
        }
        const mask = parseInt(value.slice(8), 16).toString(2).split("").reduce((a, k) => a + +k, 0);
        let ip2 = value.slice(0, 8).replace(/(.{2})/g, (match) => `${parseInt(match, 16)}.`);
        ip2 = ip2.slice(0, -1);
        return `${ip2}/${mask}`;
      }
      static toString(buf) {
        if (buf.byteLength === 4 || buf.byteLength === 16) {
          const uint8 = new Uint8Array(buf);
          const addr = ip.fromByteArray(Array.from(uint8));
          return addr.toString();
        }
        return this.decodeIP(pvtsutils_1.Convert.ToHex(buf));
      }
      static fromString(text) {
        const addr = ip.parse(text);
        return new Uint8Array(addr.toByteArray()).buffer;
      }
    };
    exports.IpConverter = IpConverter;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/name.js
var require_name = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/name.js"(exports) {
    "use strict";
    var RelativeDistinguishedName_1;
    var RDNSequence_1;
    var Name_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Name = exports.RDNSequence = exports.RelativeDistinguishedName = exports.AttributeTypeAndValue = exports.AttributeValue = exports.DirectoryString = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var pvtsutils_1 = require_build();
    var DirectoryString = class DirectoryString {
      constructor(params = {}) {
        Object.assign(this, params);
      }
      toString() {
        return this.bmpString || this.printableString || this.teletexString || this.universalString || this.utf8String || "";
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.TeletexString })
    ], DirectoryString.prototype, "teletexString", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.PrintableString })
    ], DirectoryString.prototype, "printableString", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.UniversalString })
    ], DirectoryString.prototype, "universalString", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Utf8String })
    ], DirectoryString.prototype, "utf8String", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BmpString })
    ], DirectoryString.prototype, "bmpString", void 0);
    DirectoryString = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], DirectoryString);
    exports.DirectoryString = DirectoryString;
    var AttributeValue = class AttributeValue extends DirectoryString {
      constructor(params = {}) {
        super(params);
        Object.assign(this, params);
      }
      toString() {
        return this.ia5String || (this.anyValue ? pvtsutils_1.Convert.ToHex(this.anyValue) : super.toString());
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.IA5String })
    ], AttributeValue.prototype, "ia5String", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any })
    ], AttributeValue.prototype, "anyValue", void 0);
    AttributeValue = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], AttributeValue);
    exports.AttributeValue = AttributeValue;
    var AttributeTypeAndValue = class {
      constructor(params = {}) {
        this.type = "";
        this.value = new AttributeValue();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], AttributeTypeAndValue.prototype, "type", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: AttributeValue })
    ], AttributeTypeAndValue.prototype, "value", void 0);
    exports.AttributeTypeAndValue = AttributeTypeAndValue;
    var RelativeDistinguishedName = RelativeDistinguishedName_1 = class RelativeDistinguishedName extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RelativeDistinguishedName_1.prototype);
      }
    };
    RelativeDistinguishedName = RelativeDistinguishedName_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Set, itemType: AttributeTypeAndValue })
    ], RelativeDistinguishedName);
    exports.RelativeDistinguishedName = RelativeDistinguishedName;
    var RDNSequence = RDNSequence_1 = class RDNSequence extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RDNSequence_1.prototype);
      }
    };
    RDNSequence = RDNSequence_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: RelativeDistinguishedName })
    ], RDNSequence);
    exports.RDNSequence = RDNSequence;
    var Name = Name_1 = class Name extends RDNSequence {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Name_1.prototype);
      }
    };
    Name = Name_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], Name);
    exports.Name = Name;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/general_name.js
var require_general_name = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/general_name.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GeneralName = exports.EDIPartyName = exports.OtherName = exports.AsnIpConverter = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var ip_converter_1 = require_ip_converter();
    var name_1 = require_name();
    exports.AsnIpConverter = {
      fromASN: (value) => ip_converter_1.IpConverter.toString(asn1_schema_1.AsnOctetStringConverter.fromASN(value)),
      toASN: (value) => asn1_schema_1.AsnOctetStringConverter.toASN(ip_converter_1.IpConverter.fromString(value))
    };
    var OtherName = class {
      constructor(params = {}) {
        this.typeId = "";
        this.value = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], OtherName.prototype, "typeId", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, context: 0 })
    ], OtherName.prototype, "value", void 0);
    exports.OtherName = OtherName;
    var EDIPartyName = class {
      constructor(params = {}) {
        this.partyName = new name_1.DirectoryString();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: name_1.DirectoryString, optional: true, context: 0, implicit: true })
    ], EDIPartyName.prototype, "nameAssigner", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: name_1.DirectoryString, context: 1, implicit: true })
    ], EDIPartyName.prototype, "partyName", void 0);
    exports.EDIPartyName = EDIPartyName;
    var GeneralName = class GeneralName {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: OtherName, context: 0, implicit: true })
    ], GeneralName.prototype, "otherName", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.IA5String, context: 1, implicit: true })
    ], GeneralName.prototype, "rfc822Name", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.IA5String, context: 2, implicit: true })
    ], GeneralName.prototype, "dNSName", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, context: 3, implicit: true })
    ], GeneralName.prototype, "x400Address", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: name_1.Name, context: 4, implicit: false })
    ], GeneralName.prototype, "directoryName", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: EDIPartyName, context: 5 })
    ], GeneralName.prototype, "ediPartyName", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.IA5String, context: 6, implicit: true })
    ], GeneralName.prototype, "uniformResourceIdentifier", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.OctetString, context: 7, implicit: true, converter: exports.AsnIpConverter })
    ], GeneralName.prototype, "iPAddress", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier, context: 8, implicit: true })
    ], GeneralName.prototype, "registeredID", void 0);
    GeneralName = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], GeneralName);
    exports.GeneralName = GeneralName;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/object_identifiers.js
var require_object_identifiers = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/object_identifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id_ce = exports.id_ad_caRepository = exports.id_ad_timeStamping = exports.id_ad_caIssuers = exports.id_ad_ocsp = exports.id_qt_unotice = exports.id_qt_csp = exports.id_ad = exports.id_kp = exports.id_qt = exports.id_pe = exports.id_pkix = void 0;
    exports.id_pkix = "1.3.6.1.5.5.7";
    exports.id_pe = `${exports.id_pkix}.1`;
    exports.id_qt = `${exports.id_pkix}.2`;
    exports.id_kp = `${exports.id_pkix}.3`;
    exports.id_ad = `${exports.id_pkix}.48`;
    exports.id_qt_csp = `${exports.id_qt}.1`;
    exports.id_qt_unotice = `${exports.id_qt}.2`;
    exports.id_ad_ocsp = `${exports.id_ad}.1`;
    exports.id_ad_caIssuers = `${exports.id_ad}.2`;
    exports.id_ad_timeStamping = `${exports.id_ad}.3`;
    exports.id_ad_caRepository = `${exports.id_ad}.5`;
    exports.id_ce = "2.5.29";
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/authority_information_access.js
var require_authority_information_access = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/authority_information_access.js"(exports) {
    "use strict";
    var AuthorityInfoAccessSyntax_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthorityInfoAccessSyntax = exports.AccessDescription = exports.id_pe_authorityInfoAccess = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var general_name_1 = require_general_name();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_pe_authorityInfoAccess = `${object_identifiers_1.id_pe}.1`;
    var AccessDescription = class {
      constructor(params = {}) {
        this.accessMethod = "";
        this.accessLocation = new general_name_1.GeneralName();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], AccessDescription.prototype, "accessMethod", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: general_name_1.GeneralName })
    ], AccessDescription.prototype, "accessLocation", void 0);
    exports.AccessDescription = AccessDescription;
    var AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = class AuthorityInfoAccessSyntax extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, AuthorityInfoAccessSyntax_1.prototype);
      }
    };
    AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: AccessDescription })
    ], AuthorityInfoAccessSyntax);
    exports.AuthorityInfoAccessSyntax = AuthorityInfoAccessSyntax;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/authority_key_identifier.js
var require_authority_key_identifier = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/authority_key_identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthorityKeyIdentifier = exports.KeyIdentifier = exports.id_ce_authorityKeyIdentifier = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var general_name_1 = require_general_name();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_authorityKeyIdentifier = `${object_identifiers_1.id_ce}.35`;
    var KeyIdentifier = class extends asn1_schema_1.OctetString {
    };
    exports.KeyIdentifier = KeyIdentifier;
    var AuthorityKeyIdentifier = class {
      constructor(params = {}) {
        if (params) {
          Object.assign(this, params);
        }
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: KeyIdentifier, context: 0, optional: true, implicit: true })
    ], AuthorityKeyIdentifier.prototype, "keyIdentifier", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: general_name_1.GeneralName, context: 1, optional: true, implicit: true, repeated: "sequence" })
    ], AuthorityKeyIdentifier.prototype, "authorityCertIssuer", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({
        type: asn1_schema_1.AsnPropTypes.Integer,
        context: 2,
        optional: true,
        implicit: true,
        converter: asn1_schema_1.AsnIntegerArrayBufferConverter
      })
    ], AuthorityKeyIdentifier.prototype, "authorityCertSerialNumber", void 0);
    exports.AuthorityKeyIdentifier = AuthorityKeyIdentifier;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/basic_constraints.js
var require_basic_constraints = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/basic_constraints.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicConstraints = exports.id_ce_basicConstraints = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_basicConstraints = `${object_identifiers_1.id_ce}.19`;
    var BasicConstraints = class {
      constructor(params = {}) {
        this.cA = false;
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Boolean, defaultValue: false })
    ], BasicConstraints.prototype, "cA", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, optional: true })
    ], BasicConstraints.prototype, "pathLenConstraint", void 0);
    exports.BasicConstraints = BasicConstraints;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/general_names.js
var require_general_names = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/general_names.js"(exports) {
    "use strict";
    var GeneralNames_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GeneralNames = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var general_name_1 = require_general_name();
    var asn1_schema_2 = require_cjs();
    var GeneralNames = GeneralNames_1 = class GeneralNames extends asn1_schema_2.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, GeneralNames_1.prototype);
      }
    };
    GeneralNames = GeneralNames_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: general_name_1.GeneralName })
    ], GeneralNames);
    exports.GeneralNames = GeneralNames;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/certificate_issuer.js
var require_certificate_issuer = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/certificate_issuer.js"(exports) {
    "use strict";
    var CertificateIssuer_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CertificateIssuer = exports.id_ce_certificateIssuer = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var general_names_1 = require_general_names();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_certificateIssuer = `${object_identifiers_1.id_ce}.29`;
    var CertificateIssuer = CertificateIssuer_1 = class CertificateIssuer extends general_names_1.GeneralNames {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, CertificateIssuer_1.prototype);
      }
    };
    CertificateIssuer = CertificateIssuer_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], CertificateIssuer);
    exports.CertificateIssuer = CertificateIssuer;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/certificate_policies.js
var require_certificate_policies = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/certificate_policies.js"(exports) {
    "use strict";
    var CertificatePolicies_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CertificatePolicies = exports.PolicyInformation = exports.PolicyQualifierInfo = exports.Qualifier = exports.UserNotice = exports.NoticeReference = exports.DisplayText = exports.id_ce_certificatePolicies_anyPolicy = exports.id_ce_certificatePolicies = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_certificatePolicies = `${object_identifiers_1.id_ce}.32`;
    exports.id_ce_certificatePolicies_anyPolicy = `${exports.id_ce_certificatePolicies}.0`;
    var DisplayText = class DisplayText {
      constructor(params = {}) {
        Object.assign(this, params);
      }
      toString() {
        return this.ia5String || this.visibleString || this.bmpString || this.utf8String || "";
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.IA5String })
    ], DisplayText.prototype, "ia5String", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.VisibleString })
    ], DisplayText.prototype, "visibleString", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BmpString })
    ], DisplayText.prototype, "bmpString", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Utf8String })
    ], DisplayText.prototype, "utf8String", void 0);
    DisplayText = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], DisplayText);
    exports.DisplayText = DisplayText;
    var NoticeReference = class {
      constructor(params = {}) {
        this.organization = new DisplayText();
        this.noticeNumbers = [];
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: DisplayText })
    ], NoticeReference.prototype, "organization", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, repeated: "sequence" })
    ], NoticeReference.prototype, "noticeNumbers", void 0);
    exports.NoticeReference = NoticeReference;
    var UserNotice = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: NoticeReference, optional: true })
    ], UserNotice.prototype, "noticeRef", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: DisplayText, optional: true })
    ], UserNotice.prototype, "explicitText", void 0);
    exports.UserNotice = UserNotice;
    var Qualifier = class Qualifier {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.IA5String })
    ], Qualifier.prototype, "cPSuri", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: UserNotice })
    ], Qualifier.prototype, "userNotice", void 0);
    Qualifier = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], Qualifier);
    exports.Qualifier = Qualifier;
    var PolicyQualifierInfo = class {
      constructor(params = {}) {
        this.policyQualifierId = "";
        this.qualifier = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], PolicyQualifierInfo.prototype, "policyQualifierId", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any })
    ], PolicyQualifierInfo.prototype, "qualifier", void 0);
    exports.PolicyQualifierInfo = PolicyQualifierInfo;
    var PolicyInformation = class {
      constructor(params = {}) {
        this.policyIdentifier = "";
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], PolicyInformation.prototype, "policyIdentifier", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: PolicyQualifierInfo, repeated: "sequence", optional: true })
    ], PolicyInformation.prototype, "policyQualifiers", void 0);
    exports.PolicyInformation = PolicyInformation;
    var CertificatePolicies = CertificatePolicies_1 = class CertificatePolicies extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, CertificatePolicies_1.prototype);
      }
    };
    CertificatePolicies = CertificatePolicies_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: PolicyInformation })
    ], CertificatePolicies);
    exports.CertificatePolicies = CertificatePolicies;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_number.js
var require_crl_number = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CRLNumber = exports.id_ce_cRLNumber = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_cRLNumber = `${object_identifiers_1.id_ce}.20`;
    var CRLNumber = class CRLNumber {
      constructor(value = 0) {
        this.value = value;
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], CRLNumber.prototype, "value", void 0);
    CRLNumber = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], CRLNumber);
    exports.CRLNumber = CRLNumber;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_delta_indicator.js
var require_crl_delta_indicator = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_delta_indicator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseCRLNumber = exports.id_ce_deltaCRLIndicator = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    var crl_number_1 = require_crl_number();
    exports.id_ce_deltaCRLIndicator = `${object_identifiers_1.id_ce}.27`;
    var BaseCRLNumber = class BaseCRLNumber extends crl_number_1.CRLNumber {
    };
    BaseCRLNumber = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], BaseCRLNumber);
    exports.BaseCRLNumber = BaseCRLNumber;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_distribution_points.js
var require_crl_distribution_points = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_distribution_points.js"(exports) {
    "use strict";
    var CRLDistributionPoints_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CRLDistributionPoints = exports.DistributionPoint = exports.DistributionPointName = exports.Reason = exports.ReasonFlags = exports.id_ce_cRLDistributionPoints = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var name_1 = require_name();
    var general_name_1 = require_general_name();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_cRLDistributionPoints = `${object_identifiers_1.id_ce}.31`;
    var ReasonFlags;
    (function(ReasonFlags2) {
      ReasonFlags2[ReasonFlags2["unused"] = 1] = "unused";
      ReasonFlags2[ReasonFlags2["keyCompromise"] = 2] = "keyCompromise";
      ReasonFlags2[ReasonFlags2["cACompromise"] = 4] = "cACompromise";
      ReasonFlags2[ReasonFlags2["affiliationChanged"] = 8] = "affiliationChanged";
      ReasonFlags2[ReasonFlags2["superseded"] = 16] = "superseded";
      ReasonFlags2[ReasonFlags2["cessationOfOperation"] = 32] = "cessationOfOperation";
      ReasonFlags2[ReasonFlags2["certificateHold"] = 64] = "certificateHold";
      ReasonFlags2[ReasonFlags2["privilegeWithdrawn"] = 128] = "privilegeWithdrawn";
      ReasonFlags2[ReasonFlags2["aACompromise"] = 256] = "aACompromise";
    })(ReasonFlags = exports.ReasonFlags || (exports.ReasonFlags = {}));
    var Reason = class extends asn1_schema_1.BitString {
      toJSON() {
        const res = [];
        const flags = this.toNumber();
        if (flags & ReasonFlags.aACompromise) {
          res.push("aACompromise");
        }
        if (flags & ReasonFlags.affiliationChanged) {
          res.push("affiliationChanged");
        }
        if (flags & ReasonFlags.cACompromise) {
          res.push("cACompromise");
        }
        if (flags & ReasonFlags.certificateHold) {
          res.push("certificateHold");
        }
        if (flags & ReasonFlags.cessationOfOperation) {
          res.push("cessationOfOperation");
        }
        if (flags & ReasonFlags.keyCompromise) {
          res.push("keyCompromise");
        }
        if (flags & ReasonFlags.privilegeWithdrawn) {
          res.push("privilegeWithdrawn");
        }
        if (flags & ReasonFlags.superseded) {
          res.push("superseded");
        }
        if (flags & ReasonFlags.unused) {
          res.push("unused");
        }
        return res;
      }
      toString() {
        return `[${this.toJSON().join(", ")}]`;
      }
    };
    exports.Reason = Reason;
    var DistributionPointName = class DistributionPointName {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: general_name_1.GeneralName, context: 0, repeated: "sequence", implicit: true })
    ], DistributionPointName.prototype, "fullName", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: name_1.RelativeDistinguishedName, context: 1, implicit: true })
    ], DistributionPointName.prototype, "nameRelativeToCRLIssuer", void 0);
    DistributionPointName = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], DistributionPointName);
    exports.DistributionPointName = DistributionPointName;
    var DistributionPoint = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: DistributionPointName, context: 0, optional: true })
    ], DistributionPoint.prototype, "distributionPoint", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: Reason, context: 1, optional: true, implicit: true })
    ], DistributionPoint.prototype, "reasons", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: general_name_1.GeneralName, context: 2, optional: true, repeated: "sequence", implicit: true })
    ], DistributionPoint.prototype, "cRLIssuer", void 0);
    exports.DistributionPoint = DistributionPoint;
    var CRLDistributionPoints = CRLDistributionPoints_1 = class CRLDistributionPoints extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, CRLDistributionPoints_1.prototype);
      }
    };
    CRLDistributionPoints = CRLDistributionPoints_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: DistributionPoint })
    ], CRLDistributionPoints);
    exports.CRLDistributionPoints = CRLDistributionPoints;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_freshest.js
var require_crl_freshest = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_freshest.js"(exports) {
    "use strict";
    var FreshestCRL_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FreshestCRL = exports.id_ce_freshestCRL = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    var crl_distribution_points_1 = require_crl_distribution_points();
    exports.id_ce_freshestCRL = `${object_identifiers_1.id_ce}.46`;
    var FreshestCRL = FreshestCRL_1 = class FreshestCRL extends crl_distribution_points_1.CRLDistributionPoints {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, FreshestCRL_1.prototype);
      }
    };
    FreshestCRL = FreshestCRL_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: crl_distribution_points_1.DistributionPoint })
    ], FreshestCRL);
    exports.FreshestCRL = FreshestCRL;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_issuing_distribution_point.js
var require_crl_issuing_distribution_point = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_issuing_distribution_point.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IssuingDistributionPoint = exports.id_ce_issuingDistributionPoint = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var crl_distribution_points_1 = require_crl_distribution_points();
    var object_identifiers_1 = require_object_identifiers();
    var asn1_schema_2 = require_cjs();
    exports.id_ce_issuingDistributionPoint = `${object_identifiers_1.id_ce}.28`;
    var IssuingDistributionPoint = class _IssuingDistributionPoint {
      constructor(params = {}) {
        this.onlyContainsUserCerts = _IssuingDistributionPoint.ONLY;
        this.onlyContainsCACerts = _IssuingDistributionPoint.ONLY;
        this.indirectCRL = _IssuingDistributionPoint.ONLY;
        this.onlyContainsAttributeCerts = _IssuingDistributionPoint.ONLY;
        Object.assign(this, params);
      }
    };
    IssuingDistributionPoint.ONLY = false;
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: crl_distribution_points_1.DistributionPointName, context: 0, optional: true })
    ], IssuingDistributionPoint.prototype, "distributionPoint", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_2.AsnPropTypes.Boolean, context: 1, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
    ], IssuingDistributionPoint.prototype, "onlyContainsUserCerts", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_2.AsnPropTypes.Boolean, context: 2, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
    ], IssuingDistributionPoint.prototype, "onlyContainsCACerts", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: crl_distribution_points_1.Reason, context: 3, optional: true, implicit: true })
    ], IssuingDistributionPoint.prototype, "onlySomeReasons", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_2.AsnPropTypes.Boolean, context: 4, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
    ], IssuingDistributionPoint.prototype, "indirectCRL", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_2.AsnPropTypes.Boolean, context: 5, defaultValue: IssuingDistributionPoint.ONLY, implicit: true })
    ], IssuingDistributionPoint.prototype, "onlyContainsAttributeCerts", void 0);
    exports.IssuingDistributionPoint = IssuingDistributionPoint;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_reason.js
var require_crl_reason = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/crl_reason.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CRLReason = exports.CRLReasons = exports.id_ce_cRLReasons = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_cRLReasons = `${object_identifiers_1.id_ce}.21`;
    var CRLReasons;
    (function(CRLReasons2) {
      CRLReasons2[CRLReasons2["unspecified"] = 0] = "unspecified";
      CRLReasons2[CRLReasons2["keyCompromise"] = 1] = "keyCompromise";
      CRLReasons2[CRLReasons2["cACompromise"] = 2] = "cACompromise";
      CRLReasons2[CRLReasons2["affiliationChanged"] = 3] = "affiliationChanged";
      CRLReasons2[CRLReasons2["superseded"] = 4] = "superseded";
      CRLReasons2[CRLReasons2["cessationOfOperation"] = 5] = "cessationOfOperation";
      CRLReasons2[CRLReasons2["certificateHold"] = 6] = "certificateHold";
      CRLReasons2[CRLReasons2["removeFromCRL"] = 8] = "removeFromCRL";
      CRLReasons2[CRLReasons2["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
      CRLReasons2[CRLReasons2["aACompromise"] = 10] = "aACompromise";
    })(CRLReasons = exports.CRLReasons || (exports.CRLReasons = {}));
    var CRLReason = class CRLReason {
      constructor(reason = CRLReasons.unspecified) {
        this.reason = CRLReasons.unspecified;
        this.reason = reason;
      }
      toJSON() {
        return CRLReasons[this.reason];
      }
      toString() {
        return this.toJSON();
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Enumerated })
    ], CRLReason.prototype, "reason", void 0);
    CRLReason = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], CRLReason);
    exports.CRLReason = CRLReason;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/extended_key_usage.js
var require_extended_key_usage = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/extended_key_usage.js"(exports) {
    "use strict";
    var ExtendedKeyUsage_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id_kp_OCSPSigning = exports.id_kp_timeStamping = exports.id_kp_emailProtection = exports.id_kp_codeSigning = exports.id_kp_clientAuth = exports.id_kp_serverAuth = exports.anyExtendedKeyUsage = exports.ExtendedKeyUsage = exports.id_ce_extKeyUsage = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_extKeyUsage = `${object_identifiers_1.id_ce}.37`;
    var ExtendedKeyUsage = ExtendedKeyUsage_1 = class ExtendedKeyUsage extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, ExtendedKeyUsage_1.prototype);
      }
    };
    ExtendedKeyUsage = ExtendedKeyUsage_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], ExtendedKeyUsage);
    exports.ExtendedKeyUsage = ExtendedKeyUsage;
    exports.anyExtendedKeyUsage = `${exports.id_ce_extKeyUsage}.0`;
    exports.id_kp_serverAuth = `${object_identifiers_1.id_kp}.1`;
    exports.id_kp_clientAuth = `${object_identifiers_1.id_kp}.2`;
    exports.id_kp_codeSigning = `${object_identifiers_1.id_kp}.3`;
    exports.id_kp_emailProtection = `${object_identifiers_1.id_kp}.4`;
    exports.id_kp_timeStamping = `${object_identifiers_1.id_kp}.8`;
    exports.id_kp_OCSPSigning = `${object_identifiers_1.id_kp}.9`;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/inhibit_any_policy.js
var require_inhibit_any_policy = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/inhibit_any_policy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InhibitAnyPolicy = exports.id_ce_inhibitAnyPolicy = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_inhibitAnyPolicy = `${object_identifiers_1.id_ce}.54`;
    var InhibitAnyPolicy = class InhibitAnyPolicy {
      constructor(value = new ArrayBuffer(0)) {
        this.value = value;
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], InhibitAnyPolicy.prototype, "value", void 0);
    InhibitAnyPolicy = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], InhibitAnyPolicy);
    exports.InhibitAnyPolicy = InhibitAnyPolicy;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/invalidity_date.js
var require_invalidity_date = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/invalidity_date.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidityDate = exports.id_ce_invalidityDate = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_invalidityDate = `${object_identifiers_1.id_ce}.24`;
    var InvalidityDate = class InvalidityDate {
      constructor(value) {
        this.value = /* @__PURE__ */ new Date();
        if (value) {
          this.value = value;
        }
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.GeneralizedTime })
    ], InvalidityDate.prototype, "value", void 0);
    InvalidityDate = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], InvalidityDate);
    exports.InvalidityDate = InvalidityDate;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/issuer_alternative_name.js
var require_issuer_alternative_name = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/issuer_alternative_name.js"(exports) {
    "use strict";
    var IssueAlternativeName_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IssueAlternativeName = exports.id_ce_issuerAltName = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var general_names_1 = require_general_names();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_issuerAltName = `${object_identifiers_1.id_ce}.18`;
    var IssueAlternativeName = IssueAlternativeName_1 = class IssueAlternativeName extends general_names_1.GeneralNames {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, IssueAlternativeName_1.prototype);
      }
    };
    IssueAlternativeName = IssueAlternativeName_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], IssueAlternativeName);
    exports.IssueAlternativeName = IssueAlternativeName;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/key_usage.js
var require_key_usage = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/key_usage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyUsage = exports.KeyUsageFlags = exports.id_ce_keyUsage = void 0;
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_keyUsage = `${object_identifiers_1.id_ce}.15`;
    var KeyUsageFlags;
    (function(KeyUsageFlags2) {
      KeyUsageFlags2[KeyUsageFlags2["digitalSignature"] = 1] = "digitalSignature";
      KeyUsageFlags2[KeyUsageFlags2["nonRepudiation"] = 2] = "nonRepudiation";
      KeyUsageFlags2[KeyUsageFlags2["keyEncipherment"] = 4] = "keyEncipherment";
      KeyUsageFlags2[KeyUsageFlags2["dataEncipherment"] = 8] = "dataEncipherment";
      KeyUsageFlags2[KeyUsageFlags2["keyAgreement"] = 16] = "keyAgreement";
      KeyUsageFlags2[KeyUsageFlags2["keyCertSign"] = 32] = "keyCertSign";
      KeyUsageFlags2[KeyUsageFlags2["cRLSign"] = 64] = "cRLSign";
      KeyUsageFlags2[KeyUsageFlags2["encipherOnly"] = 128] = "encipherOnly";
      KeyUsageFlags2[KeyUsageFlags2["decipherOnly"] = 256] = "decipherOnly";
    })(KeyUsageFlags = exports.KeyUsageFlags || (exports.KeyUsageFlags = {}));
    var KeyUsage = class extends asn1_schema_1.BitString {
      toJSON() {
        const flag = this.toNumber();
        const res = [];
        if (flag & KeyUsageFlags.cRLSign) {
          res.push("crlSign");
        }
        if (flag & KeyUsageFlags.dataEncipherment) {
          res.push("dataEncipherment");
        }
        if (flag & KeyUsageFlags.decipherOnly) {
          res.push("decipherOnly");
        }
        if (flag & KeyUsageFlags.digitalSignature) {
          res.push("digitalSignature");
        }
        if (flag & KeyUsageFlags.encipherOnly) {
          res.push("encipherOnly");
        }
        if (flag & KeyUsageFlags.keyAgreement) {
          res.push("keyAgreement");
        }
        if (flag & KeyUsageFlags.keyCertSign) {
          res.push("keyCertSign");
        }
        if (flag & KeyUsageFlags.keyEncipherment) {
          res.push("keyEncipherment");
        }
        if (flag & KeyUsageFlags.nonRepudiation) {
          res.push("nonRepudiation");
        }
        return res;
      }
      toString() {
        return `[${this.toJSON().join(", ")}]`;
      }
    };
    exports.KeyUsage = KeyUsage;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/name_constraints.js
var require_name_constraints = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/name_constraints.js"(exports) {
    "use strict";
    var GeneralSubtrees_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NameConstraints = exports.GeneralSubtrees = exports.GeneralSubtree = exports.id_ce_nameConstraints = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var general_name_1 = require_general_name();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_nameConstraints = `${object_identifiers_1.id_ce}.30`;
    var GeneralSubtree = class {
      constructor(params = {}) {
        this.base = new general_name_1.GeneralName();
        this.minimum = 0;
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: general_name_1.GeneralName })
    ], GeneralSubtree.prototype, "base", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, context: 0, defaultValue: 0, implicit: true })
    ], GeneralSubtree.prototype, "minimum", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, context: 1, optional: true, implicit: true })
    ], GeneralSubtree.prototype, "maximum", void 0);
    exports.GeneralSubtree = GeneralSubtree;
    var GeneralSubtrees = GeneralSubtrees_1 = class GeneralSubtrees extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, GeneralSubtrees_1.prototype);
      }
    };
    GeneralSubtrees = GeneralSubtrees_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: GeneralSubtree })
    ], GeneralSubtrees);
    exports.GeneralSubtrees = GeneralSubtrees;
    var NameConstraints = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: GeneralSubtrees, context: 0, optional: true, implicit: true })
    ], NameConstraints.prototype, "permittedSubtrees", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: GeneralSubtrees, context: 1, optional: true, implicit: true })
    ], NameConstraints.prototype, "excludedSubtrees", void 0);
    exports.NameConstraints = NameConstraints;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/policy_constraints.js
var require_policy_constraints = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/policy_constraints.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PolicyConstraints = exports.id_ce_policyConstraints = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_policyConstraints = `${object_identifiers_1.id_ce}.36`;
    var PolicyConstraints = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({
        type: asn1_schema_1.AsnPropTypes.Integer,
        context: 0,
        implicit: true,
        optional: true,
        converter: asn1_schema_1.AsnIntegerArrayBufferConverter
      })
    ], PolicyConstraints.prototype, "requireExplicitPolicy", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({
        type: asn1_schema_1.AsnPropTypes.Integer,
        context: 1,
        implicit: true,
        optional: true,
        converter: asn1_schema_1.AsnIntegerArrayBufferConverter
      })
    ], PolicyConstraints.prototype, "inhibitPolicyMapping", void 0);
    exports.PolicyConstraints = PolicyConstraints;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/policy_mappings.js
var require_policy_mappings = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/policy_mappings.js"(exports) {
    "use strict";
    var PolicyMappings_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PolicyMappings = exports.PolicyMapping = exports.id_ce_policyMappings = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_policyMappings = `${object_identifiers_1.id_ce}.33`;
    var PolicyMapping = class {
      constructor(params = {}) {
        this.issuerDomainPolicy = "";
        this.subjectDomainPolicy = "";
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], PolicyMapping.prototype, "issuerDomainPolicy", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], PolicyMapping.prototype, "subjectDomainPolicy", void 0);
    exports.PolicyMapping = PolicyMapping;
    var PolicyMappings = PolicyMappings_1 = class PolicyMappings extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, PolicyMappings_1.prototype);
      }
    };
    PolicyMappings = PolicyMappings_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: PolicyMapping })
    ], PolicyMappings);
    exports.PolicyMappings = PolicyMappings;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/subject_alternative_name.js
var require_subject_alternative_name = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/subject_alternative_name.js"(exports) {
    "use strict";
    var SubjectAlternativeName_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubjectAlternativeName = exports.id_ce_subjectAltName = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var general_names_1 = require_general_names();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_subjectAltName = `${object_identifiers_1.id_ce}.17`;
    var SubjectAlternativeName = SubjectAlternativeName_1 = class SubjectAlternativeName extends general_names_1.GeneralNames {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SubjectAlternativeName_1.prototype);
      }
    };
    SubjectAlternativeName = SubjectAlternativeName_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], SubjectAlternativeName);
    exports.SubjectAlternativeName = SubjectAlternativeName;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/attribute.js
var require_attribute = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/attribute.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Attribute = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var Attribute = class {
      constructor(params = {}) {
        this.type = "";
        this.values = [];
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], Attribute.prototype, "type", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, repeated: "set" })
    ], Attribute.prototype, "values", void 0);
    exports.Attribute = Attribute;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/subject_directory_attributes.js
var require_subject_directory_attributes = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/subject_directory_attributes.js"(exports) {
    "use strict";
    var SubjectDirectoryAttributes_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubjectDirectoryAttributes = exports.id_ce_subjectDirectoryAttributes = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var attribute_1 = require_attribute();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_subjectDirectoryAttributes = `${object_identifiers_1.id_ce}.9`;
    var SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = class SubjectDirectoryAttributes extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SubjectDirectoryAttributes_1.prototype);
      }
    };
    SubjectDirectoryAttributes = SubjectDirectoryAttributes_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: attribute_1.Attribute })
    ], SubjectDirectoryAttributes);
    exports.SubjectDirectoryAttributes = SubjectDirectoryAttributes;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/subject_key_identifier.js
var require_subject_key_identifier = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/subject_key_identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubjectKeyIdentifier = exports.id_ce_subjectKeyIdentifier = void 0;
    var object_identifiers_1 = require_object_identifiers();
    var authority_key_identifier_1 = require_authority_key_identifier();
    exports.id_ce_subjectKeyIdentifier = `${object_identifiers_1.id_ce}.14`;
    var SubjectKeyIdentifier = class extends authority_key_identifier_1.KeyIdentifier {
    };
    exports.SubjectKeyIdentifier = SubjectKeyIdentifier;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/private_key_usage_period.js
var require_private_key_usage_period = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/private_key_usage_period.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrivateKeyUsagePeriod = exports.id_ce_privateKeyUsagePeriod = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    exports.id_ce_privateKeyUsagePeriod = `${object_identifiers_1.id_ce}.16`;
    var PrivateKeyUsagePeriod = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.GeneralizedTime, context: 0, implicit: true, optional: true })
    ], PrivateKeyUsagePeriod.prototype, "notBefore", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.GeneralizedTime, context: 1, implicit: true, optional: true })
    ], PrivateKeyUsagePeriod.prototype, "notAfter", void 0);
    exports.PrivateKeyUsagePeriod = PrivateKeyUsagePeriod;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/entrust_version_info.js
var require_entrust_version_info = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/entrust_version_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntrustVersionInfo = exports.EntrustInfo = exports.EntrustInfoFlags = exports.id_entrust_entrustVersInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    exports.id_entrust_entrustVersInfo = "1.2.840.113533.7.65.0";
    var EntrustInfoFlags;
    (function(EntrustInfoFlags2) {
      EntrustInfoFlags2[EntrustInfoFlags2["keyUpdateAllowed"] = 1] = "keyUpdateAllowed";
      EntrustInfoFlags2[EntrustInfoFlags2["newExtensions"] = 2] = "newExtensions";
      EntrustInfoFlags2[EntrustInfoFlags2["pKIXCertificate"] = 4] = "pKIXCertificate";
    })(EntrustInfoFlags = exports.EntrustInfoFlags || (exports.EntrustInfoFlags = {}));
    var EntrustInfo = class extends asn1_schema_1.BitString {
      toJSON() {
        const res = [];
        const flags = this.toNumber();
        if (flags & EntrustInfoFlags.pKIXCertificate) {
          res.push("pKIXCertificate");
        }
        if (flags & EntrustInfoFlags.newExtensions) {
          res.push("newExtensions");
        }
        if (flags & EntrustInfoFlags.keyUpdateAllowed) {
          res.push("keyUpdateAllowed");
        }
        return res;
      }
      toString() {
        return `[${this.toJSON().join(", ")}]`;
      }
    };
    exports.EntrustInfo = EntrustInfo;
    var EntrustVersionInfo = class {
      constructor(params = {}) {
        this.entrustVers = "";
        this.entrustInfoFlags = new EntrustInfo();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.GeneralString })
    ], EntrustVersionInfo.prototype, "entrustVers", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: EntrustInfo })
    ], EntrustVersionInfo.prototype, "entrustInfoFlags", void 0);
    exports.EntrustVersionInfo = EntrustVersionInfo;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/subject_info_access.js
var require_subject_info_access = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/subject_info_access.js"(exports) {
    "use strict";
    var SubjectInfoAccessSyntax_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubjectInfoAccessSyntax = exports.id_pe_subjectInfoAccess = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var object_identifiers_1 = require_object_identifiers();
    var authority_information_access_1 = require_authority_information_access();
    exports.id_pe_subjectInfoAccess = `${object_identifiers_1.id_pe}.11`;
    var SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = class SubjectInfoAccessSyntax extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SubjectInfoAccessSyntax_1.prototype);
      }
    };
    SubjectInfoAccessSyntax = SubjectInfoAccessSyntax_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: authority_information_access_1.AccessDescription })
    ], SubjectInfoAccessSyntax);
    exports.SubjectInfoAccessSyntax = SubjectInfoAccessSyntax;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extensions/index.js
var require_extensions = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extensions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_authority_information_access(), exports);
    tslib_1.__exportStar(require_authority_key_identifier(), exports);
    tslib_1.__exportStar(require_basic_constraints(), exports);
    tslib_1.__exportStar(require_certificate_issuer(), exports);
    tslib_1.__exportStar(require_certificate_policies(), exports);
    tslib_1.__exportStar(require_crl_delta_indicator(), exports);
    tslib_1.__exportStar(require_crl_distribution_points(), exports);
    tslib_1.__exportStar(require_crl_freshest(), exports);
    tslib_1.__exportStar(require_crl_issuing_distribution_point(), exports);
    tslib_1.__exportStar(require_crl_number(), exports);
    tslib_1.__exportStar(require_crl_reason(), exports);
    tslib_1.__exportStar(require_extended_key_usage(), exports);
    tslib_1.__exportStar(require_inhibit_any_policy(), exports);
    tslib_1.__exportStar(require_invalidity_date(), exports);
    tslib_1.__exportStar(require_issuer_alternative_name(), exports);
    tslib_1.__exportStar(require_key_usage(), exports);
    tslib_1.__exportStar(require_name_constraints(), exports);
    tslib_1.__exportStar(require_policy_constraints(), exports);
    tslib_1.__exportStar(require_policy_mappings(), exports);
    tslib_1.__exportStar(require_subject_alternative_name(), exports);
    tslib_1.__exportStar(require_subject_directory_attributes(), exports);
    tslib_1.__exportStar(require_subject_key_identifier(), exports);
    tslib_1.__exportStar(require_private_key_usage_period(), exports);
    tslib_1.__exportStar(require_entrust_version_info(), exports);
    tslib_1.__exportStar(require_subject_info_access(), exports);
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/algorithm_identifier.js
var require_algorithm_identifier = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/algorithm_identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlgorithmIdentifier = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var pvtsutils = require_build();
    var AlgorithmIdentifier = class _AlgorithmIdentifier {
      constructor(params = {}) {
        this.algorithm = "";
        Object.assign(this, params);
      }
      isEqual(data) {
        return data instanceof _AlgorithmIdentifier && data.algorithm == this.algorithm && (data.parameters && this.parameters && pvtsutils.isEqual(data.parameters, this.parameters) || data.parameters === this.parameters);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({
        type: asn1_schema_1.AsnPropTypes.ObjectIdentifier
      })
    ], AlgorithmIdentifier.prototype, "algorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({
        type: asn1_schema_1.AsnPropTypes.Any,
        optional: true
      })
    ], AlgorithmIdentifier.prototype, "parameters", void 0);
    exports.AlgorithmIdentifier = AlgorithmIdentifier;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/subject_public_key_info.js
var require_subject_public_key_info = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/subject_public_key_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubjectPublicKeyInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var algorithm_identifier_1 = require_algorithm_identifier();
    var SubjectPublicKeyInfo = class {
      constructor(params = {}) {
        this.algorithm = new algorithm_identifier_1.AlgorithmIdentifier();
        this.subjectPublicKey = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: algorithm_identifier_1.AlgorithmIdentifier })
    ], SubjectPublicKeyInfo.prototype, "algorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BitString })
    ], SubjectPublicKeyInfo.prototype, "subjectPublicKey", void 0);
    exports.SubjectPublicKeyInfo = SubjectPublicKeyInfo;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/time.js
var require_time = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Time = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var Time = class Time {
      constructor(time) {
        if (time) {
          if (typeof time === "string" || typeof time === "number" || time instanceof Date) {
            const date = new Date(time);
            if (date.getUTCFullYear() > 2049) {
              this.generalTime = date;
            } else {
              this.utcTime = date;
            }
          } else {
            Object.assign(this, time);
          }
        }
      }
      getTime() {
        const time = this.utcTime || this.generalTime;
        if (!time) {
          throw new Error("Cannot get time from CHOICE object");
        }
        return time;
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({
        type: asn1_schema_1.AsnPropTypes.UTCTime
      })
    ], Time.prototype, "utcTime", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({
        type: asn1_schema_1.AsnPropTypes.GeneralizedTime
      })
    ], Time.prototype, "generalTime", void 0);
    Time = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], Time);
    exports.Time = Time;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/validity.js
var require_validity = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/validity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Validity = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var time_1 = require_time();
    var Validity = class {
      constructor(params) {
        this.notBefore = new time_1.Time(/* @__PURE__ */ new Date());
        this.notAfter = new time_1.Time(/* @__PURE__ */ new Date());
        if (params) {
          this.notBefore = new time_1.Time(params.notBefore);
          this.notAfter = new time_1.Time(params.notAfter);
        }
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: time_1.Time })
    ], Validity.prototype, "notBefore", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: time_1.Time })
    ], Validity.prototype, "notAfter", void 0);
    exports.Validity = Validity;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/extension.js
var require_extension = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/extension.js"(exports) {
    "use strict";
    var Extensions_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Extensions = exports.Extension = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var Extension = class _Extension {
      constructor(params = {}) {
        this.extnID = "";
        this.critical = _Extension.CRITICAL;
        this.extnValue = new asn1_schema_1.OctetString();
        Object.assign(this, params);
      }
    };
    Extension.CRITICAL = false;
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], Extension.prototype, "extnID", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({
        type: asn1_schema_1.AsnPropTypes.Boolean,
        defaultValue: Extension.CRITICAL
      })
    ], Extension.prototype, "critical", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], Extension.prototype, "extnValue", void 0);
    exports.Extension = Extension;
    var Extensions = Extensions_1 = class Extensions extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Extensions_1.prototype);
      }
    };
    Extensions = Extensions_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: Extension })
    ], Extensions);
    exports.Extensions = Extensions;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/types.js
var require_types2 = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Version = void 0;
    var Version;
    (function(Version2) {
      Version2[Version2["v1"] = 0] = "v1";
      Version2[Version2["v2"] = 1] = "v2";
      Version2[Version2["v3"] = 2] = "v3";
    })(Version = exports.Version || (exports.Version = {}));
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/tbs_certificate.js
var require_tbs_certificate = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/tbs_certificate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TBSCertificate = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var algorithm_identifier_1 = require_algorithm_identifier();
    var name_1 = require_name();
    var subject_public_key_info_1 = require_subject_public_key_info();
    var validity_1 = require_validity();
    var extension_1 = require_extension();
    var types_1 = require_types2();
    var TBSCertificate = class {
      constructor(params = {}) {
        this.version = types_1.Version.v1;
        this.serialNumber = new ArrayBuffer(0);
        this.signature = new algorithm_identifier_1.AlgorithmIdentifier();
        this.issuer = new name_1.Name();
        this.validity = new validity_1.Validity();
        this.subject = new name_1.Name();
        this.subjectPublicKeyInfo = new subject_public_key_info_1.SubjectPublicKeyInfo();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({
        type: asn1_schema_1.AsnPropTypes.Integer,
        context: 0,
        defaultValue: types_1.Version.v1
      })
    ], TBSCertificate.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({
        type: asn1_schema_1.AsnPropTypes.Integer,
        converter: asn1_schema_1.AsnIntegerArrayBufferConverter
      })
    ], TBSCertificate.prototype, "serialNumber", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: algorithm_identifier_1.AlgorithmIdentifier })
    ], TBSCertificate.prototype, "signature", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: name_1.Name })
    ], TBSCertificate.prototype, "issuer", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: validity_1.Validity })
    ], TBSCertificate.prototype, "validity", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: name_1.Name })
    ], TBSCertificate.prototype, "subject", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: subject_public_key_info_1.SubjectPublicKeyInfo })
    ], TBSCertificate.prototype, "subjectPublicKeyInfo", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({
        type: asn1_schema_1.AsnPropTypes.BitString,
        context: 1,
        implicit: true,
        optional: true
      })
    ], TBSCertificate.prototype, "issuerUniqueID", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BitString, context: 2, implicit: true, optional: true })
    ], TBSCertificate.prototype, "subjectUniqueID", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: extension_1.Extensions, context: 3, optional: true })
    ], TBSCertificate.prototype, "extensions", void 0);
    exports.TBSCertificate = TBSCertificate;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/certificate.js
var require_certificate = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/certificate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Certificate = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var algorithm_identifier_1 = require_algorithm_identifier();
    var tbs_certificate_1 = require_tbs_certificate();
    var Certificate = class {
      constructor(params = {}) {
        this.tbsCertificate = new tbs_certificate_1.TBSCertificate();
        this.signatureAlgorithm = new algorithm_identifier_1.AlgorithmIdentifier();
        this.signatureValue = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: tbs_certificate_1.TBSCertificate })
    ], Certificate.prototype, "tbsCertificate", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: algorithm_identifier_1.AlgorithmIdentifier })
    ], Certificate.prototype, "signatureAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BitString })
    ], Certificate.prototype, "signatureValue", void 0);
    exports.Certificate = Certificate;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/tbs_cert_list.js
var require_tbs_cert_list = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/tbs_cert_list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TBSCertList = exports.RevokedCertificate = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var algorithm_identifier_1 = require_algorithm_identifier();
    var name_1 = require_name();
    var time_1 = require_time();
    var extension_1 = require_extension();
    var RevokedCertificate = class {
      constructor(params = {}) {
        this.userCertificate = new ArrayBuffer(0);
        this.revocationDate = new time_1.Time();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], RevokedCertificate.prototype, "userCertificate", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: time_1.Time })
    ], RevokedCertificate.prototype, "revocationDate", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: extension_1.Extension, optional: true, repeated: "sequence" })
    ], RevokedCertificate.prototype, "crlEntryExtensions", void 0);
    exports.RevokedCertificate = RevokedCertificate;
    var TBSCertList = class {
      constructor(params = {}) {
        this.signature = new algorithm_identifier_1.AlgorithmIdentifier();
        this.issuer = new name_1.Name();
        this.thisUpdate = new time_1.Time();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, optional: true })
    ], TBSCertList.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: algorithm_identifier_1.AlgorithmIdentifier })
    ], TBSCertList.prototype, "signature", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: name_1.Name })
    ], TBSCertList.prototype, "issuer", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: time_1.Time })
    ], TBSCertList.prototype, "thisUpdate", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: time_1.Time, optional: true })
    ], TBSCertList.prototype, "nextUpdate", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: RevokedCertificate, repeated: "sequence", optional: true })
    ], TBSCertList.prototype, "revokedCertificates", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: extension_1.Extension, optional: true, context: 0, repeated: "sequence" })
    ], TBSCertList.prototype, "crlExtensions", void 0);
    exports.TBSCertList = TBSCertList;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/certificate_list.js
var require_certificate_list = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/certificate_list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CertificateList = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var algorithm_identifier_1 = require_algorithm_identifier();
    var tbs_cert_list_1 = require_tbs_cert_list();
    var CertificateList = class {
      constructor(params = {}) {
        this.tbsCertList = new tbs_cert_list_1.TBSCertList();
        this.signatureAlgorithm = new algorithm_identifier_1.AlgorithmIdentifier();
        this.signature = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: tbs_cert_list_1.TBSCertList })
    ], CertificateList.prototype, "tbsCertList", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: algorithm_identifier_1.AlgorithmIdentifier })
    ], CertificateList.prototype, "signatureAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BitString })
    ], CertificateList.prototype, "signature", void 0);
    exports.CertificateList = CertificateList;
  }
});

// node_modules/@peculiar/asn1-x509/build/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@peculiar/asn1-x509/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_extensions(), exports);
    tslib_1.__exportStar(require_algorithm_identifier(), exports);
    tslib_1.__exportStar(require_attribute(), exports);
    tslib_1.__exportStar(require_certificate(), exports);
    tslib_1.__exportStar(require_certificate_list(), exports);
    tslib_1.__exportStar(require_extension(), exports);
    tslib_1.__exportStar(require_general_name(), exports);
    tslib_1.__exportStar(require_general_names(), exports);
    tslib_1.__exportStar(require_name(), exports);
    tslib_1.__exportStar(require_object_identifiers(), exports);
    tslib_1.__exportStar(require_subject_public_key_info(), exports);
    tslib_1.__exportStar(require_tbs_cert_list(), exports);
    tslib_1.__exportStar(require_tbs_certificate(), exports);
    tslib_1.__exportStar(require_time(), exports);
    tslib_1.__exportStar(require_types2(), exports);
    tslib_1.__exportStar(require_validity(), exports);
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/attribute.js
var require_attribute2 = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/attribute.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Attribute = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var Attribute = class {
      constructor(params = {}) {
        this.attrType = "";
        this.attrValues = [];
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], Attribute.prototype, "attrType", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, repeated: "set" })
    ], Attribute.prototype, "attrValues", void 0);
    exports.Attribute = Attribute;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/aa_clear_attrs.js
var require_aa_clear_attrs = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/aa_clear_attrs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ACClearAttrs = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var ACClearAttrs = class {
      constructor(params = {}) {
        this.acIssuer = new asn1_x509_1.GeneralName();
        this.acSerial = 0;
        this.attrs = [];
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralName })
    ], ACClearAttrs.prototype, "acIssuer", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], ACClearAttrs.prototype, "acSerial", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.Attribute, repeated: "sequence" })
    ], ACClearAttrs.prototype, "attrs", void 0);
    exports.ACClearAttrs = ACClearAttrs;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/attr_spec.js
var require_attr_spec = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/attr_spec.js"(exports) {
    "use strict";
    var AttrSpec_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttrSpec = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var AttrSpec = AttrSpec_1 = class AttrSpec extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, AttrSpec_1.prototype);
      }
    };
    AttrSpec = AttrSpec_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], AttrSpec);
    exports.AttrSpec = AttrSpec;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/aa_controls.js
var require_aa_controls = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/aa_controls.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AAControls = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var attr_spec_1 = require_attr_spec();
    var AAControls = class {
      constructor(params = {}) {
        this.permitUnSpecified = true;
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, optional: true })
    ], AAControls.prototype, "pathLenConstraint", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: attr_spec_1.AttrSpec, implicit: true, context: 0, optional: true })
    ], AAControls.prototype, "permittedAttrs", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: attr_spec_1.AttrSpec, implicit: true, context: 1, optional: true })
    ], AAControls.prototype, "excludedAttrs", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Boolean, defaultValue: true })
    ], AAControls.prototype, "permitUnSpecified", void 0);
    exports.AAControls = AAControls;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/issuer_serial.js
var require_issuer_serial = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/issuer_serial.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IssuerSerial = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var IssuerSerial = class {
      constructor(params = {}) {
        this.issuer = new asn1_x509_1.GeneralNames();
        this.serial = new ArrayBuffer(0);
        this.issuerUID = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralNames })
    ], IssuerSerial.prototype, "issuer", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], IssuerSerial.prototype, "serial", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BitString, optional: true })
    ], IssuerSerial.prototype, "issuerUID", void 0);
    exports.IssuerSerial = IssuerSerial;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/object_digest_info.js
var require_object_digest_info = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/object_digest_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectDigestInfo = exports.DigestedObjectType = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var DigestedObjectType;
    (function(DigestedObjectType2) {
      DigestedObjectType2[DigestedObjectType2["publicKey"] = 0] = "publicKey";
      DigestedObjectType2[DigestedObjectType2["publicKeyCert"] = 1] = "publicKeyCert";
      DigestedObjectType2[DigestedObjectType2["otherObjectTypes"] = 2] = "otherObjectTypes";
    })(DigestedObjectType = exports.DigestedObjectType || (exports.DigestedObjectType = {}));
    var ObjectDigestInfo = class {
      constructor(params = {}) {
        this.digestedObjectType = DigestedObjectType.publicKey;
        this.digestAlgorithm = new asn1_x509_1.AlgorithmIdentifier();
        this.objectDigest = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Enumerated })
    ], ObjectDigestInfo.prototype, "digestedObjectType", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier, optional: true })
    ], ObjectDigestInfo.prototype, "otherObjectTypeID", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier })
    ], ObjectDigestInfo.prototype, "digestAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BitString })
    ], ObjectDigestInfo.prototype, "objectDigest", void 0);
    exports.ObjectDigestInfo = ObjectDigestInfo;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/v2_form.js
var require_v2_form = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/v2_form.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2Form = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var issuer_serial_1 = require_issuer_serial();
    var object_digest_info_1 = require_object_digest_info();
    var V2Form = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralNames, optional: true })
    ], V2Form.prototype, "issuerName", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: issuer_serial_1.IssuerSerial, context: 0, implicit: true, optional: true })
    ], V2Form.prototype, "baseCertificateID", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: object_digest_info_1.ObjectDigestInfo, context: 1, implicit: true, optional: true })
    ], V2Form.prototype, "objectDigestInfo", void 0);
    exports.V2Form = V2Form;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/attr_cert_issuer.js
var require_attr_cert_issuer = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/attr_cert_issuer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttCertIssuer = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var v2_form_1 = require_v2_form();
    var AttCertIssuer = class AttCertIssuer {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralName, repeated: "sequence" })
    ], AttCertIssuer.prototype, "v1Form", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: v2_form_1.V2Form, context: 0, implicit: true })
    ], AttCertIssuer.prototype, "v2Form", void 0);
    AttCertIssuer = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], AttCertIssuer);
    exports.AttCertIssuer = AttCertIssuer;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/attr_cert_validity_period.js
var require_attr_cert_validity_period = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/attr_cert_validity_period.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttCertValidityPeriod = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var AttCertValidityPeriod = class {
      constructor(params = {}) {
        this.notBeforeTime = /* @__PURE__ */ new Date();
        this.notAfterTime = /* @__PURE__ */ new Date();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.GeneralizedTime })
    ], AttCertValidityPeriod.prototype, "notBeforeTime", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.GeneralizedTime })
    ], AttCertValidityPeriod.prototype, "notAfterTime", void 0);
    exports.AttCertValidityPeriod = AttCertValidityPeriod;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/holder.js
var require_holder = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/holder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Holder = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var issuer_serial_1 = require_issuer_serial();
    var asn1_x509_1 = require_cjs2();
    var object_digest_info_1 = require_object_digest_info();
    var Holder = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: issuer_serial_1.IssuerSerial, implicit: true, context: 0, optional: true })
    ], Holder.prototype, "baseCertificateID", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralNames, implicit: true, context: 1, optional: true })
    ], Holder.prototype, "entityName", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: object_digest_info_1.ObjectDigestInfo, implicit: true, context: 2, optional: true })
    ], Holder.prototype, "objectDigestInfo", void 0);
    exports.Holder = Holder;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/attribute_certificate_info.js
var require_attribute_certificate_info = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/attribute_certificate_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeCertificateInfo = exports.AttCertVersion = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var holder_1 = require_holder();
    var attr_cert_issuer_1 = require_attr_cert_issuer();
    var attr_cert_validity_period_1 = require_attr_cert_validity_period();
    var AttCertVersion;
    (function(AttCertVersion2) {
      AttCertVersion2[AttCertVersion2["v2"] = 1] = "v2";
    })(AttCertVersion = exports.AttCertVersion || (exports.AttCertVersion = {}));
    var AttributeCertificateInfo = class {
      constructor(params = {}) {
        this.version = AttCertVersion.v2;
        this.holder = new holder_1.Holder();
        this.issuer = new attr_cert_issuer_1.AttCertIssuer();
        this.signature = new asn1_x509_1.AlgorithmIdentifier();
        this.serialNumber = new ArrayBuffer(0);
        this.attrCertValidityPeriod = new attr_cert_validity_period_1.AttCertValidityPeriod();
        this.attributes = [];
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], AttributeCertificateInfo.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: holder_1.Holder })
    ], AttributeCertificateInfo.prototype, "holder", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: attr_cert_issuer_1.AttCertIssuer })
    ], AttributeCertificateInfo.prototype, "issuer", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier })
    ], AttributeCertificateInfo.prototype, "signature", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], AttributeCertificateInfo.prototype, "serialNumber", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: attr_cert_validity_period_1.AttCertValidityPeriod })
    ], AttributeCertificateInfo.prototype, "attrCertValidityPeriod", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.Attribute, repeated: "sequence" })
    ], AttributeCertificateInfo.prototype, "attributes", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BitString, optional: true })
    ], AttributeCertificateInfo.prototype, "issuerUniqueID", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.Extensions, optional: true })
    ], AttributeCertificateInfo.prototype, "extensions", void 0);
    exports.AttributeCertificateInfo = AttributeCertificateInfo;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/attribute_certificate.js
var require_attribute_certificate = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/attribute_certificate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeCertificate = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var attribute_certificate_info_1 = require_attribute_certificate_info();
    var AttributeCertificate = class {
      constructor(params = {}) {
        this.acinfo = new attribute_certificate_info_1.AttributeCertificateInfo();
        this.signatureAlgorithm = new asn1_x509_1.AlgorithmIdentifier();
        this.signatureValue = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: attribute_certificate_info_1.AttributeCertificateInfo })
    ], AttributeCertificate.prototype, "acinfo", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier })
    ], AttributeCertificate.prototype, "signatureAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BitString })
    ], AttributeCertificate.prototype, "signatureValue", void 0);
    exports.AttributeCertificate = AttributeCertificate;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/class_list.js
var require_class_list = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/class_list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassList = exports.ClassListFlags = void 0;
    var asn1_schema_1 = require_cjs();
    var ClassListFlags;
    (function(ClassListFlags2) {
      ClassListFlags2[ClassListFlags2["unmarked"] = 1] = "unmarked";
      ClassListFlags2[ClassListFlags2["unclassified"] = 2] = "unclassified";
      ClassListFlags2[ClassListFlags2["restricted"] = 4] = "restricted";
      ClassListFlags2[ClassListFlags2["confidential"] = 8] = "confidential";
      ClassListFlags2[ClassListFlags2["secret"] = 16] = "secret";
      ClassListFlags2[ClassListFlags2["topSecret"] = 32] = "topSecret";
    })(ClassListFlags = exports.ClassListFlags || (exports.ClassListFlags = {}));
    var ClassList = class extends asn1_schema_1.BitString {
    };
    exports.ClassList = ClassList;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/security_category.js
var require_security_category = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/security_category.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SecurityCategory = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var SecurityCategory = class {
      constructor(params = {}) {
        this.type = "";
        this.value = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier, implicit: true, context: 0 })
    ], SecurityCategory.prototype, "type", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, implicit: true, context: 1 })
    ], SecurityCategory.prototype, "value", void 0);
    exports.SecurityCategory = SecurityCategory;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/clearance.js
var require_clearance = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/clearance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Clearance = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var class_list_1 = require_class_list();
    var security_category_1 = require_security_category();
    var Clearance = class {
      constructor(params = {}) {
        this.policyId = "";
        this.classList = new class_list_1.ClassList(class_list_1.ClassListFlags.unclassified);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], Clearance.prototype, "policyId", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: class_list_1.ClassList, defaultValue: new class_list_1.ClassList(class_list_1.ClassListFlags.unclassified) })
    ], Clearance.prototype, "classList", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: security_category_1.SecurityCategory, repeated: "set" })
    ], Clearance.prototype, "securityCategories", void 0);
    exports.Clearance = Clearance;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/ietf_attr_syntax.js
var require_ietf_attr_syntax = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/ietf_attr_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IetfAttrSyntax = exports.IetfAttrSyntaxValueChoices = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var IetfAttrSyntaxValueChoices = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], IetfAttrSyntaxValueChoices.prototype, "cotets", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], IetfAttrSyntaxValueChoices.prototype, "oid", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Utf8String })
    ], IetfAttrSyntaxValueChoices.prototype, "string", void 0);
    exports.IetfAttrSyntaxValueChoices = IetfAttrSyntaxValueChoices;
    var IetfAttrSyntax = class {
      constructor(params = {}) {
        this.values = [];
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralNames, implicit: true, context: 0, optional: true })
    ], IetfAttrSyntax.prototype, "policyAuthority", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: IetfAttrSyntaxValueChoices, repeated: "sequence" })
    ], IetfAttrSyntax.prototype, "values", void 0);
    exports.IetfAttrSyntax = IetfAttrSyntax;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/object_identifiers.js
var require_object_identifiers2 = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/object_identifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id_at_clearance = exports.id_at_role = exports.id_at = exports.id_aca_encAttrs = exports.id_aca_group = exports.id_aca_chargingIdentity = exports.id_aca_accessIdentity = exports.id_aca_authenticationInfo = exports.id_aca = exports.id_ce_targetInformation = exports.id_pe_ac_proxying = exports.id_pe_aaControls = exports.id_pe_ac_auditIdentity = void 0;
    var asn1_x509_1 = require_cjs2();
    exports.id_pe_ac_auditIdentity = `${asn1_x509_1.id_pe}.4`;
    exports.id_pe_aaControls = `${asn1_x509_1.id_pe}.6`;
    exports.id_pe_ac_proxying = `${asn1_x509_1.id_pe}.10`;
    exports.id_ce_targetInformation = `${asn1_x509_1.id_ce}.55`;
    exports.id_aca = `${asn1_x509_1.id_pkix}.10`;
    exports.id_aca_authenticationInfo = `${exports.id_aca}.1`;
    exports.id_aca_accessIdentity = `${exports.id_aca}.2`;
    exports.id_aca_chargingIdentity = `${exports.id_aca}.3`;
    exports.id_aca_group = `${exports.id_aca}.4`;
    exports.id_aca_encAttrs = `${exports.id_aca}.6`;
    exports.id_at = "2.5.4";
    exports.id_at_role = `${exports.id_at}.72`;
    exports.id_at_clearance = "2.5.1.5.55";
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/target.js
var require_target = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/target.js"(exports) {
    "use strict";
    var Targets_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Targets = exports.Target = exports.TargetCert = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var issuer_serial_1 = require_issuer_serial();
    var object_digest_info_1 = require_object_digest_info();
    var TargetCert = class {
      constructor(params = {}) {
        this.targetCertificate = new issuer_serial_1.IssuerSerial();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: issuer_serial_1.IssuerSerial })
    ], TargetCert.prototype, "targetCertificate", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralName, optional: true })
    ], TargetCert.prototype, "targetName", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: object_digest_info_1.ObjectDigestInfo, optional: true })
    ], TargetCert.prototype, "certDigestInfo", void 0);
    exports.TargetCert = TargetCert;
    var Target = class Target {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralName, context: 0, implicit: true })
    ], Target.prototype, "targetName", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralName, context: 1, implicit: true })
    ], Target.prototype, "targetGroup", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: TargetCert, context: 2, implicit: true })
    ], Target.prototype, "targetCert", void 0);
    Target = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], Target);
    exports.Target = Target;
    var Targets = Targets_1 = class Targets extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Targets_1.prototype);
      }
    };
    Targets = Targets_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: Target })
    ], Targets);
    exports.Targets = Targets;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/proxy_info.js
var require_proxy_info = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/proxy_info.js"(exports) {
    "use strict";
    var ProxyInfo_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var target_1 = require_target();
    var ProxyInfo = ProxyInfo_1 = class ProxyInfo extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, ProxyInfo_1.prototype);
      }
    };
    ProxyInfo = ProxyInfo_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: target_1.Targets })
    ], ProxyInfo);
    exports.ProxyInfo = ProxyInfo;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/role_syntax.js
var require_role_syntax = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/role_syntax.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RoleSyntax = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var RoleSyntax = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralNames, implicit: true, context: 0, optional: true })
    ], RoleSyntax.prototype, "roleAuthority", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralName, implicit: true, context: 1 })
    ], RoleSyntax.prototype, "roleName", void 0);
    exports.RoleSyntax = RoleSyntax;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/svce_auth_info.js
var require_svce_auth_info = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/svce_auth_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SvceAuthInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var SvceAuthInfo = class {
      constructor(params = {}) {
        this.service = new asn1_x509_1.GeneralName();
        this.ident = new asn1_x509_1.GeneralName();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralName })
    ], SvceAuthInfo.prototype, "service", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.GeneralName })
    ], SvceAuthInfo.prototype, "ident", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString, optional: true })
    ], SvceAuthInfo.prototype, "authInfo", void 0);
    exports.SvceAuthInfo = SvceAuthInfo;
  }
});

// node_modules/@peculiar/asn1-x509-attr/build/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@peculiar/asn1-x509-attr/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_aa_clear_attrs(), exports);
    tslib_1.__exportStar(require_aa_controls(), exports);
    tslib_1.__exportStar(require_attr_cert_issuer(), exports);
    tslib_1.__exportStar(require_attr_cert_validity_period(), exports);
    tslib_1.__exportStar(require_attr_spec(), exports);
    tslib_1.__exportStar(require_attribute_certificate(), exports);
    tslib_1.__exportStar(require_attribute_certificate_info(), exports);
    tslib_1.__exportStar(require_class_list(), exports);
    tslib_1.__exportStar(require_clearance(), exports);
    tslib_1.__exportStar(require_holder(), exports);
    tslib_1.__exportStar(require_ietf_attr_syntax(), exports);
    tslib_1.__exportStar(require_issuer_serial(), exports);
    tslib_1.__exportStar(require_object_digest_info(), exports);
    tslib_1.__exportStar(require_object_identifiers2(), exports);
    tslib_1.__exportStar(require_proxy_info(), exports);
    tslib_1.__exportStar(require_role_syntax(), exports);
    tslib_1.__exportStar(require_security_category(), exports);
    tslib_1.__exportStar(require_svce_auth_info(), exports);
    tslib_1.__exportStar(require_target(), exports);
    tslib_1.__exportStar(require_v2_form(), exports);
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/certificate_choices.js
var require_certificate_choices = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/certificate_choices.js"(exports) {
    "use strict";
    var CertificateSet_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CertificateSet = exports.CertificateChoices = exports.OtherCertificateFormat = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var asn1_x509_attr_1 = require_cjs3();
    var OtherCertificateFormat = class {
      constructor(params = {}) {
        this.otherCertFormat = "";
        this.otherCert = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], OtherCertificateFormat.prototype, "otherCertFormat", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any })
    ], OtherCertificateFormat.prototype, "otherCert", void 0);
    exports.OtherCertificateFormat = OtherCertificateFormat;
    var CertificateChoices = class CertificateChoices {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.Certificate })
    ], CertificateChoices.prototype, "certificate", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_attr_1.AttributeCertificate, context: 2, implicit: true })
    ], CertificateChoices.prototype, "v2AttrCert", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: OtherCertificateFormat, context: 3, implicit: true })
    ], CertificateChoices.prototype, "other", void 0);
    CertificateChoices = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], CertificateChoices);
    exports.CertificateChoices = CertificateChoices;
    var CertificateSet = CertificateSet_1 = class CertificateSet extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, CertificateSet_1.prototype);
      }
    };
    CertificateSet = CertificateSet_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Set, itemType: CertificateChoices })
    ], CertificateSet);
    exports.CertificateSet = CertificateSet;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/content_info.js
var require_content_info = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/content_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContentInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var ContentInfo = class {
      constructor(params = {}) {
        this.contentType = "";
        this.content = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], ContentInfo.prototype, "contentType", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, context: 0 })
    ], ContentInfo.prototype, "content", void 0);
    exports.ContentInfo = ContentInfo;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/encapsulated_content_info.js
var require_encapsulated_content_info = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/encapsulated_content_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EncapsulatedContentInfo = exports.EncapsulatedContent = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var EncapsulatedContent = class EncapsulatedContent {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], EncapsulatedContent.prototype, "single", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any })
    ], EncapsulatedContent.prototype, "any", void 0);
    EncapsulatedContent = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], EncapsulatedContent);
    exports.EncapsulatedContent = EncapsulatedContent;
    var EncapsulatedContentInfo = class {
      constructor(params = {}) {
        this.eContentType = "";
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], EncapsulatedContentInfo.prototype, "eContentType", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: EncapsulatedContent, context: 0, optional: true })
    ], EncapsulatedContentInfo.prototype, "eContent", void 0);
    exports.EncapsulatedContentInfo = EncapsulatedContentInfo;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/types.js
var require_types3 = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyDerivationAlgorithmIdentifier = exports.MessageAuthenticationCodeAlgorithm = exports.ContentEncryptionAlgorithmIdentifier = exports.KeyEncryptionAlgorithmIdentifier = exports.SignatureAlgorithmIdentifier = exports.DigestAlgorithmIdentifier = exports.CMSVersion = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_x509_1 = require_cjs2();
    var asn1_schema_1 = require_cjs();
    var CMSVersion;
    (function(CMSVersion2) {
      CMSVersion2[CMSVersion2["v0"] = 0] = "v0";
      CMSVersion2[CMSVersion2["v1"] = 1] = "v1";
      CMSVersion2[CMSVersion2["v2"] = 2] = "v2";
      CMSVersion2[CMSVersion2["v3"] = 3] = "v3";
      CMSVersion2[CMSVersion2["v4"] = 4] = "v4";
      CMSVersion2[CMSVersion2["v5"] = 5] = "v5";
    })(CMSVersion = exports.CMSVersion || (exports.CMSVersion = {}));
    var DigestAlgorithmIdentifier = class DigestAlgorithmIdentifier extends asn1_x509_1.AlgorithmIdentifier {
    };
    DigestAlgorithmIdentifier = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], DigestAlgorithmIdentifier);
    exports.DigestAlgorithmIdentifier = DigestAlgorithmIdentifier;
    var SignatureAlgorithmIdentifier = class SignatureAlgorithmIdentifier extends asn1_x509_1.AlgorithmIdentifier {
    };
    SignatureAlgorithmIdentifier = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], SignatureAlgorithmIdentifier);
    exports.SignatureAlgorithmIdentifier = SignatureAlgorithmIdentifier;
    var KeyEncryptionAlgorithmIdentifier = class KeyEncryptionAlgorithmIdentifier extends asn1_x509_1.AlgorithmIdentifier {
    };
    KeyEncryptionAlgorithmIdentifier = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], KeyEncryptionAlgorithmIdentifier);
    exports.KeyEncryptionAlgorithmIdentifier = KeyEncryptionAlgorithmIdentifier;
    var ContentEncryptionAlgorithmIdentifier = class ContentEncryptionAlgorithmIdentifier extends asn1_x509_1.AlgorithmIdentifier {
    };
    ContentEncryptionAlgorithmIdentifier = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], ContentEncryptionAlgorithmIdentifier);
    exports.ContentEncryptionAlgorithmIdentifier = ContentEncryptionAlgorithmIdentifier;
    var MessageAuthenticationCodeAlgorithm = class MessageAuthenticationCodeAlgorithm extends asn1_x509_1.AlgorithmIdentifier {
    };
    MessageAuthenticationCodeAlgorithm = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], MessageAuthenticationCodeAlgorithm);
    exports.MessageAuthenticationCodeAlgorithm = MessageAuthenticationCodeAlgorithm;
    var KeyDerivationAlgorithmIdentifier = class KeyDerivationAlgorithmIdentifier extends asn1_x509_1.AlgorithmIdentifier {
    };
    KeyDerivationAlgorithmIdentifier = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], KeyDerivationAlgorithmIdentifier);
    exports.KeyDerivationAlgorithmIdentifier = KeyDerivationAlgorithmIdentifier;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/encrypted_content_info.js
var require_encrypted_content_info = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/encrypted_content_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EncryptedContentInfo = exports.EncryptedContent = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var types_1 = require_types3();
    var EncryptedContent = class EncryptedContent {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString, context: 0, implicit: true, optional: true })
    ], EncryptedContent.prototype, "value", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString, converter: asn1_schema_1.AsnConstructedOctetStringConverter, context: 0, implicit: true, optional: true, repeated: "sequence" })
    ], EncryptedContent.prototype, "constructedValue", void 0);
    EncryptedContent = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], EncryptedContent);
    exports.EncryptedContent = EncryptedContent;
    var EncryptedContentInfo = class {
      constructor(params = {}) {
        this.contentType = "";
        this.contentEncryptionAlgorithm = new types_1.ContentEncryptionAlgorithmIdentifier();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], EncryptedContentInfo.prototype, "contentType", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: types_1.ContentEncryptionAlgorithmIdentifier })
    ], EncryptedContentInfo.prototype, "contentEncryptionAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: EncryptedContent, optional: true })
    ], EncryptedContentInfo.prototype, "encryptedContent", void 0);
    exports.EncryptedContentInfo = EncryptedContentInfo;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/issuer_and_serial_number.js
var require_issuer_and_serial_number = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/issuer_and_serial_number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IssuerAndSerialNumber = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var IssuerAndSerialNumber = class {
      constructor(params = {}) {
        this.issuer = new asn1_x509_1.Name();
        this.serialNumber = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.Name })
    ], IssuerAndSerialNumber.prototype, "issuer", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], IssuerAndSerialNumber.prototype, "serialNumber", void 0);
    exports.IssuerAndSerialNumber = IssuerAndSerialNumber;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/other_key_attribute.js
var require_other_key_attribute = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/other_key_attribute.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OtherKeyAttribute = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var OtherKeyAttribute = class {
      constructor(params = {}) {
        this.keyAttrId = "";
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], OtherKeyAttribute.prototype, "keyAttrId", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, optional: true })
    ], OtherKeyAttribute.prototype, "keyAttr", void 0);
    exports.OtherKeyAttribute = OtherKeyAttribute;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/key_agree_recipient_info.js
var require_key_agree_recipient_info = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/key_agree_recipient_info.js"(exports) {
    "use strict";
    var RecipientEncryptedKeys_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyAgreeRecipientInfo = exports.OriginatorIdentifierOrKey = exports.OriginatorPublicKey = exports.RecipientEncryptedKeys = exports.RecipientEncryptedKey = exports.KeyAgreeRecipientIdentifier = exports.RecipientKeyIdentifier = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var types_1 = require_types3();
    var issuer_and_serial_number_1 = require_issuer_and_serial_number();
    var asn1_x509_1 = require_cjs2();
    var other_key_attribute_1 = require_other_key_attribute();
    var RecipientKeyIdentifier = class {
      constructor(params = {}) {
        this.subjectKeyIdentifier = new asn1_x509_1.SubjectKeyIdentifier();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.SubjectKeyIdentifier })
    ], RecipientKeyIdentifier.prototype, "subjectKeyIdentifier", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.GeneralizedTime, optional: true })
    ], RecipientKeyIdentifier.prototype, "date", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: other_key_attribute_1.OtherKeyAttribute, optional: true })
    ], RecipientKeyIdentifier.prototype, "other", void 0);
    exports.RecipientKeyIdentifier = RecipientKeyIdentifier;
    var KeyAgreeRecipientIdentifier = class KeyAgreeRecipientIdentifier {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: RecipientKeyIdentifier, context: 0, implicit: true, optional: true })
    ], KeyAgreeRecipientIdentifier.prototype, "rKeyId", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: issuer_and_serial_number_1.IssuerAndSerialNumber, optional: true })
    ], KeyAgreeRecipientIdentifier.prototype, "issuerAndSerialNumber", void 0);
    KeyAgreeRecipientIdentifier = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], KeyAgreeRecipientIdentifier);
    exports.KeyAgreeRecipientIdentifier = KeyAgreeRecipientIdentifier;
    var RecipientEncryptedKey = class {
      constructor(params = {}) {
        this.rid = new KeyAgreeRecipientIdentifier();
        this.encryptedKey = new asn1_schema_1.OctetString();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: KeyAgreeRecipientIdentifier })
    ], RecipientEncryptedKey.prototype, "rid", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], RecipientEncryptedKey.prototype, "encryptedKey", void 0);
    exports.RecipientEncryptedKey = RecipientEncryptedKey;
    var RecipientEncryptedKeys = RecipientEncryptedKeys_1 = class RecipientEncryptedKeys extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RecipientEncryptedKeys_1.prototype);
      }
    };
    RecipientEncryptedKeys = RecipientEncryptedKeys_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: RecipientEncryptedKey })
    ], RecipientEncryptedKeys);
    exports.RecipientEncryptedKeys = RecipientEncryptedKeys;
    var OriginatorPublicKey = class {
      constructor(params = {}) {
        this.algorithm = new asn1_x509_1.AlgorithmIdentifier();
        this.publicKey = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier })
    ], OriginatorPublicKey.prototype, "algorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BitString })
    ], OriginatorPublicKey.prototype, "publicKey", void 0);
    exports.OriginatorPublicKey = OriginatorPublicKey;
    var OriginatorIdentifierOrKey = class OriginatorIdentifierOrKey {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.SubjectKeyIdentifier, context: 0, implicit: true, optional: true })
    ], OriginatorIdentifierOrKey.prototype, "subjectKeyIdentifier", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: OriginatorPublicKey, context: 1, implicit: true, optional: true })
    ], OriginatorIdentifierOrKey.prototype, "originatorKey", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: issuer_and_serial_number_1.IssuerAndSerialNumber, optional: true })
    ], OriginatorIdentifierOrKey.prototype, "issuerAndSerialNumber", void 0);
    OriginatorIdentifierOrKey = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], OriginatorIdentifierOrKey);
    exports.OriginatorIdentifierOrKey = OriginatorIdentifierOrKey;
    var KeyAgreeRecipientInfo = class {
      constructor(params = {}) {
        this.version = types_1.CMSVersion.v3;
        this.originator = new OriginatorIdentifierOrKey();
        this.keyEncryptionAlgorithm = new types_1.KeyEncryptionAlgorithmIdentifier();
        this.recipientEncryptedKeys = new RecipientEncryptedKeys();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], KeyAgreeRecipientInfo.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: OriginatorIdentifierOrKey, context: 0 })
    ], KeyAgreeRecipientInfo.prototype, "originator", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString, context: 1, optional: true })
    ], KeyAgreeRecipientInfo.prototype, "ukm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: types_1.KeyEncryptionAlgorithmIdentifier })
    ], KeyAgreeRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: RecipientEncryptedKeys })
    ], KeyAgreeRecipientInfo.prototype, "recipientEncryptedKeys", void 0);
    exports.KeyAgreeRecipientInfo = KeyAgreeRecipientInfo;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/key_trans_recipient_info.js
var require_key_trans_recipient_info = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/key_trans_recipient_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyTransRecipientInfo = exports.RecipientIdentifier = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var types_1 = require_types3();
    var issuer_and_serial_number_1 = require_issuer_and_serial_number();
    var asn1_x509_1 = require_cjs2();
    var RecipientIdentifier = class RecipientIdentifier {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.SubjectKeyIdentifier, context: 0, implicit: true })
    ], RecipientIdentifier.prototype, "subjectKeyIdentifier", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: issuer_and_serial_number_1.IssuerAndSerialNumber })
    ], RecipientIdentifier.prototype, "issuerAndSerialNumber", void 0);
    RecipientIdentifier = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], RecipientIdentifier);
    exports.RecipientIdentifier = RecipientIdentifier;
    var KeyTransRecipientInfo = class {
      constructor(params = {}) {
        this.version = types_1.CMSVersion.v0;
        this.rid = new RecipientIdentifier();
        this.keyEncryptionAlgorithm = new types_1.KeyEncryptionAlgorithmIdentifier();
        this.encryptedKey = new asn1_schema_1.OctetString();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], KeyTransRecipientInfo.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: RecipientIdentifier })
    ], KeyTransRecipientInfo.prototype, "rid", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: types_1.KeyEncryptionAlgorithmIdentifier })
    ], KeyTransRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], KeyTransRecipientInfo.prototype, "encryptedKey", void 0);
    exports.KeyTransRecipientInfo = KeyTransRecipientInfo;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/kek_recipient_info.js
var require_kek_recipient_info = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/kek_recipient_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KEKRecipientInfo = exports.KEKIdentifier = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var other_key_attribute_1 = require_other_key_attribute();
    var types_1 = require_types3();
    var KEKIdentifier = class {
      constructor(params = {}) {
        this.keyIdentifier = new asn1_schema_1.OctetString();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], KEKIdentifier.prototype, "keyIdentifier", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.GeneralizedTime, optional: true })
    ], KEKIdentifier.prototype, "date", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: other_key_attribute_1.OtherKeyAttribute, optional: true })
    ], KEKIdentifier.prototype, "other", void 0);
    exports.KEKIdentifier = KEKIdentifier;
    var KEKRecipientInfo = class {
      constructor(params = {}) {
        this.version = types_1.CMSVersion.v4;
        this.kekid = new KEKIdentifier();
        this.keyEncryptionAlgorithm = new types_1.KeyEncryptionAlgorithmIdentifier();
        this.encryptedKey = new asn1_schema_1.OctetString();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], KEKRecipientInfo.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: KEKIdentifier })
    ], KEKRecipientInfo.prototype, "kekid", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: types_1.KeyEncryptionAlgorithmIdentifier })
    ], KEKRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], KEKRecipientInfo.prototype, "encryptedKey", void 0);
    exports.KEKRecipientInfo = KEKRecipientInfo;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/password_recipient_info.js
var require_password_recipient_info = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/password_recipient_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PasswordRecipientInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var types_1 = require_types3();
    var PasswordRecipientInfo = class {
      constructor(params = {}) {
        this.version = types_1.CMSVersion.v0;
        this.keyEncryptionAlgorithm = new types_1.KeyEncryptionAlgorithmIdentifier();
        this.encryptedKey = new asn1_schema_1.OctetString();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], PasswordRecipientInfo.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: types_1.KeyDerivationAlgorithmIdentifier, context: 0, optional: true })
    ], PasswordRecipientInfo.prototype, "keyDerivationAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: types_1.KeyEncryptionAlgorithmIdentifier })
    ], PasswordRecipientInfo.prototype, "keyEncryptionAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], PasswordRecipientInfo.prototype, "encryptedKey", void 0);
    exports.PasswordRecipientInfo = PasswordRecipientInfo;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/recipient_info.js
var require_recipient_info = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/recipient_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecipientInfo = exports.OtherRecipientInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var key_agree_recipient_info_1 = require_key_agree_recipient_info();
    var key_trans_recipient_info_1 = require_key_trans_recipient_info();
    var kek_recipient_info_1 = require_kek_recipient_info();
    var password_recipient_info_1 = require_password_recipient_info();
    var OtherRecipientInfo = class {
      constructor(params = {}) {
        this.oriType = "";
        this.oriValue = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], OtherRecipientInfo.prototype, "oriType", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any })
    ], OtherRecipientInfo.prototype, "oriValue", void 0);
    exports.OtherRecipientInfo = OtherRecipientInfo;
    var RecipientInfo = class RecipientInfo {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: key_trans_recipient_info_1.KeyTransRecipientInfo, optional: true })
    ], RecipientInfo.prototype, "ktri", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: key_agree_recipient_info_1.KeyAgreeRecipientInfo, context: 1, implicit: true, optional: true })
    ], RecipientInfo.prototype, "kari", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: kek_recipient_info_1.KEKRecipientInfo, context: 2, implicit: true, optional: true })
    ], RecipientInfo.prototype, "kekri", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: password_recipient_info_1.PasswordRecipientInfo, context: 3, implicit: true, optional: true })
    ], RecipientInfo.prototype, "pwri", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: OtherRecipientInfo, context: 4, implicit: true, optional: true })
    ], RecipientInfo.prototype, "ori", void 0);
    RecipientInfo = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], RecipientInfo);
    exports.RecipientInfo = RecipientInfo;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/recipient_infos.js
var require_recipient_infos = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/recipient_infos.js"(exports) {
    "use strict";
    var RecipientInfos_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecipientInfos = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var recipient_info_1 = require_recipient_info();
    var RecipientInfos = RecipientInfos_1 = class RecipientInfos extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RecipientInfos_1.prototype);
      }
    };
    RecipientInfos = RecipientInfos_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Set, itemType: recipient_info_1.RecipientInfo })
    ], RecipientInfos);
    exports.RecipientInfos = RecipientInfos;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/revocation_info_choice.js
var require_revocation_info_choice = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/revocation_info_choice.js"(exports) {
    "use strict";
    var RevocationInfoChoices_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RevocationInfoChoices = exports.RevocationInfoChoice = exports.OtherRevocationInfoFormat = exports.id_ri_scvp = exports.id_ri_ocsp_response = exports.id_ri = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    exports.id_ri = `${asn1_x509_1.id_pkix}.16`;
    exports.id_ri_ocsp_response = `${exports.id_ri}.2`;
    exports.id_ri_scvp = `${exports.id_ri}.4`;
    var OtherRevocationInfoFormat = class {
      constructor(params = {}) {
        this.otherRevInfoFormat = "";
        this.otherRevInfo = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], OtherRevocationInfoFormat.prototype, "otherRevInfoFormat", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any })
    ], OtherRevocationInfoFormat.prototype, "otherRevInfo", void 0);
    exports.OtherRevocationInfoFormat = OtherRevocationInfoFormat;
    var RevocationInfoChoice = class RevocationInfoChoice {
      constructor(params = {}) {
        this.other = new OtherRevocationInfoFormat();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: OtherRevocationInfoFormat, context: 1, implicit: true })
    ], RevocationInfoChoice.prototype, "other", void 0);
    RevocationInfoChoice = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], RevocationInfoChoice);
    exports.RevocationInfoChoice = RevocationInfoChoice;
    var RevocationInfoChoices = RevocationInfoChoices_1 = class RevocationInfoChoices extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, RevocationInfoChoices_1.prototype);
      }
    };
    RevocationInfoChoices = RevocationInfoChoices_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Set, itemType: RevocationInfoChoice })
    ], RevocationInfoChoices);
    exports.RevocationInfoChoices = RevocationInfoChoices;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/originator_info.js
var require_originator_info = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/originator_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OriginatorInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var certificate_choices_1 = require_certificate_choices();
    var revocation_info_choice_1 = require_revocation_info_choice();
    var OriginatorInfo = class {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: certificate_choices_1.CertificateSet, context: 0, implicit: true, optional: true })
    ], OriginatorInfo.prototype, "certs", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: revocation_info_choice_1.RevocationInfoChoices, context: 1, implicit: true, optional: true })
    ], OriginatorInfo.prototype, "crls", void 0);
    exports.OriginatorInfo = OriginatorInfo;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/enveloped_data.js
var require_enveloped_data = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/enveloped_data.js"(exports) {
    "use strict";
    var UnprotectedAttributes_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnvelopedData = exports.UnprotectedAttributes = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var types_1 = require_types3();
    var attribute_1 = require_attribute2();
    var recipient_infos_1 = require_recipient_infos();
    var originator_info_1 = require_originator_info();
    var encrypted_content_info_1 = require_encrypted_content_info();
    var UnprotectedAttributes = UnprotectedAttributes_1 = class UnprotectedAttributes extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, UnprotectedAttributes_1.prototype);
      }
    };
    UnprotectedAttributes = UnprotectedAttributes_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Set, itemType: attribute_1.Attribute })
    ], UnprotectedAttributes);
    exports.UnprotectedAttributes = UnprotectedAttributes;
    var EnvelopedData = class {
      constructor(params = {}) {
        this.version = types_1.CMSVersion.v0;
        this.recipientInfos = new recipient_infos_1.RecipientInfos();
        this.encryptedContentInfo = new encrypted_content_info_1.EncryptedContentInfo();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], EnvelopedData.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: originator_info_1.OriginatorInfo, context: 0, implicit: true, optional: true })
    ], EnvelopedData.prototype, "originatorInfo", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: recipient_infos_1.RecipientInfos })
    ], EnvelopedData.prototype, "recipientInfos", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: encrypted_content_info_1.EncryptedContentInfo })
    ], EnvelopedData.prototype, "encryptedContentInfo", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: UnprotectedAttributes, context: 1, implicit: true, optional: true })
    ], EnvelopedData.prototype, "unprotectedAttrs", void 0);
    exports.EnvelopedData = EnvelopedData;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/object_identifiers.js
var require_object_identifiers3 = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/object_identifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id_authData = exports.id_encryptedData = exports.id_digestedData = exports.id_envelopedData = exports.id_signedData = exports.id_data = exports.id_ct_contentInfo = void 0;
    exports.id_ct_contentInfo = "1.2.840.113549.1.9.16.1.6";
    exports.id_data = "1.2.840.113549.1.7.1";
    exports.id_signedData = "1.2.840.113549.1.7.2";
    exports.id_envelopedData = "1.2.840.113549.1.7.3";
    exports.id_digestedData = "1.2.840.113549.1.7.5";
    exports.id_encryptedData = "1.2.840.113549.1.7.6";
    exports.id_authData = "1.2.840.113549.1.9.16.1.2";
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/signer_identifier.js
var require_signer_identifier = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/signer_identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignerIdentifier = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var issuer_and_serial_number_1 = require_issuer_and_serial_number();
    var asn1_x509_1 = require_cjs2();
    var SignerIdentifier = class SignerIdentifier {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.SubjectKeyIdentifier, context: 0, implicit: true })
    ], SignerIdentifier.prototype, "subjectKeyIdentifier", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: issuer_and_serial_number_1.IssuerAndSerialNumber })
    ], SignerIdentifier.prototype, "issuerAndSerialNumber", void 0);
    SignerIdentifier = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], SignerIdentifier);
    exports.SignerIdentifier = SignerIdentifier;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/signer_info.js
var require_signer_info = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/signer_info.js"(exports) {
    "use strict";
    var SignerInfos_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignerInfos = exports.SignerInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var signer_identifier_1 = require_signer_identifier();
    var types_1 = require_types3();
    var attribute_1 = require_attribute2();
    var SignerInfo = class {
      constructor(params = {}) {
        this.version = types_1.CMSVersion.v0;
        this.sid = new signer_identifier_1.SignerIdentifier();
        this.digestAlgorithm = new types_1.DigestAlgorithmIdentifier();
        this.signatureAlgorithm = new types_1.SignatureAlgorithmIdentifier();
        this.signature = new asn1_schema_1.OctetString();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], SignerInfo.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: signer_identifier_1.SignerIdentifier })
    ], SignerInfo.prototype, "sid", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: types_1.DigestAlgorithmIdentifier })
    ], SignerInfo.prototype, "digestAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: attribute_1.Attribute, repeated: "set", context: 0, implicit: true, optional: true })
    ], SignerInfo.prototype, "signedAttrs", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: types_1.SignatureAlgorithmIdentifier })
    ], SignerInfo.prototype, "signatureAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], SignerInfo.prototype, "signature", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: attribute_1.Attribute, repeated: "set", context: 1, implicit: true, optional: true })
    ], SignerInfo.prototype, "unsignedAttrs", void 0);
    exports.SignerInfo = SignerInfo;
    var SignerInfos = SignerInfos_1 = class SignerInfos extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SignerInfos_1.prototype);
      }
    };
    SignerInfos = SignerInfos_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Set, itemType: SignerInfo })
    ], SignerInfos);
    exports.SignerInfos = SignerInfos;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/signed_data.js
var require_signed_data = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/signed_data.js"(exports) {
    "use strict";
    var DigestAlgorithmIdentifiers_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignedData = exports.DigestAlgorithmIdentifiers = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var certificate_choices_1 = require_certificate_choices();
    var types_1 = require_types3();
    var encapsulated_content_info_1 = require_encapsulated_content_info();
    var revocation_info_choice_1 = require_revocation_info_choice();
    var signer_info_1 = require_signer_info();
    var DigestAlgorithmIdentifiers = DigestAlgorithmIdentifiers_1 = class DigestAlgorithmIdentifiers extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, DigestAlgorithmIdentifiers_1.prototype);
      }
    };
    DigestAlgorithmIdentifiers = DigestAlgorithmIdentifiers_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Set, itemType: types_1.DigestAlgorithmIdentifier })
    ], DigestAlgorithmIdentifiers);
    exports.DigestAlgorithmIdentifiers = DigestAlgorithmIdentifiers;
    var SignedData = class {
      constructor(params = {}) {
        this.version = types_1.CMSVersion.v0;
        this.digestAlgorithms = new DigestAlgorithmIdentifiers();
        this.encapContentInfo = new encapsulated_content_info_1.EncapsulatedContentInfo();
        this.signerInfos = new signer_info_1.SignerInfos();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], SignedData.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: DigestAlgorithmIdentifiers })
    ], SignedData.prototype, "digestAlgorithms", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: encapsulated_content_info_1.EncapsulatedContentInfo })
    ], SignedData.prototype, "encapContentInfo", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: certificate_choices_1.CertificateSet, context: 0, implicit: true, optional: true })
    ], SignedData.prototype, "certificates", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: revocation_info_choice_1.RevocationInfoChoice, context: 1, implicit: true, optional: true })
    ], SignedData.prototype, "crls", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: signer_info_1.SignerInfos })
    ], SignedData.prototype, "signerInfos", void 0);
    exports.SignedData = SignedData;
  }
});

// node_modules/@peculiar/asn1-cms/build/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@peculiar/asn1-cms/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_attribute2(), exports);
    tslib_1.__exportStar(require_certificate_choices(), exports);
    tslib_1.__exportStar(require_content_info(), exports);
    tslib_1.__exportStar(require_encapsulated_content_info(), exports);
    tslib_1.__exportStar(require_encrypted_content_info(), exports);
    tslib_1.__exportStar(require_enveloped_data(), exports);
    tslib_1.__exportStar(require_issuer_and_serial_number(), exports);
    tslib_1.__exportStar(require_kek_recipient_info(), exports);
    tslib_1.__exportStar(require_key_agree_recipient_info(), exports);
    tslib_1.__exportStar(require_key_trans_recipient_info(), exports);
    tslib_1.__exportStar(require_object_identifiers3(), exports);
    tslib_1.__exportStar(require_originator_info(), exports);
    tslib_1.__exportStar(require_password_recipient_info(), exports);
    tslib_1.__exportStar(require_recipient_info(), exports);
    tslib_1.__exportStar(require_recipient_infos(), exports);
    tslib_1.__exportStar(require_revocation_info_choice(), exports);
    tslib_1.__exportStar(require_signed_data(), exports);
    tslib_1.__exportStar(require_signer_identifier(), exports);
    tslib_1.__exportStar(require_signer_info(), exports);
    tslib_1.__exportStar(require_types3(), exports);
  }
});

// node_modules/@peculiar/asn1-ecc/build/cjs/object_identifiers.js
var require_object_identifiers4 = __commonJS({
  "node_modules/@peculiar/asn1-ecc/build/cjs/object_identifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id_sect571r1 = exports.id_sect571k1 = exports.id_secp521r1 = exports.id_sect409r1 = exports.id_sect409k1 = exports.id_secp384r1 = exports.id_sect283r1 = exports.id_sect283k1 = exports.id_secp256r1 = exports.id_sect233r1 = exports.id_sect233k1 = exports.id_secp224r1 = exports.id_sect163r2 = exports.id_sect163k1 = exports.id_secp192r1 = exports.id_ecdsaWithSHA512 = exports.id_ecdsaWithSHA384 = exports.id_ecdsaWithSHA256 = exports.id_ecdsaWithSHA224 = exports.id_ecdsaWithSHA1 = exports.id_ecMQV = exports.id_ecDH = exports.id_ecPublicKey = void 0;
    exports.id_ecPublicKey = "1.2.840.10045.2.1";
    exports.id_ecDH = "1.3.132.1.12";
    exports.id_ecMQV = "1.3.132.1.13";
    exports.id_ecdsaWithSHA1 = "1.2.840.10045.4.1";
    exports.id_ecdsaWithSHA224 = "1.2.840.10045.4.3.1";
    exports.id_ecdsaWithSHA256 = "1.2.840.10045.4.3.2";
    exports.id_ecdsaWithSHA384 = "1.2.840.10045.4.3.3";
    exports.id_ecdsaWithSHA512 = "1.2.840.10045.4.3.4";
    exports.id_secp192r1 = "1.2.840.10045.3.1.1";
    exports.id_sect163k1 = "1.3.132.0.1";
    exports.id_sect163r2 = "1.3.132.0.15";
    exports.id_secp224r1 = "1.3.132.0.33";
    exports.id_sect233k1 = "1.3.132.0.26";
    exports.id_sect233r1 = "1.3.132.0.27";
    exports.id_secp256r1 = "1.2.840.10045.3.1.7";
    exports.id_sect283k1 = "1.3.132.0.16";
    exports.id_sect283r1 = "1.3.132.0.17";
    exports.id_secp384r1 = "1.3.132.0.34";
    exports.id_sect409k1 = "1.3.132.0.36";
    exports.id_sect409r1 = "1.3.132.0.37";
    exports.id_secp521r1 = "1.3.132.0.35";
    exports.id_sect571k1 = "1.3.132.0.38";
    exports.id_sect571r1 = "1.3.132.0.39";
  }
});

// node_modules/@peculiar/asn1-ecc/build/cjs/algorithms.js
var require_algorithms = __commonJS({
  "node_modules/@peculiar/asn1-ecc/build/cjs/algorithms.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ecdsaWithSHA512 = exports.ecdsaWithSHA384 = exports.ecdsaWithSHA256 = exports.ecdsaWithSHA224 = exports.ecdsaWithSHA1 = void 0;
    var asn1_x509_1 = require_cjs2();
    var oid = require_object_identifiers4();
    function create(algorithm) {
      return new asn1_x509_1.AlgorithmIdentifier({ algorithm });
    }
    exports.ecdsaWithSHA1 = create(oid.id_ecdsaWithSHA1);
    exports.ecdsaWithSHA224 = create(oid.id_ecdsaWithSHA224);
    exports.ecdsaWithSHA256 = create(oid.id_ecdsaWithSHA256);
    exports.ecdsaWithSHA384 = create(oid.id_ecdsaWithSHA384);
    exports.ecdsaWithSHA512 = create(oid.id_ecdsaWithSHA512);
  }
});

// node_modules/@peculiar/asn1-ecc/build/cjs/ec_parameters.js
var require_ec_parameters = __commonJS({
  "node_modules/@peculiar/asn1-ecc/build/cjs/ec_parameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ECParameters = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var ECParameters = class ECParameters {
      constructor(params = {}) {
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], ECParameters.prototype, "namedCurve", void 0);
    ECParameters = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], ECParameters);
    exports.ECParameters = ECParameters;
  }
});

// node_modules/@peculiar/asn1-ecc/build/cjs/ec_private_key.js
var require_ec_private_key = __commonJS({
  "node_modules/@peculiar/asn1-ecc/build/cjs/ec_private_key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ECPrivateKey = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var ec_parameters_1 = require_ec_parameters();
    var ECPrivateKey = class {
      constructor(params = {}) {
        this.version = 1;
        this.privateKey = new asn1_schema_1.OctetString();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], ECPrivateKey.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], ECPrivateKey.prototype, "privateKey", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: ec_parameters_1.ECParameters, context: 0, optional: true })
    ], ECPrivateKey.prototype, "parameters", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BitString, context: 1, optional: true })
    ], ECPrivateKey.prototype, "publicKey", void 0);
    exports.ECPrivateKey = ECPrivateKey;
  }
});

// node_modules/@peculiar/asn1-ecc/build/cjs/ec_signature_value.js
var require_ec_signature_value = __commonJS({
  "node_modules/@peculiar/asn1-ecc/build/cjs/ec_signature_value.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ECDSASigValue = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var ECDSASigValue = class {
      constructor(params = {}) {
        this.r = new ArrayBuffer(0);
        this.s = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], ECDSASigValue.prototype, "r", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], ECDSASigValue.prototype, "s", void 0);
    exports.ECDSASigValue = ECDSASigValue;
  }
});

// node_modules/@peculiar/asn1-ecc/build/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@peculiar/asn1-ecc/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_algorithms(), exports);
    tslib_1.__exportStar(require_ec_parameters(), exports);
    tslib_1.__exportStar(require_ec_private_key(), exports);
    tslib_1.__exportStar(require_ec_signature_value(), exports);
    tslib_1.__exportStar(require_object_identifiers4(), exports);
  }
});

// node_modules/@peculiar/asn1-rsa/build/cjs/object_identifiers.js
var require_object_identifiers5 = __commonJS({
  "node_modules/@peculiar/asn1-rsa/build/cjs/object_identifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id_mgf1 = exports.id_md5 = exports.id_md2 = exports.id_sha512_256 = exports.id_sha512_224 = exports.id_sha512 = exports.id_sha384 = exports.id_sha256 = exports.id_sha224 = exports.id_sha1 = exports.id_sha512_256WithRSAEncryption = exports.id_sha512_224WithRSAEncryption = exports.id_sha512WithRSAEncryption = exports.id_sha384WithRSAEncryption = exports.id_sha256WithRSAEncryption = exports.id_ssha224WithRSAEncryption = exports.id_sha224WithRSAEncryption = exports.id_sha1WithRSAEncryption = exports.id_md5WithRSAEncryption = exports.id_md2WithRSAEncryption = exports.id_RSASSA_PSS = exports.id_pSpecified = exports.id_RSAES_OAEP = exports.id_rsaEncryption = exports.id_pkcs_1 = void 0;
    exports.id_pkcs_1 = "1.2.840.113549.1.1";
    exports.id_rsaEncryption = `${exports.id_pkcs_1}.1`;
    exports.id_RSAES_OAEP = `${exports.id_pkcs_1}.7`;
    exports.id_pSpecified = `${exports.id_pkcs_1}.9`;
    exports.id_RSASSA_PSS = `${exports.id_pkcs_1}.10`;
    exports.id_md2WithRSAEncryption = `${exports.id_pkcs_1}.2`;
    exports.id_md5WithRSAEncryption = `${exports.id_pkcs_1}.4`;
    exports.id_sha1WithRSAEncryption = `${exports.id_pkcs_1}.5`;
    exports.id_sha224WithRSAEncryption = `${exports.id_pkcs_1}.14`;
    exports.id_ssha224WithRSAEncryption = exports.id_sha224WithRSAEncryption;
    exports.id_sha256WithRSAEncryption = `${exports.id_pkcs_1}.11`;
    exports.id_sha384WithRSAEncryption = `${exports.id_pkcs_1}.12`;
    exports.id_sha512WithRSAEncryption = `${exports.id_pkcs_1}.13`;
    exports.id_sha512_224WithRSAEncryption = `${exports.id_pkcs_1}.15`;
    exports.id_sha512_256WithRSAEncryption = `${exports.id_pkcs_1}.16`;
    exports.id_sha1 = "1.3.14.3.2.26";
    exports.id_sha224 = "2.16.840.1.101.3.4.2.4";
    exports.id_sha256 = "2.16.840.1.101.3.4.2.1";
    exports.id_sha384 = "2.16.840.1.101.3.4.2.2";
    exports.id_sha512 = "2.16.840.1.101.3.4.2.3";
    exports.id_sha512_224 = "2.16.840.1.101.3.4.2.5";
    exports.id_sha512_256 = "2.16.840.1.101.3.4.2.6";
    exports.id_md2 = "1.2.840.113549.2.2";
    exports.id_md5 = "1.2.840.113549.2.5";
    exports.id_mgf1 = `${exports.id_pkcs_1}.8`;
  }
});

// node_modules/@peculiar/asn1-rsa/build/cjs/algorithms.js
var require_algorithms2 = __commonJS({
  "node_modules/@peculiar/asn1-rsa/build/cjs/algorithms.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512_256WithRSAEncryption = exports.sha512_224WithRSAEncryption = exports.sha512WithRSAEncryption = exports.sha384WithRSAEncryption = exports.sha256WithRSAEncryption = exports.sha224WithRSAEncryption = exports.sha1WithRSAEncryption = exports.md5WithRSAEncryption = exports.md2WithRSAEncryption = exports.rsaEncryption = exports.pSpecifiedEmpty = exports.mgf1SHA1 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.sha384 = exports.sha256 = exports.sha224 = exports.sha1 = exports.md4 = exports.md2 = void 0;
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var oid = require_object_identifiers5();
    function create(algorithm) {
      return new asn1_x509_1.AlgorithmIdentifier({ algorithm, parameters: null });
    }
    exports.md2 = create(oid.id_md2);
    exports.md4 = create(oid.id_md5);
    exports.sha1 = create(oid.id_sha1);
    exports.sha224 = create(oid.id_sha224);
    exports.sha256 = create(oid.id_sha256);
    exports.sha384 = create(oid.id_sha384);
    exports.sha512 = create(oid.id_sha512);
    exports.sha512_224 = create(oid.id_sha512_224);
    exports.sha512_256 = create(oid.id_sha512_256);
    exports.mgf1SHA1 = new asn1_x509_1.AlgorithmIdentifier({
      algorithm: oid.id_mgf1,
      parameters: asn1_schema_1.AsnConvert.serialize(exports.sha1)
    });
    exports.pSpecifiedEmpty = new asn1_x509_1.AlgorithmIdentifier({
      algorithm: oid.id_pSpecified,
      parameters: asn1_schema_1.AsnConvert.serialize(asn1_schema_1.AsnOctetStringConverter.toASN(new Uint8Array([218, 57, 163, 238, 94, 107, 75, 13, 50, 85, 191, 239, 149, 96, 24, 144, 175, 216, 7, 9]).buffer))
    });
    exports.rsaEncryption = create(oid.id_rsaEncryption);
    exports.md2WithRSAEncryption = create(oid.id_md2WithRSAEncryption);
    exports.md5WithRSAEncryption = create(oid.id_md5WithRSAEncryption);
    exports.sha1WithRSAEncryption = create(oid.id_sha1WithRSAEncryption);
    exports.sha224WithRSAEncryption = create(oid.id_sha512_224WithRSAEncryption);
    exports.sha256WithRSAEncryption = create(oid.id_sha512_256WithRSAEncryption);
    exports.sha384WithRSAEncryption = create(oid.id_sha384WithRSAEncryption);
    exports.sha512WithRSAEncryption = create(oid.id_sha512WithRSAEncryption);
    exports.sha512_224WithRSAEncryption = create(oid.id_sha512_224WithRSAEncryption);
    exports.sha512_256WithRSAEncryption = create(oid.id_sha512_256WithRSAEncryption);
  }
});

// node_modules/@peculiar/asn1-rsa/build/cjs/parameters/rsaes_oaep.js
var require_rsaes_oaep = __commonJS({
  "node_modules/@peculiar/asn1-rsa/build/cjs/parameters/rsaes_oaep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RSAES_OAEP = exports.RsaEsOaepParams = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var object_identifiers_1 = require_object_identifiers5();
    var algorithms_1 = require_algorithms2();
    var RsaEsOaepParams = class {
      constructor(params = {}) {
        this.hashAlgorithm = new asn1_x509_1.AlgorithmIdentifier(algorithms_1.sha1);
        this.maskGenAlgorithm = new asn1_x509_1.AlgorithmIdentifier({
          algorithm: object_identifiers_1.id_mgf1,
          parameters: asn1_schema_1.AsnConvert.serialize(algorithms_1.sha1)
        });
        this.pSourceAlgorithm = new asn1_x509_1.AlgorithmIdentifier(algorithms_1.pSpecifiedEmpty);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier, context: 0, defaultValue: algorithms_1.sha1 })
    ], RsaEsOaepParams.prototype, "hashAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier, context: 1, defaultValue: algorithms_1.mgf1SHA1 })
    ], RsaEsOaepParams.prototype, "maskGenAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier, context: 2, defaultValue: algorithms_1.pSpecifiedEmpty })
    ], RsaEsOaepParams.prototype, "pSourceAlgorithm", void 0);
    exports.RsaEsOaepParams = RsaEsOaepParams;
    exports.RSAES_OAEP = new asn1_x509_1.AlgorithmIdentifier({
      algorithm: object_identifiers_1.id_RSAES_OAEP,
      parameters: asn1_schema_1.AsnConvert.serialize(new RsaEsOaepParams())
    });
  }
});

// node_modules/@peculiar/asn1-rsa/build/cjs/parameters/rsassa_pss.js
var require_rsassa_pss = __commonJS({
  "node_modules/@peculiar/asn1-rsa/build/cjs/parameters/rsassa_pss.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RSASSA_PSS = exports.RsaSaPssParams = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var object_identifiers_1 = require_object_identifiers5();
    var algorithms_1 = require_algorithms2();
    var RsaSaPssParams = class {
      constructor(params = {}) {
        this.hashAlgorithm = new asn1_x509_1.AlgorithmIdentifier(algorithms_1.sha1);
        this.maskGenAlgorithm = new asn1_x509_1.AlgorithmIdentifier({
          algorithm: object_identifiers_1.id_mgf1,
          parameters: asn1_schema_1.AsnConvert.serialize(algorithms_1.sha1)
        });
        this.saltLength = 20;
        this.trailerField = 1;
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier, context: 0, defaultValue: algorithms_1.sha1 })
    ], RsaSaPssParams.prototype, "hashAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier, context: 1, defaultValue: algorithms_1.mgf1SHA1 })
    ], RsaSaPssParams.prototype, "maskGenAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, context: 2, defaultValue: 20 })
    ], RsaSaPssParams.prototype, "saltLength", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, context: 3, defaultValue: 1 })
    ], RsaSaPssParams.prototype, "trailerField", void 0);
    exports.RsaSaPssParams = RsaSaPssParams;
    exports.RSASSA_PSS = new asn1_x509_1.AlgorithmIdentifier({
      algorithm: object_identifiers_1.id_RSASSA_PSS,
      parameters: asn1_schema_1.AsnConvert.serialize(new RsaSaPssParams())
    });
  }
});

// node_modules/@peculiar/asn1-rsa/build/cjs/parameters/rsassa_pkcs1_v1_5.js
var require_rsassa_pkcs1_v1_5 = __commonJS({
  "node_modules/@peculiar/asn1-rsa/build/cjs/parameters/rsassa_pkcs1_v1_5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DigestInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_x509_1 = require_cjs2();
    var asn1_schema_1 = require_cjs();
    var DigestInfo = class {
      constructor(params = {}) {
        this.digestAlgorithm = new asn1_x509_1.AlgorithmIdentifier();
        this.digest = new asn1_schema_1.OctetString();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier })
    ], DigestInfo.prototype, "digestAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], DigestInfo.prototype, "digest", void 0);
    exports.DigestInfo = DigestInfo;
  }
});

// node_modules/@peculiar/asn1-rsa/build/cjs/parameters/index.js
var require_parameters = __commonJS({
  "node_modules/@peculiar/asn1-rsa/build/cjs/parameters/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_rsaes_oaep(), exports);
    tslib_1.__exportStar(require_rsassa_pss(), exports);
    tslib_1.__exportStar(require_rsassa_pkcs1_v1_5(), exports);
  }
});

// node_modules/@peculiar/asn1-rsa/build/cjs/other_prime_info.js
var require_other_prime_info = __commonJS({
  "node_modules/@peculiar/asn1-rsa/build/cjs/other_prime_info.js"(exports) {
    "use strict";
    var OtherPrimeInfos_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OtherPrimeInfos = exports.OtherPrimeInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var OtherPrimeInfo = class {
      constructor(params = {}) {
        this.prime = new ArrayBuffer(0);
        this.exponent = new ArrayBuffer(0);
        this.coefficient = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], OtherPrimeInfo.prototype, "prime", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], OtherPrimeInfo.prototype, "exponent", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], OtherPrimeInfo.prototype, "coefficient", void 0);
    exports.OtherPrimeInfo = OtherPrimeInfo;
    var OtherPrimeInfos = OtherPrimeInfos_1 = class OtherPrimeInfos extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, OtherPrimeInfos_1.prototype);
      }
    };
    OtherPrimeInfos = OtherPrimeInfos_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: OtherPrimeInfo })
    ], OtherPrimeInfos);
    exports.OtherPrimeInfos = OtherPrimeInfos;
  }
});

// node_modules/@peculiar/asn1-rsa/build/cjs/rsa_private_key.js
var require_rsa_private_key = __commonJS({
  "node_modules/@peculiar/asn1-rsa/build/cjs/rsa_private_key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RSAPrivateKey = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var other_prime_info_1 = require_other_prime_info();
    var RSAPrivateKey = class {
      constructor(params = {}) {
        this.version = 0;
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
        this.privateExponent = new ArrayBuffer(0);
        this.prime1 = new ArrayBuffer(0);
        this.prime2 = new ArrayBuffer(0);
        this.exponent1 = new ArrayBuffer(0);
        this.exponent2 = new ArrayBuffer(0);
        this.coefficient = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], RSAPrivateKey.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "modulus", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "publicExponent", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "privateExponent", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "prime1", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "prime2", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "exponent1", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "exponent2", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], RSAPrivateKey.prototype, "coefficient", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: other_prime_info_1.OtherPrimeInfos, optional: true })
    ], RSAPrivateKey.prototype, "otherPrimeInfos", void 0);
    exports.RSAPrivateKey = RSAPrivateKey;
  }
});

// node_modules/@peculiar/asn1-rsa/build/cjs/rsa_public_key.js
var require_rsa_public_key = __commonJS({
  "node_modules/@peculiar/asn1-rsa/build/cjs/rsa_public_key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RSAPublicKey = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var RSAPublicKey = class {
      constructor(params = {}) {
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], RSAPublicKey.prototype, "modulus", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, converter: asn1_schema_1.AsnIntegerArrayBufferConverter })
    ], RSAPublicKey.prototype, "publicExponent", void 0);
    exports.RSAPublicKey = RSAPublicKey;
  }
});

// node_modules/@peculiar/asn1-rsa/build/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@peculiar/asn1-rsa/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_parameters(), exports);
    tslib_1.__exportStar(require_algorithms2(), exports);
    tslib_1.__exportStar(require_object_identifiers5(), exports);
    tslib_1.__exportStar(require_other_prime_info(), exports);
    tslib_1.__exportStar(require_rsa_private_key(), exports);
    tslib_1.__exportStar(require_rsa_public_key(), exports);
  }
});

// node_modules/tsyringe/node_modules/tslib/tslib.es6.js
var tslib_es6_exports2 = {};
__export(tslib_es6_exports2, {
  __assign: () => __assign2,
  __asyncDelegator: () => __asyncDelegator2,
  __asyncGenerator: () => __asyncGenerator2,
  __asyncValues: () => __asyncValues2,
  __await: () => __await2,
  __awaiter: () => __awaiter2,
  __classPrivateFieldGet: () => __classPrivateFieldGet2,
  __classPrivateFieldSet: () => __classPrivateFieldSet2,
  __createBinding: () => __createBinding2,
  __decorate: () => __decorate2,
  __exportStar: () => __exportStar2,
  __extends: () => __extends2,
  __generator: () => __generator2,
  __importDefault: () => __importDefault2,
  __importStar: () => __importStar2,
  __makeTemplateObject: () => __makeTemplateObject2,
  __metadata: () => __metadata2,
  __param: () => __param2,
  __read: () => __read2,
  __rest: () => __rest2,
  __spread: () => __spread2,
  __spreadArrays: () => __spreadArrays2,
  __values: () => __values2
});
function __extends2(d, b) {
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest2(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate2(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
}
function __param2(paramIndex, decorator) {
  return function(target2, key) {
    decorator(target2, key, paramIndex);
  };
}
function __metadata2(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator2(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding2(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
}
function __exportStar2(m, exports) {
  for (var p in m)
    if (p !== "default" && !exports.hasOwnProperty(p))
      exports[p] = m[p];
}
function __values2(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read2(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread2() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read2(arguments[i]));
  return ar;
}
function __spreadArrays2() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __await2(v) {
  return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
}
function __asyncGenerator2(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator2(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues2(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject2(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar2(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (Object.hasOwnProperty.call(mod, k))
        result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault2(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet2(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet2(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics2, __assign2;
var init_tslib_es62 = __esm({
  "node_modules/tsyringe/node_modules/tslib/tslib.es6.js"() {
    extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    __assign2 = function() {
      __assign2 = Object.assign || function __assign3(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
  }
});

// node_modules/tsyringe/dist/cjs/types/lifecycle.js
var require_lifecycle = __commonJS({
  "node_modules/tsyringe/dist/cjs/types/lifecycle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Lifecycle;
    (function(Lifecycle2) {
      Lifecycle2[Lifecycle2["Transient"] = 0] = "Transient";
      Lifecycle2[Lifecycle2["Singleton"] = 1] = "Singleton";
      Lifecycle2[Lifecycle2["ResolutionScoped"] = 2] = "ResolutionScoped";
      Lifecycle2[Lifecycle2["ContainerScoped"] = 3] = "ContainerScoped";
    })(Lifecycle || (Lifecycle = {}));
    exports.default = Lifecycle;
  }
});

// node_modules/tsyringe/dist/cjs/types/index.js
var require_types4 = __commonJS({
  "node_modules/tsyringe/dist/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lifecycle_1 = require_lifecycle();
    Object.defineProperty(exports, "Lifecycle", { enumerable: true, get: function() {
      return lifecycle_1.default;
    } });
  }
});

// node_modules/tsyringe/dist/cjs/reflection-helpers.js
var require_reflection_helpers = __commonJS({
  "node_modules/tsyringe/dist/cjs/reflection-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineInjectionTokenMetadata = exports.getParamInfo = exports.INJECTION_TOKEN_METADATA_KEY = void 0;
    exports.INJECTION_TOKEN_METADATA_KEY = "injectionTokens";
    function getParamInfo(target2) {
      const params = Reflect.getMetadata("design:paramtypes", target2) || [];
      const injectionTokens = Reflect.getOwnMetadata(exports.INJECTION_TOKEN_METADATA_KEY, target2) || {};
      Object.keys(injectionTokens).forEach((key) => {
        params[+key] = injectionTokens[key];
      });
      return params;
    }
    exports.getParamInfo = getParamInfo;
    function defineInjectionTokenMetadata(data, transform) {
      return function(target2, _propertyKey, parameterIndex) {
        const descriptors = Reflect.getOwnMetadata(exports.INJECTION_TOKEN_METADATA_KEY, target2) || {};
        descriptors[parameterIndex] = transform ? {
          token: data,
          transform: transform.transformToken,
          transformArgs: transform.args || []
        } : data;
        Reflect.defineMetadata(exports.INJECTION_TOKEN_METADATA_KEY, descriptors, target2);
      };
    }
    exports.defineInjectionTokenMetadata = defineInjectionTokenMetadata;
  }
});

// node_modules/tsyringe/dist/cjs/providers/class-provider.js
var require_class_provider = __commonJS({
  "node_modules/tsyringe/dist/cjs/providers/class-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isClassProvider = void 0;
    function isClassProvider(provider) {
      return !!provider.useClass;
    }
    exports.isClassProvider = isClassProvider;
  }
});

// node_modules/tsyringe/dist/cjs/providers/factory-provider.js
var require_factory_provider = __commonJS({
  "node_modules/tsyringe/dist/cjs/providers/factory-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isFactoryProvider = void 0;
    function isFactoryProvider(provider) {
      return !!provider.useFactory;
    }
    exports.isFactoryProvider = isFactoryProvider;
  }
});

// node_modules/tsyringe/dist/cjs/lazy-helpers.js
var require_lazy_helpers = __commonJS({
  "node_modules/tsyringe/dist/cjs/lazy-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = exports.DelayedConstructor = void 0;
    var DelayedConstructor = class {
      constructor(wrap3) {
        this.wrap = wrap3;
        this.reflectMethods = [
          "get",
          "getPrototypeOf",
          "setPrototypeOf",
          "getOwnPropertyDescriptor",
          "defineProperty",
          "has",
          "set",
          "deleteProperty",
          "apply",
          "construct",
          "ownKeys"
        ];
      }
      createProxy(createObject) {
        const target2 = {};
        let init = false;
        let value;
        const delayedObject = () => {
          if (!init) {
            value = createObject(this.wrap());
            init = true;
          }
          return value;
        };
        return new Proxy(target2, this.createHandler(delayedObject));
      }
      createHandler(delayedObject) {
        const handler = {};
        const install = (name) => {
          handler[name] = (...args) => {
            args[0] = delayedObject();
            const method = Reflect[name];
            return method(...args);
          };
        };
        this.reflectMethods.forEach(install);
        return handler;
      }
    };
    exports.DelayedConstructor = DelayedConstructor;
    function delay(wrappedConstructor) {
      if (typeof wrappedConstructor === "undefined") {
        throw new Error("Attempt to `delay` undefined. Constructor must be wrapped in a callback");
      }
      return new DelayedConstructor(wrappedConstructor);
    }
    exports.delay = delay;
  }
});

// node_modules/tsyringe/dist/cjs/providers/injection-token.js
var require_injection_token = __commonJS({
  "node_modules/tsyringe/dist/cjs/providers/injection-token.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isConstructorToken = exports.isTransformDescriptor = exports.isTokenDescriptor = exports.isNormalToken = void 0;
    var lazy_helpers_1 = require_lazy_helpers();
    function isNormalToken(token) {
      return typeof token === "string" || typeof token === "symbol";
    }
    exports.isNormalToken = isNormalToken;
    function isTokenDescriptor(descriptor) {
      return typeof descriptor === "object" && "token" in descriptor && "multiple" in descriptor;
    }
    exports.isTokenDescriptor = isTokenDescriptor;
    function isTransformDescriptor(descriptor) {
      return typeof descriptor === "object" && "token" in descriptor && "transform" in descriptor;
    }
    exports.isTransformDescriptor = isTransformDescriptor;
    function isConstructorToken(token) {
      return typeof token === "function" || token instanceof lazy_helpers_1.DelayedConstructor;
    }
    exports.isConstructorToken = isConstructorToken;
  }
});

// node_modules/tsyringe/dist/cjs/providers/token-provider.js
var require_token_provider = __commonJS({
  "node_modules/tsyringe/dist/cjs/providers/token-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTokenProvider = void 0;
    function isTokenProvider(provider) {
      return !!provider.useToken;
    }
    exports.isTokenProvider = isTokenProvider;
  }
});

// node_modules/tsyringe/dist/cjs/providers/value-provider.js
var require_value_provider = __commonJS({
  "node_modules/tsyringe/dist/cjs/providers/value-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValueProvider = void 0;
    function isValueProvider(provider) {
      return provider.useValue != void 0;
    }
    exports.isValueProvider = isValueProvider;
  }
});

// node_modules/tsyringe/dist/cjs/providers/index.js
var require_providers = __commonJS({
  "node_modules/tsyringe/dist/cjs/providers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var class_provider_1 = require_class_provider();
    Object.defineProperty(exports, "isClassProvider", { enumerable: true, get: function() {
      return class_provider_1.isClassProvider;
    } });
    var factory_provider_1 = require_factory_provider();
    Object.defineProperty(exports, "isFactoryProvider", { enumerable: true, get: function() {
      return factory_provider_1.isFactoryProvider;
    } });
    var injection_token_1 = require_injection_token();
    Object.defineProperty(exports, "isNormalToken", { enumerable: true, get: function() {
      return injection_token_1.isNormalToken;
    } });
    var token_provider_1 = require_token_provider();
    Object.defineProperty(exports, "isTokenProvider", { enumerable: true, get: function() {
      return token_provider_1.isTokenProvider;
    } });
    var value_provider_1 = require_value_provider();
    Object.defineProperty(exports, "isValueProvider", { enumerable: true, get: function() {
      return value_provider_1.isValueProvider;
    } });
  }
});

// node_modules/tsyringe/dist/cjs/providers/provider.js
var require_provider = __commonJS({
  "node_modules/tsyringe/dist/cjs/providers/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isProvider = void 0;
    var class_provider_1 = require_class_provider();
    var value_provider_1 = require_value_provider();
    var token_provider_1 = require_token_provider();
    var factory_provider_1 = require_factory_provider();
    function isProvider(provider) {
      return class_provider_1.isClassProvider(provider) || value_provider_1.isValueProvider(provider) || token_provider_1.isTokenProvider(provider) || factory_provider_1.isFactoryProvider(provider);
    }
    exports.isProvider = isProvider;
  }
});

// node_modules/tsyringe/dist/cjs/registry-base.js
var require_registry_base = __commonJS({
  "node_modules/tsyringe/dist/cjs/registry-base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RegistryBase = class {
      constructor() {
        this._registryMap = /* @__PURE__ */ new Map();
      }
      entries() {
        return this._registryMap.entries();
      }
      getAll(key) {
        this.ensure(key);
        return this._registryMap.get(key);
      }
      get(key) {
        this.ensure(key);
        const value = this._registryMap.get(key);
        return value[value.length - 1] || null;
      }
      set(key, value) {
        this.ensure(key);
        this._registryMap.get(key).push(value);
      }
      setAll(key, value) {
        this._registryMap.set(key, value);
      }
      has(key) {
        this.ensure(key);
        return this._registryMap.get(key).length > 0;
      }
      clear() {
        this._registryMap.clear();
      }
      ensure(key) {
        if (!this._registryMap.has(key)) {
          this._registryMap.set(key, []);
        }
      }
    };
    exports.default = RegistryBase;
  }
});

// node_modules/tsyringe/dist/cjs/registry.js
var require_registry = __commonJS({
  "node_modules/tsyringe/dist/cjs/registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var registry_base_1 = require_registry_base();
    var Registry = class extends registry_base_1.default {
    };
    exports.default = Registry;
  }
});

// node_modules/tsyringe/dist/cjs/resolution-context.js
var require_resolution_context = __commonJS({
  "node_modules/tsyringe/dist/cjs/resolution-context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ResolutionContext = class {
      constructor() {
        this.scopedResolutions = /* @__PURE__ */ new Map();
      }
    };
    exports.default = ResolutionContext;
  }
});

// node_modules/tsyringe/dist/cjs/error-helpers.js
var require_error_helpers = __commonJS({
  "node_modules/tsyringe/dist/cjs/error-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatErrorCtor = void 0;
    function formatDependency(params, idx) {
      if (params === null) {
        return `at position #${idx}`;
      }
      const argName = params.split(",")[idx].trim();
      return `"${argName}" at position #${idx}`;
    }
    function composeErrorMessage(msg, e, indent = "    ") {
      return [msg, ...e.message.split("\n").map((l) => indent + l)].join("\n");
    }
    function formatErrorCtor(ctor, paramIdx, error) {
      const [, params = null] = ctor.toString().match(/constructor\(([\w, ]+)\)/) || [];
      const dep = formatDependency(params, paramIdx);
      return composeErrorMessage(`Cannot inject the dependency ${dep} of "${ctor.name}" constructor. Reason:`, error);
    }
    exports.formatErrorCtor = formatErrorCtor;
  }
});

// node_modules/tsyringe/dist/cjs/types/disposable.js
var require_disposable = __commonJS({
  "node_modules/tsyringe/dist/cjs/types/disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDisposable = void 0;
    function isDisposable(value) {
      if (typeof value.dispose !== "function")
        return false;
      const disposeFun = value.dispose;
      if (disposeFun.length > 0) {
        return false;
      }
      return true;
    }
    exports.isDisposable = isDisposable;
  }
});

// node_modules/tsyringe/dist/cjs/interceptors.js
var require_interceptors = __commonJS({
  "node_modules/tsyringe/dist/cjs/interceptors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PostResolutionInterceptors = exports.PreResolutionInterceptors = void 0;
    var registry_base_1 = require_registry_base();
    var PreResolutionInterceptors = class extends registry_base_1.default {
    };
    exports.PreResolutionInterceptors = PreResolutionInterceptors;
    var PostResolutionInterceptors = class extends registry_base_1.default {
    };
    exports.PostResolutionInterceptors = PostResolutionInterceptors;
    var Interceptors = class {
      constructor() {
        this.preResolution = new PreResolutionInterceptors();
        this.postResolution = new PostResolutionInterceptors();
      }
    };
    exports.default = Interceptors;
  }
});

// node_modules/tsyringe/dist/cjs/dependency-container.js
var require_dependency_container = __commonJS({
  "node_modules/tsyringe/dist/cjs/dependency-container.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.instance = exports.typeInfo = void 0;
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    var providers_1 = require_providers();
    var provider_1 = require_provider();
    var injection_token_1 = require_injection_token();
    var registry_1 = require_registry();
    var lifecycle_1 = require_lifecycle();
    var resolution_context_1 = require_resolution_context();
    var error_helpers_1 = require_error_helpers();
    var lazy_helpers_1 = require_lazy_helpers();
    var disposable_1 = require_disposable();
    var interceptors_1 = require_interceptors();
    exports.typeInfo = /* @__PURE__ */ new Map();
    var InternalDependencyContainer = class _InternalDependencyContainer {
      constructor(parent) {
        this.parent = parent;
        this._registry = new registry_1.default();
        this.interceptors = new interceptors_1.default();
        this.disposed = false;
        this.disposables = /* @__PURE__ */ new Set();
      }
      register(token, providerOrConstructor, options = { lifecycle: lifecycle_1.default.Transient }) {
        this.ensureNotDisposed();
        let provider;
        if (!provider_1.isProvider(providerOrConstructor)) {
          provider = { useClass: providerOrConstructor };
        } else {
          provider = providerOrConstructor;
        }
        if (providers_1.isTokenProvider(provider)) {
          const path = [token];
          let tokenProvider = provider;
          while (tokenProvider != null) {
            const currentToken = tokenProvider.useToken;
            if (path.includes(currentToken)) {
              throw new Error(`Token registration cycle detected! ${[...path, currentToken].join(" -> ")}`);
            }
            path.push(currentToken);
            const registration = this._registry.get(currentToken);
            if (registration && providers_1.isTokenProvider(registration.provider)) {
              tokenProvider = registration.provider;
            } else {
              tokenProvider = null;
            }
          }
        }
        if (options.lifecycle === lifecycle_1.default.Singleton || options.lifecycle == lifecycle_1.default.ContainerScoped || options.lifecycle == lifecycle_1.default.ResolutionScoped) {
          if (providers_1.isValueProvider(provider) || providers_1.isFactoryProvider(provider)) {
            throw new Error(`Cannot use lifecycle "${lifecycle_1.default[options.lifecycle]}" with ValueProviders or FactoryProviders`);
          }
        }
        this._registry.set(token, { provider, options });
        return this;
      }
      registerType(from, to) {
        this.ensureNotDisposed();
        if (providers_1.isNormalToken(to)) {
          return this.register(from, {
            useToken: to
          });
        }
        return this.register(from, {
          useClass: to
        });
      }
      registerInstance(token, instance) {
        this.ensureNotDisposed();
        return this.register(token, {
          useValue: instance
        });
      }
      registerSingleton(from, to) {
        this.ensureNotDisposed();
        if (providers_1.isNormalToken(from)) {
          if (providers_1.isNormalToken(to)) {
            return this.register(from, {
              useToken: to
            }, { lifecycle: lifecycle_1.default.Singleton });
          } else if (to) {
            return this.register(from, {
              useClass: to
            }, { lifecycle: lifecycle_1.default.Singleton });
          }
          throw new Error('Cannot register a type name as a singleton without a "to" token');
        }
        let useClass = from;
        if (to && !providers_1.isNormalToken(to)) {
          useClass = to;
        }
        return this.register(from, {
          useClass
        }, { lifecycle: lifecycle_1.default.Singleton });
      }
      resolve(token, context = new resolution_context_1.default()) {
        this.ensureNotDisposed();
        const registration = this.getRegistration(token);
        if (!registration && providers_1.isNormalToken(token)) {
          throw new Error(`Attempted to resolve unregistered dependency token: "${token.toString()}"`);
        }
        this.executePreResolutionInterceptor(token, "Single");
        if (registration) {
          const result = this.resolveRegistration(registration, context);
          this.executePostResolutionInterceptor(token, result, "Single");
          return result;
        }
        if (injection_token_1.isConstructorToken(token)) {
          const result = this.construct(token, context);
          this.executePostResolutionInterceptor(token, result, "Single");
          return result;
        }
        throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.");
      }
      executePreResolutionInterceptor(token, resolutionType) {
        if (this.interceptors.preResolution.has(token)) {
          const remainingInterceptors = [];
          for (const interceptor of this.interceptors.preResolution.getAll(token)) {
            if (interceptor.options.frequency != "Once") {
              remainingInterceptors.push(interceptor);
            }
            interceptor.callback(token, resolutionType);
          }
          this.interceptors.preResolution.setAll(token, remainingInterceptors);
        }
      }
      executePostResolutionInterceptor(token, result, resolutionType) {
        if (this.interceptors.postResolution.has(token)) {
          const remainingInterceptors = [];
          for (const interceptor of this.interceptors.postResolution.getAll(token)) {
            if (interceptor.options.frequency != "Once") {
              remainingInterceptors.push(interceptor);
            }
            interceptor.callback(token, result, resolutionType);
          }
          this.interceptors.postResolution.setAll(token, remainingInterceptors);
        }
      }
      resolveRegistration(registration, context) {
        this.ensureNotDisposed();
        if (registration.options.lifecycle === lifecycle_1.default.ResolutionScoped && context.scopedResolutions.has(registration)) {
          return context.scopedResolutions.get(registration);
        }
        const isSingleton = registration.options.lifecycle === lifecycle_1.default.Singleton;
        const isContainerScoped = registration.options.lifecycle === lifecycle_1.default.ContainerScoped;
        const returnInstance = isSingleton || isContainerScoped;
        let resolved;
        if (providers_1.isValueProvider(registration.provider)) {
          resolved = registration.provider.useValue;
        } else if (providers_1.isTokenProvider(registration.provider)) {
          resolved = returnInstance ? registration.instance || (registration.instance = this.resolve(registration.provider.useToken, context)) : this.resolve(registration.provider.useToken, context);
        } else if (providers_1.isClassProvider(registration.provider)) {
          resolved = returnInstance ? registration.instance || (registration.instance = this.construct(registration.provider.useClass, context)) : this.construct(registration.provider.useClass, context);
        } else if (providers_1.isFactoryProvider(registration.provider)) {
          resolved = registration.provider.useFactory(this);
        } else {
          resolved = this.construct(registration.provider, context);
        }
        if (registration.options.lifecycle === lifecycle_1.default.ResolutionScoped) {
          context.scopedResolutions.set(registration, resolved);
        }
        return resolved;
      }
      resolveAll(token, context = new resolution_context_1.default()) {
        this.ensureNotDisposed();
        const registrations = this.getAllRegistrations(token);
        if (!registrations && providers_1.isNormalToken(token)) {
          throw new Error(`Attempted to resolve unregistered dependency token: "${token.toString()}"`);
        }
        this.executePreResolutionInterceptor(token, "All");
        if (registrations) {
          const result2 = registrations.map((item) => this.resolveRegistration(item, context));
          this.executePostResolutionInterceptor(token, result2, "All");
          return result2;
        }
        const result = [this.construct(token, context)];
        this.executePostResolutionInterceptor(token, result, "All");
        return result;
      }
      isRegistered(token, recursive = false) {
        this.ensureNotDisposed();
        return this._registry.has(token) || recursive && (this.parent || false) && this.parent.isRegistered(token, true);
      }
      reset() {
        this.ensureNotDisposed();
        this._registry.clear();
        this.interceptors.preResolution.clear();
        this.interceptors.postResolution.clear();
      }
      clearInstances() {
        this.ensureNotDisposed();
        for (const [token, registrations] of this._registry.entries()) {
          this._registry.setAll(token, registrations.filter((registration) => !providers_1.isValueProvider(registration.provider)).map((registration) => {
            registration.instance = void 0;
            return registration;
          }));
        }
      }
      createChildContainer() {
        this.ensureNotDisposed();
        const childContainer = new _InternalDependencyContainer(this);
        for (const [token, registrations] of this._registry.entries()) {
          if (registrations.some(({ options }) => options.lifecycle === lifecycle_1.default.ContainerScoped)) {
            childContainer._registry.setAll(token, registrations.map((registration) => {
              if (registration.options.lifecycle === lifecycle_1.default.ContainerScoped) {
                return {
                  provider: registration.provider,
                  options: registration.options
                };
              }
              return registration;
            }));
          }
        }
        return childContainer;
      }
      beforeResolution(token, callback, options = { frequency: "Always" }) {
        this.interceptors.preResolution.set(token, {
          callback,
          options
        });
      }
      afterResolution(token, callback, options = { frequency: "Always" }) {
        this.interceptors.postResolution.set(token, {
          callback,
          options
        });
      }
      dispose() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this.disposed = true;
          const promises = [];
          this.disposables.forEach((disposable) => {
            const maybePromise = disposable.dispose();
            if (maybePromise) {
              promises.push(maybePromise);
            }
          });
          yield Promise.all(promises);
        });
      }
      getRegistration(token) {
        if (this.isRegistered(token)) {
          return this._registry.get(token);
        }
        if (this.parent) {
          return this.parent.getRegistration(token);
        }
        return null;
      }
      getAllRegistrations(token) {
        if (this.isRegistered(token)) {
          return this._registry.getAll(token);
        }
        if (this.parent) {
          return this.parent.getAllRegistrations(token);
        }
        return null;
      }
      construct(ctor, context) {
        if (ctor instanceof lazy_helpers_1.DelayedConstructor) {
          return ctor.createProxy((target2) => this.resolve(target2, context));
        }
        const instance = (() => {
          const paramInfo = exports.typeInfo.get(ctor);
          if (!paramInfo || paramInfo.length === 0) {
            if (ctor.length === 0) {
              return new ctor();
            } else {
              throw new Error(`TypeInfo not known for "${ctor.name}"`);
            }
          }
          const params = paramInfo.map(this.resolveParams(context, ctor));
          return new ctor(...params);
        })();
        if (disposable_1.isDisposable(instance)) {
          this.disposables.add(instance);
        }
        return instance;
      }
      resolveParams(context, ctor) {
        return (param, idx) => {
          try {
            if (injection_token_1.isTokenDescriptor(param)) {
              if (injection_token_1.isTransformDescriptor(param)) {
                return param.multiple ? this.resolve(param.transform).transform(this.resolveAll(param.token), ...param.transformArgs) : this.resolve(param.transform).transform(this.resolve(param.token, context), ...param.transformArgs);
              } else {
                return param.multiple ? this.resolveAll(param.token) : this.resolve(param.token, context);
              }
            } else if (injection_token_1.isTransformDescriptor(param)) {
              return this.resolve(param.transform, context).transform(this.resolve(param.token, context), ...param.transformArgs);
            }
            return this.resolve(param, context);
          } catch (e) {
            throw new Error(error_helpers_1.formatErrorCtor(ctor, idx, e));
          }
        };
      }
      ensureNotDisposed() {
        if (this.disposed) {
          throw new Error("This container has been disposed, you cannot interact with a disposed container");
        }
      }
    };
    exports.instance = new InternalDependencyContainer();
    exports.default = exports.instance;
  }
});

// node_modules/tsyringe/dist/cjs/decorators/auto-injectable.js
var require_auto_injectable = __commonJS({
  "node_modules/tsyringe/dist/cjs/decorators/auto-injectable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var reflection_helpers_1 = require_reflection_helpers();
    var dependency_container_1 = require_dependency_container();
    var injection_token_1 = require_injection_token();
    var error_helpers_1 = require_error_helpers();
    function autoInjectable() {
      return function(target2) {
        const paramInfo = reflection_helpers_1.getParamInfo(target2);
        return class extends target2 {
          constructor(...args) {
            super(...args.concat(paramInfo.slice(args.length).map((type, index) => {
              try {
                if (injection_token_1.isTokenDescriptor(type)) {
                  if (injection_token_1.isTransformDescriptor(type)) {
                    return type.multiple ? dependency_container_1.instance.resolve(type.transform).transform(dependency_container_1.instance.resolveAll(type.token), ...type.transformArgs) : dependency_container_1.instance.resolve(type.transform).transform(dependency_container_1.instance.resolve(type.token), ...type.transformArgs);
                  } else {
                    return type.multiple ? dependency_container_1.instance.resolveAll(type.token) : dependency_container_1.instance.resolve(type.token);
                  }
                } else if (injection_token_1.isTransformDescriptor(type)) {
                  return dependency_container_1.instance.resolve(type.transform).transform(dependency_container_1.instance.resolve(type.token), ...type.transformArgs);
                }
                return dependency_container_1.instance.resolve(type);
              } catch (e) {
                const argIndex = index + args.length;
                throw new Error(error_helpers_1.formatErrorCtor(target2, argIndex, e));
              }
            })));
          }
        };
      };
    }
    exports.default = autoInjectable;
  }
});

// node_modules/tsyringe/dist/cjs/decorators/inject.js
var require_inject = __commonJS({
  "node_modules/tsyringe/dist/cjs/decorators/inject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var reflection_helpers_1 = require_reflection_helpers();
    function inject(token) {
      return reflection_helpers_1.defineInjectionTokenMetadata(token);
    }
    exports.default = inject;
  }
});

// node_modules/tsyringe/dist/cjs/decorators/injectable.js
var require_injectable = __commonJS({
  "node_modules/tsyringe/dist/cjs/decorators/injectable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var reflection_helpers_1 = require_reflection_helpers();
    var dependency_container_1 = require_dependency_container();
    function injectable() {
      return function(target2) {
        dependency_container_1.typeInfo.set(target2, reflection_helpers_1.getParamInfo(target2));
      };
    }
    exports.default = injectable;
  }
});

// node_modules/tsyringe/dist/cjs/decorators/registry.js
var require_registry2 = __commonJS({
  "node_modules/tsyringe/dist/cjs/decorators/registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    var dependency_container_1 = require_dependency_container();
    function registry(registrations = []) {
      return function(target2) {
        registrations.forEach((_a) => {
          var { token, options } = _a, provider = tslib_1.__rest(_a, ["token", "options"]);
          return dependency_container_1.instance.register(token, provider, options);
        });
        return target2;
      };
    }
    exports.default = registry;
  }
});

// node_modules/tsyringe/dist/cjs/decorators/singleton.js
var require_singleton = __commonJS({
  "node_modules/tsyringe/dist/cjs/decorators/singleton.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var injectable_1 = require_injectable();
    var dependency_container_1 = require_dependency_container();
    function singleton() {
      return function(target2) {
        injectable_1.default()(target2);
        dependency_container_1.instance.registerSingleton(target2);
      };
    }
    exports.default = singleton;
  }
});

// node_modules/tsyringe/dist/cjs/decorators/inject-all.js
var require_inject_all = __commonJS({
  "node_modules/tsyringe/dist/cjs/decorators/inject-all.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var reflection_helpers_1 = require_reflection_helpers();
    function injectAll(token) {
      const data = { token, multiple: true };
      return reflection_helpers_1.defineInjectionTokenMetadata(data);
    }
    exports.default = injectAll;
  }
});

// node_modules/tsyringe/dist/cjs/decorators/inject-all-with-transform.js
var require_inject_all_with_transform = __commonJS({
  "node_modules/tsyringe/dist/cjs/decorators/inject-all-with-transform.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var reflection_helpers_1 = require_reflection_helpers();
    function injectAllWithTransform(token, transformer, ...args) {
      const data = {
        token,
        multiple: true,
        transform: transformer,
        transformArgs: args
      };
      return reflection_helpers_1.defineInjectionTokenMetadata(data);
    }
    exports.default = injectAllWithTransform;
  }
});

// node_modules/tsyringe/dist/cjs/decorators/inject-with-transform.js
var require_inject_with_transform = __commonJS({
  "node_modules/tsyringe/dist/cjs/decorators/inject-with-transform.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var reflection_helpers_1 = require_reflection_helpers();
    function injectWithTransform(token, transformer, ...args) {
      return reflection_helpers_1.defineInjectionTokenMetadata(token, {
        transformToken: transformer,
        args
      });
    }
    exports.default = injectWithTransform;
  }
});

// node_modules/tsyringe/dist/cjs/decorators/scoped.js
var require_scoped = __commonJS({
  "node_modules/tsyringe/dist/cjs/decorators/scoped.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var injectable_1 = require_injectable();
    var dependency_container_1 = require_dependency_container();
    function scoped(lifecycle, token) {
      return function(target2) {
        injectable_1.default()(target2);
        dependency_container_1.instance.register(token || target2, target2, {
          lifecycle
        });
      };
    }
    exports.default = scoped;
  }
});

// node_modules/tsyringe/dist/cjs/decorators/index.js
var require_decorators2 = __commonJS({
  "node_modules/tsyringe/dist/cjs/decorators/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var auto_injectable_1 = require_auto_injectable();
    Object.defineProperty(exports, "autoInjectable", { enumerable: true, get: function() {
      return auto_injectable_1.default;
    } });
    var inject_1 = require_inject();
    Object.defineProperty(exports, "inject", { enumerable: true, get: function() {
      return inject_1.default;
    } });
    var injectable_1 = require_injectable();
    Object.defineProperty(exports, "injectable", { enumerable: true, get: function() {
      return injectable_1.default;
    } });
    var registry_1 = require_registry2();
    Object.defineProperty(exports, "registry", { enumerable: true, get: function() {
      return registry_1.default;
    } });
    var singleton_1 = require_singleton();
    Object.defineProperty(exports, "singleton", { enumerable: true, get: function() {
      return singleton_1.default;
    } });
    var inject_all_1 = require_inject_all();
    Object.defineProperty(exports, "injectAll", { enumerable: true, get: function() {
      return inject_all_1.default;
    } });
    var inject_all_with_transform_1 = require_inject_all_with_transform();
    Object.defineProperty(exports, "injectAllWithTransform", { enumerable: true, get: function() {
      return inject_all_with_transform_1.default;
    } });
    var inject_with_transform_1 = require_inject_with_transform();
    Object.defineProperty(exports, "injectWithTransform", { enumerable: true, get: function() {
      return inject_with_transform_1.default;
    } });
    var scoped_1 = require_scoped();
    Object.defineProperty(exports, "scoped", { enumerable: true, get: function() {
      return scoped_1.default;
    } });
  }
});

// node_modules/tsyringe/dist/cjs/factories/instance-caching-factory.js
var require_instance_caching_factory = __commonJS({
  "node_modules/tsyringe/dist/cjs/factories/instance-caching-factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function instanceCachingFactory(factoryFunc) {
      let instance;
      return (dependencyContainer) => {
        if (instance == void 0) {
          instance = factoryFunc(dependencyContainer);
        }
        return instance;
      };
    }
    exports.default = instanceCachingFactory;
  }
});

// node_modules/tsyringe/dist/cjs/factories/instance-per-container-caching-factory.js
var require_instance_per_container_caching_factory = __commonJS({
  "node_modules/tsyringe/dist/cjs/factories/instance-per-container-caching-factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function instancePerContainerCachingFactory(factoryFunc) {
      const cache = /* @__PURE__ */ new WeakMap();
      return (dependencyContainer) => {
        let instance = cache.get(dependencyContainer);
        if (instance == void 0) {
          instance = factoryFunc(dependencyContainer);
          cache.set(dependencyContainer, instance);
        }
        return instance;
      };
    }
    exports.default = instancePerContainerCachingFactory;
  }
});

// node_modules/tsyringe/dist/cjs/factories/predicate-aware-class-factory.js
var require_predicate_aware_class_factory = __commonJS({
  "node_modules/tsyringe/dist/cjs/factories/predicate-aware-class-factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function predicateAwareClassFactory(predicate, trueConstructor, falseConstructor, useCaching = true) {
      let instance;
      let previousPredicate;
      return (dependencyContainer) => {
        const currentPredicate = predicate(dependencyContainer);
        if (!useCaching || previousPredicate !== currentPredicate) {
          if (previousPredicate = currentPredicate) {
            instance = dependencyContainer.resolve(trueConstructor);
          } else {
            instance = dependencyContainer.resolve(falseConstructor);
          }
        }
        return instance;
      };
    }
    exports.default = predicateAwareClassFactory;
  }
});

// node_modules/tsyringe/dist/cjs/factories/index.js
var require_factories = __commonJS({
  "node_modules/tsyringe/dist/cjs/factories/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var instance_caching_factory_1 = require_instance_caching_factory();
    Object.defineProperty(exports, "instanceCachingFactory", { enumerable: true, get: function() {
      return instance_caching_factory_1.default;
    } });
    var instance_per_container_caching_factory_1 = require_instance_per_container_caching_factory();
    Object.defineProperty(exports, "instancePerContainerCachingFactory", { enumerable: true, get: function() {
      return instance_per_container_caching_factory_1.default;
    } });
    var predicate_aware_class_factory_1 = require_predicate_aware_class_factory();
    Object.defineProperty(exports, "predicateAwareClassFactory", { enumerable: true, get: function() {
      return predicate_aware_class_factory_1.default;
    } });
  }
});

// node_modules/tsyringe/dist/cjs/index.js
var require_cjs7 = __commonJS({
  "node_modules/tsyringe/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    if (typeof Reflect === "undefined" || !Reflect.getMetadata) {
      throw new Error(`tsyringe requires a reflect polyfill. Please add 'import "reflect-metadata"' to the top of your entry point.`);
    }
    var types_1 = require_types4();
    Object.defineProperty(exports, "Lifecycle", { enumerable: true, get: function() {
      return types_1.Lifecycle;
    } });
    tslib_1.__exportStar(require_decorators2(), exports);
    tslib_1.__exportStar(require_factories(), exports);
    tslib_1.__exportStar(require_providers(), exports);
    var lazy_helpers_1 = require_lazy_helpers();
    Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
      return lazy_helpers_1.delay;
    } });
    var dependency_container_1 = require_dependency_container();
    Object.defineProperty(exports, "container", { enumerable: true, get: function() {
      return dependency_container_1.instance;
    } });
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/attribute.js
var require_attribute3 = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/attribute.js"(exports) {
    "use strict";
    var PKCS12AttrSet_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PKCS12AttrSet = exports.PKCS12Attribute = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var PKCS12Attribute = class {
      constructor(params = {}) {
        this.attrId = "";
        this.attrValues = [];
        Object.assign(params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], PKCS12Attribute.prototype, "attrId", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, repeated: "set" })
    ], PKCS12Attribute.prototype, "attrValues", void 0);
    exports.PKCS12Attribute = PKCS12Attribute;
    var PKCS12AttrSet = PKCS12AttrSet_1 = class PKCS12AttrSet extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, PKCS12AttrSet_1.prototype);
      }
    };
    PKCS12AttrSet = PKCS12AttrSet_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: PKCS12Attribute })
    ], PKCS12AttrSet);
    exports.PKCS12AttrSet = PKCS12AttrSet;
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/authenticated_safe.js
var require_authenticated_safe = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/authenticated_safe.js"(exports) {
    "use strict";
    var AuthenticatedSafe_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthenticatedSafe = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_cms_1 = require_cjs4();
    var AuthenticatedSafe = AuthenticatedSafe_1 = class AuthenticatedSafe extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, AuthenticatedSafe_1.prototype);
      }
    };
    AuthenticatedSafe = AuthenticatedSafe_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: asn1_cms_1.ContentInfo })
    ], AuthenticatedSafe);
    exports.AuthenticatedSafe = AuthenticatedSafe;
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/object_identifiers.js
var require_object_identifiers6 = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/object_identifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id_bagtypes = exports.id_pbewithSHAAnd40BitRC2_CBC = exports.id_pbeWithSHAAnd128BitRC2_CBC = exports.id_pbeWithSHAAnd2_KeyTripleDES_CBC = exports.id_pbeWithSHAAnd3_KeyTripleDES_CBC = exports.id_pbeWithSHAAnd40BitRC4 = exports.id_pbeWithSHAAnd128BitRC4 = exports.id_pkcs_12PbeIds = exports.id_pkcs_12 = exports.id_pkcs = exports.id_rsadsi = void 0;
    exports.id_rsadsi = "1.2.840.113549";
    exports.id_pkcs = `${exports.id_rsadsi}.1`;
    exports.id_pkcs_12 = `${exports.id_pkcs}.12`;
    exports.id_pkcs_12PbeIds = `${exports.id_pkcs_12}.1`;
    exports.id_pbeWithSHAAnd128BitRC4 = `${exports.id_pkcs_12PbeIds}.1`;
    exports.id_pbeWithSHAAnd40BitRC4 = `${exports.id_pkcs_12PbeIds}.2`;
    exports.id_pbeWithSHAAnd3_KeyTripleDES_CBC = `${exports.id_pkcs_12PbeIds}.3`;
    exports.id_pbeWithSHAAnd2_KeyTripleDES_CBC = `${exports.id_pkcs_12PbeIds}.4`;
    exports.id_pbeWithSHAAnd128BitRC2_CBC = `${exports.id_pkcs_12PbeIds}.5`;
    exports.id_pbewithSHAAnd40BitRC2_CBC = `${exports.id_pkcs_12PbeIds}.6`;
    exports.id_bagtypes = `${exports.id_pkcs_12}.10.1`;
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/bags/types.js
var require_types5 = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/bags/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id_pkcs_9 = exports.id_SafeContents = exports.id_SecretBag = exports.id_CRLBag = exports.id_certBag = exports.id_pkcs8ShroudedKeyBag = exports.id_keyBag = void 0;
    var object_identifiers_1 = require_object_identifiers6();
    exports.id_keyBag = `${object_identifiers_1.id_bagtypes}.1`;
    exports.id_pkcs8ShroudedKeyBag = `${object_identifiers_1.id_bagtypes}.2`;
    exports.id_certBag = `${object_identifiers_1.id_bagtypes}.3`;
    exports.id_CRLBag = `${object_identifiers_1.id_bagtypes}.4`;
    exports.id_SecretBag = `${object_identifiers_1.id_bagtypes}.5`;
    exports.id_SafeContents = `${object_identifiers_1.id_bagtypes}.6`;
    exports.id_pkcs_9 = "1.2.840.113549.1.9";
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/bags/cert_bag.js
var require_cert_bag = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/bags/cert_bag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id_sdsiCertificate = exports.id_x509Certificate = exports.id_certTypes = exports.CertBag = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var types_1 = require_types5();
    var CertBag = class {
      constructor(params = {}) {
        this.certId = "";
        this.certValue = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], CertBag.prototype, "certId", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, context: 0 })
    ], CertBag.prototype, "certValue", void 0);
    exports.CertBag = CertBag;
    exports.id_certTypes = `${types_1.id_pkcs_9}.22`;
    exports.id_x509Certificate = `${exports.id_certTypes}.1`;
    exports.id_sdsiCertificate = `${exports.id_certTypes}.2`;
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/bags/crl_bag.js
var require_crl_bag = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/bags/crl_bag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id_x509CRL = exports.id_crlTypes = exports.CRLBag = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var types_1 = require_types5();
    var CRLBag = class {
      constructor(params = {}) {
        this.crlId = "";
        this.crltValue = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], CRLBag.prototype, "crlId", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, context: 0 })
    ], CRLBag.prototype, "crltValue", void 0);
    exports.CRLBag = CRLBag;
    exports.id_crlTypes = `${types_1.id_pkcs_9}.23`;
    exports.id_x509CRL = `${exports.id_crlTypes}.1`;
  }
});

// node_modules/@peculiar/asn1-pkcs8/build/cjs/encrypted_private_key_info.js
var require_encrypted_private_key_info = __commonJS({
  "node_modules/@peculiar/asn1-pkcs8/build/cjs/encrypted_private_key_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EncryptedPrivateKeyInfo = exports.EncryptedData = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var EncryptedData = class extends asn1_schema_1.OctetString {
    };
    exports.EncryptedData = EncryptedData;
    var EncryptedPrivateKeyInfo = class {
      constructor(params = {}) {
        this.encryptionAlgorithm = new asn1_x509_1.AlgorithmIdentifier();
        this.encryptedData = new EncryptedData();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier })
    ], EncryptedPrivateKeyInfo.prototype, "encryptionAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: EncryptedData })
    ], EncryptedPrivateKeyInfo.prototype, "encryptedData", void 0);
    exports.EncryptedPrivateKeyInfo = EncryptedPrivateKeyInfo;
  }
});

// node_modules/@peculiar/asn1-pkcs8/build/cjs/private_key_info.js
var require_private_key_info = __commonJS({
  "node_modules/@peculiar/asn1-pkcs8/build/cjs/private_key_info.js"(exports) {
    "use strict";
    var Attributes_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrivateKeyInfo = exports.Attributes = exports.PrivateKey = exports.Version = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var Version;
    (function(Version2) {
      Version2[Version2["v1"] = 0] = "v1";
    })(Version = exports.Version || (exports.Version = {}));
    var PrivateKey = class extends asn1_schema_1.OctetString {
    };
    exports.PrivateKey = PrivateKey;
    var Attributes = Attributes_1 = class Attributes extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Attributes_1.prototype);
      }
    };
    Attributes = Attributes_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: asn1_x509_1.Attribute })
    ], Attributes);
    exports.Attributes = Attributes;
    var PrivateKeyInfo = class {
      constructor(params = {}) {
        this.version = Version.v1;
        this.privateKeyAlgorithm = new asn1_x509_1.AlgorithmIdentifier();
        this.privateKey = new PrivateKey();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], PrivateKeyInfo.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier })
    ], PrivateKeyInfo.prototype, "privateKeyAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: PrivateKey })
    ], PrivateKeyInfo.prototype, "privateKey", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: Attributes, implicit: true, context: 0, optional: true })
    ], PrivateKeyInfo.prototype, "attributes", void 0);
    exports.PrivateKeyInfo = PrivateKeyInfo;
  }
});

// node_modules/@peculiar/asn1-pkcs8/build/cjs/index.js
var require_cjs8 = __commonJS({
  "node_modules/@peculiar/asn1-pkcs8/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_encrypted_private_key_info(), exports);
    tslib_1.__exportStar(require_private_key_info(), exports);
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/bags/key_bag.js
var require_key_bag = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/bags/key_bag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyBag = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_pkcs8_1 = require_cjs8();
    var asn1_schema_1 = require_cjs();
    var KeyBag = class KeyBag extends asn1_pkcs8_1.PrivateKeyInfo {
    };
    KeyBag = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], KeyBag);
    exports.KeyBag = KeyBag;
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/bags/pkcs8_shrouded_key_bag.js
var require_pkcs8_shrouded_key_bag = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/bags/pkcs8_shrouded_key_bag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PKCS8ShroudedKeyBag = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_pkcs8_1 = require_cjs8();
    var asn1_schema_1 = require_cjs();
    var PKCS8ShroudedKeyBag = class PKCS8ShroudedKeyBag extends asn1_pkcs8_1.EncryptedPrivateKeyInfo {
    };
    PKCS8ShroudedKeyBag = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], PKCS8ShroudedKeyBag);
    exports.PKCS8ShroudedKeyBag = PKCS8ShroudedKeyBag;
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/bags/secret_bag.js
var require_secret_bag = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/bags/secret_bag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SecretBag = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var SecretBag = class {
      constructor(params = {}) {
        this.secretTypeId = "";
        this.secretValue = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], SecretBag.prototype, "secretTypeId", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, context: 0 })
    ], SecretBag.prototype, "secretValue", void 0);
    exports.SecretBag = SecretBag;
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/bags/index.js
var require_bags = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/bags/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_cert_bag(), exports);
    tslib_1.__exportStar(require_crl_bag(), exports);
    tslib_1.__exportStar(require_key_bag(), exports);
    tslib_1.__exportStar(require_pkcs8_shrouded_key_bag(), exports);
    tslib_1.__exportStar(require_secret_bag(), exports);
    tslib_1.__exportStar(require_types5(), exports);
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/mac_data.js
var require_mac_data = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/mac_data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MacData = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_rsa_1 = require_cjs6();
    var asn1_schema_1 = require_cjs();
    var MacData = class {
      constructor(params = {}) {
        this.mac = new asn1_rsa_1.DigestInfo();
        this.macSalt = new asn1_schema_1.OctetString();
        this.iterations = 1;
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_rsa_1.DigestInfo })
    ], MacData.prototype, "mac", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.OctetString })
    ], MacData.prototype, "macSalt", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer, defaultValue: 1 })
    ], MacData.prototype, "iterations", void 0);
    exports.MacData = MacData;
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/pfx.js
var require_pfx = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/pfx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PFX = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_cms_1 = require_cjs4();
    var mac_data_1 = require_mac_data();
    var PFX = class {
      constructor(params = {}) {
        this.version = 3;
        this.authSafe = new asn1_cms_1.ContentInfo();
        this.macData = new mac_data_1.MacData();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], PFX.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_cms_1.ContentInfo })
    ], PFX.prototype, "authSafe", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: mac_data_1.MacData, optional: true })
    ], PFX.prototype, "macData", void 0);
    exports.PFX = PFX;
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/safe_bag.js
var require_safe_bag = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/safe_bag.js"(exports) {
    "use strict";
    var SafeContents_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SafeContents = exports.SafeBag = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var attribute_1 = require_attribute3();
    var SafeBag = class {
      constructor(params = {}) {
        this.bagId = "";
        this.bagValue = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], SafeBag.prototype, "bagId", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Any, context: 0 })
    ], SafeBag.prototype, "bagValue", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: attribute_1.PKCS12Attribute, repeated: "set", optional: true })
    ], SafeBag.prototype, "bagAttributes", void 0);
    exports.SafeBag = SafeBag;
    var SafeContents = SafeContents_1 = class SafeContents extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SafeContents_1.prototype);
      }
    };
    SafeContents = SafeContents_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: SafeBag })
    ], SafeContents);
    exports.SafeContents = SafeContents;
  }
});

// node_modules/@peculiar/asn1-pfx/build/cjs/index.js
var require_cjs9 = __commonJS({
  "node_modules/@peculiar/asn1-pfx/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_attribute3(), exports);
    tslib_1.__exportStar(require_authenticated_safe(), exports);
    tslib_1.__exportStar(require_bags(), exports);
    tslib_1.__exportStar(require_mac_data(), exports);
    tslib_1.__exportStar(require_object_identifiers6(), exports);
    tslib_1.__exportStar(require_pfx(), exports);
    tslib_1.__exportStar(require_safe_bag(), exports);
  }
});

// node_modules/@peculiar/asn1-pkcs9/build/cjs/index.js
var require_cjs10 = __commonJS({
  "node_modules/@peculiar/asn1-pkcs9/build/cjs/index.js"(exports) {
    "use strict";
    var ExtensionRequest_1;
    var ExtendedCertificateAttributes_1;
    var SMIMECapabilities_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateOfBirth = exports.UnstructuredAddress = exports.UnstructuredName = exports.EmailAddress = exports.EncryptedPrivateKeyInfo = exports.UserPKCS12 = exports.Pkcs7PDU = exports.PKCS9String = exports.id_at_pseudonym = exports.crlTypes = exports.id_certTypes = exports.id_smime = exports.id_pkcs9_mr_signingTimeMatch = exports.id_pkcs9_mr_caseIgnoreMatch = exports.id_pkcs9_sx_signingTime = exports.id_pkcs9_sx_pkcs9String = exports.id_pkcs9_at_countryOfResidence = exports.id_pkcs9_at_countryOfCitizenship = exports.id_pkcs9_at_gender = exports.id_pkcs9_at_placeOfBirth = exports.id_pkcs9_at_dateOfBirth = exports.id_ietf_at = exports.id_pkcs9_at_pkcs7PDU = exports.id_pkcs9_at_sequenceNumber = exports.id_pkcs9_at_randomNonce = exports.id_pkcs9_at_encryptedPrivateKeyInfo = exports.id_pkcs9_at_pkcs15Token = exports.id_pkcs9_at_userPKCS12 = exports.id_pkcs9_at_localKeyId = exports.id_pkcs9_at_friendlyName = exports.id_pkcs9_at_smimeCapabilities = exports.id_pkcs9_at_extensionRequest = exports.id_pkcs9_at_signingDescription = exports.id_pkcs9_at_extendedCertificateAttributes = exports.id_pkcs9_at_unstructuredAddress = exports.id_pkcs9_at_challengePassword = exports.id_pkcs9_at_counterSignature = exports.id_pkcs9_at_signingTime = exports.id_pkcs9_at_messageDigest = exports.id_pkcs9_at_contentType = exports.id_pkcs9_at_unstructuredName = exports.id_pkcs9_at_emailAddress = exports.id_pkcs9_oc_naturalPerson = exports.id_pkcs9_oc_pkcsEntity = exports.id_pkcs9_mr = exports.id_pkcs9_sx = exports.id_pkcs9_at = exports.id_pkcs9_oc = exports.id_pkcs9_mo = exports.id_pkcs9 = void 0;
    exports.SMIMECapabilities = exports.SMIMECapability = exports.SigningDescription = exports.LocalKeyId = exports.FriendlyName = exports.ExtendedCertificateAttributes = exports.ExtensionRequest = exports.ChallengePassword = exports.CounterSignature = exports.SequenceNumber = exports.RandomNonce = exports.SigningTime = exports.MessageDigest = exports.ContentType = exports.Pseudonym = exports.CountryOfResidence = exports.CountryOfCitizenship = exports.Gender = exports.PlaceOfBirth = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var cms = require_cjs4();
    var pfx = require_cjs9();
    var pkcs8 = require_cjs8();
    var x509 = require_cjs2();
    var attr = require_cjs3();
    exports.id_pkcs9 = "1.2.840.113549.1.9";
    exports.id_pkcs9_mo = `${exports.id_pkcs9}.0`;
    exports.id_pkcs9_oc = `${exports.id_pkcs9}.24`;
    exports.id_pkcs9_at = `${exports.id_pkcs9}.25`;
    exports.id_pkcs9_sx = `${exports.id_pkcs9}.26`;
    exports.id_pkcs9_mr = `${exports.id_pkcs9}.27`;
    exports.id_pkcs9_oc_pkcsEntity = `${exports.id_pkcs9_oc}.1`;
    exports.id_pkcs9_oc_naturalPerson = `${exports.id_pkcs9_oc}.2`;
    exports.id_pkcs9_at_emailAddress = `${exports.id_pkcs9}.1`;
    exports.id_pkcs9_at_unstructuredName = `${exports.id_pkcs9}.2`;
    exports.id_pkcs9_at_contentType = `${exports.id_pkcs9}.3`;
    exports.id_pkcs9_at_messageDigest = `${exports.id_pkcs9}.4`;
    exports.id_pkcs9_at_signingTime = `${exports.id_pkcs9}.5`;
    exports.id_pkcs9_at_counterSignature = `${exports.id_pkcs9}.6`;
    exports.id_pkcs9_at_challengePassword = `${exports.id_pkcs9}.7`;
    exports.id_pkcs9_at_unstructuredAddress = `${exports.id_pkcs9}.8`;
    exports.id_pkcs9_at_extendedCertificateAttributes = `${exports.id_pkcs9}.9`;
    exports.id_pkcs9_at_signingDescription = `${exports.id_pkcs9}.13`;
    exports.id_pkcs9_at_extensionRequest = `${exports.id_pkcs9}.14`;
    exports.id_pkcs9_at_smimeCapabilities = `${exports.id_pkcs9}.15`;
    exports.id_pkcs9_at_friendlyName = `${exports.id_pkcs9}.20`;
    exports.id_pkcs9_at_localKeyId = `${exports.id_pkcs9}.21`;
    exports.id_pkcs9_at_userPKCS12 = `2.16.840.1.113730.3.1.216`;
    exports.id_pkcs9_at_pkcs15Token = `${exports.id_pkcs9_at}.1`;
    exports.id_pkcs9_at_encryptedPrivateKeyInfo = `${exports.id_pkcs9_at}.2`;
    exports.id_pkcs9_at_randomNonce = `${exports.id_pkcs9_at}.3`;
    exports.id_pkcs9_at_sequenceNumber = `${exports.id_pkcs9_at}.4`;
    exports.id_pkcs9_at_pkcs7PDU = `${exports.id_pkcs9_at}.5`;
    exports.id_ietf_at = `1.3.6.1.5.5.7.9`;
    exports.id_pkcs9_at_dateOfBirth = `${exports.id_ietf_at}.1`;
    exports.id_pkcs9_at_placeOfBirth = `${exports.id_ietf_at}.2`;
    exports.id_pkcs9_at_gender = `${exports.id_ietf_at}.3`;
    exports.id_pkcs9_at_countryOfCitizenship = `${exports.id_ietf_at}.4`;
    exports.id_pkcs9_at_countryOfResidence = `${exports.id_ietf_at}.5`;
    exports.id_pkcs9_sx_pkcs9String = `${exports.id_pkcs9_sx}.1`;
    exports.id_pkcs9_sx_signingTime = `${exports.id_pkcs9_sx}.2`;
    exports.id_pkcs9_mr_caseIgnoreMatch = `${exports.id_pkcs9_mr}.1`;
    exports.id_pkcs9_mr_signingTimeMatch = `${exports.id_pkcs9_mr}.2`;
    exports.id_smime = `${exports.id_pkcs9}.16`;
    exports.id_certTypes = `${exports.id_pkcs9}.22`;
    exports.crlTypes = `${exports.id_pkcs9}.23`;
    exports.id_at_pseudonym = `${attr.id_at}.65`;
    var PKCS9String = class PKCS9String extends x509.DirectoryString {
      constructor(params = {}) {
        super(params);
      }
      toString() {
        const o = {};
        o.toString();
        return this.ia5String || super.toString();
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.IA5String })
    ], PKCS9String.prototype, "ia5String", void 0);
    PKCS9String = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], PKCS9String);
    exports.PKCS9String = PKCS9String;
    var Pkcs7PDU = class Pkcs7PDU extends cms.ContentInfo {
    };
    Pkcs7PDU = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], Pkcs7PDU);
    exports.Pkcs7PDU = Pkcs7PDU;
    var UserPKCS12 = class UserPKCS12 extends pfx.PFX {
    };
    UserPKCS12 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], UserPKCS12);
    exports.UserPKCS12 = UserPKCS12;
    var EncryptedPrivateKeyInfo = class EncryptedPrivateKeyInfo extends pkcs8.EncryptedPrivateKeyInfo {
    };
    EncryptedPrivateKeyInfo = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], EncryptedPrivateKeyInfo);
    exports.EncryptedPrivateKeyInfo = EncryptedPrivateKeyInfo;
    var EmailAddress = class EmailAddress {
      constructor(value = "") {
        this.value = value;
      }
      toString() {
        return this.value;
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.IA5String })
    ], EmailAddress.prototype, "value", void 0);
    EmailAddress = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], EmailAddress);
    exports.EmailAddress = EmailAddress;
    var UnstructuredName = class UnstructuredName extends PKCS9String {
    };
    UnstructuredName = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], UnstructuredName);
    exports.UnstructuredName = UnstructuredName;
    var UnstructuredAddress = class UnstructuredAddress extends x509.DirectoryString {
    };
    UnstructuredAddress = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], UnstructuredAddress);
    exports.UnstructuredAddress = UnstructuredAddress;
    var DateOfBirth = class DateOfBirth {
      constructor(value = /* @__PURE__ */ new Date()) {
        this.value = value;
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.GeneralizedTime })
    ], DateOfBirth.prototype, "value", void 0);
    DateOfBirth = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], DateOfBirth);
    exports.DateOfBirth = DateOfBirth;
    var PlaceOfBirth = class PlaceOfBirth extends x509.DirectoryString {
    };
    PlaceOfBirth = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], PlaceOfBirth);
    exports.PlaceOfBirth = PlaceOfBirth;
    var Gender = class Gender {
      constructor(value = "M") {
        this.value = value;
      }
      toString() {
        return this.value;
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.PrintableString })
    ], Gender.prototype, "value", void 0);
    Gender = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], Gender);
    exports.Gender = Gender;
    var CountryOfCitizenship = class CountryOfCitizenship {
      constructor(value = "") {
        this.value = value;
      }
      toString() {
        return this.value;
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.PrintableString })
    ], CountryOfCitizenship.prototype, "value", void 0);
    CountryOfCitizenship = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], CountryOfCitizenship);
    exports.CountryOfCitizenship = CountryOfCitizenship;
    var CountryOfResidence = class CountryOfResidence extends CountryOfCitizenship {
    };
    CountryOfResidence = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], CountryOfResidence);
    exports.CountryOfResidence = CountryOfResidence;
    var Pseudonym = class Pseudonym extends x509.DirectoryString {
    };
    Pseudonym = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], Pseudonym);
    exports.Pseudonym = Pseudonym;
    var ContentType = class ContentType {
      constructor(value = "") {
        this.value = value;
      }
      toString() {
        return this.value;
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.ObjectIdentifier })
    ], ContentType.prototype, "value", void 0);
    ContentType = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], ContentType);
    exports.ContentType = ContentType;
    var MessageDigest = class extends asn1_schema_1.OctetString {
    };
    exports.MessageDigest = MessageDigest;
    var SigningTime = class SigningTime extends x509.Time {
    };
    SigningTime = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], SigningTime);
    exports.SigningTime = SigningTime;
    var RandomNonce = class extends asn1_schema_1.OctetString {
    };
    exports.RandomNonce = RandomNonce;
    var SequenceNumber = class SequenceNumber {
      constructor(value = 0) {
        this.value = value;
      }
      toString() {
        return this.value.toString();
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], SequenceNumber.prototype, "value", void 0);
    SequenceNumber = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], SequenceNumber);
    exports.SequenceNumber = SequenceNumber;
    var CounterSignature = class CounterSignature extends cms.SignerInfo {
    };
    CounterSignature = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], CounterSignature);
    exports.CounterSignature = CounterSignature;
    var ChallengePassword = class ChallengePassword extends x509.DirectoryString {
    };
    ChallengePassword = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], ChallengePassword);
    exports.ChallengePassword = ChallengePassword;
    var ExtensionRequest = ExtensionRequest_1 = class ExtensionRequest extends x509.Extensions {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, ExtensionRequest_1.prototype);
      }
    };
    ExtensionRequest = ExtensionRequest_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], ExtensionRequest);
    exports.ExtensionRequest = ExtensionRequest;
    var ExtendedCertificateAttributes = ExtendedCertificateAttributes_1 = class ExtendedCertificateAttributes extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, ExtendedCertificateAttributes_1.prototype);
      }
    };
    ExtendedCertificateAttributes = ExtendedCertificateAttributes_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Set, itemType: cms.Attribute })
    ], ExtendedCertificateAttributes);
    exports.ExtendedCertificateAttributes = ExtendedCertificateAttributes;
    var FriendlyName = class FriendlyName {
      constructor(value = "") {
        this.value = value;
      }
      toString() {
        return this.value;
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BmpString })
    ], FriendlyName.prototype, "value", void 0);
    FriendlyName = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Choice })
    ], FriendlyName);
    exports.FriendlyName = FriendlyName;
    var LocalKeyId = class extends asn1_schema_1.OctetString {
    };
    exports.LocalKeyId = LocalKeyId;
    var SigningDescription = class extends x509.DirectoryString {
    };
    exports.SigningDescription = SigningDescription;
    var SMIMECapability = class SMIMECapability extends x509.AlgorithmIdentifier {
    };
    SMIMECapability = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence })
    ], SMIMECapability);
    exports.SMIMECapability = SMIMECapability;
    var SMIMECapabilities = SMIMECapabilities_1 = class SMIMECapabilities extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, SMIMECapabilities_1.prototype);
      }
    };
    SMIMECapabilities = SMIMECapabilities_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: SMIMECapability })
    ], SMIMECapabilities);
    exports.SMIMECapabilities = SMIMECapabilities;
  }
});

// node_modules/@peculiar/asn1-csr/build/cjs/attributes.js
var require_attributes = __commonJS({
  "node_modules/@peculiar/asn1-csr/build/cjs/attributes.js"(exports) {
    "use strict";
    var Attributes_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Attributes = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var Attributes = Attributes_1 = class Attributes extends asn1_schema_1.AsnArray {
      constructor(items) {
        super(items);
        Object.setPrototypeOf(this, Attributes_1.prototype);
      }
    };
    Attributes = Attributes_1 = tslib_1.__decorate([
      (0, asn1_schema_1.AsnType)({ type: asn1_schema_1.AsnTypeTypes.Sequence, itemType: asn1_x509_1.Attribute })
    ], Attributes);
    exports.Attributes = Attributes;
  }
});

// node_modules/@peculiar/asn1-csr/build/cjs/certification_request_info.js
var require_certification_request_info = __commonJS({
  "node_modules/@peculiar/asn1-csr/build/cjs/certification_request_info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CertificationRequestInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var asn1_x509_1 = require_cjs2();
    var attributes_1 = require_attributes();
    var CertificationRequestInfo = class {
      constructor(params = {}) {
        this.version = 0;
        this.subject = new asn1_x509_1.Name();
        this.subjectPKInfo = new asn1_x509_1.SubjectPublicKeyInfo();
        this.attributes = new attributes_1.Attributes();
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.Integer })
    ], CertificationRequestInfo.prototype, "version", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.Name })
    ], CertificationRequestInfo.prototype, "subject", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.SubjectPublicKeyInfo })
    ], CertificationRequestInfo.prototype, "subjectPKInfo", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: attributes_1.Attributes, implicit: true, context: 0 })
    ], CertificationRequestInfo.prototype, "attributes", void 0);
    exports.CertificationRequestInfo = CertificationRequestInfo;
  }
});

// node_modules/@peculiar/asn1-csr/build/cjs/certification_request.js
var require_certification_request = __commonJS({
  "node_modules/@peculiar/asn1-csr/build/cjs/certification_request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CertificationRequest = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var asn1_schema_1 = require_cjs();
    var certification_request_info_1 = require_certification_request_info();
    var asn1_x509_1 = require_cjs2();
    var CertificationRequest = class {
      constructor(params = {}) {
        this.certificationRequestInfo = new certification_request_info_1.CertificationRequestInfo();
        this.signatureAlgorithm = new asn1_x509_1.AlgorithmIdentifier();
        this.signature = new ArrayBuffer(0);
        Object.assign(this, params);
      }
    };
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: certification_request_info_1.CertificationRequestInfo })
    ], CertificationRequest.prototype, "certificationRequestInfo", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_x509_1.AlgorithmIdentifier })
    ], CertificationRequest.prototype, "signatureAlgorithm", void 0);
    tslib_1.__decorate([
      (0, asn1_schema_1.AsnProp)({ type: asn1_schema_1.AsnPropTypes.BitString })
    ], CertificationRequest.prototype, "signature", void 0);
    exports.CertificationRequest = CertificationRequest;
  }
});

// node_modules/@peculiar/asn1-csr/build/cjs/index.js
var require_cjs11 = __commonJS({
  "node_modules/@peculiar/asn1-csr/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_attributes(), exports);
    tslib_1.__exportStar(require_certification_request(), exports);
    tslib_1.__exportStar(require_certification_request_info(), exports);
  }
});

// node_modules/@peculiar/x509/build/x509.cjs.js
var require_x509_cjs = __commonJS({
  "node_modules/@peculiar/x509/build/x509.cjs.js"(exports) {
    "use strict";
    require_Reflect();
    var asn1Schema = require_cjs();
    var asn1X509 = require_cjs2();
    var pvtsutils = require_build();
    var asn1Cms = require_cjs4();
    var asn1Ecc = require_cjs5();
    var asn1Rsa = require_cjs6();
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var tsyringe = require_cjs7();
    var asnPkcs9 = require_cjs10();
    var asn1Csr = require_cjs11();
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n.default = e;
      return Object.freeze(n);
    }
    var asn1X509__namespace = /* @__PURE__ */ _interopNamespaceDefault(asn1X509);
    var asn1Cms__namespace = /* @__PURE__ */ _interopNamespaceDefault(asn1Cms);
    var asn1Ecc__namespace = /* @__PURE__ */ _interopNamespaceDefault(asn1Ecc);
    var asn1Rsa__namespace = /* @__PURE__ */ _interopNamespaceDefault(asn1Rsa);
    var asnPkcs9__namespace = /* @__PURE__ */ _interopNamespaceDefault(asnPkcs9);
    var diAlgorithm = "crypto.algorithm";
    var AlgorithmProvider = class {
      getAlgorithms() {
        return tsyringe.container.resolveAll(diAlgorithm);
      }
      toAsnAlgorithm(alg) {
        ({ ...alg });
        for (const algorithm of this.getAlgorithms()) {
          const res = algorithm.toAsnAlgorithm(alg);
          if (res) {
            return res;
          }
        }
        if (/^[0-9.]+$/.test(alg.name)) {
          const res = new asn1X509.AlgorithmIdentifier({
            algorithm: alg.name
          });
          if ("parameters" in alg) {
            const unknown = alg;
            res.parameters = unknown.parameters;
          }
          return res;
        }
        throw new Error("Cannot convert WebCrypto algorithm to ASN.1 algorithm");
      }
      toWebAlgorithm(alg) {
        for (const algorithm of this.getAlgorithms()) {
          const res = algorithm.toWebAlgorithm(alg);
          if (res) {
            return res;
          }
        }
        const unknown = {
          name: alg.algorithm,
          parameters: alg.parameters
        };
        return unknown;
      }
    };
    var diAlgorithmProvider = "crypto.algorithmProvider";
    tsyringe.container.registerSingleton(diAlgorithmProvider, AlgorithmProvider);
    var EcAlgorithm_1;
    var idVersionOne = "1.3.36.3.3.2.8.1.1";
    var idBrainpoolP160r1 = `${idVersionOne}.1`;
    var idBrainpoolP160t1 = `${idVersionOne}.2`;
    var idBrainpoolP192r1 = `${idVersionOne}.3`;
    var idBrainpoolP192t1 = `${idVersionOne}.4`;
    var idBrainpoolP224r1 = `${idVersionOne}.5`;
    var idBrainpoolP224t1 = `${idVersionOne}.6`;
    var idBrainpoolP256r1 = `${idVersionOne}.7`;
    var idBrainpoolP256t1 = `${idVersionOne}.8`;
    var idBrainpoolP320r1 = `${idVersionOne}.9`;
    var idBrainpoolP320t1 = `${idVersionOne}.10`;
    var idBrainpoolP384r1 = `${idVersionOne}.11`;
    var idBrainpoolP384t1 = `${idVersionOne}.12`;
    var idBrainpoolP512r1 = `${idVersionOne}.13`;
    var idBrainpoolP512t1 = `${idVersionOne}.14`;
    var brainpoolP160r1 = "brainpoolP160r1";
    var brainpoolP160t1 = "brainpoolP160t1";
    var brainpoolP192r1 = "brainpoolP192r1";
    var brainpoolP192t1 = "brainpoolP192t1";
    var brainpoolP224r1 = "brainpoolP224r1";
    var brainpoolP224t1 = "brainpoolP224t1";
    var brainpoolP256r1 = "brainpoolP256r1";
    var brainpoolP256t1 = "brainpoolP256t1";
    var brainpoolP320r1 = "brainpoolP320r1";
    var brainpoolP320t1 = "brainpoolP320t1";
    var brainpoolP384r1 = "brainpoolP384r1";
    var brainpoolP384t1 = "brainpoolP384t1";
    var brainpoolP512r1 = "brainpoolP512r1";
    var brainpoolP512t1 = "brainpoolP512t1";
    var ECDSA = "ECDSA";
    exports.EcAlgorithm = EcAlgorithm_1 = class EcAlgorithm {
      toAsnAlgorithm(alg) {
        switch (alg.name.toLowerCase()) {
          case ECDSA.toLowerCase():
            if ("hash" in alg) {
              const hash2 = typeof alg.hash === "string" ? alg.hash : alg.hash.name;
              switch (hash2.toLowerCase()) {
                case "sha-1":
                  return asn1Ecc__namespace.ecdsaWithSHA1;
                case "sha-256":
                  return asn1Ecc__namespace.ecdsaWithSHA256;
                case "sha-384":
                  return asn1Ecc__namespace.ecdsaWithSHA384;
                case "sha-512":
                  return asn1Ecc__namespace.ecdsaWithSHA512;
              }
            } else if ("namedCurve" in alg) {
              let parameters = "";
              switch (alg.namedCurve) {
                case "P-256":
                  parameters = asn1Ecc__namespace.id_secp256r1;
                  break;
                case "K-256":
                  parameters = EcAlgorithm_1.SECP256K1;
                  break;
                case "P-384":
                  parameters = asn1Ecc__namespace.id_secp384r1;
                  break;
                case "P-521":
                  parameters = asn1Ecc__namespace.id_secp521r1;
                  break;
                case brainpoolP160r1:
                  parameters = idBrainpoolP160r1;
                  break;
                case brainpoolP160t1:
                  parameters = idBrainpoolP160t1;
                  break;
                case brainpoolP192r1:
                  parameters = idBrainpoolP192r1;
                  break;
                case brainpoolP192t1:
                  parameters = idBrainpoolP192t1;
                  break;
                case brainpoolP224r1:
                  parameters = idBrainpoolP224r1;
                  break;
                case brainpoolP224t1:
                  parameters = idBrainpoolP224t1;
                  break;
                case brainpoolP256r1:
                  parameters = idBrainpoolP256r1;
                  break;
                case brainpoolP256t1:
                  parameters = idBrainpoolP256t1;
                  break;
                case brainpoolP320r1:
                  parameters = idBrainpoolP320r1;
                  break;
                case brainpoolP320t1:
                  parameters = idBrainpoolP320t1;
                  break;
                case brainpoolP384r1:
                  parameters = idBrainpoolP384r1;
                  break;
                case brainpoolP384t1:
                  parameters = idBrainpoolP384t1;
                  break;
                case brainpoolP512r1:
                  parameters = idBrainpoolP512r1;
                  break;
                case brainpoolP512t1:
                  parameters = idBrainpoolP512t1;
                  break;
              }
              if (parameters) {
                return new asn1X509.AlgorithmIdentifier({
                  algorithm: asn1Ecc__namespace.id_ecPublicKey,
                  parameters: asn1Schema.AsnConvert.serialize(new asn1Ecc__namespace.ECParameters({ namedCurve: parameters }))
                });
              }
            }
        }
        return null;
      }
      toWebAlgorithm(alg) {
        switch (alg.algorithm) {
          case asn1Ecc__namespace.id_ecdsaWithSHA1:
            return { name: ECDSA, hash: { name: "SHA-1" } };
          case asn1Ecc__namespace.id_ecdsaWithSHA256:
            return { name: ECDSA, hash: { name: "SHA-256" } };
          case asn1Ecc__namespace.id_ecdsaWithSHA384:
            return { name: ECDSA, hash: { name: "SHA-384" } };
          case asn1Ecc__namespace.id_ecdsaWithSHA512:
            return { name: ECDSA, hash: { name: "SHA-512" } };
          case asn1Ecc__namespace.id_ecPublicKey: {
            if (!alg.parameters) {
              throw new TypeError("Cannot get required parameters from EC algorithm");
            }
            const parameters = asn1Schema.AsnConvert.parse(alg.parameters, asn1Ecc__namespace.ECParameters);
            switch (parameters.namedCurve) {
              case asn1Ecc__namespace.id_secp256r1:
                return { name: ECDSA, namedCurve: "P-256" };
              case EcAlgorithm_1.SECP256K1:
                return { name: ECDSA, namedCurve: "K-256" };
              case asn1Ecc__namespace.id_secp384r1:
                return { name: ECDSA, namedCurve: "P-384" };
              case asn1Ecc__namespace.id_secp521r1:
                return { name: ECDSA, namedCurve: "P-521" };
              case idBrainpoolP160r1:
                return { name: ECDSA, namedCurve: brainpoolP160r1 };
              case idBrainpoolP160t1:
                return { name: ECDSA, namedCurve: brainpoolP160t1 };
              case idBrainpoolP192r1:
                return { name: ECDSA, namedCurve: brainpoolP192r1 };
              case idBrainpoolP192t1:
                return { name: ECDSA, namedCurve: brainpoolP192t1 };
              case idBrainpoolP224r1:
                return { name: ECDSA, namedCurve: brainpoolP224r1 };
              case idBrainpoolP224t1:
                return { name: ECDSA, namedCurve: brainpoolP224t1 };
              case idBrainpoolP256r1:
                return { name: ECDSA, namedCurve: brainpoolP256r1 };
              case idBrainpoolP256t1:
                return { name: ECDSA, namedCurve: brainpoolP256t1 };
              case idBrainpoolP320r1:
                return { name: ECDSA, namedCurve: brainpoolP320r1 };
              case idBrainpoolP320t1:
                return { name: ECDSA, namedCurve: brainpoolP320t1 };
              case idBrainpoolP384r1:
                return { name: ECDSA, namedCurve: brainpoolP384r1 };
              case idBrainpoolP384t1:
                return { name: ECDSA, namedCurve: brainpoolP384t1 };
              case idBrainpoolP512r1:
                return { name: ECDSA, namedCurve: brainpoolP512r1 };
              case idBrainpoolP512t1:
                return { name: ECDSA, namedCurve: brainpoolP512t1 };
            }
          }
        }
        return null;
      }
    };
    exports.EcAlgorithm.SECP256K1 = "1.3.132.0.10";
    exports.EcAlgorithm = EcAlgorithm_1 = tslib.__decorate([
      tsyringe.injectable()
    ], exports.EcAlgorithm);
    tsyringe.container.registerSingleton(diAlgorithm, exports.EcAlgorithm);
    var NAME = Symbol("name");
    var VALUE = Symbol("value");
    var TextObject = class {
      constructor(name, items = {}, value = "") {
        this[NAME] = name;
        this[VALUE] = value;
        for (const key in items) {
          this[key] = items[key];
        }
      }
    };
    TextObject.NAME = NAME;
    TextObject.VALUE = VALUE;
    var DefaultAlgorithmSerializer = class {
      static toTextObject(alg) {
        const obj = new TextObject("Algorithm Identifier", {}, OidSerializer.toString(alg.algorithm));
        if (alg.parameters) {
          switch (alg.algorithm) {
            case asn1Ecc__namespace.id_ecPublicKey: {
              const ecAlg = new exports.EcAlgorithm().toWebAlgorithm(alg);
              if (ecAlg && "namedCurve" in ecAlg) {
                obj["Named Curve"] = ecAlg.namedCurve;
              } else {
                obj["Parameters"] = alg.parameters;
              }
              break;
            }
            default:
              obj["Parameters"] = alg.parameters;
          }
        }
        return obj;
      }
    };
    var OidSerializer = class {
      static toString(oid) {
        const name = this.items[oid];
        if (name) {
          return name;
        }
        return oid;
      }
    };
    OidSerializer.items = {
      [asn1Rsa__namespace.id_sha1]: "sha1",
      [asn1Rsa__namespace.id_sha224]: "sha224",
      [asn1Rsa__namespace.id_sha256]: "sha256",
      [asn1Rsa__namespace.id_sha384]: "sha384",
      [asn1Rsa__namespace.id_sha512]: "sha512",
      [asn1Rsa__namespace.id_rsaEncryption]: "rsaEncryption",
      [asn1Rsa__namespace.id_sha1WithRSAEncryption]: "sha1WithRSAEncryption",
      [asn1Rsa__namespace.id_sha224WithRSAEncryption]: "sha224WithRSAEncryption",
      [asn1Rsa__namespace.id_sha256WithRSAEncryption]: "sha256WithRSAEncryption",
      [asn1Rsa__namespace.id_sha384WithRSAEncryption]: "sha384WithRSAEncryption",
      [asn1Rsa__namespace.id_sha512WithRSAEncryption]: "sha512WithRSAEncryption",
      [asn1Ecc__namespace.id_ecPublicKey]: "ecPublicKey",
      [asn1Ecc__namespace.id_ecdsaWithSHA1]: "ecdsaWithSHA1",
      [asn1Ecc__namespace.id_ecdsaWithSHA224]: "ecdsaWithSHA224",
      [asn1Ecc__namespace.id_ecdsaWithSHA256]: "ecdsaWithSHA256",
      [asn1Ecc__namespace.id_ecdsaWithSHA384]: "ecdsaWithSHA384",
      [asn1Ecc__namespace.id_ecdsaWithSHA512]: "ecdsaWithSHA512",
      [asn1X509__namespace.id_kp_serverAuth]: "TLS WWW server authentication",
      [asn1X509__namespace.id_kp_clientAuth]: "TLS WWW client authentication",
      [asn1X509__namespace.id_kp_codeSigning]: "Code Signing",
      [asn1X509__namespace.id_kp_emailProtection]: "E-mail Protection",
      [asn1X509__namespace.id_kp_timeStamping]: "Time Stamping",
      [asn1X509__namespace.id_kp_OCSPSigning]: "OCSP Signing",
      [asn1Cms__namespace.id_signedData]: "Signed Data"
    };
    var TextConverter = class {
      static serialize(obj) {
        return this.serializeObj(obj).join("\n");
      }
      static pad(deep = 0) {
        return "".padStart(2 * deep, " ");
      }
      static serializeObj(obj, deep = 0) {
        const res = [];
        let pad = this.pad(deep++);
        let value = "";
        const objValue = obj[TextObject.VALUE];
        if (objValue) {
          value = ` ${objValue}`;
        }
        res.push(`${pad}${obj[TextObject.NAME]}:${value}`);
        pad = this.pad(deep);
        for (const key in obj) {
          if (typeof key === "symbol") {
            continue;
          }
          const value2 = obj[key];
          const keyValue = key ? `${key}: ` : "";
          if (typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "boolean") {
            res.push(`${pad}${keyValue}${value2}`);
          } else if (value2 instanceof Date) {
            res.push(`${pad}${keyValue}${value2.toUTCString()}`);
          } else if (Array.isArray(value2)) {
            for (const obj2 of value2) {
              obj2[TextObject.NAME] = key;
              res.push(...this.serializeObj(obj2, deep));
            }
          } else if (value2 instanceof TextObject) {
            value2[TextObject.NAME] = key;
            res.push(...this.serializeObj(value2, deep));
          } else if (pvtsutils.BufferSourceConverter.isBufferSource(value2)) {
            if (key) {
              res.push(`${pad}${keyValue}`);
              res.push(...this.serializeBufferSource(value2, deep + 1));
            } else {
              res.push(...this.serializeBufferSource(value2, deep));
            }
          } else if ("toTextObject" in value2) {
            const obj2 = value2.toTextObject();
            obj2[TextObject.NAME] = key;
            res.push(...this.serializeObj(obj2, deep));
          } else {
            throw new TypeError("Cannot serialize data in text format. Unsupported type.");
          }
        }
        return res;
      }
      static serializeBufferSource(buffer, deep = 0) {
        const pad = this.pad(deep);
        const view = pvtsutils.BufferSourceConverter.toUint8Array(buffer);
        const res = [];
        for (let i = 0; i < view.length; ) {
          const row = [];
          for (let j = 0; j < 16 && i < view.length; j++) {
            if (j === 8) {
              row.push("");
            }
            const hex = view[i++].toString(16).padStart(2, "0");
            row.push(hex);
          }
          res.push(`${pad}${row.join(" ")}`);
        }
        return res;
      }
      static serializeAlgorithm(alg) {
        return this.algorithmSerializer.toTextObject(alg);
      }
    };
    TextConverter.oidSerializer = OidSerializer;
    TextConverter.algorithmSerializer = DefaultAlgorithmSerializer;
    var AsnData = class _AsnData {
      constructor(...args) {
        if (args.length === 1) {
          const asn = args[0];
          this.rawData = asn1Schema.AsnConvert.serialize(asn);
          this.onInit(asn);
        } else {
          const asn = asn1Schema.AsnConvert.parse(args[0], args[1]);
          this.rawData = pvtsutils.BufferSourceConverter.toArrayBuffer(args[0]);
          this.onInit(asn);
        }
      }
      equal(data) {
        if (data instanceof _AsnData) {
          return pvtsutils.isEqual(data.rawData, this.rawData);
        }
        return false;
      }
      toString(format = "text") {
        switch (format) {
          case "asn":
            return asn1Schema.AsnConvert.toString(this.rawData);
          case "text":
            return TextConverter.serialize(this.toTextObject());
          case "hex":
            return pvtsutils.Convert.ToHex(this.rawData);
          case "base64":
            return pvtsutils.Convert.ToBase64(this.rawData);
          case "base64url":
            return pvtsutils.Convert.ToBase64Url(this.rawData);
          default:
            throw TypeError("Argument 'format' is unsupported value");
        }
      }
      getTextName() {
        const constructor = this.constructor;
        return constructor.NAME;
      }
      toTextObject() {
        const obj = this.toTextObjectEmpty();
        obj[""] = this.rawData;
        return obj;
      }
      toTextObjectEmpty(value) {
        return new TextObject(this.getTextName(), {}, value);
      }
    };
    AsnData.NAME = "ASN";
    var Extension = class _Extension extends AsnData {
      constructor(...args) {
        let raw;
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          raw = pvtsutils.BufferSourceConverter.toArrayBuffer(args[0]);
        } else {
          raw = asn1Schema.AsnConvert.serialize(new asn1X509.Extension({
            extnID: args[0],
            critical: args[1],
            extnValue: new asn1Schema.OctetString(pvtsutils.BufferSourceConverter.toArrayBuffer(args[2]))
          }));
        }
        super(raw, asn1X509.Extension);
      }
      onInit(asn) {
        this.type = asn.extnID;
        this.critical = asn.critical;
        this.value = asn.extnValue.buffer;
      }
      toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        obj[""] = this.value;
        return obj;
      }
      toTextObjectWithoutValue() {
        const obj = this.toTextObjectEmpty(this.critical ? "critical" : void 0);
        if (obj[TextObject.NAME] === _Extension.NAME) {
          obj[TextObject.NAME] = OidSerializer.toString(this.type);
        }
        return obj;
      }
    };
    var _a;
    var CryptoProvider = class _CryptoProvider {
      static isCryptoKeyPair(data) {
        return data && data.privateKey && data.publicKey;
      }
      static isCryptoKey(data) {
        return data && data.usages && data.type && data.algorithm && data.extractable !== void 0;
      }
      constructor() {
        this.items = /* @__PURE__ */ new Map();
        this[_a] = "CryptoProvider";
        if (typeof self !== "undefined" && typeof crypto !== "undefined") {
          this.set(_CryptoProvider.DEFAULT, crypto);
        }
      }
      clear() {
        this.items.clear();
      }
      delete(key) {
        return this.items.delete(key);
      }
      forEach(callbackfn, thisArg) {
        return this.items.forEach(callbackfn, thisArg);
      }
      has(key) {
        return this.items.has(key);
      }
      get size() {
        return this.items.size;
      }
      entries() {
        return this.items.entries();
      }
      keys() {
        return this.items.keys();
      }
      values() {
        return this.items.values();
      }
      [Symbol.iterator]() {
        return this.items[Symbol.iterator]();
      }
      get(key = _CryptoProvider.DEFAULT) {
        const crypto2 = this.items.get(key.toLowerCase());
        if (!crypto2) {
          throw new Error(`Cannot get Crypto by name '${key}'`);
        }
        return crypto2;
      }
      set(key, value) {
        if (typeof key === "string") {
          if (!value) {
            throw new TypeError("Argument 'value' is required");
          }
          this.items.set(key.toLowerCase(), value);
        } else {
          this.items.set(_CryptoProvider.DEFAULT, key);
        }
        return this;
      }
    };
    _a = Symbol.toStringTag;
    CryptoProvider.DEFAULT = "default";
    var cryptoProvider = new CryptoProvider();
    var OID_REGEX = /^[0-2](?:\.[1-9][0-9]*)+$/;
    function isOID(id) {
      return new RegExp(OID_REGEX).test(id);
    }
    var NameIdentifier = class {
      constructor(names2 = {}) {
        this.items = {};
        for (const id in names2) {
          this.register(id, names2[id]);
        }
      }
      get(idOrName) {
        return this.items[idOrName] || null;
      }
      findId(idOrName) {
        if (!isOID(idOrName)) {
          return this.get(idOrName);
        }
        return idOrName;
      }
      register(id, name) {
        this.items[id] = name;
        this.items[name] = id;
      }
    };
    var names = new NameIdentifier();
    names.register("CN", "2.5.4.3");
    names.register("L", "2.5.4.7");
    names.register("ST", "2.5.4.8");
    names.register("O", "2.5.4.10");
    names.register("OU", "2.5.4.11");
    names.register("C", "2.5.4.6");
    names.register("DC", "0.9.2342.19200300.100.1.25");
    names.register("E", "1.2.840.113549.1.9.1");
    names.register("G", "2.5.4.42");
    names.register("I", "2.5.4.43");
    names.register("SN", "2.5.4.4");
    names.register("T", "2.5.4.12");
    function replaceUnknownCharacter(text, char) {
      return `\\${pvtsutils.Convert.ToHex(pvtsutils.Convert.FromUtf8String(char)).toUpperCase()}`;
    }
    function escape2(data) {
      return data.replace(/([,+"\\<>;])/g, "\\$1").replace(/^([ #])/, "\\$1").replace(/([ ]$)/, "\\$1").replace(/([\r\n\t])/, replaceUnknownCharacter);
    }
    var Name = class _Name {
      static isASCII(text) {
        for (let i = 0; i < text.length; i++) {
          const code = text.charCodeAt(i);
          if (code > 255) {
            return false;
          }
        }
        return true;
      }
      constructor(data, extraNames = {}) {
        this.extraNames = new NameIdentifier();
        this.asn = new asn1X509.Name();
        for (const key in extraNames) {
          if (Object.prototype.hasOwnProperty.call(extraNames, key)) {
            const value = extraNames[key];
            this.extraNames.register(key, value);
          }
        }
        if (typeof data === "string") {
          this.asn = this.fromString(data);
        } else if (data instanceof asn1X509.Name) {
          this.asn = data;
        } else if (pvtsutils.BufferSourceConverter.isBufferSource(data)) {
          this.asn = asn1Schema.AsnConvert.parse(data, asn1X509.Name);
        } else {
          this.asn = this.fromJSON(data);
        }
      }
      getField(idOrName) {
        const id = this.extraNames.findId(idOrName) || names.findId(idOrName);
        const res = [];
        for (const name of this.asn) {
          for (const rdn of name) {
            if (rdn.type === id) {
              res.push(rdn.value.toString());
            }
          }
        }
        return res;
      }
      getName(idOrName) {
        return this.extraNames.get(idOrName) || names.get(idOrName);
      }
      toString() {
        return this.asn.map((rdn) => rdn.map((o) => {
          const type = this.getName(o.type) || o.type;
          const value = o.value.anyValue ? `#${pvtsutils.Convert.ToHex(o.value.anyValue)}` : escape2(o.value.toString());
          return `${type}=${value}`;
        }).join("+")).join(", ");
      }
      toJSON() {
        var _a2;
        const json = [];
        for (const rdn of this.asn) {
          const jsonItem = {};
          for (const attr of rdn) {
            const type = this.getName(attr.type) || attr.type;
            (_a2 = jsonItem[type]) !== null && _a2 !== void 0 ? _a2 : jsonItem[type] = [];
            jsonItem[type].push(attr.value.anyValue ? `#${pvtsutils.Convert.ToHex(attr.value.anyValue)}` : attr.value.toString());
          }
          json.push(jsonItem);
        }
        return json;
      }
      fromString(data) {
        const asn = new asn1X509.Name();
        const regex = /(\d\.[\d.]*\d|[A-Za-z]+)=((?:"")|(?:".*?[^\\]")|(?:[^,+].*?(?:[^\\][,+]))|(?:))([,+])?/g;
        let matches = null;
        let level = ",";
        while (matches = regex.exec(`${data},`)) {
          let [, type, value] = matches;
          const lastChar = value[value.length - 1];
          if (lastChar === "," || lastChar === "+") {
            value = value.slice(0, value.length - 1);
            matches[3] = lastChar;
          }
          const next = matches[3];
          if (!/[\d.]+/.test(type)) {
            type = this.getName(type) || "";
          }
          if (!type) {
            throw new Error(`Cannot get OID for name type '${type}'`);
          }
          const attr = new asn1X509.AttributeTypeAndValue({ type });
          if (value.charAt(0) === "#") {
            attr.value.anyValue = pvtsutils.Convert.FromHex(value.slice(1));
          } else {
            const quotedMatches = /"(.*?[^\\])?"/.exec(value);
            if (quotedMatches) {
              value = quotedMatches[1];
            }
            value = value.replace(/\\0a/ig, "\n").replace(/\\0d/ig, "\r").replace(/\\0g/ig, "	").replace(/\\(.)/g, "$1");
            if (type === this.getName("E") || type === this.getName("DC")) {
              attr.value.ia5String = value;
            } else {
              if (_Name.isASCII(value)) {
                attr.value.printableString = value;
              } else {
                attr.value.utf8String = value;
              }
            }
          }
          if (level === "+") {
            asn[asn.length - 1].push(attr);
          } else {
            asn.push(new asn1X509.RelativeDistinguishedName([attr]));
          }
          level = next;
        }
        return asn;
      }
      fromJSON(data) {
        const asn = new asn1X509.Name();
        for (const item of data) {
          const asnRdn = new asn1X509.RelativeDistinguishedName();
          for (const type in item) {
            let typeId = type;
            if (!/[\d.]+/.test(type)) {
              typeId = this.getName(type) || "";
            }
            if (!typeId) {
              throw new Error(`Cannot get OID for name type '${type}'`);
            }
            const values = item[type];
            for (const value of values) {
              const asnAttr = new asn1X509.AttributeTypeAndValue({ type: typeId });
              if (typeof value === "object") {
                for (const key in value) {
                  switch (key) {
                    case "ia5String":
                      asnAttr.value.ia5String = value[key];
                      break;
                    case "utf8String":
                      asnAttr.value.utf8String = value[key];
                      break;
                    case "universalString":
                      asnAttr.value.universalString = value[key];
                      break;
                    case "bmpString":
                      asnAttr.value.bmpString = value[key];
                      break;
                    case "printableString":
                      asnAttr.value.printableString = value[key];
                      break;
                  }
                }
              } else if (value[0] === "#") {
                asnAttr.value.anyValue = pvtsutils.Convert.FromHex(value.slice(1));
              } else {
                if (typeId === this.getName("E") || typeId === this.getName("DC")) {
                  asnAttr.value.ia5String = value;
                } else {
                  asnAttr.value.printableString = value;
                }
              }
              asnRdn.push(asnAttr);
            }
          }
          asn.push(asnRdn);
        }
        return asn;
      }
      toArrayBuffer() {
        return asn1Schema.AsnConvert.serialize(this.asn);
      }
      async getThumbprint(...args) {
        var _a2;
        let crypto2;
        let algorithm = "SHA-1";
        if (args.length >= 1 && !((_a2 = args[0]) === null || _a2 === void 0 ? void 0 : _a2.subtle)) {
          algorithm = args[0] || algorithm;
          crypto2 = args[1] || cryptoProvider.get();
        } else {
          crypto2 = args[0] || cryptoProvider.get();
        }
        return await crypto2.subtle.digest(algorithm, this.toArrayBuffer());
      }
    };
    var ERR_GN_CONSTRUCTOR = "Cannot initialize GeneralName from ASN.1 data.";
    var ERR_GN_STRING_FORMAT = `${ERR_GN_CONSTRUCTOR} Unsupported string format in use.`;
    var ERR_GUID = `${ERR_GN_CONSTRUCTOR} Value doesn't match to GUID regular expression.`;
    var GUID_REGEX = /^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i;
    var id_GUID = "1.3.6.1.4.1.311.25.1";
    var id_UPN = "1.3.6.1.4.1.311.20.2.3";
    var DNS = "dns";
    var DN = "dn";
    var EMAIL = "email";
    var IP = "ip";
    var URL2 = "url";
    var GUID = "guid";
    var UPN = "upn";
    var REGISTERED_ID = "id";
    var GeneralName = class extends AsnData {
      constructor(...args) {
        let name;
        if (args.length === 2) {
          switch (args[0]) {
            case DN: {
              const derName = new Name(args[1]).toArrayBuffer();
              const asnName = asn1Schema.AsnConvert.parse(derName, asn1X509__namespace.Name);
              name = new asn1X509__namespace.GeneralName({ directoryName: asnName });
              break;
            }
            case DNS:
              name = new asn1X509__namespace.GeneralName({ dNSName: args[1] });
              break;
            case EMAIL:
              name = new asn1X509__namespace.GeneralName({ rfc822Name: args[1] });
              break;
            case GUID: {
              const matches = new RegExp(GUID_REGEX, "i").exec(args[1]);
              if (!matches) {
                throw new Error("Cannot parse GUID value. Value doesn't match to regular expression");
              }
              const hex = matches.slice(1).map((o, i) => {
                if (i < 3) {
                  return pvtsutils.Convert.ToHex(new Uint8Array(pvtsutils.Convert.FromHex(o)).reverse());
                }
                return o;
              }).join("");
              name = new asn1X509__namespace.GeneralName({
                otherName: new asn1X509__namespace.OtherName({
                  typeId: id_GUID,
                  value: asn1Schema.AsnConvert.serialize(new asn1Schema.OctetString(pvtsutils.Convert.FromHex(hex)))
                })
              });
              break;
            }
            case IP:
              name = new asn1X509__namespace.GeneralName({ iPAddress: args[1] });
              break;
            case REGISTERED_ID:
              name = new asn1X509__namespace.GeneralName({ registeredID: args[1] });
              break;
            case UPN: {
              name = new asn1X509__namespace.GeneralName({
                otherName: new asn1X509__namespace.OtherName({
                  typeId: id_UPN,
                  value: asn1Schema.AsnConvert.serialize(asn1Schema.AsnUtf8StringConverter.toASN(args[1]))
                })
              });
              break;
            }
            case URL2:
              name = new asn1X509__namespace.GeneralName({ uniformResourceIdentifier: args[1] });
              break;
            default:
              throw new Error("Cannot create GeneralName. Unsupported type of the name");
          }
        } else if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          name = asn1Schema.AsnConvert.parse(args[0], asn1X509__namespace.GeneralName);
        } else {
          name = args[0];
        }
        super(name);
      }
      onInit(asn) {
        if (asn.dNSName != void 0) {
          this.type = DNS;
          this.value = asn.dNSName;
        } else if (asn.rfc822Name != void 0) {
          this.type = EMAIL;
          this.value = asn.rfc822Name;
        } else if (asn.iPAddress != void 0) {
          this.type = IP;
          this.value = asn.iPAddress;
        } else if (asn.uniformResourceIdentifier != void 0) {
          this.type = URL2;
          this.value = asn.uniformResourceIdentifier;
        } else if (asn.registeredID != void 0) {
          this.type = REGISTERED_ID;
          this.value = asn.registeredID;
        } else if (asn.directoryName != void 0) {
          this.type = DN;
          this.value = new Name(asn.directoryName).toString();
        } else if (asn.otherName != void 0) {
          if (asn.otherName.typeId === id_GUID) {
            this.type = GUID;
            const guid = asn1Schema.AsnConvert.parse(asn.otherName.value, asn1Schema.OctetString);
            const matches = new RegExp(GUID_REGEX, "i").exec(pvtsutils.Convert.ToHex(guid));
            if (!matches) {
              throw new Error(ERR_GUID);
            }
            this.value = matches.slice(1).map((o, i) => {
              if (i < 3) {
                return pvtsutils.Convert.ToHex(new Uint8Array(pvtsutils.Convert.FromHex(o)).reverse());
              }
              return o;
            }).join("-");
          } else if (asn.otherName.typeId === id_UPN) {
            this.type = UPN;
            this.value = asn1Schema.AsnConvert.parse(asn.otherName.value, asn1X509__namespace.DirectoryString).toString();
          } else {
            throw new Error(ERR_GN_STRING_FORMAT);
          }
        } else {
          throw new Error(ERR_GN_STRING_FORMAT);
        }
      }
      toJSON() {
        return {
          type: this.type,
          value: this.value
        };
      }
      toTextObject() {
        let type;
        switch (this.type) {
          case DN:
          case DNS:
          case GUID:
          case IP:
          case REGISTERED_ID:
          case UPN:
          case URL2:
            type = this.type.toUpperCase();
            break;
          case EMAIL:
            type = "Email";
            break;
          default:
            throw new Error("Unsupported GeneralName type");
        }
        let value = this.value;
        if (this.type === REGISTERED_ID) {
          value = OidSerializer.toString(value);
        }
        return new TextObject(type, void 0, value);
      }
    };
    var GeneralNames = class extends AsnData {
      constructor(params) {
        let names2;
        if (params instanceof asn1X509__namespace.GeneralNames) {
          names2 = params;
        } else if (Array.isArray(params)) {
          const items = [];
          for (const name of params) {
            if (name instanceof asn1X509__namespace.GeneralName) {
              items.push(name);
            } else {
              const asnName = asn1Schema.AsnConvert.parse(new GeneralName(name.type, name.value).rawData, asn1X509__namespace.GeneralName);
              items.push(asnName);
            }
          }
          names2 = new asn1X509__namespace.GeneralNames(items);
        } else if (pvtsutils.BufferSourceConverter.isBufferSource(params)) {
          names2 = asn1Schema.AsnConvert.parse(params, asn1X509__namespace.GeneralNames);
        } else {
          throw new Error("Cannot initialize GeneralNames. Incorrect incoming arguments");
        }
        super(names2);
      }
      onInit(asn) {
        const items = [];
        for (const asnName of asn) {
          let name = null;
          try {
            name = new GeneralName(asnName);
          } catch {
            continue;
          }
          items.push(name);
        }
        this.items = items;
      }
      toJSON() {
        return this.items.map((o) => o.toJSON());
      }
      toTextObject() {
        const res = super.toTextObjectEmpty();
        for (const name of this.items) {
          const nameObj = name.toTextObject();
          let field = res[nameObj[TextObject.NAME]];
          if (!Array.isArray(field)) {
            field = [];
            res[nameObj[TextObject.NAME]] = field;
          }
          field.push(nameObj);
        }
        return res;
      }
    };
    GeneralNames.NAME = "GeneralNames";
    var rPaddingTag = "-{5}";
    var rEolChars = "\\n";
    var rNameTag = `[^${rEolChars}]+`;
    var rBeginTag = `${rPaddingTag}BEGIN (${rNameTag}(?=${rPaddingTag}))${rPaddingTag}`;
    var rEndTag = `${rPaddingTag}END \\1${rPaddingTag}`;
    var rEolGroup = "\\n";
    var rHeaderKey = `[^:${rEolChars}]+`;
    var rHeaderValue = `(?:[^${rEolChars}]+${rEolGroup}(?: +[^${rEolChars}]+${rEolGroup})*)`;
    var rBase64Chars = "[a-zA-Z0-9=+/]+";
    var rBase64 = `(?:${rBase64Chars}${rEolGroup})+`;
    var rPem = `${rBeginTag}${rEolGroup}(?:((?:${rHeaderKey}: ${rHeaderValue})+))?${rEolGroup}?(${rBase64})${rEndTag}`;
    var PemConverter = class {
      static isPem(data) {
        return typeof data === "string" && new RegExp(rPem, "g").test(data);
      }
      static decodeWithHeaders(pem) {
        pem = pem.replace(/\r/g, "");
        const pattern = new RegExp(rPem, "g");
        const res = [];
        let matches = null;
        while (matches = pattern.exec(pem)) {
          const base64 = matches[3].replace(new RegExp(`[${rEolChars}]+`, "g"), "");
          const pemStruct = {
            type: matches[1],
            headers: [],
            rawData: pvtsutils.Convert.FromBase64(base64)
          };
          const headersString = matches[2];
          if (headersString) {
            const headers2 = headersString.split(new RegExp(rEolGroup, "g"));
            let lastHeader = null;
            for (const header of headers2) {
              const [key, value] = header.split(/:(.*)/);
              if (value === void 0) {
                if (!lastHeader) {
                  throw new Error("Cannot parse PEM string. Incorrect header value");
                }
                lastHeader.value += key.trim();
              } else {
                if (lastHeader) {
                  pemStruct.headers.push(lastHeader);
                }
                lastHeader = { key, value: value.trim() };
              }
            }
            if (lastHeader) {
              pemStruct.headers.push(lastHeader);
            }
          }
          res.push(pemStruct);
        }
        return res;
      }
      static decode(pem) {
        const blocks = this.decodeWithHeaders(pem);
        return blocks.map((o) => o.rawData);
      }
      static decodeFirst(pem) {
        const items = this.decode(pem);
        if (!items.length) {
          throw new RangeError("PEM string doesn't contain any objects");
        }
        return items[0];
      }
      static encode(rawData, tag) {
        if (Array.isArray(rawData)) {
          const raws = new Array();
          if (tag) {
            rawData.forEach((element) => {
              if (!pvtsutils.BufferSourceConverter.isBufferSource(element)) {
                throw new TypeError("Cannot encode array of BufferSource in PEM format. Not all items of the array are BufferSource");
              }
              raws.push(this.encodeStruct({
                type: tag,
                rawData: pvtsutils.BufferSourceConverter.toArrayBuffer(element)
              }));
            });
          } else {
            rawData.forEach((element) => {
              if (!("type" in element)) {
                throw new TypeError("Cannot encode array of PemStruct in PEM format. Not all items of the array are PemStrut");
              }
              raws.push(this.encodeStruct(element));
            });
          }
          return raws.join("\n");
        } else {
          if (!tag) {
            throw new Error("Required argument 'tag' is missed");
          }
          return this.encodeStruct({
            type: tag,
            rawData: pvtsutils.BufferSourceConverter.toArrayBuffer(rawData)
          });
        }
      }
      static encodeStruct(pem) {
        var _a2;
        const upperCaseType = pem.type.toLocaleUpperCase();
        const res = [];
        res.push(`-----BEGIN ${upperCaseType}-----`);
        if ((_a2 = pem.headers) === null || _a2 === void 0 ? void 0 : _a2.length) {
          for (const header of pem.headers) {
            res.push(`${header.key}: ${header.value}`);
          }
          res.push("");
        }
        const base64 = pvtsutils.Convert.ToBase64(pem.rawData);
        let sliced;
        let offset = 0;
        const rows = Array();
        while (offset < base64.length) {
          if (base64.length - offset < 64) {
            sliced = base64.substring(offset);
          } else {
            sliced = base64.substring(offset, offset + 64);
            offset += 64;
          }
          if (sliced.length !== 0) {
            rows.push(sliced);
            if (sliced.length < 64) {
              break;
            }
          } else {
            break;
          }
        }
        res.push(...rows);
        res.push(`-----END ${upperCaseType}-----`);
        return res.join("\n");
      }
    };
    PemConverter.CertificateTag = "CERTIFICATE";
    PemConverter.CrlTag = "CRL";
    PemConverter.CertificateRequestTag = "CERTIFICATE REQUEST";
    PemConverter.PublicKeyTag = "PUBLIC KEY";
    PemConverter.PrivateKeyTag = "PRIVATE KEY";
    var PemData = class _PemData extends AsnData {
      static isAsnEncoded(data) {
        return pvtsutils.BufferSourceConverter.isBufferSource(data) || typeof data === "string";
      }
      static toArrayBuffer(raw) {
        if (typeof raw === "string") {
          if (PemConverter.isPem(raw)) {
            return PemConverter.decode(raw)[0];
          } else if (pvtsutils.Convert.isHex(raw)) {
            return pvtsutils.Convert.FromHex(raw);
          } else if (pvtsutils.Convert.isBase64(raw)) {
            return pvtsutils.Convert.FromBase64(raw);
          } else if (pvtsutils.Convert.isBase64Url(raw)) {
            return pvtsutils.Convert.FromBase64Url(raw);
          } else {
            throw new TypeError("Unsupported format of 'raw' argument. Must be one of DER, PEM, HEX, Base64, or Base4Url");
          }
        } else {
          const stringRaw = pvtsutils.Convert.ToBinary(raw);
          if (PemConverter.isPem(stringRaw)) {
            return PemConverter.decode(stringRaw)[0];
          } else if (pvtsutils.Convert.isHex(stringRaw)) {
            return pvtsutils.Convert.FromHex(stringRaw);
          } else if (pvtsutils.Convert.isBase64(stringRaw)) {
            return pvtsutils.Convert.FromBase64(stringRaw);
          } else if (pvtsutils.Convert.isBase64Url(stringRaw)) {
            return pvtsutils.Convert.FromBase64Url(stringRaw);
          }
          return pvtsutils.BufferSourceConverter.toArrayBuffer(raw);
        }
      }
      constructor(...args) {
        if (_PemData.isAsnEncoded(args[0])) {
          super(_PemData.toArrayBuffer(args[0]), args[1]);
        } else {
          super(args[0]);
        }
      }
      toString(format = "pem") {
        switch (format) {
          case "pem":
            return PemConverter.encode(this.rawData, this.tag);
          default:
            return super.toString(format);
        }
      }
    };
    var PublicKey = class extends PemData {
      constructor(param) {
        if (PemData.isAsnEncoded(param)) {
          super(param, asn1X509.SubjectPublicKeyInfo);
        } else {
          super(param);
        }
        this.tag = PemConverter.PublicKeyTag;
      }
      async export(...args) {
        let crypto2;
        let keyUsages = ["verify"];
        let algorithm = { hash: "SHA-256", ...this.algorithm };
        if (args.length > 1) {
          algorithm = args[0] || algorithm;
          keyUsages = args[1] || keyUsages;
          crypto2 = args[2] || cryptoProvider.get();
        } else {
          crypto2 = args[0] || cryptoProvider.get();
        }
        return crypto2.subtle.importKey("spki", this.rawData, algorithm, true, keyUsages);
      }
      onInit(asn) {
        const algProv = tsyringe.container.resolve(diAlgorithmProvider);
        const algorithm = this.algorithm = algProv.toWebAlgorithm(asn.algorithm);
        switch (asn.algorithm.algorithm) {
          case asn1Rsa.id_rsaEncryption: {
            const rsaPublicKey = asn1Schema.AsnConvert.parse(asn.subjectPublicKey, asn1Rsa.RSAPublicKey);
            const modulus = pvtsutils.BufferSourceConverter.toUint8Array(rsaPublicKey.modulus);
            algorithm.publicExponent = pvtsutils.BufferSourceConverter.toUint8Array(rsaPublicKey.publicExponent);
            algorithm.modulusLength = (!modulus[0] ? modulus.slice(1) : modulus).byteLength << 3;
            break;
          }
        }
      }
      async getThumbprint(...args) {
        var _a2;
        let crypto2;
        let algorithm = "SHA-1";
        if (args.length >= 1 && !((_a2 = args[0]) === null || _a2 === void 0 ? void 0 : _a2.subtle)) {
          algorithm = args[0] || algorithm;
          crypto2 = args[1] || cryptoProvider.get();
        } else {
          crypto2 = args[0] || cryptoProvider.get();
        }
        return await crypto2.subtle.digest(algorithm, this.rawData);
      }
      async getKeyIdentifier(crypto2) {
        if (!crypto2) {
          crypto2 = cryptoProvider.get();
        }
        const asn = asn1Schema.AsnConvert.parse(this.rawData, asn1X509.SubjectPublicKeyInfo);
        return await crypto2.subtle.digest("SHA-1", asn.subjectPublicKey);
      }
      toTextObject() {
        const obj = this.toTextObjectEmpty();
        const asn = asn1Schema.AsnConvert.parse(this.rawData, asn1X509.SubjectPublicKeyInfo);
        obj["Algorithm"] = TextConverter.serializeAlgorithm(asn.algorithm);
        switch (asn.algorithm.algorithm) {
          case asn1Ecc.id_ecPublicKey:
            obj["EC Point"] = asn.subjectPublicKey;
            break;
          case asn1Rsa.id_rsaEncryption:
          default:
            obj["Raw Data"] = asn.subjectPublicKey;
        }
        return obj;
      }
    };
    var ExtensionFactory = class {
      static register(id, type) {
        this.items.set(id, type);
      }
      static create(data) {
        const extension = new Extension(data);
        const Type = this.items.get(extension.type);
        if (Type) {
          return new Type(data);
        }
        return extension;
      }
    };
    ExtensionFactory.items = /* @__PURE__ */ new Map();
    var diAsnSignatureFormatter = "crypto.signatureFormatter";
    var AsnDefaultSignatureFormatter = class {
      toAsnSignature(algorithm, signature) {
        return pvtsutils.BufferSourceConverter.toArrayBuffer(signature);
      }
      toWebSignature(algorithm, signature) {
        return pvtsutils.BufferSourceConverter.toArrayBuffer(signature);
      }
    };
    var X509Certificate = class extends PemData {
      constructor(param) {
        if (PemData.isAsnEncoded(param)) {
          super(param, asn1X509.Certificate);
        } else {
          super(param);
        }
        this.tag = PemConverter.CertificateTag;
      }
      onInit(asn) {
        const tbs = asn.tbsCertificate;
        this.tbs = asn1Schema.AsnConvert.serialize(tbs);
        this.serialNumber = pvtsutils.Convert.ToHex(tbs.serialNumber);
        this.subjectName = new Name(tbs.subject);
        this.subject = new Name(tbs.subject).toString();
        this.issuerName = new Name(tbs.issuer);
        this.issuer = this.issuerName.toString();
        const algProv = tsyringe.container.resolve(diAlgorithmProvider);
        this.signatureAlgorithm = algProv.toWebAlgorithm(asn.signatureAlgorithm);
        this.signature = asn.signatureValue;
        const notBefore = tbs.validity.notBefore.utcTime || tbs.validity.notBefore.generalTime;
        if (!notBefore) {
          throw new Error("Cannot get 'notBefore' value");
        }
        this.notBefore = notBefore;
        const notAfter = tbs.validity.notAfter.utcTime || tbs.validity.notAfter.generalTime;
        if (!notAfter) {
          throw new Error("Cannot get 'notAfter' value");
        }
        this.notAfter = notAfter;
        this.extensions = [];
        if (tbs.extensions) {
          this.extensions = tbs.extensions.map((o) => ExtensionFactory.create(asn1Schema.AsnConvert.serialize(o)));
        }
        this.publicKey = new PublicKey(tbs.subjectPublicKeyInfo);
      }
      getExtension(type) {
        for (const ext of this.extensions) {
          if (typeof type === "string") {
            if (ext.type === type) {
              return ext;
            }
          } else {
            if (ext instanceof type) {
              return ext;
            }
          }
        }
        return null;
      }
      getExtensions(type) {
        return this.extensions.filter((o) => {
          if (typeof type === "string") {
            return o.type === type;
          } else {
            return o instanceof type;
          }
        });
      }
      async verify(params = {}, crypto2 = cryptoProvider.get()) {
        let keyAlgorithm;
        let publicKey;
        const paramsKey = params.publicKey;
        try {
          if (!paramsKey) {
            keyAlgorithm = { ...this.publicKey.algorithm, ...this.signatureAlgorithm };
            publicKey = await this.publicKey.export(keyAlgorithm, ["verify"], crypto2);
          } else if ("publicKey" in paramsKey) {
            keyAlgorithm = { ...paramsKey.publicKey.algorithm, ...this.signatureAlgorithm };
            publicKey = await paramsKey.publicKey.export(keyAlgorithm, ["verify"], crypto2);
          } else if (paramsKey instanceof PublicKey) {
            keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
            publicKey = await paramsKey.export(keyAlgorithm, ["verify"], crypto2);
          } else if (pvtsutils.BufferSourceConverter.isBufferSource(paramsKey)) {
            const key = new PublicKey(paramsKey);
            keyAlgorithm = { ...key.algorithm, ...this.signatureAlgorithm };
            publicKey = await key.export(keyAlgorithm, ["verify"], crypto2);
          } else {
            keyAlgorithm = { ...paramsKey.algorithm, ...this.signatureAlgorithm };
            publicKey = paramsKey;
          }
        } catch (e) {
          return false;
        }
        const signatureFormatters = tsyringe.container.resolveAll(diAsnSignatureFormatter).reverse();
        let signature = null;
        for (const signatureFormatter of signatureFormatters) {
          signature = signatureFormatter.toWebSignature(keyAlgorithm, this.signature);
          if (signature) {
            break;
          }
        }
        if (!signature) {
          throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
        }
        const ok = await crypto2.subtle.verify(this.signatureAlgorithm, publicKey, signature, this.tbs);
        if (params.signatureOnly) {
          return ok;
        } else {
          const date = params.date || /* @__PURE__ */ new Date();
          const time = date.getTime();
          return ok && this.notBefore.getTime() < time && time < this.notAfter.getTime();
        }
      }
      async getThumbprint(...args) {
        let crypto2;
        let algorithm = "SHA-1";
        if (args[0]) {
          if (!args[0].subtle) {
            algorithm = args[0] || algorithm;
            crypto2 = args[1];
          } else {
            crypto2 = args[0];
          }
        }
        crypto2 !== null && crypto2 !== void 0 ? crypto2 : crypto2 = cryptoProvider.get();
        return await crypto2.subtle.digest(algorithm, this.rawData);
      }
      async isSelfSigned(crypto2 = cryptoProvider.get()) {
        return this.subject === this.issuer && await this.verify({ signatureOnly: true }, crypto2);
      }
      toTextObject() {
        const obj = this.toTextObjectEmpty();
        const cert = asn1Schema.AsnConvert.parse(this.rawData, asn1X509.Certificate);
        const tbs = cert.tbsCertificate;
        const data = new TextObject("", {
          "Version": `${asn1X509.Version[tbs.version]} (${tbs.version})`,
          "Serial Number": tbs.serialNumber,
          "Signature Algorithm": TextConverter.serializeAlgorithm(tbs.signature),
          "Issuer": this.issuer,
          "Validity": new TextObject("", {
            "Not Before": tbs.validity.notBefore.getTime(),
            "Not After": tbs.validity.notAfter.getTime()
          }),
          "Subject": this.subject,
          "Subject Public Key Info": this.publicKey
        });
        if (tbs.issuerUniqueID) {
          data["Issuer Unique ID"] = tbs.issuerUniqueID;
        }
        if (tbs.subjectUniqueID) {
          data["Subject Unique ID"] = tbs.subjectUniqueID;
        }
        if (this.extensions.length) {
          const extensions2 = new TextObject("");
          for (const ext of this.extensions) {
            const extObj = ext.toTextObject();
            extensions2[extObj[TextObject.NAME]] = extObj;
          }
          data["Extensions"] = extensions2;
        }
        obj["Data"] = data;
        obj["Signature"] = new TextObject("", {
          "Algorithm": TextConverter.serializeAlgorithm(cert.signatureAlgorithm),
          "": cert.signatureValue
        });
        return obj;
      }
    };
    X509Certificate.NAME = "Certificate";
    var AuthorityKeyIdentifierExtension = class _AuthorityKeyIdentifierExtension extends Extension {
      static async create(param, critical = false, crypto2 = cryptoProvider.get()) {
        if (param instanceof X509Certificate || CryptoProvider.isCryptoKey(param)) {
          const publicKey = param instanceof X509Certificate ? await param.publicKey.export(crypto2) : param;
          const spki = await crypto2.subtle.exportKey("spki", publicKey);
          const key = new PublicKey(spki);
          const id = await key.getKeyIdentifier(crypto2);
          return new _AuthorityKeyIdentifierExtension(pvtsutils.Convert.ToHex(id), critical);
        } else {
          return new _AuthorityKeyIdentifierExtension(param, critical);
        }
      }
      constructor(...args) {
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          super(args[0]);
        } else if (typeof args[0] === "string") {
          const value = new asn1X509__namespace.AuthorityKeyIdentifier({ keyIdentifier: new asn1X509__namespace.KeyIdentifier(pvtsutils.Convert.FromHex(args[0])) });
          super(asn1X509__namespace.id_ce_authorityKeyIdentifier, args[1], asn1Schema.AsnConvert.serialize(value));
        } else {
          const certId = args[0];
          const certIdName = certId.name instanceof GeneralNames ? asn1Schema.AsnConvert.parse(certId.name.rawData, asn1X509__namespace.GeneralNames) : certId.name;
          const value = new asn1X509__namespace.AuthorityKeyIdentifier({
            authorityCertIssuer: certIdName,
            authorityCertSerialNumber: pvtsutils.Convert.FromHex(certId.serialNumber)
          });
          super(asn1X509__namespace.id_ce_authorityKeyIdentifier, args[1], asn1Schema.AsnConvert.serialize(value));
        }
      }
      onInit(asn) {
        super.onInit(asn);
        const aki = asn1Schema.AsnConvert.parse(asn.extnValue, asn1X509__namespace.AuthorityKeyIdentifier);
        if (aki.keyIdentifier) {
          this.keyId = pvtsutils.Convert.ToHex(aki.keyIdentifier);
        }
        if (aki.authorityCertIssuer && aki.authorityCertSerialNumber) {
          this.certId = {
            name: aki.authorityCertIssuer,
            serialNumber: pvtsutils.Convert.ToHex(aki.authorityCertSerialNumber)
          };
        }
      }
      toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        const asn = asn1Schema.AsnConvert.parse(this.value, asn1X509__namespace.AuthorityKeyIdentifier);
        if (asn.authorityCertIssuer) {
          obj["Authority Issuer"] = new GeneralNames(asn.authorityCertIssuer).toTextObject();
        }
        if (asn.authorityCertSerialNumber) {
          obj["Authority Serial Number"] = asn.authorityCertSerialNumber;
        }
        if (asn.keyIdentifier) {
          obj[""] = asn.keyIdentifier;
        }
        return obj;
      }
    };
    AuthorityKeyIdentifierExtension.NAME = "Authority Key Identifier";
    var BasicConstraintsExtension = class extends Extension {
      constructor(...args) {
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          super(args[0]);
          const value = asn1Schema.AsnConvert.parse(this.value, asn1X509.BasicConstraints);
          this.ca = value.cA;
          this.pathLength = value.pathLenConstraint;
        } else {
          const value = new asn1X509.BasicConstraints({
            cA: args[0],
            pathLenConstraint: args[1]
          });
          super(asn1X509.id_ce_basicConstraints, args[2], asn1Schema.AsnConvert.serialize(value));
          this.ca = args[0];
          this.pathLength = args[1];
        }
      }
      toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        if (this.ca) {
          obj["CA"] = this.ca;
        }
        if (this.pathLength !== void 0) {
          obj["Path Length"] = this.pathLength;
        }
        return obj;
      }
    };
    BasicConstraintsExtension.NAME = "Basic Constraints";
    exports.ExtendedKeyUsage = void 0;
    (function(ExtendedKeyUsage) {
      ExtendedKeyUsage["serverAuth"] = "1.3.6.1.5.5.7.3.1";
      ExtendedKeyUsage["clientAuth"] = "1.3.6.1.5.5.7.3.2";
      ExtendedKeyUsage["codeSigning"] = "1.3.6.1.5.5.7.3.3";
      ExtendedKeyUsage["emailProtection"] = "1.3.6.1.5.5.7.3.4";
      ExtendedKeyUsage["timeStamping"] = "1.3.6.1.5.5.7.3.8";
      ExtendedKeyUsage["ocspSigning"] = "1.3.6.1.5.5.7.3.9";
    })(exports.ExtendedKeyUsage || (exports.ExtendedKeyUsage = {}));
    var ExtendedKeyUsageExtension = class extends Extension {
      constructor(...args) {
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          super(args[0]);
          const value = asn1Schema.AsnConvert.parse(this.value, asn1X509__namespace.ExtendedKeyUsage);
          this.usages = value.map((o) => o);
        } else {
          const value = new asn1X509__namespace.ExtendedKeyUsage(args[0]);
          super(asn1X509__namespace.id_ce_extKeyUsage, args[1], asn1Schema.AsnConvert.serialize(value));
          this.usages = args[0];
        }
      }
      toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        obj[""] = this.usages.map((o) => OidSerializer.toString(o)).join(", ");
        return obj;
      }
    };
    ExtendedKeyUsageExtension.NAME = "Extended Key Usages";
    exports.KeyUsageFlags = void 0;
    (function(KeyUsageFlags) {
      KeyUsageFlags[KeyUsageFlags["digitalSignature"] = 1] = "digitalSignature";
      KeyUsageFlags[KeyUsageFlags["nonRepudiation"] = 2] = "nonRepudiation";
      KeyUsageFlags[KeyUsageFlags["keyEncipherment"] = 4] = "keyEncipherment";
      KeyUsageFlags[KeyUsageFlags["dataEncipherment"] = 8] = "dataEncipherment";
      KeyUsageFlags[KeyUsageFlags["keyAgreement"] = 16] = "keyAgreement";
      KeyUsageFlags[KeyUsageFlags["keyCertSign"] = 32] = "keyCertSign";
      KeyUsageFlags[KeyUsageFlags["cRLSign"] = 64] = "cRLSign";
      KeyUsageFlags[KeyUsageFlags["encipherOnly"] = 128] = "encipherOnly";
      KeyUsageFlags[KeyUsageFlags["decipherOnly"] = 256] = "decipherOnly";
    })(exports.KeyUsageFlags || (exports.KeyUsageFlags = {}));
    var KeyUsagesExtension = class extends Extension {
      constructor(...args) {
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          super(args[0]);
          const value = asn1Schema.AsnConvert.parse(this.value, asn1X509.KeyUsage);
          this.usages = value.toNumber();
        } else {
          const value = new asn1X509.KeyUsage(args[0]);
          super(asn1X509.id_ce_keyUsage, args[1], asn1Schema.AsnConvert.serialize(value));
          this.usages = args[0];
        }
      }
      toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        const asn = asn1Schema.AsnConvert.parse(this.value, asn1X509.KeyUsage);
        obj[""] = asn.toJSON().join(", ");
        return obj;
      }
    };
    KeyUsagesExtension.NAME = "Key Usages";
    var SubjectKeyIdentifierExtension = class _SubjectKeyIdentifierExtension extends Extension {
      static async create(publicKey, critical = false, crypto2 = cryptoProvider.get()) {
        let spki;
        if (publicKey instanceof PublicKey) {
          spki = publicKey.rawData;
        } else if ("publicKey" in publicKey) {
          spki = publicKey.publicKey.rawData;
        } else if (pvtsutils.BufferSourceConverter.isBufferSource(publicKey)) {
          spki = publicKey;
        } else {
          spki = await crypto2.subtle.exportKey("spki", publicKey);
        }
        const key = new PublicKey(spki);
        const id = await key.getKeyIdentifier(crypto2);
        return new _SubjectKeyIdentifierExtension(pvtsutils.Convert.ToHex(id), critical);
      }
      constructor(...args) {
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          super(args[0]);
          const value = asn1Schema.AsnConvert.parse(this.value, asn1X509__namespace.SubjectKeyIdentifier);
          this.keyId = pvtsutils.Convert.ToHex(value);
        } else {
          const identifier = typeof args[0] === "string" ? pvtsutils.Convert.FromHex(args[0]) : args[0];
          const value = new asn1X509__namespace.SubjectKeyIdentifier(identifier);
          super(asn1X509__namespace.id_ce_subjectKeyIdentifier, args[1], asn1Schema.AsnConvert.serialize(value));
          this.keyId = pvtsutils.Convert.ToHex(identifier);
        }
      }
      toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        const asn = asn1Schema.AsnConvert.parse(this.value, asn1X509__namespace.SubjectKeyIdentifier);
        obj[""] = asn;
        return obj;
      }
    };
    SubjectKeyIdentifierExtension.NAME = "Subject Key Identifier";
    var SubjectAlternativeNameExtension = class extends Extension {
      constructor(...args) {
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          super(args[0]);
        } else {
          super(asn1X509__namespace.id_ce_subjectAltName, args[1], new GeneralNames(args[0] || []).rawData);
        }
      }
      onInit(asn) {
        super.onInit(asn);
        const value = asn1Schema.AsnConvert.parse(asn.extnValue, asn1X509__namespace.SubjectAlternativeName);
        this.names = new GeneralNames(value);
      }
      toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        const namesObj = this.names.toTextObject();
        for (const key in namesObj) {
          obj[key] = namesObj[key];
        }
        return obj;
      }
    };
    SubjectAlternativeNameExtension.NAME = "Subject Alternative Name";
    var CertificatePolicyExtension = class extends Extension {
      constructor(...args) {
        var _a2;
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          super(args[0]);
          const asnPolicies = asn1Schema.AsnConvert.parse(this.value, asn1X509__namespace.CertificatePolicies);
          this.policies = asnPolicies.map((o) => o.policyIdentifier);
        } else {
          const policies = args[0];
          const critical = (_a2 = args[1]) !== null && _a2 !== void 0 ? _a2 : false;
          const value = new asn1X509__namespace.CertificatePolicies(policies.map((o) => new asn1X509__namespace.PolicyInformation({
            policyIdentifier: o
          })));
          super(asn1X509__namespace.id_ce_certificatePolicies, critical, asn1Schema.AsnConvert.serialize(value));
          this.policies = policies;
        }
      }
      toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        obj["Policy"] = this.policies.map((o) => new TextObject("", {}, OidSerializer.toString(o)));
        return obj;
      }
    };
    CertificatePolicyExtension.NAME = "Certificate Policies";
    ExtensionFactory.register(asn1X509__namespace.id_ce_certificatePolicies, CertificatePolicyExtension);
    var Attribute = class _Attribute extends AsnData {
      constructor(...args) {
        let raw;
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          raw = pvtsutils.BufferSourceConverter.toArrayBuffer(args[0]);
        } else {
          const type = args[0];
          const values = Array.isArray(args[1]) ? args[1].map((o) => pvtsutils.BufferSourceConverter.toArrayBuffer(o)) : [];
          raw = asn1Schema.AsnConvert.serialize(new asn1X509.Attribute({ type, values }));
        }
        super(raw, asn1X509.Attribute);
      }
      onInit(asn) {
        this.type = asn.type;
        this.values = asn.values;
      }
      toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        obj["Value"] = this.values.map((o) => new TextObject("", { "": o }));
        return obj;
      }
      toTextObjectWithoutValue() {
        const obj = this.toTextObjectEmpty();
        if (obj[TextObject.NAME] === _Attribute.NAME) {
          obj[TextObject.NAME] = OidSerializer.toString(this.type);
        }
        return obj;
      }
    };
    Attribute.NAME = "Attribute";
    var ChallengePasswordAttribute = class extends Attribute {
      constructor(...args) {
        var _a2;
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          super(args[0]);
        } else {
          const value = new asnPkcs9__namespace.ChallengePassword({
            printableString: args[0]
          });
          super(asnPkcs9__namespace.id_pkcs9_at_challengePassword, [asn1Schema.AsnConvert.serialize(value)]);
        }
        (_a2 = this.password) !== null && _a2 !== void 0 ? _a2 : this.password = "";
      }
      onInit(asn) {
        super.onInit(asn);
        if (this.values[0]) {
          const value = asn1Schema.AsnConvert.parse(this.values[0], asnPkcs9__namespace.ChallengePassword);
          this.password = value.toString();
        }
      }
      toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        obj[TextObject.VALUE] = this.password;
        return obj;
      }
    };
    ChallengePasswordAttribute.NAME = "Challenge Password";
    var ExtensionsAttribute = class extends Attribute {
      constructor(...args) {
        var _a2;
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          super(args[0]);
        } else {
          const extensions2 = args[0];
          const value = new asn1X509__namespace.Extensions();
          for (const extension of extensions2) {
            value.push(asn1Schema.AsnConvert.parse(extension.rawData, asn1X509__namespace.Extension));
          }
          super(asnPkcs9__namespace.id_pkcs9_at_extensionRequest, [asn1Schema.AsnConvert.serialize(value)]);
        }
        (_a2 = this.items) !== null && _a2 !== void 0 ? _a2 : this.items = [];
      }
      onInit(asn) {
        super.onInit(asn);
        if (this.values[0]) {
          const value = asn1Schema.AsnConvert.parse(this.values[0], asn1X509__namespace.Extensions);
          this.items = value.map((o) => ExtensionFactory.create(asn1Schema.AsnConvert.serialize(o)));
        }
      }
      toTextObject() {
        const obj = this.toTextObjectWithoutValue();
        const extensions2 = this.items.map((o) => o.toTextObject());
        for (const extension of extensions2) {
          obj[extension[TextObject.NAME]] = extension;
        }
        return obj;
      }
    };
    ExtensionsAttribute.NAME = "Extensions";
    var AttributeFactory = class {
      static register(id, type) {
        this.items.set(id, type);
      }
      static create(data) {
        const attribute = new Attribute(data);
        const Type = this.items.get(attribute.type);
        if (Type) {
          return new Type(data);
        }
        return attribute;
      }
    };
    AttributeFactory.items = /* @__PURE__ */ new Map();
    exports.RsaAlgorithm = class RsaAlgorithm {
      toAsnAlgorithm(alg) {
        switch (alg.name.toLowerCase()) {
          case "rsassa-pkcs1-v1_5":
            if ("hash" in alg) {
              let hash2;
              if (typeof alg.hash === "string") {
                hash2 = alg.hash;
              } else if (alg.hash && typeof alg.hash === "object" && "name" in alg.hash && typeof alg.hash.name === "string") {
                hash2 = alg.hash.name.toUpperCase();
              } else {
                throw new Error("Cannot get hash algorithm name");
              }
              switch (hash2.toLowerCase()) {
                case "sha-1":
                  return new asn1X509.AlgorithmIdentifier({ algorithm: asn1Rsa__namespace.id_sha1WithRSAEncryption, parameters: null });
                case "sha-256":
                  return new asn1X509.AlgorithmIdentifier({ algorithm: asn1Rsa__namespace.id_sha256WithRSAEncryption, parameters: null });
                case "sha-384":
                  return new asn1X509.AlgorithmIdentifier({ algorithm: asn1Rsa__namespace.id_sha384WithRSAEncryption, parameters: null });
                case "sha-512":
                  return new asn1X509.AlgorithmIdentifier({ algorithm: asn1Rsa__namespace.id_sha512WithRSAEncryption, parameters: null });
              }
            } else {
              return new asn1X509.AlgorithmIdentifier({ algorithm: asn1Rsa__namespace.id_rsaEncryption, parameters: null });
            }
        }
        return null;
      }
      toWebAlgorithm(alg) {
        switch (alg.algorithm) {
          case asn1Rsa__namespace.id_rsaEncryption:
            return { name: "RSASSA-PKCS1-v1_5" };
          case asn1Rsa__namespace.id_sha1WithRSAEncryption:
            return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-1" } };
          case asn1Rsa__namespace.id_sha256WithRSAEncryption:
            return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } };
          case asn1Rsa__namespace.id_sha384WithRSAEncryption:
            return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-384" } };
          case asn1Rsa__namespace.id_sha512WithRSAEncryption:
            return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-512" } };
        }
        return null;
      }
    };
    exports.RsaAlgorithm = tslib.__decorate([
      tsyringe.injectable()
    ], exports.RsaAlgorithm);
    tsyringe.container.registerSingleton(diAlgorithm, exports.RsaAlgorithm);
    var AsnEcSignatureFormatter = class _AsnEcSignatureFormatter {
      addPadding(pointSize, data) {
        const bytes = pvtsutils.BufferSourceConverter.toUint8Array(data);
        const res = new Uint8Array(pointSize);
        res.set(bytes, pointSize - bytes.length);
        return res;
      }
      removePadding(data, positive = false) {
        let bytes = pvtsutils.BufferSourceConverter.toUint8Array(data);
        for (let i = 0; i < bytes.length; i++) {
          if (!bytes[i]) {
            continue;
          }
          bytes = bytes.slice(i);
          break;
        }
        if (positive && bytes[0] > 127) {
          const result = new Uint8Array(bytes.length + 1);
          result.set(bytes, 1);
          return result.buffer;
        }
        return bytes.buffer;
      }
      toAsnSignature(algorithm, signature) {
        if (algorithm.name === "ECDSA") {
          const namedCurve = algorithm.namedCurve;
          const pointSize = _AsnEcSignatureFormatter.namedCurveSize.get(namedCurve) || _AsnEcSignatureFormatter.defaultNamedCurveSize;
          const ecSignature = new asn1Ecc.ECDSASigValue();
          const uint8Signature = pvtsutils.BufferSourceConverter.toUint8Array(signature);
          ecSignature.r = this.removePadding(uint8Signature.slice(0, pointSize), true);
          ecSignature.s = this.removePadding(uint8Signature.slice(pointSize, pointSize + pointSize), true);
          return asn1Schema.AsnConvert.serialize(ecSignature);
        }
        return null;
      }
      toWebSignature(algorithm, signature) {
        if (algorithm.name === "ECDSA") {
          const ecSigValue = asn1Schema.AsnConvert.parse(signature, asn1Ecc.ECDSASigValue);
          const namedCurve = algorithm.namedCurve;
          const pointSize = _AsnEcSignatureFormatter.namedCurveSize.get(namedCurve) || _AsnEcSignatureFormatter.defaultNamedCurveSize;
          const r = this.addPadding(pointSize, this.removePadding(ecSigValue.r));
          const s = this.addPadding(pointSize, this.removePadding(ecSigValue.s));
          return pvtsutils.combine(r, s);
        }
        return null;
      }
    };
    AsnEcSignatureFormatter.namedCurveSize = /* @__PURE__ */ new Map();
    AsnEcSignatureFormatter.defaultNamedCurveSize = 32;
    var idX25519 = "1.3.101.110";
    var idX448 = "1.3.101.111";
    var idEd25519 = "1.3.101.112";
    var idEd448 = "1.3.101.113";
    exports.EdAlgorithm = class EdAlgorithm {
      toAsnAlgorithm(alg) {
        let algorithm = null;
        switch (alg.name.toLowerCase()) {
          case "eddsa":
            switch (alg.namedCurve.toLowerCase()) {
              case "ed25519":
                algorithm = idEd25519;
                break;
              case "ed448":
                algorithm = idEd448;
                break;
            }
            break;
          case "ecdh-es":
            switch (alg.namedCurve.toLowerCase()) {
              case "x25519":
                algorithm = idX25519;
                break;
              case "x448":
                algorithm = idX448;
                break;
            }
        }
        if (algorithm) {
          return new asn1X509.AlgorithmIdentifier({
            algorithm
          });
        }
        return null;
      }
      toWebAlgorithm(alg) {
        switch (alg.algorithm) {
          case idEd25519:
            return { name: "EdDSA", namedCurve: "Ed25519" };
          case idEd448:
            return { name: "EdDSA", namedCurve: "Ed448" };
          case idX25519:
            return { name: "ECDH-ES", namedCurve: "X25519" };
          case idX448:
            return { name: "ECDH-ES", namedCurve: "X448" };
        }
        return null;
      }
    };
    exports.EdAlgorithm = tslib.__decorate([
      tsyringe.injectable()
    ], exports.EdAlgorithm);
    tsyringe.container.registerSingleton(diAlgorithm, exports.EdAlgorithm);
    var Pkcs10CertificateRequest = class extends PemData {
      constructor(param) {
        if (PemData.isAsnEncoded(param)) {
          super(param, asn1Csr.CertificationRequest);
        } else {
          super(param);
        }
        this.tag = PemConverter.CertificateRequestTag;
      }
      onInit(asn) {
        this.tbs = asn1Schema.AsnConvert.serialize(asn.certificationRequestInfo);
        this.publicKey = new PublicKey(asn.certificationRequestInfo.subjectPKInfo);
        const algProv = tsyringe.container.resolve(diAlgorithmProvider);
        this.signatureAlgorithm = algProv.toWebAlgorithm(asn.signatureAlgorithm);
        this.signature = asn.signature;
        this.attributes = asn.certificationRequestInfo.attributes.map((o) => AttributeFactory.create(asn1Schema.AsnConvert.serialize(o)));
        const extensions2 = this.getAttribute(asnPkcs9.id_pkcs9_at_extensionRequest);
        this.extensions = [];
        if (extensions2 instanceof ExtensionsAttribute) {
          this.extensions = extensions2.items;
        }
        this.subjectName = new Name(asn.certificationRequestInfo.subject);
        this.subject = this.subjectName.toString();
      }
      getAttribute(type) {
        for (const attr of this.attributes) {
          if (attr.type === type) {
            return attr;
          }
        }
        return null;
      }
      getAttributes(type) {
        return this.attributes.filter((o) => o.type === type);
      }
      getExtension(type) {
        for (const ext of this.extensions) {
          if (ext.type === type) {
            return ext;
          }
        }
        return null;
      }
      getExtensions(type) {
        return this.extensions.filter((o) => o.type === type);
      }
      async verify(crypto2 = cryptoProvider.get()) {
        const algorithm = { ...this.publicKey.algorithm, ...this.signatureAlgorithm };
        const publicKey = await this.publicKey.export(algorithm, ["verify"], crypto2);
        const signatureFormatters = tsyringe.container.resolveAll(diAsnSignatureFormatter).reverse();
        let signature = null;
        for (const signatureFormatter of signatureFormatters) {
          signature = signatureFormatter.toWebSignature(algorithm, this.signature);
          if (signature) {
            break;
          }
        }
        if (!signature) {
          throw Error("Cannot convert WebCrypto signature value to ASN.1 format");
        }
        const ok = await crypto2.subtle.verify(this.signatureAlgorithm, publicKey, signature, this.tbs);
        return ok;
      }
      toTextObject() {
        const obj = this.toTextObjectEmpty();
        const req = asn1Schema.AsnConvert.parse(this.rawData, asn1Csr.CertificationRequest);
        const tbs = req.certificationRequestInfo;
        const data = new TextObject("", {
          "Version": `${asn1X509.Version[tbs.version]} (${tbs.version})`,
          "Subject": this.subject,
          "Subject Public Key Info": this.publicKey
        });
        if (this.attributes.length) {
          const attrs = new TextObject("");
          for (const ext of this.attributes) {
            const attrObj = ext.toTextObject();
            attrs[attrObj[TextObject.NAME]] = attrObj;
          }
          data["Attributes"] = attrs;
        }
        obj["Data"] = data;
        obj["Signature"] = new TextObject("", {
          "Algorithm": TextConverter.serializeAlgorithm(req.signatureAlgorithm),
          "": req.signature
        });
        return obj;
      }
    };
    Pkcs10CertificateRequest.NAME = "PKCS#10 Certificate Request";
    var Pkcs10CertificateRequestGenerator = class {
      static async create(params, crypto2 = cryptoProvider.get()) {
        if (!params.keys.privateKey) {
          throw new Error("Bad field 'keys' in 'params' argument. 'privateKey' is empty");
        }
        if (!params.keys.publicKey) {
          throw new Error("Bad field 'keys' in 'params' argument. 'publicKey' is empty");
        }
        const spki = await crypto2.subtle.exportKey("spki", params.keys.publicKey);
        const asnReq = new asn1Csr.CertificationRequest({
          certificationRequestInfo: new asn1Csr.CertificationRequestInfo({
            subjectPKInfo: asn1Schema.AsnConvert.parse(spki, asn1X509.SubjectPublicKeyInfo)
          })
        });
        if (params.name) {
          const name = params.name instanceof Name ? params.name : new Name(params.name);
          asnReq.certificationRequestInfo.subject = asn1Schema.AsnConvert.parse(name.toArrayBuffer(), asn1X509.Name);
        }
        if (params.attributes) {
          for (const o of params.attributes) {
            asnReq.certificationRequestInfo.attributes.push(asn1Schema.AsnConvert.parse(o.rawData, asn1X509.Attribute));
          }
        }
        if (params.extensions && params.extensions.length) {
          const attr = new asn1X509.Attribute({ type: asnPkcs9.id_pkcs9_at_extensionRequest });
          const extensions2 = new asn1X509.Extensions();
          for (const o of params.extensions) {
            extensions2.push(asn1Schema.AsnConvert.parse(o.rawData, asn1X509.Extension));
          }
          attr.values.push(asn1Schema.AsnConvert.serialize(extensions2));
          asnReq.certificationRequestInfo.attributes.push(attr);
        }
        const signingAlgorithm = { ...params.signingAlgorithm, ...params.keys.privateKey.algorithm };
        const algProv = tsyringe.container.resolve(diAlgorithmProvider);
        asnReq.signatureAlgorithm = algProv.toAsnAlgorithm(signingAlgorithm);
        const tbs = asn1Schema.AsnConvert.serialize(asnReq.certificationRequestInfo);
        const signature = await crypto2.subtle.sign(signingAlgorithm, params.keys.privateKey, tbs);
        const signatureFormatters = tsyringe.container.resolveAll(diAsnSignatureFormatter).reverse();
        let asnSignature = null;
        for (const signatureFormatter of signatureFormatters) {
          asnSignature = signatureFormatter.toAsnSignature(signingAlgorithm, signature);
          if (asnSignature) {
            break;
          }
        }
        if (!asnSignature) {
          throw Error("Cannot convert WebCrypto signature value to ASN.1 format");
        }
        asnReq.signature = asnSignature;
        return new Pkcs10CertificateRequest(asn1Schema.AsnConvert.serialize(asnReq));
      }
    };
    var X509Certificates = class extends Array {
      constructor(param) {
        super();
        if (PemData.isAsnEncoded(param)) {
          this.import(param);
        } else if (param instanceof X509Certificate) {
          this.push(param);
        } else if (Array.isArray(param)) {
          for (const item of param) {
            this.push(item);
          }
        }
      }
      export(format) {
        const signedData = new asn1Cms__namespace.SignedData();
        signedData.version = 1;
        signedData.encapContentInfo.eContentType = asn1Cms__namespace.id_data;
        signedData.encapContentInfo.eContent = new asn1Cms__namespace.EncapsulatedContent({
          single: new asn1Schema.OctetString()
        });
        signedData.certificates = new asn1Cms__namespace.CertificateSet(this.map((o) => new asn1Cms__namespace.CertificateChoices({
          certificate: asn1Schema.AsnConvert.parse(o.rawData, asn1X509.Certificate)
        })));
        const cms = new asn1Cms__namespace.ContentInfo({
          contentType: asn1Cms__namespace.id_signedData,
          content: asn1Schema.AsnConvert.serialize(signedData)
        });
        const raw = asn1Schema.AsnConvert.serialize(cms);
        if (format === "raw") {
          return raw;
        }
        return this.toString(format);
      }
      import(data) {
        const raw = PemData.toArrayBuffer(data);
        const cms = asn1Schema.AsnConvert.parse(raw, asn1Cms__namespace.ContentInfo);
        if (cms.contentType !== asn1Cms__namespace.id_signedData) {
          throw new TypeError("Cannot parse CMS package. Incoming data is not a SignedData object.");
        }
        const signedData = asn1Schema.AsnConvert.parse(cms.content, asn1Cms__namespace.SignedData);
        this.clear();
        for (const item of signedData.certificates || []) {
          if (item.certificate) {
            this.push(new X509Certificate(item.certificate));
          }
        }
      }
      clear() {
        while (this.pop()) {
        }
      }
      toString(format = "pem") {
        const raw = this.export("raw");
        switch (format) {
          case "pem":
            return PemConverter.encode(raw, "CMS");
          case "pem-chain":
            return this.map((o) => o.toString("pem")).join("\n");
          case "asn":
            return asn1Schema.AsnConvert.toString(raw);
          case "hex":
            return pvtsutils.Convert.ToHex(raw);
          case "base64":
            return pvtsutils.Convert.ToBase64(raw);
          case "base64url":
            return pvtsutils.Convert.ToBase64Url(raw);
          case "text":
            return TextConverter.serialize(this.toTextObject());
          default:
            throw TypeError("Argument 'format' is unsupported value");
        }
      }
      toTextObject() {
        const contentInfo = asn1Schema.AsnConvert.parse(this.export("raw"), asn1Cms__namespace.ContentInfo);
        const signedData = asn1Schema.AsnConvert.parse(contentInfo.content, asn1Cms__namespace.SignedData);
        const obj = new TextObject("X509Certificates", {
          "Content Type": OidSerializer.toString(contentInfo.contentType),
          "Content": new TextObject("", {
            "Version": `${asn1Cms__namespace.CMSVersion[signedData.version]} (${signedData.version})`,
            "Certificates": new TextObject("", { "Certificate": this.map((o) => o.toTextObject()) })
          })
        });
        return obj;
      }
    };
    var X509ChainBuilder = class {
      constructor(params = {}) {
        this.certificates = [];
        if (params.certificates) {
          this.certificates = params.certificates;
        }
      }
      async build(cert, crypto2 = cryptoProvider.get()) {
        const chain = new X509Certificates(cert);
        let current = cert;
        while (current = await this.findIssuer(current, crypto2)) {
          const thumbprint = await current.getThumbprint(crypto2);
          for (const item of chain) {
            const thumbprint2 = await item.getThumbprint(crypto2);
            if (pvtsutils.isEqual(thumbprint, thumbprint2)) {
              throw new Error("Cannot build a certificate chain. Circular dependency.");
            }
          }
          chain.push(current);
        }
        return chain;
      }
      async findIssuer(cert, crypto2 = cryptoProvider.get()) {
        if (!await cert.isSelfSigned(crypto2)) {
          const akiExt = cert.getExtension(asn1X509__namespace.id_ce_authorityKeyIdentifier);
          for (const item of this.certificates) {
            if (item.subject !== cert.issuer) {
              continue;
            }
            if (akiExt) {
              if (akiExt.keyId) {
                const skiExt = item.getExtension(asn1X509__namespace.id_ce_subjectKeyIdentifier);
                if (skiExt && skiExt.keyId !== akiExt.keyId) {
                  continue;
                }
              } else if (akiExt.certId) {
                const sanExt = item.getExtension(asn1X509__namespace.id_ce_subjectAltName);
                if (sanExt && !(akiExt.certId.serialNumber === item.serialNumber && pvtsutils.isEqual(asn1Schema.AsnConvert.serialize(akiExt.certId.name), asn1Schema.AsnConvert.serialize(sanExt)))) {
                  continue;
                }
              }
            }
            if (!await cert.verify({
              publicKey: await item.publicKey.export(cert.signatureAlgorithm, ["verify"], crypto2),
              signatureOnly: true
            }, crypto2)) {
              continue;
            }
            return item;
          }
        }
        return null;
      }
    };
    var X509CertificateGenerator = class {
      static async createSelfSigned(params, crypto2 = cryptoProvider.get()) {
        if (!params.keys.privateKey) {
          throw new Error("Bad field 'keys' in 'params' argument. 'privateKey' is empty");
        }
        if (!params.keys.publicKey) {
          throw new Error("Bad field 'keys' in 'params' argument. 'privateKey' is empty");
        }
        return this.create({
          serialNumber: params.serialNumber,
          subject: params.name,
          issuer: params.name,
          notBefore: params.notBefore,
          notAfter: params.notAfter,
          publicKey: params.keys.publicKey,
          signingKey: params.keys.privateKey,
          signingAlgorithm: params.signingAlgorithm,
          extensions: params.extensions
        }, crypto2);
      }
      static async create(params, crypto2 = cryptoProvider.get()) {
        var _a2;
        let spki;
        if (params.publicKey instanceof PublicKey) {
          spki = params.publicKey.rawData;
        } else if ("publicKey" in params.publicKey) {
          spki = params.publicKey.publicKey.rawData;
        } else if (pvtsutils.BufferSourceConverter.isBufferSource(params.publicKey)) {
          spki = params.publicKey;
        } else {
          spki = await crypto2.subtle.exportKey("spki", params.publicKey);
        }
        const asnX509 = new asn1X509__namespace.Certificate({
          tbsCertificate: new asn1X509__namespace.TBSCertificate({
            version: asn1X509__namespace.Version.v3,
            serialNumber: pvtsutils.Convert.FromHex(params.serialNumber),
            validity: new asn1X509__namespace.Validity({
              notBefore: params.notBefore,
              notAfter: params.notAfter
            }),
            extensions: new asn1X509__namespace.Extensions(((_a2 = params.extensions) === null || _a2 === void 0 ? void 0 : _a2.map((o) => asn1Schema.AsnConvert.parse(o.rawData, asn1X509__namespace.Extension))) || []),
            subjectPublicKeyInfo: asn1Schema.AsnConvert.parse(spki, asn1X509__namespace.SubjectPublicKeyInfo)
          })
        });
        if (params.subject) {
          const name = params.subject instanceof Name ? params.subject : new Name(params.subject);
          asnX509.tbsCertificate.subject = asn1Schema.AsnConvert.parse(name.toArrayBuffer(), asn1X509__namespace.Name);
        }
        if (params.issuer) {
          const name = params.issuer instanceof Name ? params.issuer : new Name(params.issuer);
          asnX509.tbsCertificate.issuer = asn1Schema.AsnConvert.parse(name.toArrayBuffer(), asn1X509__namespace.Name);
        }
        const signatureAlgorithm = "signingKey" in params ? { ...params.signingAlgorithm, ...params.signingKey.algorithm } : params.publicKey.algorithm;
        const algProv = tsyringe.container.resolve(diAlgorithmProvider);
        asnX509.tbsCertificate.signature = asnX509.signatureAlgorithm = algProv.toAsnAlgorithm(signatureAlgorithm);
        const tbs = asn1Schema.AsnConvert.serialize(asnX509.tbsCertificate);
        const signatureValue = "signingKey" in params ? await crypto2.subtle.sign(signatureAlgorithm, params.signingKey, tbs) : params.signature;
        const signatureFormatters = tsyringe.container.resolveAll(diAsnSignatureFormatter).reverse();
        let asnSignature = null;
        for (const signatureFormatter of signatureFormatters) {
          asnSignature = signatureFormatter.toAsnSignature(signatureAlgorithm, signatureValue);
          if (asnSignature) {
            break;
          }
        }
        if (!asnSignature) {
          throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
        }
        asnX509.signatureValue = asnSignature;
        return new X509Certificate(asn1Schema.AsnConvert.serialize(asnX509));
      }
    };
    exports.X509CrlReason = void 0;
    (function(X509CrlReason) {
      X509CrlReason[X509CrlReason["unspecified"] = 0] = "unspecified";
      X509CrlReason[X509CrlReason["keyCompromise"] = 1] = "keyCompromise";
      X509CrlReason[X509CrlReason["cACompromise"] = 2] = "cACompromise";
      X509CrlReason[X509CrlReason["affiliationChanged"] = 3] = "affiliationChanged";
      X509CrlReason[X509CrlReason["superseded"] = 4] = "superseded";
      X509CrlReason[X509CrlReason["cessationOfOperation"] = 5] = "cessationOfOperation";
      X509CrlReason[X509CrlReason["certificateHold"] = 6] = "certificateHold";
      X509CrlReason[X509CrlReason["removeFromCRL"] = 8] = "removeFromCRL";
      X509CrlReason[X509CrlReason["privilegeWithdrawn"] = 9] = "privilegeWithdrawn";
      X509CrlReason[X509CrlReason["aACompromise"] = 10] = "aACompromise";
    })(exports.X509CrlReason || (exports.X509CrlReason = {}));
    var X509CrlEntry = class extends AsnData {
      constructor(...args) {
        let raw;
        if (pvtsutils.BufferSourceConverter.isBufferSource(args[0])) {
          raw = pvtsutils.BufferSourceConverter.toArrayBuffer(args[0]);
        } else {
          raw = asn1Schema.AsnConvert.serialize(new asn1X509.RevokedCertificate({
            userCertificate: args[0],
            revocationDate: new asn1X509.Time(args[1]),
            crlEntryExtensions: args[2]
          }));
        }
        super(raw, asn1X509.RevokedCertificate);
      }
      onInit(asn) {
        this.serialNumber = pvtsutils.Convert.ToHex(asn.userCertificate);
        this.revocationDate = asn.revocationDate.getTime();
        this.extensions = [];
        if (asn.crlEntryExtensions) {
          this.extensions = asn.crlEntryExtensions.map((o) => {
            const extension = ExtensionFactory.create(asn1Schema.AsnConvert.serialize(o));
            switch (extension.type) {
              case asn1X509.id_ce_cRLReasons:
                this.reason = asn1Schema.AsnConvert.parse(extension.value, asn1X509.CRLReason).reason;
                break;
              case asn1X509.id_ce_invalidityDate:
                this.invalidity = asn1Schema.AsnConvert.parse(extension.value, asn1X509.InvalidityDate).value;
                break;
            }
            return extension;
          });
        }
      }
    };
    var X509Crl = class extends PemData {
      constructor(param) {
        if (PemData.isAsnEncoded(param)) {
          super(param, asn1X509.CertificateList);
        } else {
          super(param);
        }
        this.tag = PemConverter.CrlTag;
      }
      onInit(asn) {
        var _a2, _b;
        const tbs = asn.tbsCertList;
        this.tbs = asn1Schema.AsnConvert.serialize(tbs);
        this.version = tbs.version;
        const algProv = tsyringe.container.resolve(diAlgorithmProvider);
        this.signatureAlgorithm = algProv.toWebAlgorithm(asn.signatureAlgorithm);
        this.tbsCertListSignatureAlgorithm = tbs.signature;
        this.certListSignatureAlgorithm = asn.signatureAlgorithm;
        this.signature = asn.signature;
        this.issuerName = new Name(tbs.issuer);
        this.issuer = this.issuerName.toString();
        const thisUpdate = tbs.thisUpdate.getTime();
        if (!thisUpdate) {
          throw new Error("Cannot get 'thisUpdate' value");
        }
        this.thisUpdate = thisUpdate;
        const nextUpdate = (_a2 = tbs.nextUpdate) === null || _a2 === void 0 ? void 0 : _a2.getTime();
        this.nextUpdate = nextUpdate;
        this.entries = ((_b = tbs.revokedCertificates) === null || _b === void 0 ? void 0 : _b.map((o) => new X509CrlEntry(asn1Schema.AsnConvert.serialize(o)))) || [];
        this.extensions = [];
        if (tbs.crlExtensions) {
          this.extensions = tbs.crlExtensions.map((o) => ExtensionFactory.create(asn1Schema.AsnConvert.serialize(o)));
        }
      }
      getExtension(type) {
        for (const ext of this.extensions) {
          if (typeof type === "string") {
            if (ext.type === type) {
              return ext;
            }
          } else {
            if (ext instanceof type) {
              return ext;
            }
          }
        }
        return null;
      }
      getExtensions(type) {
        return this.extensions.filter((o) => {
          if (typeof type === "string") {
            return o.type === type;
          } else {
            return o instanceof type;
          }
        });
      }
      async verify(params, crypto2 = cryptoProvider.get()) {
        if (!this.certListSignatureAlgorithm.isEqual(this.tbsCertListSignatureAlgorithm)) {
          throw new Error("algorithm identifier in the sequence tbsCertList and CertificateList mismatch");
        }
        let keyAlgorithm;
        let publicKey;
        const paramsKey = params.publicKey;
        try {
          if (paramsKey instanceof X509Certificate) {
            keyAlgorithm = {
              ...paramsKey.publicKey.algorithm,
              ...paramsKey.signatureAlgorithm
            };
            publicKey = await paramsKey.publicKey.export(keyAlgorithm, ["verify"]);
          } else if (paramsKey instanceof PublicKey) {
            keyAlgorithm = { ...paramsKey.algorithm, ...this.signature };
            publicKey = await paramsKey.export(keyAlgorithm, ["verify"]);
          } else {
            keyAlgorithm = { ...paramsKey.algorithm, ...this.signature };
            publicKey = paramsKey;
          }
        } catch (e) {
          return false;
        }
        const signatureFormatters = tsyringe.container.resolveAll(diAsnSignatureFormatter).reverse();
        let signature = null;
        for (const signatureFormatter of signatureFormatters) {
          signature = signatureFormatter.toWebSignature(keyAlgorithm, this.signature);
          if (signature) {
            break;
          }
        }
        if (!signature) {
          throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
        }
        return await crypto2.subtle.verify(this.signatureAlgorithm, publicKey, signature, this.tbs);
      }
      async getThumbprint(...args) {
        let crypto2;
        let algorithm = "SHA-1";
        if (args[0]) {
          if (!args[0].subtle) {
            algorithm = args[0] || algorithm;
            crypto2 = args[1];
          } else {
            crypto2 = args[0];
          }
        }
        crypto2 !== null && crypto2 !== void 0 ? crypto2 : crypto2 = cryptoProvider.get();
        return await crypto2.subtle.digest(algorithm, this.rawData);
      }
      findRevoked(certOrSerialNumber) {
        const serialNumber = typeof certOrSerialNumber === "string" ? certOrSerialNumber : certOrSerialNumber.serialNumber;
        for (const entry of this.entries) {
          if (entry.serialNumber === serialNumber) {
            return entry;
          }
        }
        return null;
      }
    };
    var X509CrlGenerator = class {
      static async create(params, crypto2 = cryptoProvider.get()) {
        var _a2;
        const name = params.issuer instanceof Name ? params.issuer : new Name(params.issuer);
        const asnX509Crl = new asn1X509__namespace.CertificateList({
          tbsCertList: new asn1X509__namespace.TBSCertList({
            version: asn1X509__namespace.Version.v2,
            issuer: asn1Schema.AsnConvert.parse(name.toArrayBuffer(), asn1X509__namespace.Name),
            thisUpdate: new asn1X509.Time(params.thisUpdate || /* @__PURE__ */ new Date())
          })
        });
        if (params.nextUpdate) {
          asnX509Crl.tbsCertList.nextUpdate = new asn1X509.Time(params.nextUpdate);
        }
        if (params.extensions && params.extensions.length) {
          asnX509Crl.tbsCertList.crlExtensions = new asn1X509__namespace.Extensions(params.extensions.map((o) => asn1Schema.AsnConvert.parse(o.rawData, asn1X509__namespace.Extension)) || []);
        }
        if (params.entries && params.entries.length) {
          asnX509Crl.tbsCertList.revokedCertificates = [];
          for (const entry of params.entries) {
            const userCertificate = PemData.toArrayBuffer(entry.serialNumber);
            const index = asnX509Crl.tbsCertList.revokedCertificates.findIndex((cert) => pvtsutils.isEqual(cert.userCertificate, userCertificate));
            if (index > -1) {
              throw new Error(`Certificate serial number ${entry.serialNumber} already exists in tbsCertList`);
            }
            const revokedCert = new asn1X509.RevokedCertificate({
              userCertificate,
              revocationDate: new asn1X509.Time(entry.revocationDate || /* @__PURE__ */ new Date())
            });
            if ("extensions" in entry && ((_a2 = entry.extensions) === null || _a2 === void 0 ? void 0 : _a2.length)) {
              revokedCert.crlEntryExtensions = entry.extensions.map((o) => asn1Schema.AsnConvert.parse(o.rawData, asn1X509__namespace.Extension));
            } else {
              revokedCert.crlEntryExtensions = [];
            }
            if (!(entry instanceof X509CrlEntry)) {
              if (entry.reason) {
                revokedCert.crlEntryExtensions.push(new asn1X509__namespace.Extension({
                  extnID: asn1X509__namespace.id_ce_cRLReasons,
                  critical: false,
                  extnValue: new asn1Schema.OctetString(asn1Schema.AsnConvert.serialize(new asn1X509__namespace.CRLReason(entry.reason)))
                }));
              }
              if (entry.invalidity) {
                revokedCert.crlEntryExtensions.push(new asn1X509__namespace.Extension({
                  extnID: asn1X509__namespace.id_ce_invalidityDate,
                  critical: false,
                  extnValue: new asn1Schema.OctetString(asn1Schema.AsnConvert.serialize(new asn1X509__namespace.InvalidityDate(entry.invalidity)))
                }));
              }
              if (entry.issuer) {
                const name2 = params.issuer instanceof Name ? params.issuer : new Name(params.issuer);
                revokedCert.crlEntryExtensions.push(new asn1X509__namespace.Extension({
                  extnID: asn1X509__namespace.id_ce_certificateIssuer,
                  critical: false,
                  extnValue: new asn1Schema.OctetString(asn1Schema.AsnConvert.serialize(asn1Schema.AsnConvert.parse(name2.toArrayBuffer(), asn1X509__namespace.Name)))
                }));
              }
            }
            asnX509Crl.tbsCertList.revokedCertificates.push(revokedCert);
          }
        }
        const signingAlgorithm = { ...params.signingAlgorithm, ...params.signingKey.algorithm };
        const algProv = tsyringe.container.resolve(diAlgorithmProvider);
        asnX509Crl.tbsCertList.signature = asnX509Crl.signatureAlgorithm = algProv.toAsnAlgorithm(signingAlgorithm);
        const tbs = asn1Schema.AsnConvert.serialize(asnX509Crl.tbsCertList);
        const signature = await crypto2.subtle.sign(signingAlgorithm, params.signingKey, tbs);
        const signatureFormatters = tsyringe.container.resolveAll(diAsnSignatureFormatter).reverse();
        let asnSignature = null;
        for (const signatureFormatter of signatureFormatters) {
          asnSignature = signatureFormatter.toAsnSignature(signingAlgorithm, signature);
          if (asnSignature) {
            break;
          }
        }
        if (!asnSignature) {
          throw Error("Cannot convert ASN.1 signature value to WebCrypto format");
        }
        asnX509Crl.signature = asnSignature;
        return new X509Crl(asn1Schema.AsnConvert.serialize(asnX509Crl));
      }
    };
    ExtensionFactory.register(asn1X509__namespace.id_ce_basicConstraints, BasicConstraintsExtension);
    ExtensionFactory.register(asn1X509__namespace.id_ce_extKeyUsage, ExtendedKeyUsageExtension);
    ExtensionFactory.register(asn1X509__namespace.id_ce_keyUsage, KeyUsagesExtension);
    ExtensionFactory.register(asn1X509__namespace.id_ce_subjectKeyIdentifier, SubjectKeyIdentifierExtension);
    ExtensionFactory.register(asn1X509__namespace.id_ce_authorityKeyIdentifier, AuthorityKeyIdentifierExtension);
    ExtensionFactory.register(asn1X509__namespace.id_ce_subjectAltName, SubjectAlternativeNameExtension);
    AttributeFactory.register(asnPkcs9__namespace.id_pkcs9_at_challengePassword, ChallengePasswordAttribute);
    AttributeFactory.register(asnPkcs9__namespace.id_pkcs9_at_extensionRequest, ExtensionsAttribute);
    tsyringe.container.registerSingleton(diAsnSignatureFormatter, AsnDefaultSignatureFormatter);
    tsyringe.container.registerSingleton(diAsnSignatureFormatter, AsnEcSignatureFormatter);
    AsnEcSignatureFormatter.namedCurveSize.set("P-256", 32);
    AsnEcSignatureFormatter.namedCurveSize.set("K-256", 32);
    AsnEcSignatureFormatter.namedCurveSize.set("P-384", 48);
    AsnEcSignatureFormatter.namedCurveSize.set("P-521", 66);
    exports.AlgorithmProvider = AlgorithmProvider;
    exports.AsnData = AsnData;
    exports.AsnDefaultSignatureFormatter = AsnDefaultSignatureFormatter;
    exports.AsnEcSignatureFormatter = AsnEcSignatureFormatter;
    exports.Attribute = Attribute;
    exports.AttributeFactory = AttributeFactory;
    exports.AuthorityKeyIdentifierExtension = AuthorityKeyIdentifierExtension;
    exports.BasicConstraintsExtension = BasicConstraintsExtension;
    exports.CertificatePolicyExtension = CertificatePolicyExtension;
    exports.ChallengePasswordAttribute = ChallengePasswordAttribute;
    exports.CryptoProvider = CryptoProvider;
    exports.DefaultAlgorithmSerializer = DefaultAlgorithmSerializer;
    exports.ExtendedKeyUsageExtension = ExtendedKeyUsageExtension;
    exports.Extension = Extension;
    exports.ExtensionFactory = ExtensionFactory;
    exports.ExtensionsAttribute = ExtensionsAttribute;
    exports.GeneralName = GeneralName;
    exports.GeneralNames = GeneralNames;
    exports.KeyUsagesExtension = KeyUsagesExtension;
    exports.Name = Name;
    exports.NameIdentifier = NameIdentifier;
    exports.OidSerializer = OidSerializer;
    exports.PemConverter = PemConverter;
    exports.Pkcs10CertificateRequest = Pkcs10CertificateRequest;
    exports.Pkcs10CertificateRequestGenerator = Pkcs10CertificateRequestGenerator;
    exports.PublicKey = PublicKey;
    exports.SubjectAlternativeNameExtension = SubjectAlternativeNameExtension;
    exports.SubjectKeyIdentifierExtension = SubjectKeyIdentifierExtension;
    exports.TextConverter = TextConverter;
    exports.TextObject = TextObject;
    exports.X509Certificate = X509Certificate;
    exports.X509CertificateGenerator = X509CertificateGenerator;
    exports.X509Certificates = X509Certificates;
    exports.X509ChainBuilder = X509ChainBuilder;
    exports.X509Crl = X509Crl;
    exports.X509CrlEntry = X509CrlEntry;
    exports.X509CrlGenerator = X509CrlGenerator;
    exports.cryptoProvider = cryptoProvider;
    exports.diAlgorithm = diAlgorithm;
    exports.diAlgorithmProvider = diAlgorithmProvider;
    exports.diAsnSignatureFormatter = diAsnSignatureFormatter;
    exports.idEd25519 = idEd25519;
    exports.idEd448 = idEd448;
    exports.idX25519 = idX25519;
    exports.idX448 = idX448;
  }
});

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default, isCryptoKey;
var init_webcrypto = __esm({
  "node_modules/jose/dist/browser/runtime/webcrypto.js"() {
    webcrypto_default = crypto;
    isCryptoKey = (key) => key instanceof CryptoKey;
  }
});

// node_modules/jose/dist/browser/runtime/digest.js
var digest, digest_default;
var init_digest = __esm({
  "node_modules/jose/dist/browser/runtime/digest.js"() {
    init_webcrypto();
    digest = async (algorithm, data) => {
      const subtleDigest = `SHA-${algorithm.slice(-3)}`;
      return new Uint8Array(await webcrypto_default.subtle.digest(subtleDigest, data));
    };
    digest_default = digest;
  }
});

// node_modules/jose/dist/browser/lib/buffer_utils.js
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}
function p2s(alg, p2sInput) {
  return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);
}
function writeUInt32BE(buf, value, offset) {
  if (value < 0 || value >= MAX_INT32) {
    throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
  }
  buf.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset);
}
function uint64be(value) {
  const high = Math.floor(value / MAX_INT32);
  const low = value % MAX_INT32;
  const buf = new Uint8Array(8);
  writeUInt32BE(buf, high, 0);
  writeUInt32BE(buf, low, 4);
  return buf;
}
function uint32be(value) {
  const buf = new Uint8Array(4);
  writeUInt32BE(buf, value);
  return buf;
}
function lengthAndInput(input) {
  return concat(uint32be(input.length), input);
}
async function concatKdf(secret, bits, value) {
  const iterations = Math.ceil((bits >> 3) / 32);
  const res = new Uint8Array(iterations * 32);
  for (let iter = 0; iter < iterations; iter++) {
    const buf = new Uint8Array(4 + secret.length + value.length);
    buf.set(uint32be(iter + 1));
    buf.set(secret, 4);
    buf.set(value, 4 + secret.length);
    res.set(await digest_default("sha256", buf), iter * 32);
  }
  return res.slice(0, bits >> 3);
}
var encoder, decoder2, MAX_INT32;
var init_buffer_utils = __esm({
  "node_modules/jose/dist/browser/lib/buffer_utils.js"() {
    init_digest();
    encoder = new TextEncoder();
    decoder2 = new TextDecoder();
    MAX_INT32 = 2 ** 32;
  }
});

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64, encode2, decodeBase64, decode2;
var init_base64url = __esm({
  "node_modules/jose/dist/browser/runtime/base64url.js"() {
    init_buffer_utils();
    encodeBase64 = (input) => {
      let unencoded = input;
      if (typeof unencoded === "string") {
        unencoded = encoder.encode(unencoded);
      }
      const CHUNK_SIZE = 32768;
      const arr = [];
      for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
      }
      return btoa(arr.join(""));
    };
    encode2 = (input) => {
      return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    };
    decodeBase64 = (encoded) => {
      const binary = atob(encoded);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    };
    decode2 = (input) => {
      let encoded = input;
      if (encoded instanceof Uint8Array) {
        encoded = decoder2.decode(encoded);
      }
      encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
      try {
        return decodeBase64(encoded);
      } catch (_a) {
        throw new TypeError("The input to be decoded is not correctly encoded.");
      }
    };
  }
});

// node_modules/jose/dist/browser/util/errors.js
var errors_exports = {};
__export(errors_exports, {
  JOSEAlgNotAllowed: () => JOSEAlgNotAllowed,
  JOSEError: () => JOSEError,
  JOSENotSupported: () => JOSENotSupported,
  JWEDecryptionFailed: () => JWEDecryptionFailed,
  JWEInvalid: () => JWEInvalid,
  JWKInvalid: () => JWKInvalid,
  JWKSInvalid: () => JWKSInvalid,
  JWKSMultipleMatchingKeys: () => JWKSMultipleMatchingKeys,
  JWKSNoMatchingKey: () => JWKSNoMatchingKey,
  JWKSTimeout: () => JWKSTimeout,
  JWSInvalid: () => JWSInvalid,
  JWSSignatureVerificationFailed: () => JWSSignatureVerificationFailed,
  JWTClaimValidationFailed: () => JWTClaimValidationFailed,
  JWTExpired: () => JWTExpired,
  JWTInvalid: () => JWTInvalid
});
var JOSEError, JWTClaimValidationFailed, JWTExpired, JOSEAlgNotAllowed, JOSENotSupported, JWEDecryptionFailed, JWEInvalid, JWSInvalid, JWTInvalid, JWKInvalid, JWKSInvalid, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, JWKSTimeout, JWSSignatureVerificationFailed;
var init_errors = __esm({
  "node_modules/jose/dist/browser/util/errors.js"() {
    JOSEError = class extends Error {
      static get code() {
        return "ERR_JOSE_GENERIC";
      }
      constructor(message3) {
        var _a;
        super(message3);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
      }
    };
    JWTClaimValidationFailed = class extends JOSEError {
      static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
      }
      constructor(message3, claim = "unspecified", reason = "unspecified") {
        super(message3);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JWTExpired = class extends JOSEError {
      static get code() {
        return "ERR_JWT_EXPIRED";
      }
      constructor(message3, claim = "unspecified", reason = "unspecified") {
        super(message3);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JOSEAlgNotAllowed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    };
    JOSENotSupported = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
      }
    };
    JWEDecryptionFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_DECRYPTION_FAILED";
        this.message = "decryption operation failed";
      }
      static get code() {
        return "ERR_JWE_DECRYPTION_FAILED";
      }
    };
    JWEInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_INVALID";
      }
      static get code() {
        return "ERR_JWE_INVALID";
      }
    };
    JWSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
      static get code() {
        return "ERR_JWS_INVALID";
      }
    };
    JWTInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
      static get code() {
        return "ERR_JWT_INVALID";
      }
    };
    JWKInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWK_INVALID";
      }
      static get code() {
        return "ERR_JWK_INVALID";
      }
    };
    JWKSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
      static get code() {
        return "ERR_JWKS_INVALID";
      }
    };
    JWKSNoMatchingKey = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
      }
    };
    JWKSMultipleMatchingKeys = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    };
    JWKSTimeout = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_TIMEOUT";
        this.message = "request timed out";
      }
      static get code() {
        return "ERR_JWKS_TIMEOUT";
      }
    };
    JWSSignatureVerificationFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
      }
      static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/random.js
var random_default;
var init_random = __esm({
  "node_modules/jose/dist/browser/runtime/random.js"() {
    init_webcrypto();
    random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);
  }
});

// node_modules/jose/dist/browser/lib/iv.js
function bitLength(alg) {
  switch (alg) {
    case "A128GCM":
    case "A128GCMKW":
    case "A192GCM":
    case "A192GCMKW":
    case "A256GCM":
    case "A256GCMKW":
      return 96;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return 128;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var iv_default;
var init_iv = __esm({
  "node_modules/jose/dist/browser/lib/iv.js"() {
    init_errors();
    init_random();
    iv_default = (alg) => random_default(new Uint8Array(bitLength(alg) >> 3));
  }
});

// node_modules/jose/dist/browser/lib/check_iv_length.js
var checkIvLength, check_iv_length_default;
var init_check_iv_length = __esm({
  "node_modules/jose/dist/browser/lib/check_iv_length.js"() {
    init_errors();
    init_iv();
    checkIvLength = (enc, iv) => {
      if (iv.length << 3 !== bitLength(enc)) {
        throw new JWEInvalid("Invalid Initialization Vector length");
      }
    };
    check_iv_length_default = checkIvLength;
  }
});

// node_modules/jose/dist/browser/runtime/check_cek_length.js
var checkCekLength, check_cek_length_default;
var init_check_cek_length = __esm({
  "node_modules/jose/dist/browser/runtime/check_cek_length.js"() {
    init_errors();
    checkCekLength = (cek, expected) => {
      const actual = cek.byteLength << 3;
      if (actual !== expected) {
        throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
      }
    };
    check_cek_length_default = checkCekLength;
  }
});

// node_modules/jose/dist/browser/runtime/timing_safe_equal.js
var timingSafeEqual, timing_safe_equal_default;
var init_timing_safe_equal = __esm({
  "node_modules/jose/dist/browser/runtime/timing_safe_equal.js"() {
    timingSafeEqual = (a, b) => {
      if (!(a instanceof Uint8Array)) {
        throw new TypeError("First argument must be a buffer");
      }
      if (!(b instanceof Uint8Array)) {
        throw new TypeError("Second argument must be a buffer");
      }
      if (a.length !== b.length) {
        throw new TypeError("Input buffers must have the same length");
      }
      const len = a.length;
      let out = 0;
      let i = -1;
      while (++i < len) {
        out |= a[i] ^ b[i];
      }
      return out === 0;
    };
    timing_safe_equal_default = timingSafeEqual;
  }
});

// node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
function checkEncCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "A128GCM":
    case "A192GCM":
    case "A256GCM": {
      if (!isAlgorithm(key.algorithm, "AES-GCM"))
        throw unusable("AES-GCM");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (!isAlgorithm(key.algorithm, "AES-KW"))
        throw unusable("AES-KW");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "ECDH": {
      switch (key.algorithm.name) {
        case "ECDH":
        case "X25519":
        case "X448":
          break;
        default:
          throw unusable("ECDH, X25519, or X448");
      }
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW":
      if (!isAlgorithm(key.algorithm, "PBKDF2"))
        throw unusable("PBKDF2");
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
        throw unusable("RSA-OAEP");
      const expected = parseInt(alg.slice(9), 10) || 1;
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
var init_crypto_key = __esm({
  "node_modules/jose/dist/browser/lib/crypto_key.js"() {
  }
});

// node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types3) {
  if (types3.length > 2) {
    const last = types3.pop();
    msg += `one of type ${types3.join(", ")}, or ${last}.`;
  } else if (types3.length === 2) {
    msg += `one of type ${types3[0]} or ${types3[1]}.`;
  } else {
    msg += `of type ${types3[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
function withAlg(alg, actual, ...types3) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types3);
}
var invalid_key_input_default;
var init_invalid_key_input = __esm({
  "node_modules/jose/dist/browser/lib/invalid_key_input.js"() {
    invalid_key_input_default = (actual, ...types3) => {
      return message("Key must be ", actual, ...types3);
    };
  }
});

// node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default, types;
var init_is_key_like = __esm({
  "node_modules/jose/dist/browser/runtime/is_key_like.js"() {
    init_webcrypto();
    is_key_like_default = (key) => {
      return isCryptoKey(key);
    };
    types = ["CryptoKey"];
  }
});

// node_modules/jose/dist/browser/runtime/decrypt.js
async function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["decrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const expectedTag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  let macCheckPassed;
  try {
    macCheckPassed = timing_safe_equal_default(tag, expectedTag);
  } catch (_a) {
  }
  if (!macCheckPassed) {
    throw new JWEDecryptionFailed();
  }
  let plaintext;
  try {
    plaintext = new Uint8Array(await webcrypto_default.subtle.decrypt({ iv, name: "AES-CBC" }, encKey, ciphertext));
  } catch (_b) {
  }
  if (!plaintext) {
    throw new JWEDecryptionFailed();
  }
  return plaintext;
}
async function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["decrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "decrypt");
    encKey = cek;
  }
  try {
    return new Uint8Array(await webcrypto_default.subtle.decrypt({
      additionalData: aad,
      iv,
      name: "AES-GCM",
      tagLength: 128
    }, encKey, concat(ciphertext, tag)));
  } catch (_a) {
    throw new JWEDecryptionFailed();
  }
}
var decrypt, decrypt_default;
var init_decrypt = __esm({
  "node_modules/jose/dist/browser/runtime/decrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_timing_safe_equal();
    init_errors();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    decrypt = async (enc, cek, ciphertext, iv, tag, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    decrypt_default = decrypt;
  }
});

// node_modules/jose/dist/browser/runtime/zlib.js
var inflate, deflate;
var init_zlib = __esm({
  "node_modules/jose/dist/browser/runtime/zlib.js"() {
    init_errors();
    inflate = async () => {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.');
    };
    deflate = async () => {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.');
    };
  }
});

// node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint, is_disjoint_default;
var init_is_disjoint = __esm({
  "node_modules/jose/dist/browser/lib/is_disjoint.js"() {
    isDisjoint = (...headers2) => {
      const sources = headers2.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    };
    is_disjoint_default = isDisjoint;
  }
});

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var init_is_object = __esm({
  "node_modules/jose/dist/browser/lib/is_object.js"() {
  }
});

// node_modules/jose/dist/browser/runtime/bogus.js
var bogusWebCrypto, bogus_default;
var init_bogus = __esm({
  "node_modules/jose/dist/browser/runtime/bogus.js"() {
    bogusWebCrypto = [
      { hash: "SHA-256", name: "HMAC" },
      true,
      ["sign"]
    ];
    bogus_default = bogusWebCrypto;
  }
});

// node_modules/jose/dist/browser/runtime/aeskw.js
function checkKeySize(key, alg) {
  if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {
    throw new TypeError(`Invalid key size for alg: ${alg}`);
  }
}
function getCryptoKey(key, alg, usage) {
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "AES-KW", true, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
var wrap, unwrap;
var init_aeskw = __esm({
  "node_modules/jose/dist/browser/runtime/aeskw.js"() {
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    wrap = async (alg, key, cek) => {
      const cryptoKey = await getCryptoKey(key, alg, "wrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, cryptoKey, "AES-KW"));
    };
    unwrap = async (alg, key, encryptedKey) => {
      const cryptoKey = await getCryptoKey(key, alg, "unwrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, cryptoKey, "AES-KW", ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
    };
  }
});

// node_modules/jose/dist/browser/runtime/ecdhes.js
async function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
  if (!isCryptoKey(publicKey)) {
    throw new TypeError(invalid_key_input_default(publicKey, ...types));
  }
  checkEncCryptoKey(publicKey, "ECDH");
  if (!isCryptoKey(privateKey)) {
    throw new TypeError(invalid_key_input_default(privateKey, ...types));
  }
  checkEncCryptoKey(privateKey, "ECDH", "deriveBits");
  const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));
  let length;
  if (publicKey.algorithm.name === "X25519") {
    length = 256;
  } else if (publicKey.algorithm.name === "X448") {
    length = 448;
  } else {
    length = Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3;
  }
  const sharedSecret = new Uint8Array(await webcrypto_default.subtle.deriveBits({
    name: publicKey.algorithm.name,
    public: publicKey
  }, privateKey, length));
  return concatKdf(sharedSecret, keyLength, value);
}
async function generateEpk(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return webcrypto_default.subtle.generateKey(key.algorithm, true, ["deriveBits"]);
}
function ecdhAllowed(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return ["P-256", "P-384", "P-521"].includes(key.algorithm.namedCurve) || key.algorithm.name === "X25519" || key.algorithm.name === "X448";
}
var init_ecdhes = __esm({
  "node_modules/jose/dist/browser/runtime/ecdhes.js"() {
    init_buffer_utils();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/lib/check_p2s.js
function checkP2s(p2s2) {
  if (!(p2s2 instanceof Uint8Array) || p2s2.length < 8) {
    throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets");
  }
}
var init_check_p2s = __esm({
  "node_modules/jose/dist/browser/lib/check_p2s.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/pbes2kw.js
function getCryptoKey2(key, alg) {
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "PBKDF2", false, ["deriveBits"]);
  }
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, "deriveBits", "deriveKey");
    return key;
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
async function deriveKey2(p2s2, alg, p2c, key) {
  checkP2s(p2s2);
  const salt = p2s(alg, p2s2);
  const keylen = parseInt(alg.slice(13, 16), 10);
  const subtleAlg = {
    hash: `SHA-${alg.slice(8, 11)}`,
    iterations: p2c,
    name: "PBKDF2",
    salt
  };
  const wrapAlg = {
    length: keylen,
    name: "AES-KW"
  };
  const cryptoKey = await getCryptoKey2(key, alg);
  if (cryptoKey.usages.includes("deriveBits")) {
    return new Uint8Array(await webcrypto_default.subtle.deriveBits(subtleAlg, cryptoKey, keylen));
  }
  if (cryptoKey.usages.includes("deriveKey")) {
    return webcrypto_default.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ["wrapKey", "unwrapKey"]);
  }
  throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');
}
var encrypt, decrypt2;
var init_pbes2kw = __esm({
  "node_modules/jose/dist/browser/runtime/pbes2kw.js"() {
    init_random();
    init_buffer_utils();
    init_base64url();
    init_aeskw();
    init_check_p2s();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    encrypt = async (alg, key, cek, p2c = 2048, p2s2 = random_default(new Uint8Array(16))) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      const encryptedKey = await wrap(alg.slice(-6), derived, cek);
      return { encryptedKey, p2c, p2s: encode2(p2s2) };
    };
    decrypt2 = async (alg, key, encryptedKey, p2c, p2s2) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      return unwrap(alg.slice(-6), derived, encryptedKey);
    };
  }
});

// node_modules/jose/dist/browser/runtime/subtle_rsaes.js
function subtleRsaEs(alg) {
  switch (alg) {
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      return "RSA-OAEP";
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_rsaes = __esm({
  "node_modules/jose/dist/browser/runtime/subtle_rsaes.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default;
var init_check_key_length = __esm({
  "node_modules/jose/dist/browser/runtime/check_key_length.js"() {
    check_key_length_default = (alg, key) => {
      if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/rsaes.js
var encrypt2, decrypt3;
var init_rsaes = __esm({
  "node_modules/jose/dist/browser/runtime/rsaes.js"() {
    init_subtle_rsaes();
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_check_key_length();
    init_invalid_key_input();
    init_is_key_like();
    encrypt2 = async (alg, key, cek) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      checkEncCryptoKey(key, alg, "encrypt", "wrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("encrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.encrypt(subtleRsaEs(alg), key, cek));
      }
      if (key.usages.includes("wrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, key, subtleRsaEs(alg)));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation');
    };
    decrypt3 = async (alg, key, encryptedKey) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      checkEncCryptoKey(key, alg, "decrypt", "unwrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("decrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.decrypt(subtleRsaEs(alg), key, encryptedKey));
      }
      if (key.usages.includes("unwrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, key, subtleRsaEs(alg), ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation');
    };
  }
});

// node_modules/jose/dist/browser/lib/cek.js
function bitLength2(alg) {
  switch (alg) {
    case "A128GCM":
      return 128;
    case "A192GCM":
      return 192;
    case "A256GCM":
    case "A128CBC-HS256":
      return 256;
    case "A192CBC-HS384":
      return 384;
    case "A256CBC-HS512":
      return 512;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var cek_default;
var init_cek = __esm({
  "node_modules/jose/dist/browser/lib/cek.js"() {
    init_errors();
    init_random();
    cek_default = (alg) => random_default(new Uint8Array(bitLength2(alg) >> 3));
  }
});

// node_modules/jose/dist/browser/lib/format_pem.js
var format_pem_default;
var init_format_pem = __esm({
  "node_modules/jose/dist/browser/lib/format_pem.js"() {
    format_pem_default = (b64, descriptor) => {
      const newlined = (b64.match(/.{1,64}/g) || []).join("\n");
      return `-----BEGIN ${descriptor}-----
${newlined}
-----END ${descriptor}-----`;
    };
  }
});

// node_modules/jose/dist/browser/runtime/asn1.js
function getElement(seq) {
  let result = [];
  let next = 0;
  while (next < seq.length) {
    let nextPart = parseElement(seq.subarray(next));
    result.push(nextPart);
    next += nextPart.byteLength;
  }
  return result;
}
function parseElement(bytes) {
  let position3 = 0;
  let tag = bytes[0] & 31;
  position3++;
  if (tag === 31) {
    tag = 0;
    while (bytes[position3] >= 128) {
      tag = tag * 128 + bytes[position3] - 128;
      position3++;
    }
    tag = tag * 128 + bytes[position3] - 128;
    position3++;
  }
  let length = 0;
  if (bytes[position3] < 128) {
    length = bytes[position3];
    position3++;
  } else if (length === 128) {
    length = 0;
    while (bytes[position3 + length] !== 0 || bytes[position3 + length + 1] !== 0) {
      if (length > bytes.byteLength) {
        throw new TypeError("invalid indefinite form length");
      }
      length++;
    }
    const byteLength2 = position3 + length + 2;
    return {
      byteLength: byteLength2,
      contents: bytes.subarray(position3, position3 + length),
      raw: bytes.subarray(0, byteLength2)
    };
  } else {
    let numberOfDigits = bytes[position3] & 127;
    position3++;
    length = 0;
    for (let i = 0; i < numberOfDigits; i++) {
      length = length * 256 + bytes[position3];
      position3++;
    }
  }
  const byteLength = position3 + length;
  return {
    byteLength,
    contents: bytes.subarray(position3, byteLength),
    raw: bytes.subarray(0, byteLength)
  };
}
function spkiFromX509(buf) {
  const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);
  return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 160 ? 6 : 5].raw);
}
function getSPKI(x509) {
  const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, "");
  const raw = decodeBase64(pem);
  return format_pem_default(spkiFromX509(raw), "PUBLIC KEY");
}
var genericExport, toSPKI, toPKCS8, findOid, getNamedCurve2, genericImport, fromPKCS8, fromSPKI, fromX509;
var init_asn1 = __esm({
  "node_modules/jose/dist/browser/runtime/asn1.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_format_pem();
    init_errors();
    init_is_key_like();
    genericExport = async (keyType, keyFormat, key) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      if (!key.extractable) {
        throw new TypeError("CryptoKey is not extractable");
      }
      if (key.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
      }
      return format_pem_default(encodeBase64(new Uint8Array(await webcrypto_default.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);
    };
    toSPKI = (key) => {
      return genericExport("public", "spki", key);
    };
    toPKCS8 = (key) => {
      return genericExport("private", "pkcs8", key);
    };
    findOid = (keyData, oid, from = 0) => {
      if (from === 0) {
        oid.unshift(oid.length);
        oid.unshift(6);
      }
      let i = keyData.indexOf(oid[0], from);
      if (i === -1)
        return false;
      const sub = keyData.subarray(i, i + oid.length);
      if (sub.length !== oid.length)
        return false;
      return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);
    };
    getNamedCurve2 = (keyData) => {
      switch (true) {
        case findOid(keyData, [42, 134, 72, 206, 61, 3, 1, 7]):
          return "P-256";
        case findOid(keyData, [43, 129, 4, 0, 34]):
          return "P-384";
        case findOid(keyData, [43, 129, 4, 0, 35]):
          return "P-521";
        case findOid(keyData, [43, 101, 110]):
          return "X25519";
        case findOid(keyData, [43, 101, 111]):
          return "X448";
        case findOid(keyData, [43, 101, 112]):
          return "Ed25519";
        case findOid(keyData, [43, 101, 113]):
          return "Ed448";
        default:
          throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type");
      }
    };
    genericImport = async (replace, keyFormat, pem, alg, options) => {
      var _a;
      let algorithm;
      let keyUsages;
      const keyData = new Uint8Array(atob(pem.replace(replace, "")).split("").map((c) => c.charCodeAt(0)));
      const isPublic = keyFormat === "spki";
      switch (alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
          };
          keyUsages = isPublic ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
          break;
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW": {
          const namedCurve = getNamedCurve2(keyData);
          algorithm = namedCurve.startsWith("P-") ? { name: "ECDH", namedCurve } : { name: namedCurve };
          keyUsages = isPublic ? [] : ["deriveBits"];
          break;
        }
        case "EdDSA":
          algorithm = { name: getNamedCurve2(keyData) };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
      }
      return webcrypto_default.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
    };
    fromPKCS8 = (pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "pkcs8", pem, alg, options);
    };
    fromSPKI = (pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, "spki", pem, alg, options);
    };
    fromX509 = (pem, alg, options) => {
      let spki;
      try {
        spki = getSPKI(pem);
      } catch (cause) {
        throw new TypeError("Failed to parse the X.509 certificate", { cause });
      }
      return fromSPKI(spki, alg, options);
    };
  }
});

// node_modules/jose/dist/browser/runtime/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "oct": {
      switch (jwk.alg) {
        case "HS256":
        case "HS384":
        case "HS512":
          algorithm = { name: "HMAC", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = ["sign", "verify"];
          break;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
          algorithm = { name: "AES-GCM" };
          keyUsages = ["encrypt", "decrypt"];
          break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
          algorithm = { name: "AES-KW" };
          keyUsages = ["wrapKey", "unwrapKey"];
          break;
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
          algorithm = { name: "PBKDF2" };
          keyUsages = ["deriveBits"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var parse, jwk_to_key_default;
var init_jwk_to_key = __esm({
  "node_modules/jose/dist/browser/runtime/jwk_to_key.js"() {
    init_webcrypto();
    init_errors();
    init_base64url();
    parse = async (jwk) => {
      var _a, _b;
      if (!jwk.alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
      }
      const { algorithm, keyUsages } = subtleMapping(jwk);
      const rest = [
        algorithm,
        (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,
        (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages
      ];
      if (algorithm.name === "PBKDF2") {
        return webcrypto_default.subtle.importKey("raw", decode2(jwk.k), ...rest);
      }
      const keyData = { ...jwk };
      delete keyData.alg;
      delete keyData.use;
      return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
    };
    jwk_to_key_default = parse;
  }
});

// node_modules/jose/dist/browser/key/import.js
async function importSPKI(spki, alg, options) {
  if (typeof spki !== "string" || spki.indexOf("-----BEGIN PUBLIC KEY-----") !== 0) {
    throw new TypeError('"spki" must be SPKI formatted string');
  }
  return fromSPKI(spki, alg, options);
}
async function importX509(x509, alg, options) {
  if (typeof x509 !== "string" || x509.indexOf("-----BEGIN CERTIFICATE-----") !== 0) {
    throw new TypeError('"x509" must be X.509 formatted string');
  }
  return fromX509(x509, alg, options);
}
async function importPKCS8(pkcs8, alg, options) {
  if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
    throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  }
  return fromPKCS8(pkcs8, alg, options);
}
async function importJWK(jwk, alg, octAsKeyObject) {
  var _a;
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
      if (octAsKeyObject) {
        return jwk_to_key_default({ ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });
      }
      return decode2(jwk.k);
    case "RSA":
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
var init_import = __esm({
  "node_modules/jose/dist/browser/key/import.js"() {
    init_base64url();
    init_asn1();
    init_jwk_to_key();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck, asymmetricTypeCheck, checkKeyType, check_key_type_default;
var init_check_key_type = __esm({
  "node_modules/jose/dist/browser/lib/check_key_type.js"() {
    init_invalid_key_input();
    init_is_key_like();
    symmetricTypeCheck = (alg, key) => {
      if (key instanceof Uint8Array)
        return;
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    asymmetricTypeCheck = (alg, key, usage) => {
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types));
      }
      if (key.type === "secret") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    };
    checkKeyType = (alg, key, usage) => {
      const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
        symmetricTypeCheck(alg, key);
      } else {
        asymmetricTypeCheck(alg, key, usage);
      }
    };
    check_key_type_default = checkKeyType;
  }
});

// node_modules/jose/dist/browser/runtime/encrypt.js
async function cbcEncrypt(enc, plaintext, cek, iv, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["encrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const ciphertext = new Uint8Array(await webcrypto_default.subtle.encrypt({
    iv,
    name: "AES-CBC"
  }, encKey, plaintext));
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const tag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  return { ciphertext, tag };
}
async function gcmEncrypt(enc, plaintext, cek, iv, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["encrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "encrypt");
    encKey = cek;
  }
  const encrypted = new Uint8Array(await webcrypto_default.subtle.encrypt({
    additionalData: aad,
    iv,
    name: "AES-GCM",
    tagLength: 128
  }, encKey, plaintext));
  const tag = encrypted.slice(-16);
  const ciphertext = encrypted.slice(0, -16);
  return { ciphertext, tag };
}
var encrypt3, encrypt_default;
var init_encrypt = __esm({
  "node_modules/jose/dist/browser/runtime/encrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_errors();
    init_is_key_like();
    encrypt3 = async (enc, plaintext, cek, iv, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcEncrypt(enc, plaintext, cek, iv, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmEncrypt(enc, plaintext, cek, iv, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    encrypt_default = encrypt3;
  }
});

// node_modules/jose/dist/browser/lib/aesgcmkw.js
async function wrap2(alg, key, cek, iv) {
  const jweAlgorithm = alg.slice(0, 7);
  iv || (iv = iv_default(jweAlgorithm));
  const { ciphertext: encryptedKey, tag } = await encrypt_default(jweAlgorithm, cek, key, iv, new Uint8Array(0));
  return { encryptedKey, iv: encode2(iv), tag: encode2(tag) };
}
async function unwrap2(alg, key, encryptedKey, iv, tag) {
  const jweAlgorithm = alg.slice(0, 7);
  return decrypt_default(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
}
var init_aesgcmkw = __esm({
  "node_modules/jose/dist/browser/lib/aesgcmkw.js"() {
    init_encrypt();
    init_decrypt();
    init_iv();
    init_base64url();
  }
});

// node_modules/jose/dist/browser/lib/decrypt_key_management.js
async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
  check_key_type_default(alg, key, "decrypt");
  switch (alg) {
    case "dir": {
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
      return key;
    }
    case "ECDH-ES":
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!isObject(joseHeader.epk))
        throw new JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
      if (!ecdhAllowed(key))
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      const epk = await importJWK(joseHeader.epk, alg);
      let partyUInfo;
      let partyVInfo;
      if (joseHeader.apu !== void 0) {
        if (typeof joseHeader.apu !== "string")
          throw new JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
        try {
          partyUInfo = decode2(joseHeader.apu);
        } catch (_a) {
          throw new JWEInvalid("Failed to base64url decode the apu");
        }
      }
      if (joseHeader.apv !== void 0) {
        if (typeof joseHeader.apv !== "string")
          throw new JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
        try {
          partyVInfo = decode2(joseHeader.apv);
        } catch (_b) {
          throw new JWEInvalid("Failed to base64url decode the apv");
        }
      }
      const sharedSecret = await deriveKey(epk, key, alg === "ECDH-ES" ? joseHeader.enc : alg, alg === "ECDH-ES" ? bitLength2(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
      if (alg === "ECDH-ES")
        return sharedSecret;
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg.slice(-6), sharedSecret, encryptedKey);
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return decrypt3(alg, key, encryptedKey);
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.p2c !== "number")
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
      const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 1e4;
      if (joseHeader.p2c > p2cLimit)
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
      if (typeof joseHeader.p2s !== "string")
        throw new JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
      let p2s2;
      try {
        p2s2 = decode2(joseHeader.p2s);
      } catch (_c) {
        throw new JWEInvalid("Failed to base64url decode the p2s");
      }
      return decrypt2(alg, key, encryptedKey, joseHeader.p2c, p2s2);
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg, key, encryptedKey);
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.iv !== "string")
        throw new JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
      if (typeof joseHeader.tag !== "string")
        throw new JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
      let iv;
      try {
        iv = decode2(joseHeader.iv);
      } catch (_d) {
        throw new JWEInvalid("Failed to base64url decode the iv");
      }
      let tag;
      try {
        tag = decode2(joseHeader.tag);
      } catch (_e) {
        throw new JWEInvalid("Failed to base64url decode the tag");
      }
      return unwrap2(alg, key, encryptedKey, iv, tag);
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
}
var decrypt_key_management_default;
var init_decrypt_key_management = __esm({
  "node_modules/jose/dist/browser/lib/decrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_errors();
    init_cek();
    init_import();
    init_check_key_type();
    init_is_object();
    init_aesgcmkw();
    decrypt_key_management_default = decryptKeyManagement;
  }
});

// node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default;
var init_validate_crit = __esm({
  "node_modules/jose/dist/browser/lib/validate_crit.js"() {
    init_errors();
    validate_crit_default = validateCrit;
  }
});

// node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms, validate_algorithms_default;
var init_validate_algorithms = __esm({
  "node_modules/jose/dist/browser/lib/validate_algorithms.js"() {
    validateAlgorithms = (option, algorithms) => {
      if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
        return void 0;
      }
      return new Set(algorithms);
    };
    validate_algorithms_default = validateAlgorithms;
  }
});

// node_modules/jose/dist/browser/jwe/flattened/decrypt.js
async function flattenedDecrypt(jwe, key, options) {
  var _a;
  if (!isObject(jwe)) {
    throw new JWEInvalid("Flattened JWE must be an object");
  }
  if (jwe.protected === void 0 && jwe.header === void 0 && jwe.unprotected === void 0) {
    throw new JWEInvalid("JOSE Header missing");
  }
  if (typeof jwe.iv !== "string") {
    throw new JWEInvalid("JWE Initialization Vector missing or incorrect type");
  }
  if (typeof jwe.ciphertext !== "string") {
    throw new JWEInvalid("JWE Ciphertext missing or incorrect type");
  }
  if (typeof jwe.tag !== "string") {
    throw new JWEInvalid("JWE Authentication Tag missing or incorrect type");
  }
  if (jwe.protected !== void 0 && typeof jwe.protected !== "string") {
    throw new JWEInvalid("JWE Protected Header incorrect type");
  }
  if (jwe.encrypted_key !== void 0 && typeof jwe.encrypted_key !== "string") {
    throw new JWEInvalid("JWE Encrypted Key incorrect type");
  }
  if (jwe.aad !== void 0 && typeof jwe.aad !== "string") {
    throw new JWEInvalid("JWE AAD incorrect type");
  }
  if (jwe.header !== void 0 && !isObject(jwe.header)) {
    throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");
  }
  if (jwe.unprotected !== void 0 && !isObject(jwe.unprotected)) {
    throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
  }
  let parsedProt;
  if (jwe.protected) {
    try {
      const protectedHeader2 = decode2(jwe.protected);
      parsedProt = JSON.parse(decoder2.decode(protectedHeader2));
    } catch (_b) {
      throw new JWEInvalid("JWE Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jwe.header, jwe.unprotected)) {
    throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jwe.header,
    ...jwe.unprotected
  };
  validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  if (joseHeader.zip !== void 0) {
    if (!parsedProt || !parsedProt.zip) {
      throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
    }
    if (joseHeader.zip !== "DEF") {
      throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
    }
  }
  const { alg, enc } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
  }
  if (typeof enc !== "string" || !enc) {
    throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
  }
  const keyManagementAlgorithms = options && validate_algorithms_default("keyManagementAlgorithms", options.keyManagementAlgorithms);
  const contentEncryptionAlgorithms = options && validate_algorithms_default("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
  if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
    throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
  }
  let encryptedKey;
  if (jwe.encrypted_key !== void 0) {
    try {
      encryptedKey = decode2(jwe.encrypted_key);
    } catch (_c) {
      throw new JWEInvalid("Failed to base64url decode the encrypted_key");
    }
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jwe);
    resolvedKey = true;
  }
  let cek;
  try {
    cek = await decrypt_key_management_default(alg, key, encryptedKey, joseHeader, options);
  } catch (err) {
    if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {
      throw err;
    }
    cek = cek_default(enc);
  }
  let iv;
  let tag;
  try {
    iv = decode2(jwe.iv);
  } catch (_d) {
    throw new JWEInvalid("Failed to base64url decode the iv");
  }
  try {
    tag = decode2(jwe.tag);
  } catch (_e) {
    throw new JWEInvalid("Failed to base64url decode the tag");
  }
  const protectedHeader = encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : "");
  let additionalData;
  if (jwe.aad !== void 0) {
    additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(jwe.aad));
  } else {
    additionalData = protectedHeader;
  }
  let ciphertext;
  try {
    ciphertext = decode2(jwe.ciphertext);
  } catch (_f) {
    throw new JWEInvalid("Failed to base64url decode the ciphertext");
  }
  let plaintext = await decrypt_default(enc, cek, ciphertext, iv, tag, additionalData);
  if (joseHeader.zip === "DEF") {
    plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);
  }
  const result = { plaintext };
  if (jwe.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jwe.aad !== void 0) {
    try {
      result.additionalAuthenticatedData = decode2(jwe.aad);
    } catch (_g) {
      throw new JWEInvalid("Failed to base64url decode the aad");
    }
  }
  if (jwe.unprotected !== void 0) {
    result.sharedUnprotectedHeader = jwe.unprotected;
  }
  if (jwe.header !== void 0) {
    result.unprotectedHeader = jwe.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_decrypt2 = __esm({
  "node_modules/jose/dist/browser/jwe/flattened/decrypt.js"() {
    init_base64url();
    init_decrypt();
    init_zlib();
    init_errors();
    init_is_disjoint();
    init_is_object();
    init_decrypt_key_management();
    init_buffer_utils();
    init_cek();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// node_modules/jose/dist/browser/jwe/compact/decrypt.js
async function compactDecrypt(jwe, key, options) {
  if (jwe instanceof Uint8Array) {
    jwe = decoder2.decode(jwe);
  }
  if (typeof jwe !== "string") {
    throw new JWEInvalid("Compact JWE must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length } = jwe.split(".");
  if (length !== 5) {
    throw new JWEInvalid("Invalid Compact JWE");
  }
  const decrypted = await flattenedDecrypt({
    ciphertext,
    iv: iv || void 0,
    protected: protectedHeader || void 0,
    tag: tag || void 0,
    encrypted_key: encryptedKey || void 0
  }, key, options);
  const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt3 = __esm({
  "node_modules/jose/dist/browser/jwe/compact/decrypt.js"() {
    init_decrypt2();
    init_errors();
    init_buffer_utils();
  }
});

// node_modules/jose/dist/browser/jwe/general/decrypt.js
async function generalDecrypt(jwe, key, options) {
  if (!isObject(jwe)) {
    throw new JWEInvalid("General JWE must be an object");
  }
  if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject)) {
    throw new JWEInvalid("JWE Recipients missing or incorrect type");
  }
  if (!jwe.recipients.length) {
    throw new JWEInvalid("JWE Recipients has no members");
  }
  for (const recipient of jwe.recipients) {
    try {
      return await flattenedDecrypt({
        aad: jwe.aad,
        ciphertext: jwe.ciphertext,
        encrypted_key: recipient.encrypted_key,
        header: recipient.header,
        iv: jwe.iv,
        protected: jwe.protected,
        tag: jwe.tag,
        unprotected: jwe.unprotected
      }, key, options);
    } catch (_a) {
    }
  }
  throw new JWEDecryptionFailed();
}
var init_decrypt4 = __esm({
  "node_modules/jose/dist/browser/jwe/general/decrypt.js"() {
    init_decrypt2();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/runtime/key_to_jwk.js
var keyToJWK, key_to_jwk_default;
var init_key_to_jwk = __esm({
  "node_modules/jose/dist/browser/runtime/key_to_jwk.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_is_key_like();
    keyToJWK = async (key) => {
      if (key instanceof Uint8Array) {
        return {
          kty: "oct",
          k: encode2(key)
        };
      }
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
      }
      if (!key.extractable) {
        throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");
      }
      const { ext, key_ops, alg, use, ...jwk } = await webcrypto_default.subtle.exportKey("jwk", key);
      return jwk;
    };
    key_to_jwk_default = keyToJWK;
  }
});

// node_modules/jose/dist/browser/key/export.js
async function exportSPKI(key) {
  return toSPKI(key);
}
async function exportPKCS8(key) {
  return toPKCS8(key);
}
async function exportJWK(key) {
  return key_to_jwk_default(key);
}
var init_export = __esm({
  "node_modules/jose/dist/browser/key/export.js"() {
    init_asn1();
    init_asn1();
    init_key_to_jwk();
  }
});

// node_modules/jose/dist/browser/lib/encrypt_key_management.js
async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
  let encryptedKey;
  let parameters;
  let cek;
  check_key_type_default(alg, key, "encrypt");
  switch (alg) {
    case "dir": {
      cek = key;
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!ecdhAllowed(key)) {
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      }
      const { apu, apv } = providedParameters;
      let { epk: ephemeralKey } = providedParameters;
      ephemeralKey || (ephemeralKey = (await generateEpk(key)).privateKey);
      const { x, y, crv, kty } = await exportJWK(ephemeralKey);
      const sharedSecret = await deriveKey(key, ephemeralKey, alg === "ECDH-ES" ? enc : alg, alg === "ECDH-ES" ? bitLength2(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
      parameters = { epk: { x, crv, kty } };
      if (kty === "EC")
        parameters.epk.y = y;
      if (apu)
        parameters.apu = encode2(apu);
      if (apv)
        parameters.apv = encode2(apv);
      if (alg === "ECDH-ES") {
        cek = sharedSecret;
        break;
      }
      cek = providedCek || cek_default(enc);
      const kwAlg = alg.slice(-6);
      encryptedKey = await wrap(kwAlg, sharedSecret, cek);
      break;
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await encrypt2(alg, key, cek);
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      cek = providedCek || cek_default(enc);
      const { p2c, p2s: p2s2 } = providedParameters;
      ({ encryptedKey, ...parameters } = await encrypt(alg, key, cek, p2c, p2s2));
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await wrap(alg, key, cek);
      break;
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      cek = providedCek || cek_default(enc);
      const { iv } = providedParameters;
      ({ encryptedKey, ...parameters } = await wrap2(alg, key, cek, iv));
      break;
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
  return { cek, encryptedKey, parameters };
}
var encrypt_key_management_default;
var init_encrypt_key_management = __esm({
  "node_modules/jose/dist/browser/lib/encrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_cek();
    init_errors();
    init_export();
    init_check_key_type();
    init_aesgcmkw();
    encrypt_key_management_default = encryptKeyManagement;
  }
});

// node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var unprotected, FlattenedEncrypt;
var init_encrypt2 = __esm({
  "node_modules/jose/dist/browser/jwe/flattened/encrypt.js"() {
    init_base64url();
    init_encrypt();
    init_zlib();
    init_iv();
    init_encrypt_key_management();
    init_errors();
    init_is_disjoint();
    init_buffer_utils();
    init_validate_crit();
    unprotected = Symbol();
    FlattenedEncrypt = class {
      constructor(plaintext) {
        if (!(plaintext instanceof Uint8Array)) {
          throw new TypeError("plaintext must be an instance of Uint8Array");
        }
        this._plaintext = plaintext;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
          throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
          throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader,
          ...this._sharedUnprotectedHeader
        };
        validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== void 0) {
          if (!this._protectedHeader || !this._protectedHeader.zip) {
            throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
          }
          if (joseHeader.zip !== "DEF") {
            throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
          }
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== "string" || !enc) {
          throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (alg === "dir") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
          }
        } else if (alg === "ECDH-ES") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
          }
        }
        let cek;
        {
          let parameters;
          ({ cek, encryptedKey, parameters } = await encrypt_key_management_default(alg, enc, key, this._cek, this._keyManagementParameters));
          if (parameters) {
            if (options && unprotected in options) {
              if (!this._unprotectedHeader) {
                this.setUnprotectedHeader(parameters);
              } else {
                this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
              }
            } else {
              if (!this._protectedHeader) {
                this.setProtectedHeader(parameters);
              } else {
                this._protectedHeader = { ...this._protectedHeader, ...parameters };
              }
            }
          }
        }
        this._iv || (this._iv = iv_default(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode2(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        if (this._aad) {
          aadMember = encode2(this._aad);
          additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(aadMember));
        } else {
          additionalData = protectedHeader;
        }
        let ciphertext;
        let tag;
        if (joseHeader.zip === "DEF") {
          const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);
          ({ ciphertext, tag } = await encrypt_default(enc, deflated, cek, this._iv, additionalData));
        } else {
          ;
          ({ ciphertext, tag } = await encrypt_default(enc, this._plaintext, cek, this._iv, additionalData));
        }
        const jwe = {
          ciphertext: encode2(ciphertext),
          iv: encode2(this._iv),
          tag: encode2(tag)
        };
        if (encryptedKey) {
          jwe.encrypted_key = encode2(encryptedKey);
        }
        if (aadMember) {
          jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
          jwe.protected = decoder2.decode(protectedHeader);
        }
        if (this._sharedUnprotectedHeader) {
          jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
          jwe.header = this._unprotectedHeader;
        }
        return jwe;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwe/general/encrypt.js
var IndividualRecipient, GeneralEncrypt;
var init_encrypt3 = __esm({
  "node_modules/jose/dist/browser/jwe/general/encrypt.js"() {
    init_encrypt2();
    init_errors();
    init_cek();
    init_is_disjoint();
    init_encrypt_key_management();
    init_base64url();
    init_validate_crit();
    IndividualRecipient = class {
      constructor(enc, key, options) {
        this.parent = enc;
        this.key = key;
        this.options = options;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addRecipient(...args) {
        return this.parent.addRecipient(...args);
      }
      encrypt(...args) {
        return this.parent.encrypt(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralEncrypt = class {
      constructor(plaintext) {
        this._recipients = [];
        this._plaintext = plaintext;
      }
      addRecipient(key, options) {
        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });
        this._recipients.push(recipient);
        return recipient;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      async encrypt(options) {
        var _a, _b, _c;
        if (!this._recipients.length) {
          throw new JWEInvalid("at least one recipient must be added");
        }
        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };
        if (this._recipients.length === 1) {
          const [recipient] = this._recipients;
          const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options, ...options });
          let jwe2 = {
            ciphertext: flattened.ciphertext,
            iv: flattened.iv,
            recipients: [{}],
            tag: flattened.tag
          };
          if (flattened.aad)
            jwe2.aad = flattened.aad;
          if (flattened.protected)
            jwe2.protected = flattened.protected;
          if (flattened.unprotected)
            jwe2.unprotected = flattened.unprotected;
          if (flattened.encrypted_key)
            jwe2.recipients[0].encrypted_key = flattened.encrypted_key;
          if (flattened.header)
            jwe2.recipients[0].header = flattened.header;
          return jwe2;
        }
        let enc;
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
            throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
          }
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const { alg } = joseHeader;
          if (typeof alg !== "string" || !alg) {
            throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
          }
          if (alg === "dir" || alg === "ECDH-ES") {
            throw new JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
          }
          if (typeof joseHeader.enc !== "string" || !joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
          }
          if (!enc) {
            enc = joseHeader.enc;
          } else if (enc !== joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
          }
          validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
          if (joseHeader.zip !== void 0) {
            if (!this._protectedHeader || !this._protectedHeader.zip) {
              throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
          }
        }
        const cek = cek_default(enc);
        let jwe = {
          ciphertext: "",
          iv: "",
          recipients: [],
          tag: ""
        };
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          const target2 = {};
          jwe.recipients.push(target2);
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const p2c = joseHeader.alg.startsWith("PBES2") ? 2048 + i : void 0;
          if (i === 0) {
            const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({ p2c }).encrypt(recipient.key, {
              ...recipient.options,
              ...options,
              [unprotected]: true
            });
            jwe.ciphertext = flattened.ciphertext;
            jwe.iv = flattened.iv;
            jwe.tag = flattened.tag;
            if (flattened.aad)
              jwe.aad = flattened.aad;
            if (flattened.protected)
              jwe.protected = flattened.protected;
            if (flattened.unprotected)
              jwe.unprotected = flattened.unprotected;
            target2.encrypted_key = flattened.encrypted_key;
            if (flattened.header)
              target2.header = flattened.header;
            continue;
          }
          const { encryptedKey, parameters } = await encrypt_key_management_default(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });
          target2.encrypted_key = encode2(encryptedKey);
          if (recipient.unprotectedHeader || parameters)
            target2.header = { ...recipient.unprotectedHeader, ...parameters };
        }
        return jwe;
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash2 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash2, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash2, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash2, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash2, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_dsa = __esm({
  "node_modules/jose/dist/browser/runtime/subtle_dsa.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey3(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
var init_get_sign_verify_key = __esm({
  "node_modules/jose/dist/browser/runtime/get_sign_verify_key.js"() {
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/runtime/verify.js
var verify, verify_default;
var init_verify = __esm({
  "node_modules/jose/dist/browser/runtime/verify.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    verify = async (alg, key, signature, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "verify");
      check_key_length_default(alg, cryptoKey);
      const algorithm = subtleDsa(alg, cryptoKey.algorithm);
      try {
        return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
      } catch (_a) {
        return false;
      }
    };
    verify_default = verify;
  }
});

// node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a;
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode2(jws.protected);
      parsedProt = JSON.parse(decoder2.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions2 = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions2.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode2(jws.signature);
  } catch (_c) {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode2(jws.payload);
    } catch (_d) {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_verify2 = __esm({
  "node_modules/jose/dist/browser/jws/flattened/verify.js"() {
    init_base64url();
    init_verify();
    init_errors();
    init_buffer_utils();
    init_is_disjoint();
    init_is_object();
    init_check_key_type();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder2.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify3 = __esm({
  "node_modules/jose/dist/browser/jws/compact/verify.js"() {
    init_verify2();
    init_errors();
    init_buffer_utils();
  }
});

// node_modules/jose/dist/browser/jws/general/verify.js
async function generalVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("General JWS must be an object");
  }
  if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject)) {
    throw new JWSInvalid("JWS Signatures missing or incorrect type");
  }
  for (const signature of jws.signatures) {
    try {
      return await flattenedVerify({
        header: signature.header,
        payload: jws.payload,
        protected: signature.protected,
        signature: signature.signature
      }, key, options);
    } catch (_a) {
    }
  }
  throw new JWSSignatureVerificationFailed();
}
var init_verify4 = __esm({
  "node_modules/jose/dist/browser/jws/general/verify.js"() {
    init_verify2();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/lib/epoch.js
var epoch_default;
var init_epoch = __esm({
  "node_modules/jose/dist/browser/lib/epoch.js"() {
    epoch_default = (date) => Math.floor(date.getTime() / 1e3);
  }
});

// node_modules/jose/dist/browser/lib/secs.js
var minute, hour, day, week, year, REGEX, secs_default;
var init_secs = __esm({
  "node_modules/jose/dist/browser/lib/secs.js"() {
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    week = day * 7;
    year = day * 365.25;
    REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
    secs_default = (str) => {
      const matched = REGEX.exec(str);
      if (!matched) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[1]);
      const unit = matched[2].toLowerCase();
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          return Math.round(value);
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          return Math.round(value * minute);
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          return Math.round(value * hour);
        case "day":
        case "days":
        case "d":
          return Math.round(value * day);
        case "week":
        case "weeks":
        case "w":
          return Math.round(value * week);
        default:
          return Math.round(value * year);
      }
    };
  }
});

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp, checkAudiencePresence, jwt_claims_set_default;
var init_jwt_claims_set = __esm({
  "node_modules/jose/dist/browser/lib/jwt_claims_set.js"() {
    init_errors();
    init_buffer_utils();
    init_epoch();
    init_secs();
    init_is_object();
    normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
    checkAudiencePresence = (audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    };
    jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
      const { typ } = options;
      if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
      }
      let payload;
      try {
        payload = JSON.parse(decoder2.decode(encodedPayload));
      } catch (_a) {
      }
      if (!isObject(payload)) {
        throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
      }
      const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
      if (maxTokenAge !== void 0)
        requiredClaims.push("iat");
      if (audience !== void 0)
        requiredClaims.push("aud");
      if (subject !== void 0)
        requiredClaims.push("sub");
      if (issuer !== void 0)
        requiredClaims.push("iss");
      for (const claim of new Set(requiredClaims.reverse())) {
        if (!(claim in payload)) {
          throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
        }
      }
      if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
      }
      if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
      }
      if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
      }
      let tolerance;
      switch (typeof options.clockTolerance) {
        case "string":
          tolerance = secs_default(options.clockTolerance);
          break;
        case "number":
          tolerance = options.clockTolerance;
          break;
        case "undefined":
          tolerance = 0;
          break;
        default:
          throw new TypeError("Invalid clockTolerance option type");
      }
      const { currentDate } = options;
      const now = epoch_default(currentDate || /* @__PURE__ */ new Date());
      if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
      }
      if (payload.nbf !== void 0) {
        if (typeof payload.nbf !== "number") {
          throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
        }
        if (payload.nbf > now + tolerance) {
          throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
        }
      }
      if (payload.exp !== void 0) {
        if (typeof payload.exp !== "number") {
          throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
        }
        if (payload.exp <= now - tolerance) {
          throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
        }
      }
      if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
        if (age - tolerance > max) {
          throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
          throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
        }
      }
      return payload;
    };
  }
});

// node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify5 = __esm({
  "node_modules/jose/dist/browser/jwt/verify.js"() {
    init_verify3();
    init_jwt_claims_set();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwt/decrypt.js
async function jwtDecrypt(jwt, key, options) {
  const decrypted = await compactDecrypt(jwt, key, options);
  const payload = jwt_claims_set_default(decrypted.protectedHeader, decrypted.plaintext, options);
  const { protectedHeader } = decrypted;
  if (protectedHeader.iss !== void 0 && protectedHeader.iss !== payload.iss) {
    throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
  }
  if (protectedHeader.sub !== void 0 && protectedHeader.sub !== payload.sub) {
    throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
  }
  if (protectedHeader.aud !== void 0 && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
    throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
  }
  const result = { payload, protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt5 = __esm({
  "node_modules/jose/dist/browser/jwt/decrypt.js"() {
    init_decrypt3();
    init_jwt_claims_set();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwe/compact/encrypt.js
var CompactEncrypt;
var init_encrypt4 = __esm({
  "node_modules/jose/dist/browser/jwe/compact/encrypt.js"() {
    init_encrypt2();
    CompactEncrypt = class {
      constructor(plaintext) {
        this._flattened = new FlattenedEncrypt(plaintext);
      }
      setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
      }
      setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
      }
      async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/sign.js
var sign, sign_default;
var init_sign = __esm({
  "node_modules/jose/dist/browser/runtime/sign.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    sign = async (alg, key, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "sign");
      check_key_length_default(alg, cryptoKey);
      const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
      return new Uint8Array(signature);
    };
    sign_default = sign;
  }
});

// node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign;
var init_sign2 = __esm({
  "node_modules/jose/dist/browser/jws/flattened/sign.js"() {
    init_base64url();
    init_sign();
    init_is_disjoint();
    init_errors();
    init_buffer_utils();
    init_check_key_type();
    init_validate_crit();
    FlattenedSign = class {
      constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
          throw new TypeError("payload must be an instance of Uint8Array");
        }
        this._payload = payload;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
          throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
          throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader
        };
        const extensions2 = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions2.has("b64")) {
          b64 = this._protectedHeader.b64;
          if (typeof b64 !== "boolean") {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
        }
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        check_key_type_default(alg, key, "sign");
        let payload = this._payload;
        if (b64) {
          payload = encoder.encode(encode2(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode2(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        const data = concat(protectedHeader, encoder.encode("."), payload);
        const signature = await sign_default(alg, key, data);
        const jws = {
          signature: encode2(signature),
          payload: ""
        };
        if (b64) {
          jws.payload = decoder2.decode(payload);
        }
        if (this._unprotectedHeader) {
          jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
          jws.protected = decoder2.decode(protectedHeader);
        }
        return jws;
      }
    };
  }
});

// node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign;
var init_sign3 = __esm({
  "node_modules/jose/dist/browser/jws/compact/sign.js"() {
    init_sign2();
    CompactSign = class {
      constructor(payload) {
        this._flattened = new FlattenedSign(payload);
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === void 0) {
          throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
      }
    };
  }
});

// node_modules/jose/dist/browser/jws/general/sign.js
var IndividualSignature, GeneralSign;
var init_sign4 = __esm({
  "node_modules/jose/dist/browser/jws/general/sign.js"() {
    init_sign2();
    init_errors();
    IndividualSignature = class {
      constructor(sig, key, options) {
        this.parent = sig;
        this.key = key;
        this.options = options;
      }
      setProtectedHeader(protectedHeader) {
        if (this.protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this.protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addSignature(...args) {
        return this.parent.addSignature(...args);
      }
      sign(...args) {
        return this.parent.sign(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralSign = class {
      constructor(payload) {
        this._signatures = [];
        this._payload = payload;
      }
      addSignature(key, options) {
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
      }
      async sign() {
        if (!this._signatures.length) {
          throw new JWSInvalid("at least one signature must be added");
        }
        const jws = {
          signatures: [],
          payload: ""
        };
        for (let i = 0; i < this._signatures.length; i++) {
          const signature = this._signatures[i];
          const flattened = new FlattenedSign(this._payload);
          flattened.setProtectedHeader(signature.protectedHeader);
          flattened.setUnprotectedHeader(signature.unprotectedHeader);
          const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
          if (i === 0) {
            jws.payload = payload;
          } else if (jws.payload !== payload) {
            throw new JWSInvalid("inconsistent use of JWS Unencoded Payload (RFC7797)");
          }
          jws.signatures.push(rest);
        }
        return jws;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/produce.js
var ProduceJWT;
var init_produce = __esm({
  "node_modules/jose/dist/browser/jwt/produce.js"() {
    init_epoch();
    init_is_object();
    init_secs();
    ProduceJWT = class {
      constructor(payload) {
        if (!isObject(payload)) {
          throw new TypeError("JWT Claims Set MUST be an object");
        }
        this._payload = payload;
      }
      setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
      }
      setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
      }
      setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
      }
      setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
      }
      setNotBefore(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, nbf: input };
        } else {
          this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setExpirationTime(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, exp: input };
        } else {
          this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setIssuedAt(input) {
        if (typeof input === "undefined") {
          this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
        } else {
          this._payload = { ...this._payload, iat: input };
        }
        return this;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/sign.js
var SignJWT;
var init_sign5 = __esm({
  "node_modules/jose/dist/browser/jwt/sign.js"() {
    init_sign3();
    init_errors();
    init_buffer_utils();
    init_produce();
    SignJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
      }
      async sign(key, options) {
        var _a;
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
          throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/encrypt.js
var EncryptJWT;
var init_encrypt5 = __esm({
  "node_modules/jose/dist/browser/jwt/encrypt.js"() {
    init_encrypt4();
    init_buffer_utils();
    init_produce();
    EncryptJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
      }
      replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
      }
      replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
      }
      async encrypt(key, options) {
        const enc = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
        }
        if (this._replicateSubjectAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
        }
        if (this._replicateAudienceAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
          enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
          enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
          enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
      }
    };
  }
});

// node_modules/jose/dist/browser/jwk/thumbprint.js
async function calculateJwkThumbprint(jwk, digestAlgorithm) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
  if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
    throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
  }
  let components;
  switch (jwk.kty) {
    case "EC":
      check(jwk.crv, '"crv" (Curve) Parameter');
      check(jwk.x, '"x" (X Coordinate) Parameter');
      check(jwk.y, '"y" (Y Coordinate) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
      break;
    case "OKP":
      check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
      check(jwk.x, '"x" (Public Key) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
      break;
    case "RSA":
      check(jwk.e, '"e" (Exponent) Parameter');
      check(jwk.n, '"n" (Modulus) Parameter');
      components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
      break;
    case "oct":
      check(jwk.k, '"k" (Key Value) Parameter');
      components = { k: jwk.k, kty: jwk.kty };
      break;
    default:
      throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
  }
  const data = encoder.encode(JSON.stringify(components));
  return encode2(await digest_default(digestAlgorithm, data));
}
async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
  digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
  const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
  return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
}
var check;
var init_thumbprint = __esm({
  "node_modules/jose/dist/browser/jwk/thumbprint.js"() {
    init_digest();
    init_base64url();
    init_errors();
    init_buffer_utils();
    init_is_object();
    check = (value, description) => {
      if (typeof value !== "string" || !value) {
        throw new JWKInvalid(`${description} missing or invalid`);
      }
    };
  }
});

// node_modules/jose/dist/browser/jwk/embedded.js
async function EmbeddedJWK(protectedHeader, token) {
  const joseHeader = {
    ...protectedHeader,
    ...token === null || token === void 0 ? void 0 : token.header
  };
  if (!isObject(joseHeader.jwk)) {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
  }
  const key = await importJWK({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
  if (key instanceof Uint8Array || key.type !== "public") {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
  }
  return key;
}
var init_embedded = __esm({
  "node_modules/jose/dist/browser/jwk/embedded.js"() {
    init_import();
    init_is_object();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwks/local.js
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject(key);
}
function clone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
async function importWithAlgCache(cache, jwk, alg) {
  const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
  if (cached[alg] === void 0) {
    const key = await importJWK({ ...jwk, ext: true }, alg);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg] = key;
  }
  return cached[alg];
}
function createLocalJWKSet(jwks) {
  const set = new LocalJWKSet(jwks);
  return async function(protectedHeader, token) {
    return set.getKey(protectedHeader, token);
  };
}
var LocalJWKSet;
var init_local = __esm({
  "node_modules/jose/dist/browser/jwks/local.js"() {
    init_import();
    init_errors();
    init_is_object();
    LocalJWKSet = class {
      constructor(jwks) {
        this._cached = /* @__PURE__ */ new WeakMap();
        if (!isJWKSLike(jwks)) {
          throw new JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone(jwks);
      }
      async getKey(protectedHeader, token) {
        const { alg, kid } = { ...protectedHeader, ...token === null || token === void 0 ? void 0 : token.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk2) => {
          let candidate = kty === jwk2.kty;
          if (candidate && typeof kid === "string") {
            candidate = kid === jwk2.kid;
          }
          if (candidate && typeof jwk2.alg === "string") {
            candidate = alg === jwk2.alg;
          }
          if (candidate && typeof jwk2.use === "string") {
            candidate = jwk2.use === "sig";
          }
          if (candidate && Array.isArray(jwk2.key_ops)) {
            candidate = jwk2.key_ops.includes("verify");
          }
          if (candidate && alg === "EdDSA") {
            candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
          }
          if (candidate) {
            switch (alg) {
              case "ES256":
                candidate = jwk2.crv === "P-256";
                break;
              case "ES256K":
                candidate = jwk2.crv === "secp256k1";
                break;
              case "ES384":
                candidate = jwk2.crv === "P-384";
                break;
              case "ES512":
                candidate = jwk2.crv === "P-521";
                break;
            }
          }
          return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) {
          throw new JWKSNoMatchingKey();
        } else if (length !== 1) {
          const error = new JWKSMultipleMatchingKeys();
          const { _cached } = this;
          error[Symbol.asyncIterator] = async function* () {
            for (const jwk2 of candidates) {
              try {
                yield await importWithAlgCache(_cached, jwk2, alg);
              } catch (_a) {
                continue;
              }
            }
          };
          throw error;
        }
        return importWithAlgCache(this._cached, jwk, alg);
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/fetch_jwks.js
var fetchJwks, fetch_jwks_default;
var init_fetch_jwks = __esm({
  "node_modules/jose/dist/browser/runtime/fetch_jwks.js"() {
    init_errors();
    fetchJwks = async (url, timeout, options) => {
      let controller;
      let id;
      let timedOut = false;
      if (typeof AbortController === "function") {
        controller = new AbortController();
        id = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, timeout);
      }
      const response = await fetch(url.href, {
        signal: controller ? controller.signal : void 0,
        redirect: "manual",
        headers: options.headers
      }).catch((err) => {
        if (timedOut)
          throw new JWKSTimeout();
        throw err;
      });
      if (id !== void 0)
        clearTimeout(id);
      if (response.status !== 200) {
        throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
      }
      try {
        return await response.json();
      } catch (_a) {
        throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
      }
    };
    fetch_jwks_default = fetchJwks;
  }
});

// node_modules/jose/dist/browser/jwks/remote.js
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
function createRemoteJWKSet(url, options) {
  const set = new RemoteJWKSet(url, options);
  return async function(protectedHeader, token) {
    return set.getKey(protectedHeader, token);
  };
}
var RemoteJWKSet;
var init_remote = __esm({
  "node_modules/jose/dist/browser/jwks/remote.js"() {
    init_fetch_jwks();
    init_errors();
    init_local();
    RemoteJWKSet = class extends LocalJWKSet {
      constructor(url, options) {
        super({ keys: [] });
        this._jwks = void 0;
        if (!(url instanceof URL)) {
          throw new TypeError("url must be an instance of URL");
        }
        this._url = new URL(url.href);
        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
        this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3;
        this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4;
        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5;
      }
      coolingDown() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
      }
      fresh() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
      }
      async getKey(protectedHeader, token) {
        if (!this._jwks || !this.fresh()) {
          await this.reload();
        }
        try {
          return await super.getKey(protectedHeader, token);
        } catch (err) {
          if (err instanceof JWKSNoMatchingKey) {
            if (this.coolingDown() === false) {
              await this.reload();
              return super.getKey(protectedHeader, token);
            }
          }
          throw err;
        }
      }
      async reload() {
        if (this._pendingFetch && isCloudflareWorkers()) {
          this._pendingFetch = void 0;
        }
        this._pendingFetch || (this._pendingFetch = fetch_jwks_default(this._url, this._timeoutDuration, this._options).then((json) => {
          if (!isJWKSLike(json)) {
            throw new JWKSInvalid("JSON Web Key Set malformed");
          }
          this._jwks = { keys: json.keys };
          this._jwksTimestamp = Date.now();
          this._pendingFetch = void 0;
        }).catch((err) => {
          this._pendingFetch = void 0;
          throw err;
        }));
        await this._pendingFetch;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/unsecured.js
var UnsecuredJWT;
var init_unsecured = __esm({
  "node_modules/jose/dist/browser/jwt/unsecured.js"() {
    init_base64url();
    init_buffer_utils();
    init_errors();
    init_jwt_claims_set();
    init_produce();
    UnsecuredJWT = class extends ProduceJWT {
      encode() {
        const header = encode2(JSON.stringify({ alg: "none" }));
        const payload = encode2(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
      }
      static decode(jwt, options) {
        if (typeof jwt !== "string") {
          throw new JWTInvalid("Unsecured JWT must be a string");
        }
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split(".");
        if (length !== 3 || signature !== "") {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        let header;
        try {
          header = JSON.parse(decoder2.decode(decode2(encodedHeader)));
          if (header.alg !== "none")
            throw new Error();
        } catch (_a) {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        const payload = jwt_claims_set_default(header, decode2(encodedPayload), options);
        return { payload, header };
      }
    };
  }
});

// node_modules/jose/dist/browser/util/base64url.js
var base64url_exports2 = {};
__export(base64url_exports2, {
  decode: () => decode3,
  encode: () => encode3
});
var encode3, decode3;
var init_base64url2 = __esm({
  "node_modules/jose/dist/browser/util/base64url.js"() {
    init_base64url();
    encode3 = encode2;
    decode3 = decode2;
  }
});

// node_modules/jose/dist/browser/util/decode_protected_header.js
function decodeProtectedHeader(token) {
  let protectedB64u;
  if (typeof token === "string") {
    const parts = token.split(".");
    if (parts.length === 3 || parts.length === 5) {
      ;
      [protectedB64u] = parts;
    }
  } else if (typeof token === "object" && token) {
    if ("protected" in token) {
      protectedB64u = token.protected;
    } else {
      throw new TypeError("Token does not contain a Protected Header");
    }
  }
  try {
    if (typeof protectedB64u !== "string" || !protectedB64u) {
      throw new Error();
    }
    const result = JSON.parse(decoder2.decode(decode3(protectedB64u)));
    if (!isObject(result)) {
      throw new Error();
    }
    return result;
  } catch (_a) {
    throw new TypeError("Invalid Token or Protected Header formatting");
  }
}
var init_decode_protected_header = __esm({
  "node_modules/jose/dist/browser/util/decode_protected_header.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/util/decode_jwt.js
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode3(payload);
  } catch (_a) {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder2.decode(decoded));
  } catch (_b) {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}
var init_decode_jwt = __esm({
  "node_modules/jose/dist/browser/util/decode_jwt.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/generate.js
async function generateSecret(alg, options) {
  var _a;
  let length;
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      length = parseInt(alg.slice(-3), 10);
      algorithm = { name: "HMAC", hash: `SHA-${length}`, length };
      keyUsages = ["sign", "verify"];
      break;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      length = parseInt(alg.slice(-3), 10);
      return random_default(new Uint8Array(length >> 3));
    case "A128KW":
    case "A192KW":
    case "A256KW":
      length = parseInt(alg.slice(1, 4), 10);
      algorithm = { name: "AES-KW", length };
      keyUsages = ["wrapKey", "unwrapKey"];
      break;
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW":
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      length = parseInt(alg.slice(1, 4), 10);
      algorithm = { name: "AES-GCM", length };
      keyUsages = ["encrypt", "decrypt"];
      break;
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
}
function getModulusLengthOption(options) {
  var _a;
  const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;
  if (typeof modulusLength !== "number" || modulusLength < 2048) {
    throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
  }
  return modulusLength;
}
async function generateKeyPair(alg, options) {
  var _a, _b, _c;
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "PS256":
    case "PS384":
    case "PS512":
      algorithm = {
        name: "RSA-PSS",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      algorithm = {
        name: "RSASSA-PKCS1-v1_5",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      algorithm = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["decrypt", "unwrapKey", "encrypt", "wrapKey"];
      break;
    case "ES256":
      algorithm = { name: "ECDSA", namedCurve: "P-256" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES384":
      algorithm = { name: "ECDSA", namedCurve: "P-384" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES512":
      algorithm = { name: "ECDSA", namedCurve: "P-521" };
      keyUsages = ["sign", "verify"];
      break;
    case "EdDSA":
      keyUsages = ["sign", "verify"];
      const crv = (_a = options === null || options === void 0 ? void 0 : options.crv) !== null && _a !== void 0 ? _a : "Ed25519";
      switch (crv) {
        case "Ed25519":
        case "Ed448":
          algorithm = { name: crv };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided");
      }
      break;
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      keyUsages = ["deriveKey", "deriveBits"];
      const crv2 = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : "P-256";
      switch (crv2) {
        case "P-256":
        case "P-384":
        case "P-521": {
          algorithm = { name: "ECDH", namedCurve: crv2 };
          break;
        }
        case "X25519":
        case "X448":
          algorithm = { name: crv2 };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, (_c = options === null || options === void 0 ? void 0 : options.extractable) !== null && _c !== void 0 ? _c : false, keyUsages);
}
var init_generate = __esm({
  "node_modules/jose/dist/browser/runtime/generate.js"() {
    init_webcrypto();
    init_errors();
    init_random();
  }
});

// node_modules/jose/dist/browser/key/generate_key_pair.js
async function generateKeyPair2(alg, options) {
  return generateKeyPair(alg, options);
}
var init_generate_key_pair = __esm({
  "node_modules/jose/dist/browser/key/generate_key_pair.js"() {
    init_generate();
  }
});

// node_modules/jose/dist/browser/key/generate_secret.js
async function generateSecret2(alg, options) {
  return generateSecret(alg, options);
}
var init_generate_secret = __esm({
  "node_modules/jose/dist/browser/key/generate_secret.js"() {
    init_generate();
  }
});

// node_modules/jose/dist/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  CompactEncrypt: () => CompactEncrypt,
  CompactSign: () => CompactSign,
  EmbeddedJWK: () => EmbeddedJWK,
  EncryptJWT: () => EncryptJWT,
  FlattenedEncrypt: () => FlattenedEncrypt,
  FlattenedSign: () => FlattenedSign,
  GeneralEncrypt: () => GeneralEncrypt,
  GeneralSign: () => GeneralSign,
  SignJWT: () => SignJWT,
  UnsecuredJWT: () => UnsecuredJWT,
  base64url: () => base64url_exports2,
  calculateJwkThumbprint: () => calculateJwkThumbprint,
  calculateJwkThumbprintUri: () => calculateJwkThumbprintUri,
  compactDecrypt: () => compactDecrypt,
  compactVerify: () => compactVerify,
  createLocalJWKSet: () => createLocalJWKSet,
  createRemoteJWKSet: () => createRemoteJWKSet,
  decodeJwt: () => decodeJwt,
  decodeProtectedHeader: () => decodeProtectedHeader,
  errors: () => errors_exports,
  exportJWK: () => exportJWK,
  exportPKCS8: () => exportPKCS8,
  exportSPKI: () => exportSPKI,
  flattenedDecrypt: () => flattenedDecrypt,
  flattenedVerify: () => flattenedVerify,
  generalDecrypt: () => generalDecrypt,
  generalVerify: () => generalVerify,
  generateKeyPair: () => generateKeyPair2,
  generateSecret: () => generateSecret2,
  importJWK: () => importJWK,
  importPKCS8: () => importPKCS8,
  importSPKI: () => importSPKI,
  importX509: () => importX509,
  jwtDecrypt: () => jwtDecrypt,
  jwtVerify: () => jwtVerify
});
var init_browser = __esm({
  "node_modules/jose/dist/browser/index.js"() {
    init_decrypt3();
    init_decrypt2();
    init_decrypt4();
    init_encrypt3();
    init_verify3();
    init_verify2();
    init_verify4();
    init_verify5();
    init_decrypt5();
    init_encrypt4();
    init_encrypt2();
    init_sign3();
    init_sign2();
    init_sign4();
    init_sign5();
    init_encrypt5();
    init_thumbprint();
    init_embedded();
    init_local();
    init_remote();
    init_unsecured();
    init_export();
    init_import();
    init_decode_protected_header();
    init_decode_jwt();
    init_errors();
    init_generate_key_pair();
    init_generate_secret();
    init_base64url2();
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target2, start, end, thisStart, thisEnd) {
      if (isInstance(target2, Uint8Array)) {
        target2 = Buffer3.from(target2, target2.offset, target2.byteLength);
      }
      if (!Buffer3.isBuffer(target2)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target2
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target2 ? target2.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target2.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target2)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target2.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read2(arr, i + j) !== read2(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE2(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target2, targetStart, start, end) {
      if (!Buffer3.isBuffer(target2))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target2.length)
        targetStart = target2.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target2.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target2.length - targetStart < end - start) {
        end = target2.length - targetStart + start;
      }
      const len = end - start;
      if (this === target2 && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target2,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src2.length)
          break;
        dst[i + offset] = src2[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table2 = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table2[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table2;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/bytestreamjs/build/cjs/byte_stream.js
var require_byte_stream = __commonJS({
  "node_modules/bytestreamjs/build/cjs/byte_stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ByteStream = void 0;
    var ByteStream = class _ByteStream {
      constructor(parameters = {}) {
        if ("view" in parameters) {
          this.fromUint8Array(parameters.view);
        } else if ("buffer" in parameters) {
          this.fromArrayBuffer(parameters.buffer);
        } else if ("string" in parameters) {
          this.fromString(parameters.string);
        } else if ("hexstring" in parameters) {
          this.fromHexString(parameters.hexstring);
        } else {
          if ("length" in parameters && parameters.length > 0) {
            this.length = parameters.length;
            if (parameters.stub) {
              for (let i = 0; i < this._view.length; i++) {
                this._view[i] = parameters.stub;
              }
            }
          } else {
            this.length = 0;
          }
        }
      }
      set buffer(value) {
        this._buffer = value;
        this._view = new Uint8Array(this._buffer);
      }
      get buffer() {
        return this._buffer;
      }
      set view(value) {
        this._buffer = new ArrayBuffer(value.length);
        this._view = new Uint8Array(this._buffer);
        this._view.set(value);
      }
      get view() {
        return this._view;
      }
      get length() {
        return this.view.byteLength;
      }
      set length(value) {
        this._buffer = new ArrayBuffer(value);
        this._view = new Uint8Array(this._buffer);
      }
      clear() {
        this._buffer = new ArrayBuffer(0);
        this._view = new Uint8Array(this._buffer);
      }
      fromArrayBuffer(array) {
        this._buffer = array;
        this._view = new Uint8Array(this._buffer);
      }
      fromUint8Array(array) {
        this.fromArrayBuffer(new Uint8Array(array).buffer);
      }
      fromString(string) {
        const stringLength = string.length;
        this.length = stringLength;
        for (let i = 0; i < stringLength; i++)
          this.view[i] = string.charCodeAt(i);
      }
      toString(start = 0, length = this.view.length - start) {
        let result = "";
        if (start >= this.view.length || start < 0) {
          start = 0;
        }
        if (length >= this.view.length || length < 0) {
          length = this.view.length - start;
        }
        for (let i = start; i < start + length; i++)
          result += String.fromCharCode(this.view[i]);
        return result;
      }
      fromHexString(hexString) {
        const stringLength = hexString.length;
        this.buffer = new ArrayBuffer(stringLength >> 1);
        this.view = new Uint8Array(this.buffer);
        const hexMap = /* @__PURE__ */ new Map();
        hexMap.set("0", 0);
        hexMap.set("1", 1);
        hexMap.set("2", 2);
        hexMap.set("3", 3);
        hexMap.set("4", 4);
        hexMap.set("5", 5);
        hexMap.set("6", 6);
        hexMap.set("7", 7);
        hexMap.set("8", 8);
        hexMap.set("9", 9);
        hexMap.set("A", 10);
        hexMap.set("a", 10);
        hexMap.set("B", 11);
        hexMap.set("b", 11);
        hexMap.set("C", 12);
        hexMap.set("c", 12);
        hexMap.set("D", 13);
        hexMap.set("d", 13);
        hexMap.set("E", 14);
        hexMap.set("e", 14);
        hexMap.set("F", 15);
        hexMap.set("f", 15);
        let j = 0;
        let temp = 0;
        for (let i = 0; i < stringLength; i++) {
          if (!(i % 2)) {
            temp = hexMap.get(hexString.charAt(i)) << 4;
          } else {
            temp |= hexMap.get(hexString.charAt(i));
            this.view[j] = temp;
            j++;
          }
        }
      }
      toHexString(start = 0, length = this.view.length - start) {
        let result = "";
        if (start >= this.view.length || start < 0) {
          start = 0;
        }
        if (length >= this.view.length || length < 0) {
          length = this.view.length - start;
        }
        for (let i = start; i < start + length; i++) {
          const str = this.view[i].toString(16).toUpperCase();
          result = result + (str.length == 1 ? "0" : "") + str;
        }
        return result;
      }
      copy(start = 0, length = this.length - start) {
        if (!start && !this.length) {
          return new _ByteStream();
        }
        if (start < 0 || start > this.length - 1) {
          throw new Error(`Wrong start position: ${start}`);
        }
        const stream = new _ByteStream({
          buffer: this._buffer.slice(start, start + length)
        });
        return stream;
      }
      slice(start = 0, end = this.length) {
        if (!start && !this.length) {
          return new _ByteStream();
        }
        if (start < 0 || start > this.length - 1) {
          throw new Error(`Wrong start position: ${start}`);
        }
        const stream = new _ByteStream({
          buffer: this._buffer.slice(start, end)
        });
        return stream;
      }
      realloc(size) {
        const buffer = new ArrayBuffer(size);
        const view = new Uint8Array(buffer);
        if (size > this._view.length)
          view.set(this._view);
        else {
          view.set(new Uint8Array(this._buffer, 0, size));
        }
        this._buffer = buffer;
        this._view = new Uint8Array(this._buffer);
      }
      append(stream) {
        const initialSize = this.length;
        const streamViewLength = stream.length;
        const subarrayView = stream._view.subarray();
        this.realloc(initialSize + streamViewLength);
        this._view.set(subarrayView, initialSize);
      }
      insert(stream, start = 0, length = this.length - start) {
        if (start > this.length - 1)
          return false;
        if (length > this.length - start) {
          length = this.length - start;
        }
        if (length > stream.length) {
          length = stream.length;
        }
        if (length == stream.length)
          this._view.set(stream._view, start);
        else {
          this._view.set(stream._view.subarray(0, length), start);
        }
        return true;
      }
      isEqual(stream) {
        if (this.length != stream.length)
          return false;
        for (let i = 0; i < stream.length; i++) {
          if (this.view[i] != stream.view[i])
            return false;
        }
        return true;
      }
      isEqualView(view) {
        if (view.length != this.view.length)
          return false;
        for (let i = 0; i < view.length; i++) {
          if (this.view[i] != view[i])
            return false;
        }
        return true;
      }
      findPattern(pattern, start_, length_, backward_) {
        const { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
        const patternLength = pattern.length;
        if (patternLength > length) {
          return -1;
        }
        const patternArray = [];
        for (let i = 0; i < patternLength; i++)
          patternArray.push(pattern.view[i]);
        for (let i = 0; i <= length - patternLength; i++) {
          let equal = true;
          const equalStart = backward ? start - patternLength - i : start + i;
          for (let j = 0; j < patternLength; j++) {
            if (this.view[j + equalStart] != patternArray[j]) {
              equal = false;
              break;
            }
          }
          if (equal) {
            return backward ? start - patternLength - i : start + patternLength + i;
          }
        }
        return -1;
      }
      findFirstIn(patterns, start_, length_, backward_) {
        const { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
        const result = {
          id: -1,
          position: backward ? 0 : start + length,
          length: 0
        };
        for (let i = 0; i < patterns.length; i++) {
          const position3 = this.findPattern(patterns[i], start, length, backward);
          if (position3 != -1) {
            let valid = false;
            const patternLength = patterns[i].length;
            if (backward) {
              if (position3 - patternLength >= result.position - result.length)
                valid = true;
            } else {
              if (position3 - patternLength <= result.position - result.length)
                valid = true;
            }
            if (valid) {
              result.position = position3;
              result.id = i;
              result.length = patternLength;
            }
          }
        }
        return result;
      }
      findAllIn(patterns, start_, length_) {
        let { start, length } = this.prepareFindParameters(start_, length_);
        const result = [];
        let patternFound = {
          id: -1,
          position: start
        };
        do {
          const position3 = patternFound.position;
          patternFound = this.findFirstIn(patterns, patternFound.position, length);
          if (patternFound.id == -1) {
            break;
          }
          length -= patternFound.position - position3;
          result.push({
            id: patternFound.id,
            position: patternFound.position
          });
        } while (true);
        return result;
      }
      findAllPatternIn(pattern, start_, length_) {
        const { start, length } = this.prepareFindParameters(start_, length_);
        const result = [];
        const patternLength = pattern.length;
        if (patternLength > length) {
          return -1;
        }
        const patternArray = Array.from(pattern.view);
        for (let i = 0; i <= length - patternLength; i++) {
          let equal = true;
          const equalStart = start + i;
          for (let j = 0; j < patternLength; j++) {
            if (this.view[j + equalStart] != patternArray[j]) {
              equal = false;
              break;
            }
          }
          if (equal) {
            result.push(start + patternLength + i);
            i += patternLength - 1;
          }
        }
        return result;
      }
      findFirstNotIn(patterns, start_, length_, backward_) {
        let { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
        const result = {
          left: {
            id: -1,
            position: start
          },
          right: {
            id: -1,
            position: 0
          },
          value: new _ByteStream()
        };
        let currentLength = length;
        while (currentLength > 0) {
          result.right = this.findFirstIn(patterns, backward ? start - length + currentLength : start + length - currentLength, currentLength, backward);
          if (result.right.id == -1) {
            length = currentLength;
            if (backward) {
              start -= length;
            } else {
              start = result.left.position;
            }
            result.value = new _ByteStream({
              buffer: this._buffer.slice(start, start + length)
            });
            break;
          }
          if (result.right.position != (backward ? result.left.position - patterns[result.right.id].length : result.left.position + patterns[result.right.id].length)) {
            if (backward) {
              start = result.right.position + patterns[result.right.id].length;
              length = result.left.position - result.right.position - patterns[result.right.id].length;
            } else {
              start = result.left.position;
              length = result.right.position - result.left.position - patterns[result.right.id].length;
            }
            result.value = new _ByteStream({
              buffer: this._buffer.slice(start, start + length)
            });
            break;
          }
          result.left = result.right;
          currentLength -= patterns[result.right.id].length;
        }
        if (backward) {
          const temp = result.right;
          result.right = result.left;
          result.left = temp;
        }
        return result;
      }
      findAllNotIn(patterns, start_, length_) {
        let { start, length } = this.prepareFindParameters(start_, length_);
        const result = [];
        let patternFound = {
          left: {
            id: -1,
            position: start
          },
          right: {
            id: -1,
            position: start
          },
          value: new _ByteStream()
        };
        do {
          const position3 = patternFound.right.position;
          patternFound = this.findFirstNotIn(patterns, patternFound.right.position, length);
          length -= patternFound.right.position - position3;
          result.push({
            left: {
              id: patternFound.left.id,
              position: patternFound.left.position
            },
            right: {
              id: patternFound.right.id,
              position: patternFound.right.position
            },
            value: patternFound.value
          });
        } while (patternFound.right.id != -1);
        return result;
      }
      findFirstSequence(patterns, start_, length_, backward_) {
        let { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
        const firstIn = this.skipNotPatterns(patterns, start, length, backward);
        if (firstIn == -1) {
          return {
            position: -1,
            value: new _ByteStream()
          };
        }
        const firstNotIn = this.skipPatterns(patterns, firstIn, length - (backward ? start - firstIn : firstIn - start), backward);
        if (backward) {
          start = firstNotIn;
          length = firstIn - firstNotIn;
        } else {
          start = firstIn;
          length = firstNotIn - firstIn;
        }
        const value = new _ByteStream({
          buffer: this._buffer.slice(start, start + length)
        });
        return {
          position: firstNotIn,
          value
        };
      }
      findAllSequences(patterns, start_, length_) {
        let { start, length } = this.prepareFindParameters(start_, length_);
        const result = [];
        let patternFound = {
          position: start,
          value: new _ByteStream()
        };
        do {
          const position3 = patternFound.position;
          patternFound = this.findFirstSequence(patterns, patternFound.position, length);
          if (patternFound.position != -1) {
            length -= patternFound.position - position3;
            result.push({
              position: patternFound.position,
              value: patternFound.value
            });
          }
        } while (patternFound.position != -1);
        return result;
      }
      findPairedPatterns(leftPattern, rightPattern, start_, length_) {
        const result = [];
        if (leftPattern.isEqual(rightPattern))
          return result;
        const { start, length } = this.prepareFindParameters(start_, length_);
        let currentPositionLeft = 0;
        const leftPatterns = this.findAllPatternIn(leftPattern, start, length);
        if (!Array.isArray(leftPatterns) || leftPatterns.length == 0) {
          return result;
        }
        const rightPatterns = this.findAllPatternIn(rightPattern, start, length);
        if (!Array.isArray(rightPatterns) || rightPatterns.length == 0) {
          return result;
        }
        while (currentPositionLeft < leftPatterns.length) {
          if (rightPatterns.length == 0) {
            break;
          }
          if (leftPatterns[0] == rightPatterns[0]) {
            result.push({
              left: leftPatterns[0],
              right: rightPatterns[0]
            });
            leftPatterns.splice(0, 1);
            rightPatterns.splice(0, 1);
            continue;
          }
          if (leftPatterns[currentPositionLeft] > rightPatterns[0]) {
            break;
          }
          while (leftPatterns[currentPositionLeft] < rightPatterns[0]) {
            currentPositionLeft++;
            if (currentPositionLeft >= leftPatterns.length) {
              break;
            }
          }
          result.push({
            left: leftPatterns[currentPositionLeft - 1],
            right: rightPatterns[0]
          });
          leftPatterns.splice(currentPositionLeft - 1, 1);
          rightPatterns.splice(0, 1);
          currentPositionLeft = 0;
        }
        result.sort((a, b) => a.left - b.left);
        return result;
      }
      findPairedArrays(inputLeftPatterns, inputRightPatterns, start_, length_) {
        const { start, length } = this.prepareFindParameters(start_, length_);
        const result = [];
        let currentPositionLeft = 0;
        const leftPatterns = this.findAllIn(inputLeftPatterns, start, length);
        if (leftPatterns.length == 0)
          return result;
        const rightPatterns = this.findAllIn(inputRightPatterns, start, length);
        if (rightPatterns.length == 0)
          return result;
        while (currentPositionLeft < leftPatterns.length) {
          if (rightPatterns.length == 0) {
            break;
          }
          if (leftPatterns[0].position == rightPatterns[0].position) {
            result.push({
              left: leftPatterns[0],
              right: rightPatterns[0]
            });
            leftPatterns.splice(0, 1);
            rightPatterns.splice(0, 1);
            continue;
          }
          if (leftPatterns[currentPositionLeft].position > rightPatterns[0].position) {
            break;
          }
          while (leftPatterns[currentPositionLeft].position < rightPatterns[0].position) {
            currentPositionLeft++;
            if (currentPositionLeft >= leftPatterns.length) {
              break;
            }
          }
          result.push({
            left: leftPatterns[currentPositionLeft - 1],
            right: rightPatterns[0]
          });
          leftPatterns.splice(currentPositionLeft - 1, 1);
          rightPatterns.splice(0, 1);
          currentPositionLeft = 0;
        }
        result.sort((a, b) => a.left.position - b.left.position);
        return result;
      }
      replacePattern(searchPattern, replacePattern, start_, length_, findAllResult = null) {
        let result = [];
        let i;
        const output = {
          status: -1,
          searchPatternPositions: [],
          replacePatternPositions: []
        };
        const { start, length } = this.prepareFindParameters(start_, length_);
        if (findAllResult == null) {
          result = this.findAllIn([searchPattern], start, length);
          if (result.length == 0) {
            return output;
          }
        } else {
          result = findAllResult;
        }
        output.searchPatternPositions.push(...Array.from(result, (element) => element.position));
        const patternDifference = searchPattern.length - replacePattern.length;
        const changedBuffer = new ArrayBuffer(this.view.length - result.length * patternDifference);
        const changedView = new Uint8Array(changedBuffer);
        changedView.set(new Uint8Array(this.buffer, 0, start));
        for (i = 0; i < result.length; i++) {
          const currentPosition = i == 0 ? start : result[i - 1].position;
          changedView.set(new Uint8Array(this.buffer, currentPosition, result[i].position - searchPattern.length - currentPosition), currentPosition - i * patternDifference);
          changedView.set(replacePattern.view, result[i].position - searchPattern.length - i * patternDifference);
          output.replacePatternPositions.push(result[i].position - searchPattern.length - i * patternDifference);
        }
        i--;
        changedView.set(new Uint8Array(this.buffer, result[i].position, this.length - result[i].position), result[i].position - searchPattern.length + replacePattern.length - i * patternDifference);
        this.buffer = changedBuffer;
        this.view = new Uint8Array(this.buffer);
        output.status = 1;
        return output;
      }
      skipPatterns(patterns, start_, length_, backward_) {
        const { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
        let result = start;
        for (let k = 0; k < patterns.length; k++) {
          const patternLength = patterns[k].length;
          const equalStart = backward ? result - patternLength : result;
          let equal = true;
          for (let j = 0; j < patternLength; j++) {
            if (this.view[j + equalStart] != patterns[k].view[j]) {
              equal = false;
              break;
            }
          }
          if (equal) {
            k = -1;
            if (backward) {
              result -= patternLength;
              if (result <= 0)
                return result;
            } else {
              result += patternLength;
              if (result >= start + length)
                return result;
            }
          }
        }
        return result;
      }
      skipNotPatterns(patterns, start_, length_, backward_) {
        const { start, length, backward } = this.prepareFindParameters(start_, length_, backward_);
        let result = -1;
        for (let i = 0; i < length; i++) {
          for (let k = 0; k < patterns.length; k++) {
            const patternLength = patterns[k].length;
            const equalStart = backward ? start - i - patternLength : start + i;
            let equal = true;
            for (let j = 0; j < patternLength; j++) {
              if (this.view[j + equalStart] != patterns[k].view[j]) {
                equal = false;
                break;
              }
            }
            if (equal) {
              result = backward ? start - i : start + i;
              break;
            }
          }
          if (result != -1) {
            break;
          }
        }
        return result;
      }
      prepareFindParameters(start = null, length = null, backward = false) {
        if (start === null) {
          start = backward ? this.length : 0;
        }
        if (start > this.length) {
          start = this.length;
        }
        if (backward) {
          if (length === null) {
            length = start;
          }
          if (length > start) {
            length = start;
          }
        } else {
          if (length === null) {
            length = this.length - start;
          }
          if (length > this.length - start) {
            length = this.length - start;
          }
        }
        return { start, length, backward };
      }
    };
    exports.ByteStream = ByteStream;
  }
});

// node_modules/bytestreamjs/build/cjs/seq_stream.js
var require_seq_stream = __commonJS({
  "node_modules/bytestreamjs/build/cjs/seq_stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SeqStream = void 0;
    var byte_stream_1 = require_byte_stream();
    var pow2_24 = 16777216;
    var SeqStream = class _SeqStream {
      constructor(parameters = {}) {
        this._stream = new byte_stream_1.ByteStream();
        this._length = 0;
        this._start = 0;
        this.backward = false;
        this.appendBlock = 0;
        this.prevLength = 0;
        this.prevStart = 0;
        if ("view" in parameters) {
          this.stream = new byte_stream_1.ByteStream({ view: parameters.view });
        } else if ("buffer" in parameters) {
          this.stream = new byte_stream_1.ByteStream({ buffer: parameters.buffer });
        } else if ("string" in parameters) {
          this.stream = new byte_stream_1.ByteStream({ string: parameters.string });
        } else if ("hexstring" in parameters) {
          this.stream = new byte_stream_1.ByteStream({ hexstring: parameters.hexstring });
        } else if ("stream" in parameters) {
          this.stream = parameters.stream.slice();
        } else {
          this.stream = new byte_stream_1.ByteStream();
        }
        if ("backward" in parameters && parameters.backward) {
          this.backward = parameters.backward;
          this._start = this.stream.length;
        }
        if ("length" in parameters && parameters.length > 0) {
          this._length = parameters.length;
        }
        if ("start" in parameters && parameters.start && parameters.start > 0) {
          this._start = parameters.start;
        }
        if ("appendBlock" in parameters && parameters.appendBlock && parameters.appendBlock > 0) {
          this.appendBlock = parameters.appendBlock;
        }
      }
      set stream(value) {
        this._stream = value;
        this.prevLength = this._length;
        this._length = value.length;
        this.prevStart = this._start;
        this._start = 0;
      }
      get stream() {
        return this._stream;
      }
      set length(value) {
        this.prevLength = this._length;
        this._length = value;
      }
      get length() {
        if (this.appendBlock) {
          return this.start;
        }
        return this._length;
      }
      set start(value) {
        if (value > this.stream.length)
          return;
        this.prevStart = this._start;
        this.prevLength = this._length;
        this._length -= this.backward ? this._start - value : value - this._start;
        this._start = value;
      }
      get start() {
        return this._start;
      }
      get buffer() {
        return this._stream.buffer.slice(0, this._length);
      }
      resetPosition() {
        this._start = this.prevStart;
        this._length = this.prevLength;
      }
      findPattern(pattern, gap = null) {
        if (gap == null || gap > this.length) {
          gap = this.length;
        }
        const result = this.stream.findPattern(pattern, this.start, this.length, this.backward);
        if (result == -1)
          return result;
        if (this.backward) {
          if (result < this.start - pattern.length - gap) {
            return -1;
          }
        } else {
          if (result > this.start + pattern.length + gap) {
            return -1;
          }
        }
        this.start = result;
        return result;
      }
      findFirstIn(patterns, gap = null) {
        if (gap == null || gap > this.length) {
          gap = this.length;
        }
        const result = this.stream.findFirstIn(patterns, this.start, this.length, this.backward);
        if (result.id == -1)
          return result;
        if (this.backward) {
          if (result.position < this.start - patterns[result.id].length - gap) {
            return {
              id: -1,
              position: this.backward ? 0 : this.start + this.length
            };
          }
        } else {
          if (result.position > this.start + patterns[result.id].length + gap) {
            return {
              id: -1,
              position: this.backward ? 0 : this.start + this.length
            };
          }
        }
        this.start = result.position;
        return result;
      }
      findAllIn(patterns) {
        const start = this.backward ? this.start - this.length : this.start;
        return this.stream.findAllIn(patterns, start, this.length);
      }
      findFirstNotIn(patterns, gap = null) {
        if (gap == null || gap > this._length) {
          gap = this._length;
        }
        const result = this._stream.findFirstNotIn(patterns, this._start, this._length, this.backward);
        if (result.left.id == -1 && result.right.id == -1) {
          return result;
        }
        if (this.backward) {
          if (result.right.id != -1) {
            if (result.right.position < this._start - patterns[result.right.id].length - gap) {
              return {
                left: {
                  id: -1,
                  position: this._start
                },
                right: {
                  id: -1,
                  position: 0
                },
                value: new byte_stream_1.ByteStream()
              };
            }
          }
        } else {
          if (result.left.id != -1) {
            if (result.left.position > this._start + patterns[result.left.id].length + gap) {
              return {
                left: {
                  id: -1,
                  position: this._start
                },
                right: {
                  id: -1,
                  position: 0
                },
                value: new byte_stream_1.ByteStream()
              };
            }
          }
        }
        if (this.backward) {
          if (result.left.id == -1) {
            this.start = 0;
          } else {
            this.start = result.left.position;
          }
        } else {
          if (result.right.id == -1) {
            this.start = this._start + this._length;
          } else {
            this.start = result.right.position;
          }
        }
        return result;
      }
      findAllNotIn(patterns) {
        const start = this.backward ? this._start - this._length : this._start;
        return this._stream.findAllNotIn(patterns, start, this._length);
      }
      findFirstSequence(patterns, length = null, gap = null) {
        if (length == null || length > this._length) {
          length = this._length;
        }
        if (gap == null || gap > length) {
          gap = length;
        }
        const result = this._stream.findFirstSequence(patterns, this._start, length, this.backward);
        if (result.value.length == 0) {
          return result;
        }
        if (this.backward) {
          if (result.position < this._start - result.value.length - gap) {
            return {
              position: -1,
              value: new byte_stream_1.ByteStream()
            };
          }
        } else {
          if (result.position > this._start + result.value.length + gap) {
            return {
              position: -1,
              value: new byte_stream_1.ByteStream()
            };
          }
        }
        this.start = result.position;
        return result;
      }
      findAllSequences(patterns) {
        const start = this.backward ? this.start - this.length : this.start;
        return this.stream.findAllSequences(patterns, start, this.length);
      }
      findPairedPatterns(leftPattern, rightPattern, gap = null) {
        if (gap == null || gap > this.length) {
          gap = this.length;
        }
        const start = this.backward ? this.start - this.length : this.start;
        const result = this.stream.findPairedPatterns(leftPattern, rightPattern, start, this.length);
        if (result.length) {
          if (this.backward) {
            if (result[0].right < this.start - rightPattern.length - gap) {
              return [];
            }
          } else {
            if (result[0].left > this.start + leftPattern.length + gap) {
              return [];
            }
          }
        }
        return result;
      }
      findPairedArrays(leftPatterns, rightPatterns, gap = null) {
        if (gap == null || gap > this.length) {
          gap = this.length;
        }
        const start = this.backward ? this.start - this.length : this.start;
        const result = this.stream.findPairedArrays(leftPatterns, rightPatterns, start, this.length);
        if (result.length) {
          if (this.backward) {
            if (result[0].right.position < this.start - rightPatterns[result[0].right.id].length - gap) {
              return [];
            }
          } else {
            if (result[0].left.position > this.start + leftPatterns[result[0].left.id].length + gap) {
              return [];
            }
          }
        }
        return result;
      }
      replacePattern(searchPattern, replacePattern) {
        const start = this.backward ? this.start - this.length : this.start;
        return this.stream.replacePattern(searchPattern, replacePattern, start, this.length);
      }
      skipPatterns(patterns) {
        const result = this.stream.skipPatterns(patterns, this.start, this.length, this.backward);
        this.start = result;
        return result;
      }
      skipNotPatterns(patterns) {
        const result = this.stream.skipNotPatterns(patterns, this.start, this.length, this.backward);
        if (result == -1)
          return -1;
        this.start = result;
        return result;
      }
      append(stream) {
        this.beforeAppend(stream.length);
        this._stream.view.set(stream.view, this._start);
        this._length += stream.length * 2;
        this.start = this._start + stream.length;
        this.prevLength -= stream.length * 2;
      }
      appendView(view) {
        this.beforeAppend(view.length);
        this._stream.view.set(view, this._start);
        this._length += view.length * 2;
        this.start = this._start + view.length;
        this.prevLength -= view.length * 2;
      }
      appendChar(char) {
        this.beforeAppend(1);
        this._stream.view[this._start] = char;
        this._length += 2;
        this.start = this._start + 1;
        this.prevLength -= 2;
      }
      appendUint16(number) {
        this.beforeAppend(2);
        const value = new Uint16Array([number]);
        const view = new Uint8Array(value.buffer);
        this.stream.view[this._start] = view[1];
        this._stream.view[this._start + 1] = view[0];
        this._length += 4;
        this.start = this._start + 2;
        this.prevLength -= 4;
      }
      appendUint24(number) {
        this.beforeAppend(3);
        const value = new Uint32Array([number]);
        const view = new Uint8Array(value.buffer);
        this._stream.view[this._start] = view[2];
        this._stream.view[this._start + 1] = view[1];
        this._stream.view[this._start + 2] = view[0];
        this._length += 6;
        this.start = this._start + 3;
        this.prevLength -= 6;
      }
      appendUint32(number) {
        this.beforeAppend(4);
        const value = new Uint32Array([number]);
        const view = new Uint8Array(value.buffer);
        this._stream.view[this._start] = view[3];
        this._stream.view[this._start + 1] = view[2];
        this._stream.view[this._start + 2] = view[1];
        this._stream.view[this._start + 3] = view[0];
        this._length += 8;
        this.start = this._start + 4;
        this.prevLength -= 8;
      }
      appendInt16(number) {
        this.beforeAppend(2);
        const value = new Int16Array([number]);
        const view = new Uint8Array(value.buffer);
        this._stream.view[this._start] = view[1];
        this._stream.view[this._start + 1] = view[0];
        this._length += 4;
        this.start = this._start + 2;
        this.prevLength -= 4;
      }
      appendInt32(number) {
        this.beforeAppend(4);
        const value = new Int32Array([number]);
        const view = new Uint8Array(value.buffer);
        this._stream.view[this._start] = view[3];
        this._stream.view[this._start + 1] = view[2];
        this._stream.view[this._start + 2] = view[1];
        this._stream.view[this._start + 3] = view[0];
        this._length += 8;
        this.start = this._start + 4;
        this.prevLength -= 8;
      }
      getBlock(size, changeLength = true) {
        if (this._length <= 0) {
          return new Uint8Array(0);
        }
        if (this._length < size) {
          size = this._length;
        }
        let result;
        if (this.backward) {
          const view = this._stream.view.subarray(this._length - size, this._length);
          result = new Uint8Array(size);
          for (let i = 0; i < size; i++) {
            result[size - 1 - i] = view[i];
          }
        } else {
          result = this._stream.view.subarray(this._start, this._start + size);
        }
        if (changeLength) {
          this.start += this.backward ? -1 * size : size;
        }
        return result;
      }
      getUint16(changeLength = true) {
        const block = this.getBlock(2, changeLength);
        if (block.length < 2)
          return 0;
        return block[0] << 8 | block[1];
      }
      getInt16(changeLength = true) {
        const num = this.getUint16(changeLength);
        const negative = 32768;
        if (num & negative) {
          return -(negative - (num ^ negative));
        }
        return num;
      }
      getUint24(changeLength = true) {
        const block = this.getBlock(4, changeLength);
        if (block.length < 3)
          return 0;
        return block[0] << 16 | block[1] << 8 | block[2];
      }
      getUint32(changeLength = true) {
        const block = this.getBlock(4, changeLength);
        if (block.length < 4)
          return 0;
        return block[0] * pow2_24 + (block[1] << 16) + (block[2] << 8) + block[3];
      }
      getInt32(changeLength = true) {
        const num = this.getUint32(changeLength);
        const negative = 2147483648;
        if (num & negative) {
          return -(negative - (num ^ negative));
        }
        return num;
      }
      beforeAppend(size) {
        if (this._start + size > this._stream.length) {
          if (size > this.appendBlock) {
            this.appendBlock = size + _SeqStream.APPEND_BLOCK;
          }
          this._stream.realloc(this._stream.length + this.appendBlock);
        }
      }
    };
    exports.SeqStream = SeqStream;
    SeqStream.APPEND_BLOCK = 1e3;
  }
});

// node_modules/bytestreamjs/build/cjs/helpers.js
var require_helpers = __commonJS({
  "node_modules/bytestreamjs/build/cjs/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseByteMap = void 0;
    function parseByteMap(stream, map, elements, start = null, length = null) {
      if (start === null) {
        start = 0;
      }
      if (start > stream.length - 1) {
        return [];
      }
      if (length === null) {
        length = stream.length - start;
      }
      if (length > stream.length - start) {
        length = stream.length - start;
      }
      let dataView2;
      if (start == 0 && length == stream.length) {
        dataView2 = stream.view;
      } else {
        dataView2 = new Uint8Array(stream.buffer, start, length);
      }
      const resultArray = new Array(elements);
      let elementsCount = 0;
      let count = 0;
      const mapLength = map.length;
      while (count < length) {
        let structureLength = 0;
        resultArray[elementsCount] = {};
        for (let i = 0; i < mapLength; i++) {
          if (map[i].maxlength == 0) {
            if ("defaultValue" in map[i]) {
              resultArray[elementsCount][map[i].name] = map[i].defaultValue;
            }
            continue;
          }
          const array = new Uint8Array(map[i].maxlength);
          for (let j = 0; j < map[i].maxlength; j++) {
            array[j] = dataView2[count++];
          }
          const result = map[i].func(array);
          if (result.status == -1) {
            if (resultArray.length == 1) {
              return [];
            }
            return resultArray.slice(0, resultArray.length - 1);
          }
          if (map[i].type != "check") {
            resultArray[elementsCount][map[i].name] = result.value;
          }
          count -= map[i].maxlength - result.length;
          structureLength += result.length;
        }
        resultArray[elementsCount++].structureLength = structureLength;
      }
      return resultArray;
    }
    exports.parseByteMap = parseByteMap;
  }
});

// node_modules/bytestreamjs/build/cjs/bit.js
var require_bit = __commonJS({
  "node_modules/bytestreamjs/build/cjs/bit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitsToStringArray = void 0;
    exports.bitsToStringArray = [
      "00000000",
      "00000001",
      "00000010",
      "00000011",
      "00000100",
      "00000101",
      "00000110",
      "00000111",
      "00001000",
      "00001001",
      "00001010",
      "00001011",
      "00001100",
      "00001101",
      "00001110",
      "00001111",
      "00010000",
      "00010001",
      "00010010",
      "00010011",
      "00010100",
      "00010101",
      "00010110",
      "00010111",
      "00011000",
      "00011001",
      "00011010",
      "00011011",
      "00011100",
      "00011101",
      "00011110",
      "00011111",
      "00100000",
      "00100001",
      "00100010",
      "00100011",
      "00100100",
      "00100101",
      "00100110",
      "00100111",
      "00101000",
      "00101001",
      "00101010",
      "00101011",
      "00101100",
      "00101101",
      "00101110",
      "00101111",
      "00110000",
      "00110001",
      "00110010",
      "00110011",
      "00110100",
      "00110101",
      "00110110",
      "00110111",
      "00111000",
      "00111001",
      "00111010",
      "00111011",
      "00111100",
      "00111101",
      "00111110",
      "00111111",
      "01000000",
      "01000001",
      "01000010",
      "01000011",
      "01000100",
      "01000101",
      "01000110",
      "01000111",
      "01001000",
      "01001001",
      "01001010",
      "01001011",
      "01001100",
      "01001101",
      "01001110",
      "01001111",
      "01010000",
      "01010001",
      "01010010",
      "01010011",
      "01010100",
      "01010101",
      "01010110",
      "01010111",
      "01011000",
      "01011001",
      "01011010",
      "01011011",
      "01011100",
      "01011101",
      "01011110",
      "01011111",
      "01100000",
      "01100001",
      "01100010",
      "01100011",
      "01100100",
      "01100101",
      "01100110",
      "01100111",
      "01101000",
      "01101001",
      "01101010",
      "01101011",
      "01101100",
      "01101101",
      "01101110",
      "01101111",
      "01110000",
      "01110001",
      "01110010",
      "01110011",
      "01110100",
      "01110101",
      "01110110",
      "01110111",
      "01111000",
      "01111001",
      "01111010",
      "01111011",
      "01111100",
      "01111101",
      "01111110",
      "01111111",
      "10000000",
      "10000001",
      "10000010",
      "10000011",
      "10000100",
      "10000101",
      "10000110",
      "10000111",
      "10001000",
      "10001001",
      "10001010",
      "10001011",
      "10001100",
      "10001101",
      "10001110",
      "10001111",
      "10010000",
      "10010001",
      "10010010",
      "10010011",
      "10010100",
      "10010101",
      "10010110",
      "10010111",
      "10011000",
      "10011001",
      "10011010",
      "10011011",
      "10011100",
      "10011101",
      "10011110",
      "10011111",
      "10100000",
      "10100001",
      "10100010",
      "10100011",
      "10100100",
      "10100101",
      "10100110",
      "10100111",
      "10101000",
      "10101001",
      "10101010",
      "10101011",
      "10101100",
      "10101101",
      "10101110",
      "10101111",
      "10110000",
      "10110001",
      "10110010",
      "10110011",
      "10110100",
      "10110101",
      "10110110",
      "10110111",
      "10111000",
      "10111001",
      "10111010",
      "10111011",
      "10111100",
      "10111101",
      "10111110",
      "10111111",
      "11000000",
      "11000001",
      "11000010",
      "11000011",
      "11000100",
      "11000101",
      "11000110",
      "11000111",
      "11001000",
      "11001001",
      "11001010",
      "11001011",
      "11001100",
      "11001101",
      "11001110",
      "11001111",
      "11010000",
      "11010001",
      "11010010",
      "11010011",
      "11010100",
      "11010101",
      "11010110",
      "11010111",
      "11011000",
      "11011001",
      "11011010",
      "11011011",
      "11011100",
      "11011101",
      "11011110",
      "11011111",
      "11100000",
      "11100001",
      "11100010",
      "11100011",
      "11100100",
      "11100101",
      "11100110",
      "11100111",
      "11101000",
      "11101001",
      "11101010",
      "11101011",
      "11101100",
      "11101101",
      "11101110",
      "11101111",
      "11110000",
      "11110001",
      "11110010",
      "11110011",
      "11110100",
      "11110101",
      "11110110",
      "11110111",
      "11111000",
      "11111001",
      "11111010",
      "11111011",
      "11111100",
      "11111101",
      "11111110",
      "11111111"
    ];
  }
});

// node_modules/bytestreamjs/build/cjs/bit_stream.js
var require_bit_stream = __commonJS({
  "node_modules/bytestreamjs/build/cjs/bit_stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitStream = void 0;
    var bit_1 = require_bit();
    var byte_stream_1 = require_byte_stream();
    var BitStream = class _BitStream {
      constructor(parameters) {
        this.buffer = new ArrayBuffer(0);
        this.view = new Uint8Array(this.buffer);
        this.bitsCount = 0;
        if (parameters) {
          if ("byteStream" in parameters) {
            this.fromByteStream(parameters.byteStream);
          }
          if ("view" in parameters) {
            this.fromUint8Array(parameters.view);
          }
          if ("buffer" in parameters) {
            this.fromArrayBuffer(parameters.buffer);
          }
          if ("string" in parameters) {
            this.fromString(parameters.string);
          }
          if ("uint32" in parameters) {
            this.fromUint32(parameters.uint32);
          }
          if ("bitsCount" in parameters && parameters.bitsCount) {
            this.bitsCount = parameters.bitsCount;
          }
        }
      }
      clear() {
        this.buffer = new ArrayBuffer(0);
        this.view = new Uint8Array(this.buffer);
        this.bitsCount = 0;
      }
      fromByteStream(stream) {
        this.fromUint8Array(stream.view);
      }
      fromArrayBuffer(array) {
        this.buffer = array;
        this.view = new Uint8Array(array);
        this.bitsCount = this.view.length << 3;
      }
      fromUint8Array(array) {
        this.fromArrayBuffer(new Uint8Array(array).buffer);
      }
      fromString(string) {
        const stringLength = string.length;
        this.buffer = new ArrayBuffer((stringLength >> 3) + (stringLength % 8 ? 1 : 0));
        this.view = new Uint8Array(this.buffer);
        this.bitsCount = (stringLength >> 3) + 1 << 3;
        let byteIndex = 0;
        for (let i = 0; i < stringLength; i++) {
          if (string[i] == "1")
            this.view[byteIndex] |= 1 << 7 - i % 8;
          if (i && (i + 1) % 8 == 0)
            byteIndex++;
        }
        if (stringLength % 8)
          this.shiftRight(8 - stringLength % 8);
        this.bitsCount = stringLength;
      }
      fromUint32(uint32) {
        this.buffer = new ArrayBuffer(4);
        this.view = new Uint8Array(this.buffer);
        const value = new Uint32Array([uint32]);
        const view = new Uint8Array(value.buffer);
        for (let i = 3; i >= 0; i--)
          this.view[i] = view[3 - i];
        this.bitsCount = 32;
      }
      toString(start, length) {
        if (start == null) {
          start = 0;
        }
        if (start >= this.view.length || start < 0) {
          start = 0;
        }
        if (length == null) {
          length = this.view.length - start;
        }
        if (length >= this.view.length || length < 0) {
          length = this.view.length - start;
        }
        const result = [];
        for (let i = start; i < start + length; i++) {
          result.push(bit_1.bitsToStringArray[this.view[i]]);
        }
        return result.join("").substring((this.view.length << 3) - this.bitsCount);
      }
      shiftRight(shift, needShrink = true) {
        if (this.view.length == 0) {
          return;
        }
        if (shift < 0 || shift > 8) {
          throw new Error('The "shift" parameter must be in range 0-8');
        }
        if (shift > this.bitsCount) {
          throw new Error('The "shift" parameter can not be bigger than "this.bitsCount"');
        }
        const shiftMask = 255 >> 8 - shift;
        this.view[this.view.length - 1] >>= shift;
        for (let i = this.view.length - 2; i >= 0; i--) {
          this.view[i + 1] |= (this.view[i] & shiftMask) << 8 - shift;
          this.view[i] >>= shift;
        }
        this.bitsCount -= shift;
        if (this.bitsCount == 0) {
          this.clear();
        }
        if (needShrink) {
          this.shrink();
        }
      }
      shiftLeft(shift) {
        if (this.view.length == 0) {
          return;
        }
        if (shift < 0 || shift > 8) {
          throw new Error('The "shift" parameter must be in range 0-8');
        }
        if (shift > this.bitsCount) {
          throw new Error('The "shift" parameter can not be bigger than "this.bitsCount"');
        }
        const bitsOffset = this.bitsCount & 7;
        if (bitsOffset > shift) {
          this.view[0] &= 255 >> bitsOffset + shift;
        } else {
          const view = this.view.slice(1);
          view[0] &= 255 >> shift - bitsOffset;
          this.buffer = view.buffer;
          this.view = view;
        }
        this.bitsCount -= shift;
        if (this.bitsCount == 0) {
          this.clear();
        }
      }
      slice(start = 0, end = 0) {
        let valueShift = 0;
        if (this.bitsCount % 8) {
          valueShift = 8 - this.bitsCount % 8;
        }
        start += valueShift;
        end += valueShift;
        const maxEnd = (this.view.length << 3) - 1;
        if (start < 0 || start > maxEnd) {
          return new _BitStream();
        }
        if (!end) {
          end = maxEnd;
        }
        if (end < 0 || end > maxEnd) {
          return new _BitStream();
        }
        if (end - start + 1 > this.bitsCount) {
          return new _BitStream();
        }
        const startIndex = start >> 3;
        const startOffset = start & 7;
        const endIndex = end >> 3;
        const endOffset = end & 7;
        const bitsLength = endIndex - startIndex == 0 ? 1 : endIndex - startIndex + 1;
        const result = new _BitStream({
          buffer: this.buffer.slice(startIndex, startIndex + bitsLength),
          bitsCount: bitsLength << 3
        });
        result.view[0] &= 255 >> startOffset;
        result.view[bitsLength] &= 255 << 7 - endOffset;
        if (7 - endOffset) {
          result.shiftRight(7 - endOffset, false);
        }
        result.bitsCount = end - start + 1;
        result.shrink();
        return result;
      }
      copy(start = 0, length = 0) {
        const maxEnd = (this.view.length << 3) - 1;
        if (start < 0 || start > maxEnd) {
          return new _BitStream();
        }
        if (!length) {
          length = (this.view.length << 3) - start - 1;
        }
        if (length > this.bitsCount) {
          return new _BitStream();
        }
        return this.slice(start, start + length - 1);
      }
      shrink() {
        const currentLength = (this.bitsCount >> 3) + (this.bitsCount % 8 ? 1 : 0);
        if (currentLength < this.view.length) {
          const view = this.view.slice(this.view.length - currentLength, this.view.length - currentLength + currentLength);
          this.view = view;
          this.buffer = view.buffer;
        }
      }
      reverseBytes() {
        for (let i = 0; i < this.view.length; i++) {
          this.view[i] = (this.view[i] * 2050 & 139536 | this.view[i] * 32800 & 558144) * 65793 >> 16;
        }
        if (this.bitsCount % 8) {
          const currentLength = (this.bitsCount >> 3) + (this.bitsCount % 8 ? 1 : 0);
          this.view[this.view.length - currentLength] >>= 8 - (this.bitsCount & 7);
        }
      }
      reverseValue() {
        const initialValue = this.toString();
        const initialValueLength = initialValue.length;
        const reversedValue = new Array(initialValueLength);
        for (let i = 0; i < initialValueLength; i++) {
          reversedValue[initialValueLength - 1 - i] = initialValue[i];
        }
        this.fromString(reversedValue.join(""));
      }
      getNumberValue() {
        const byteLength = this.view.length - 1;
        if (byteLength > 3) {
          return -1;
        }
        if (byteLength == -1) {
          return 0;
        }
        const value = new Uint32Array(1);
        const view = new Uint8Array(value.buffer);
        for (let i = byteLength; i >= 0; i--) {
          view[byteLength - i] = this.view[i];
        }
        return value[0];
      }
      findPattern(pattern, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringPattern = new byte_stream_1.ByteStream({
          string: pattern.toString()
        });
        return stringStream.findPattern(stringPattern, start, length, backward);
      }
      findFirstIn(patterns, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i < patterns.length; i++) {
          stringPatterns[i] = new byte_stream_1.ByteStream({
            string: patterns[i].toString()
          });
        }
        return stringStream.findFirstIn(stringPatterns, start, length, backward);
      }
      findAllIn(patterns, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i < patterns.length; i++) {
          stringPatterns[i] = new byte_stream_1.ByteStream({
            string: patterns[i].toString()
          });
        }
        return stringStream.findAllIn(stringPatterns, start, length);
      }
      findAllPatternIn(pattern, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringPattern = new byte_stream_1.ByteStream({
          string: pattern.toString()
        });
        return stringStream.findAllPatternIn(stringPattern, start, length);
      }
      findFirstNotIn(patterns, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i < patterns.length; i++) {
          stringPatterns[i] = new byte_stream_1.ByteStream({
            string: patterns[i].toString()
          });
        }
        return stringStream.findFirstNotIn(stringPatterns, start, length, backward);
      }
      findAllNotIn(patterns, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i < patterns.length; i++) {
          stringPatterns[i] = new byte_stream_1.ByteStream({
            string: patterns[i].toString()
          });
        }
        return stringStream.findAllNotIn(stringPatterns, start, length);
      }
      findFirstSequence(patterns, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i < patterns.length; i++) {
          stringPatterns[i] = new byte_stream_1.ByteStream({
            string: patterns[i].toString()
          });
        }
        return stringStream.findFirstSequence(stringPatterns, start, length, backward);
      }
      findAllSequences(patterns, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i < patterns.length; i++) {
          stringPatterns[i] = new byte_stream_1.ByteStream({
            string: patterns[i].toString()
          });
        }
        return stringStream.findAllSequences(stringPatterns, start, length);
      }
      findPairedPatterns(leftPattern, rightPattern, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringLeftPattern = new byte_stream_1.ByteStream({
          string: leftPattern.toString()
        });
        const stringRightPattern = new byte_stream_1.ByteStream({
          string: rightPattern.toString()
        });
        return stringStream.findPairedPatterns(stringLeftPattern, stringRightPattern, start, length);
      }
      findPairedArrays(inputLeftPatterns, inputRightPatterns, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringLeftPatterns = new Array(inputLeftPatterns.length);
        for (let i = 0; i < inputLeftPatterns.length; i++) {
          stringLeftPatterns[i] = new byte_stream_1.ByteStream({
            string: inputLeftPatterns[i].toString()
          });
        }
        const stringRightPatterns = new Array(inputRightPatterns.length);
        for (let i = 0; i < inputRightPatterns.length; i++) {
          stringRightPatterns[i] = new byte_stream_1.ByteStream({
            string: inputRightPatterns[i].toString()
          });
        }
        return stringStream.findPairedArrays(stringLeftPatterns, stringRightPatterns, start, length);
      }
      replacePattern(searchPattern, replacePattern, start, length) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringSearchPattern = new byte_stream_1.ByteStream({
          string: searchPattern.toString()
        });
        const stringReplacePattern = new byte_stream_1.ByteStream({
          string: replacePattern.toString()
        });
        if (stringStream.replacePattern(stringSearchPattern, stringReplacePattern, start, length)) {
          this.fromString(stringStream.toString());
          return true;
        }
        return false;
      }
      skipPatterns(patterns, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i < patterns.length; i++) {
          stringPatterns[i] = new byte_stream_1.ByteStream({
            string: patterns[i].toString()
          });
        }
        return stringStream.skipPatterns(stringPatterns, start, length, backward);
      }
      skipNotPatterns(patterns, start, length, backward) {
        const stringStream = new byte_stream_1.ByteStream({
          string: this.toString()
        });
        const stringPatterns = new Array(patterns.length);
        for (let i = 0; i < patterns.length; i++) {
          stringPatterns[i] = new byte_stream_1.ByteStream({
            string: patterns[i].toString()
          });
        }
        return stringStream.skipNotPatterns(stringPatterns, start, length, backward);
      }
      append(stream) {
        this.fromString([
          this.toString(),
          stream.toString()
        ].join(""));
      }
    };
    exports.BitStream = BitStream;
  }
});

// node_modules/bytestreamjs/build/cjs/seq_bit_stream.js
var require_seq_bit_stream = __commonJS({
  "node_modules/bytestreamjs/build/cjs/seq_bit_stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SeqBitStream = void 0;
    var bit_stream_1 = require_bit_stream();
    var SeqBitStream = class {
      constructor(parameters = {}) {
        var _a;
        this._length = 0;
        this._start = 0;
        this.prevLength = 0;
        this.prevStart = 0;
        this.stream = ((_a = parameters.stream) === null || _a === void 0 ? void 0 : _a.slice()) || new bit_stream_1.BitStream();
        this.appendBlock = parameters.appendBlock || 0;
        if (parameters.start && parameters.start > 0) {
          this.start = parameters.start;
        }
        if (parameters.length && parameters.length > 0) {
          this.length = parameters.length;
        }
        this.backward = parameters.backward || false;
      }
      set start(value) {
        if (value > this.stream.bitsCount) {
          return;
        }
        this._length -= this.backward ? this._start - value : value - this._start;
        this._start = value;
        this.prevStart = this._start;
        this.prevLength = this._length;
      }
      get start() {
        return this._start;
      }
      set length(value) {
        if (value > this.stream.bitsCount) {
          return;
        }
        this.prevLength = this._length;
        this._length = value;
      }
      get length() {
        return this._length;
      }
      set stream(value) {
        this._stream = value;
        this.prevLength = this._length;
        this._length = value.bitsCount;
        this.prevStart = this._start;
        this._start = this.backward ? this.length : 0;
      }
      get stream() {
        return this._stream;
      }
      getBits(length = null) {
        if (length === null) {
          length = 0;
        } else if (length === 0) {
          return new bit_stream_1.BitStream();
        }
        if (this.start + length > this.stream.bitsCount) {
          length = this.stream.bitsCount - this.start;
        }
        let result;
        if (this.backward) {
          result = this.stream.copy(this.start - length, length);
          this.start -= result.bitsCount;
        } else {
          result = this.stream.copy(this.start, length);
          this.start += result.bitsCount;
        }
        return result;
      }
      getBitsString(length) {
        return this.getBits(length).toString();
      }
      getBitsReversedValue(length) {
        const initialValue = this.getBitsString(length);
        const initialValueLength = initialValue.length;
        let byteIndex;
        const initialOffset = 8 - initialValueLength % 8;
        const reversedValue = new Array(initialValueLength);
        const value = new Uint32Array(1);
        const valueView = new Uint8Array(value.buffer, 0, 4);
        let i;
        if (initialValueLength > 32) {
          return -1;
        }
        if (length == 32) {
          byteIndex = 3;
        } else {
          byteIndex = initialValueLength - 1 >> 3;
        }
        for (i = 0; i < initialValueLength; i++) {
          reversedValue[initialValueLength - 1 - i] = initialValue[i];
        }
        for (i = initialOffset; i < initialOffset + initialValueLength; i++) {
          if (reversedValue[i - initialOffset] == "1") {
            valueView[byteIndex] |= 1 << 7 - i % 8;
          }
          if (i && (i + 1) % 8 == 0) {
            byteIndex--;
          }
        }
        return value[0];
      }
      toString() {
        const streamToDisplay = this.stream.copy(this.start, this.length);
        return streamToDisplay.toString();
      }
    };
    exports.SeqBitStream = SeqBitStream;
  }
});

// node_modules/bytestreamjs/build/cjs/index.js
var require_cjs12 = __commonJS({
  "node_modules/bytestreamjs/build/cjs/index.js"(exports) {
    "use strict";
    var __createBinding3 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar3 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding3(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar3(require_byte_stream(), exports);
    __exportStar3(require_seq_stream(), exports);
    __exportStar3(require_helpers(), exports);
    __exportStar3(require_bit_stream(), exports);
    __exportStar3(require_seq_bit_stream(), exports);
  }
});

// node_modules/pkijs/build/index.js
var require_build3 = __commonJS({
  "node_modules/pkijs/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var asn1js = require_build2();
    var pvtsutils = require_build();
    var pvutils = require_utils();
    var bs = require_cjs12();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var asn1js__namespace = /* @__PURE__ */ _interopNamespace(asn1js);
    var pvtsutils__namespace = /* @__PURE__ */ _interopNamespace(pvtsutils);
    var pvutils__namespace = /* @__PURE__ */ _interopNamespace(pvutils);
    var bs__namespace = /* @__PURE__ */ _interopNamespace(bs);
    var EMPTY_BUFFER = new ArrayBuffer(0);
    var EMPTY_STRING = "";
    var ArgumentError = class _ArgumentError extends TypeError {
      constructor() {
        super(...arguments);
        this.name = _ArgumentError.NAME;
      }
      static isType(value, type) {
        if (typeof type === "string") {
          if (type === "Array" && Array.isArray(value)) {
            return true;
          } else if (type === "ArrayBuffer" && value instanceof ArrayBuffer) {
            return true;
          } else if (type === "ArrayBufferView" && ArrayBuffer.isView(value)) {
            return true;
          } else if (typeof value === type) {
            return true;
          }
        } else if (value instanceof type) {
          return true;
        }
        return false;
      }
      static assert(value, name, ...types3) {
        for (const type of types3) {
          if (this.isType(value, type)) {
            return;
          }
        }
        const typeNames = types3.map((o) => o instanceof Function && "name" in o ? o.name : `${o}`);
        throw new _ArgumentError(`Parameter '${name}' is not of type ${typeNames.length > 1 ? `(${typeNames.join(" or ")})` : typeNames[0]}`);
      }
    };
    ArgumentError.NAME = "ArgumentError";
    var ParameterError = class _ParameterError extends TypeError {
      constructor(field, target2 = null, message3) {
        super();
        this.name = _ParameterError.NAME;
        this.field = field;
        if (target2) {
          this.target = target2;
        }
        if (message3) {
          this.message = message3;
        } else {
          this.message = `Absent mandatory parameter '${field}' ${target2 ? ` in '${target2}'` : EMPTY_STRING}`;
        }
      }
      static assert(...args) {
        let target2 = null;
        let params;
        let fields;
        if (typeof args[0] === "string") {
          target2 = args[0];
          params = args[1];
          fields = args.slice(2);
        } else {
          params = args[0];
          fields = args.slice(1);
        }
        ArgumentError.assert(params, "parameters", "object");
        for (const field of fields) {
          const value = params[field];
          if (value === void 0 || value === null) {
            throw new _ParameterError(field, target2);
          }
        }
      }
      static assertEmpty(value, name, target2) {
        if (value === void 0 || value === null) {
          throw new _ParameterError(name, target2);
        }
      }
    };
    ParameterError.NAME = "ParameterError";
    var AsnError = class _AsnError extends Error {
      static assertSchema(asn1, target2) {
        if (!asn1.verified) {
          throw new Error(`Object's schema was not verified against input data for ${target2}`);
        }
      }
      static assert(asn, target2) {
        if (asn.offset === -1) {
          throw new _AsnError(`Error during parsing of ASN.1 data. Data is not correct for '${target2}'.`);
        }
      }
      constructor(message3) {
        super(message3);
        this.name = "AsnError";
      }
    };
    var PkiObject = class {
      static blockName() {
        return this.CLASS_NAME;
      }
      static fromBER(raw) {
        const asn1 = asn1js__namespace.fromBER(raw);
        AsnError.assert(asn1, this.name);
        try {
          return new this({ schema: asn1.result });
        } catch (e) {
          throw new AsnError(`Cannot create '${this.CLASS_NAME}' from ASN.1 object`);
        }
      }
      static defaultValues(memberName) {
        throw new Error(`Invalid member name for ${this.CLASS_NAME} class: ${memberName}`);
      }
      static schema(parameters = {}) {
        throw new Error(`Method '${this.CLASS_NAME}.schema' should be overridden`);
      }
      get className() {
        return this.constructor.CLASS_NAME;
      }
      toString(encoding = "hex") {
        let schema;
        try {
          schema = this.toSchema();
        } catch {
          schema = this.toSchema(true);
        }
        return pvtsutils__namespace.Convert.ToString(schema.toBER(), encoding);
      }
    };
    PkiObject.CLASS_NAME = "PkiObject";
    function stringPrep(inputString) {
      let isSpace = false;
      let cutResult = EMPTY_STRING;
      const result = inputString.trim();
      for (let i = 0; i < result.length; i++) {
        if (result.charCodeAt(i) === 32) {
          if (isSpace === false)
            isSpace = true;
        } else {
          if (isSpace) {
            cutResult += " ";
            isSpace = false;
          }
          cutResult += result[i];
        }
      }
      return cutResult.toLowerCase();
    }
    var TYPE$5 = "type";
    var VALUE$6 = "value";
    var AttributeTypeAndValue = class _AttributeTypeAndValue extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.type = pvutils__namespace.getParametersValue(parameters, TYPE$5, _AttributeTypeAndValue.defaultValues(TYPE$5));
        this.value = pvutils__namespace.getParametersValue(parameters, VALUE$6, _AttributeTypeAndValue.defaultValues(VALUE$6));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TYPE$5:
            return EMPTY_STRING;
          case VALUE$6:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.type || EMPTY_STRING }),
            new asn1js__namespace.Any({ name: names.value || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, [
          TYPE$5,
          "typeValue"
        ]);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _AttributeTypeAndValue.schema({
          names: {
            type: TYPE$5,
            value: "typeValue"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.type = asn1.result.type.valueBlock.toString();
        this.value = asn1.result.typeValue;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.type }),
            this.value
          ]
        });
      }
      toJSON() {
        const _object = {
          type: this.type
        };
        if (Object.keys(this.value).length !== 0) {
          _object.value = this.value.toJSON();
        } else {
          _object.value = this.value;
        }
        return _object;
      }
      isEqual(compareTo) {
        const stringBlockNames = [
          asn1js__namespace.Utf8String.blockName(),
          asn1js__namespace.BmpString.blockName(),
          asn1js__namespace.UniversalString.blockName(),
          asn1js__namespace.NumericString.blockName(),
          asn1js__namespace.PrintableString.blockName(),
          asn1js__namespace.TeletexString.blockName(),
          asn1js__namespace.VideotexString.blockName(),
          asn1js__namespace.IA5String.blockName(),
          asn1js__namespace.GraphicString.blockName(),
          asn1js__namespace.VisibleString.blockName(),
          asn1js__namespace.GeneralString.blockName(),
          asn1js__namespace.CharacterString.blockName()
        ];
        if (compareTo instanceof ArrayBuffer) {
          return pvtsutils__namespace.BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView, compareTo);
        }
        if (compareTo.constructor.blockName() === _AttributeTypeAndValue.blockName()) {
          if (this.type !== compareTo.type)
            return false;
          const isStringPair = [false, false];
          const thisName = this.value.constructor.blockName();
          for (const name of stringBlockNames) {
            if (thisName === name) {
              isStringPair[0] = true;
            }
            if (compareTo.value.constructor.blockName() === name) {
              isStringPair[1] = true;
            }
          }
          if (isStringPair[0] !== isStringPair[1]) {
            return false;
          }
          const isString = isStringPair[0] && isStringPair[1];
          if (isString) {
            const value1 = stringPrep(this.value.valueBlock.value);
            const value2 = stringPrep(compareTo.value.valueBlock.value);
            if (value1.localeCompare(value2) !== 0)
              return false;
          } else {
            if (!pvtsutils__namespace.BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView, compareTo.value.valueBeforeDecodeView))
              return false;
          }
          return true;
        }
        return false;
      }
    };
    AttributeTypeAndValue.CLASS_NAME = "AttributeTypeAndValue";
    var TYPE_AND_VALUES = "typesAndValues";
    var VALUE_BEFORE_DECODE = "valueBeforeDecode";
    var RDN = "RDN";
    var RelativeDistinguishedNames = class _RelativeDistinguishedNames extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.typesAndValues = pvutils__namespace.getParametersValue(parameters, TYPE_AND_VALUES, _RelativeDistinguishedNames.defaultValues(TYPE_AND_VALUES));
        this.valueBeforeDecode = pvutils__namespace.getParametersValue(parameters, VALUE_BEFORE_DECODE, _RelativeDistinguishedNames.defaultValues(VALUE_BEFORE_DECODE));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TYPE_AND_VALUES:
            return [];
          case VALUE_BEFORE_DECODE:
            return EMPTY_BUFFER;
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TYPE_AND_VALUES:
            return memberValue.length === 0;
          case VALUE_BEFORE_DECODE:
            return memberValue.byteLength === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.repeatedSequence || EMPTY_STRING,
              value: new asn1js__namespace.Set({
                value: [
                  new asn1js__namespace.Repeated({
                    name: names.repeatedSet || EMPTY_STRING,
                    value: AttributeTypeAndValue.schema(names.typeAndValue || {})
                  })
                ]
              })
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, [
          RDN,
          TYPE_AND_VALUES
        ]);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RelativeDistinguishedNames.schema({
          names: {
            blockName: RDN,
            repeatedSet: TYPE_AND_VALUES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (TYPE_AND_VALUES in asn1.result) {
          this.typesAndValues = Array.from(asn1.result.typesAndValues, (element) => new AttributeTypeAndValue({ schema: element }));
        }
        this.valueBeforeDecode = asn1.result.RDN.valueBeforeDecodeView.slice().buffer;
      }
      toSchema() {
        if (this.valueBeforeDecode.byteLength === 0) {
          return new asn1js__namespace.Sequence({
            value: [new asn1js__namespace.Set({
              value: Array.from(this.typesAndValues, (o) => o.toSchema())
            })]
          });
        }
        const asn1 = asn1js__namespace.fromBER(this.valueBeforeDecode);
        AsnError.assert(asn1, "RelativeDistinguishedNames");
        if (!(asn1.result instanceof asn1js__namespace.Sequence)) {
          throw new Error("ASN.1 result should be SEQUENCE");
        }
        return asn1.result;
      }
      toJSON() {
        return {
          typesAndValues: Array.from(this.typesAndValues, (o) => o.toJSON())
        };
      }
      isEqual(compareTo) {
        if (compareTo instanceof _RelativeDistinguishedNames) {
          if (this.typesAndValues.length !== compareTo.typesAndValues.length)
            return false;
          for (const [index, typeAndValue] of this.typesAndValues.entries()) {
            if (typeAndValue.isEqual(compareTo.typesAndValues[index]) === false)
              return false;
          }
          return true;
        }
        if (compareTo instanceof ArrayBuffer) {
          return pvutils__namespace.isEqualBuffer(this.valueBeforeDecode, compareTo);
        }
        return false;
      }
    };
    RelativeDistinguishedNames.CLASS_NAME = "RelativeDistinguishedNames";
    var TYPE$4 = "type";
    var VALUE$5 = "value";
    function builtInStandardAttributes(parameters = {}, optional = false) {
      const names = pvutils__namespace.getParametersValue(parameters, "names", {});
      return new asn1js__namespace.Sequence({
        optional,
        value: [
          new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 2,
              tagNumber: 1
            },
            name: names.country_name || EMPTY_STRING,
            value: [
              new asn1js__namespace.Choice({
                value: [
                  new asn1js__namespace.NumericString(),
                  new asn1js__namespace.PrintableString()
                ]
              })
            ]
          }),
          new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 2,
              tagNumber: 2
            },
            name: names.administration_domain_name || EMPTY_STRING,
            value: [
              new asn1js__namespace.Choice({
                value: [
                  new asn1js__namespace.NumericString(),
                  new asn1js__namespace.PrintableString()
                ]
              })
            ]
          }),
          new asn1js__namespace.Primitive({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            name: names.network_address || EMPTY_STRING,
            isHexOnly: true
          }),
          new asn1js__namespace.Primitive({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            name: names.terminal_identifier || EMPTY_STRING,
            isHexOnly: true
          }),
          new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            name: names.private_domain_name || EMPTY_STRING,
            value: [
              new asn1js__namespace.Choice({
                value: [
                  new asn1js__namespace.NumericString(),
                  new asn1js__namespace.PrintableString()
                ]
              })
            ]
          }),
          new asn1js__namespace.Primitive({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            name: names.organization_name || EMPTY_STRING,
            isHexOnly: true
          }),
          new asn1js__namespace.Primitive({
            optional: true,
            name: names.numeric_user_identifier || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 4
            },
            isHexOnly: true
          }),
          new asn1js__namespace.Constructed({
            optional: true,
            name: names.personal_name || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 5
            },
            value: [
              new asn1js__namespace.Primitive({
                idBlock: {
                  tagClass: 3,
                  tagNumber: 0
                },
                isHexOnly: true
              }),
              new asn1js__namespace.Primitive({
                optional: true,
                idBlock: {
                  tagClass: 3,
                  tagNumber: 1
                },
                isHexOnly: true
              }),
              new asn1js__namespace.Primitive({
                optional: true,
                idBlock: {
                  tagClass: 3,
                  tagNumber: 2
                },
                isHexOnly: true
              }),
              new asn1js__namespace.Primitive({
                optional: true,
                idBlock: {
                  tagClass: 3,
                  tagNumber: 3
                },
                isHexOnly: true
              })
            ]
          }),
          new asn1js__namespace.Constructed({
            optional: true,
            name: names.organizational_unit_names || EMPTY_STRING,
            idBlock: {
              tagClass: 3,
              tagNumber: 6
            },
            value: [
              new asn1js__namespace.Repeated({
                value: new asn1js__namespace.PrintableString()
              })
            ]
          })
        ]
      });
    }
    function builtInDomainDefinedAttributes(optional = false) {
      return new asn1js__namespace.Sequence({
        optional,
        value: [
          new asn1js__namespace.PrintableString(),
          new asn1js__namespace.PrintableString()
        ]
      });
    }
    function extensionAttributes(optional = false) {
      return new asn1js__namespace.Set({
        optional,
        value: [
          new asn1js__namespace.Primitive({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            isHexOnly: true
          }),
          new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [new asn1js__namespace.Any()]
          })
        ]
      });
    }
    var GeneralName = class _GeneralName extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.type = pvutils__namespace.getParametersValue(parameters, TYPE$4, _GeneralName.defaultValues(TYPE$4));
        this.value = pvutils__namespace.getParametersValue(parameters, VALUE$5, _GeneralName.defaultValues(VALUE$5));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TYPE$4:
            return 9;
          case VALUE$5:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TYPE$4:
            return memberValue === _GeneralName.defaultValues(memberName);
          case VALUE$5:
            return Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Choice({
          value: [
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              name: names.blockName || EMPTY_STRING,
              value: [
                new asn1js__namespace.ObjectIdentifier(),
                new asn1js__namespace.Constructed({
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  },
                  value: [new asn1js__namespace.Any()]
                })
              ]
            }),
            new asn1js__namespace.Primitive({
              name: names.blockName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              }
            }),
            new asn1js__namespace.Primitive({
              name: names.blockName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              }
            }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 3
              },
              name: names.blockName || EMPTY_STRING,
              value: [
                builtInStandardAttributes(names.builtInStandardAttributes || {}, false),
                builtInDomainDefinedAttributes(true),
                extensionAttributes(true)
              ]
            }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 4
              },
              name: names.blockName || EMPTY_STRING,
              value: [RelativeDistinguishedNames.schema(names.directoryName || {})]
            }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 5
              },
              name: names.blockName || EMPTY_STRING,
              value: [
                new asn1js__namespace.Constructed({
                  optional: true,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  },
                  value: [
                    new asn1js__namespace.Choice({
                      value: [
                        new asn1js__namespace.TeletexString(),
                        new asn1js__namespace.PrintableString(),
                        new asn1js__namespace.UniversalString(),
                        new asn1js__namespace.Utf8String(),
                        new asn1js__namespace.BmpString()
                      ]
                    })
                  ]
                }),
                new asn1js__namespace.Constructed({
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                  },
                  value: [
                    new asn1js__namespace.Choice({
                      value: [
                        new asn1js__namespace.TeletexString(),
                        new asn1js__namespace.PrintableString(),
                        new asn1js__namespace.UniversalString(),
                        new asn1js__namespace.Utf8String(),
                        new asn1js__namespace.BmpString()
                      ]
                    })
                  ]
                })
              ]
            }),
            new asn1js__namespace.Primitive({
              name: names.blockName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 6
              }
            }),
            new asn1js__namespace.Primitive({
              name: names.blockName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 7
              }
            }),
            new asn1js__namespace.Primitive({
              name: names.blockName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 8
              }
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, [
          "blockName",
          "otherName",
          "rfc822Name",
          "dNSName",
          "x400Address",
          "directoryName",
          "ediPartyName",
          "uniformResourceIdentifier",
          "iPAddress",
          "registeredID"
        ]);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _GeneralName.schema({
          names: {
            blockName: "blockName",
            otherName: "otherName",
            rfc822Name: "rfc822Name",
            dNSName: "dNSName",
            x400Address: "x400Address",
            directoryName: {
              names: {
                blockName: "directoryName"
              }
            },
            ediPartyName: "ediPartyName",
            uniformResourceIdentifier: "uniformResourceIdentifier",
            iPAddress: "iPAddress",
            registeredID: "registeredID"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.type = asn1.result.blockName.idBlock.tagNumber;
        switch (this.type) {
          case 0:
            this.value = asn1.result.blockName;
            break;
          case 1:
          case 2:
          case 6:
            {
              const value = asn1.result.blockName;
              value.idBlock.tagClass = 1;
              value.idBlock.tagNumber = 22;
              const valueBER = value.toBER(false);
              const asnValue = asn1js__namespace.fromBER(valueBER);
              AsnError.assert(asnValue, "GeneralName value");
              this.value = asnValue.result.valueBlock.value;
            }
            break;
          case 3:
            this.value = asn1.result.blockName;
            break;
          case 4:
            this.value = new RelativeDistinguishedNames({ schema: asn1.result.directoryName });
            break;
          case 5:
            this.value = asn1.result.ediPartyName;
            break;
          case 7:
            this.value = new asn1js__namespace.OctetString({ valueHex: asn1.result.blockName.valueBlock.valueHex });
            break;
          case 8:
            {
              const value = asn1.result.blockName;
              value.idBlock.tagClass = 1;
              value.idBlock.tagNumber = 6;
              const valueBER = value.toBER(false);
              const asnValue = asn1js__namespace.fromBER(valueBER);
              AsnError.assert(asnValue, "GeneralName registeredID");
              this.value = asnValue.result.valueBlock.toString();
            }
            break;
        }
      }
      toSchema() {
        switch (this.type) {
          case 0:
          case 3:
          case 5:
            return new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: this.type
              },
              value: [
                this.value
              ]
            });
          case 1:
          case 2:
          case 6: {
            const value = new asn1js__namespace.IA5String({ value: this.value });
            value.idBlock.tagClass = 3;
            value.idBlock.tagNumber = this.type;
            return value;
          }
          case 4:
            return new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 4
              },
              value: [this.value.toSchema()]
            });
          case 7: {
            const value = this.value;
            value.idBlock.tagClass = 3;
            value.idBlock.tagNumber = this.type;
            return value;
          }
          case 8: {
            const value = new asn1js__namespace.ObjectIdentifier({ value: this.value });
            value.idBlock.tagClass = 3;
            value.idBlock.tagNumber = this.type;
            return value;
          }
          default:
            return _GeneralName.schema();
        }
      }
      toJSON() {
        const _object = {
          type: this.type,
          value: EMPTY_STRING
        };
        if (typeof this.value === "string")
          _object.value = this.value;
        else {
          try {
            _object.value = this.value.toJSON();
          } catch (ex) {
          }
        }
        return _object;
      }
    };
    GeneralName.CLASS_NAME = "GeneralName";
    var ACCESS_METHOD = "accessMethod";
    var ACCESS_LOCATION = "accessLocation";
    var CLEAR_PROPS$1v = [
      ACCESS_METHOD,
      ACCESS_LOCATION
    ];
    var AccessDescription = class _AccessDescription extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.accessMethod = pvutils__namespace.getParametersValue(parameters, ACCESS_METHOD, _AccessDescription.defaultValues(ACCESS_METHOD));
        this.accessLocation = pvutils__namespace.getParametersValue(parameters, ACCESS_LOCATION, _AccessDescription.defaultValues(ACCESS_LOCATION));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ACCESS_METHOD:
            return EMPTY_STRING;
          case ACCESS_LOCATION:
            return new GeneralName();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.accessMethod || EMPTY_STRING }),
            GeneralName.schema(names.accessLocation || {})
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1v);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _AccessDescription.schema({
          names: {
            accessMethod: ACCESS_METHOD,
            accessLocation: {
              names: {
                blockName: ACCESS_LOCATION
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.accessMethod = asn1.result.accessMethod.valueBlock.toString();
        this.accessLocation = new GeneralName({ schema: asn1.result.accessLocation });
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.accessMethod }),
            this.accessLocation.toSchema()
          ]
        });
      }
      toJSON() {
        return {
          accessMethod: this.accessMethod,
          accessLocation: this.accessLocation.toJSON()
        };
      }
    };
    AccessDescription.CLASS_NAME = "AccessDescription";
    var SECONDS = "seconds";
    var MILLIS = "millis";
    var MICROS = "micros";
    var Accuracy = class _Accuracy extends PkiObject {
      constructor(parameters = {}) {
        super();
        if (SECONDS in parameters) {
          this.seconds = pvutils__namespace.getParametersValue(parameters, SECONDS, _Accuracy.defaultValues(SECONDS));
        }
        if (MILLIS in parameters) {
          this.millis = pvutils__namespace.getParametersValue(parameters, MILLIS, _Accuracy.defaultValues(MILLIS));
        }
        if (MICROS in parameters) {
          this.micros = pvutils__namespace.getParametersValue(parameters, MICROS, _Accuracy.defaultValues(MICROS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case SECONDS:
          case MILLIS:
          case MICROS:
            return 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SECONDS:
          case MILLIS:
          case MICROS:
            return memberValue === _Accuracy.defaultValues(memberName);
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          optional: true,
          value: [
            new asn1js__namespace.Integer({
              optional: true,
              name: names.seconds || EMPTY_STRING
            }),
            new asn1js__namespace.Primitive({
              name: names.millis || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              }
            }),
            new asn1js__namespace.Primitive({
              name: names.micros || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              }
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, [
          SECONDS,
          MILLIS,
          MICROS
        ]);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _Accuracy.schema({
          names: {
            seconds: SECONDS,
            millis: MILLIS,
            micros: MICROS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if ("seconds" in asn1.result) {
          this.seconds = asn1.result.seconds.valueBlock.valueDec;
        }
        if ("millis" in asn1.result) {
          const intMillis = new asn1js__namespace.Integer({ valueHex: asn1.result.millis.valueBlock.valueHex });
          this.millis = intMillis.valueBlock.valueDec;
        }
        if ("micros" in asn1.result) {
          const intMicros = new asn1js__namespace.Integer({ valueHex: asn1.result.micros.valueBlock.valueHex });
          this.micros = intMicros.valueBlock.valueDec;
        }
      }
      toSchema() {
        const outputArray = [];
        if (this.seconds !== void 0)
          outputArray.push(new asn1js__namespace.Integer({ value: this.seconds }));
        if (this.millis !== void 0) {
          const intMillis = new asn1js__namespace.Integer({ value: this.millis });
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            valueHex: intMillis.valueBlock.valueHexView
          }));
        }
        if (this.micros !== void 0) {
          const intMicros = new asn1js__namespace.Integer({ value: this.micros });
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            valueHex: intMicros.valueBlock.valueHexView
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const _object = {};
        if (this.seconds !== void 0)
          _object.seconds = this.seconds;
        if (this.millis !== void 0)
          _object.millis = this.millis;
        if (this.micros !== void 0)
          _object.micros = this.micros;
        return _object;
      }
    };
    Accuracy.CLASS_NAME = "Accuracy";
    var ALGORITHM_ID = "algorithmId";
    var ALGORITHM_PARAMS = "algorithmParams";
    var ALGORITHM$2 = "algorithm";
    var PARAMS = "params";
    var CLEAR_PROPS$1u = [
      ALGORITHM$2,
      PARAMS
    ];
    var AlgorithmIdentifier = class _AlgorithmIdentifier extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.algorithmId = pvutils__namespace.getParametersValue(parameters, ALGORITHM_ID, _AlgorithmIdentifier.defaultValues(ALGORITHM_ID));
        if (ALGORITHM_PARAMS in parameters) {
          this.algorithmParams = pvutils__namespace.getParametersValue(parameters, ALGORITHM_PARAMS, _AlgorithmIdentifier.defaultValues(ALGORITHM_PARAMS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ALGORITHM_ID:
            return EMPTY_STRING;
          case ALGORITHM_PARAMS:
            return new asn1js__namespace.Any();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ALGORITHM_ID:
            return memberValue === EMPTY_STRING;
          case ALGORITHM_PARAMS:
            return memberValue instanceof asn1js__namespace.Any;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          optional: names.optional || false,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.algorithmIdentifier || EMPTY_STRING }),
            new asn1js__namespace.Any({ name: names.algorithmParams || EMPTY_STRING, optional: true })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1u);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _AlgorithmIdentifier.schema({
          names: {
            algorithmIdentifier: ALGORITHM$2,
            algorithmParams: PARAMS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.algorithmId = asn1.result.algorithm.valueBlock.toString();
        if (PARAMS in asn1.result) {
          this.algorithmParams = asn1.result.params;
        }
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.ObjectIdentifier({ value: this.algorithmId }));
        if (this.algorithmParams && !(this.algorithmParams instanceof asn1js__namespace.Any)) {
          outputArray.push(this.algorithmParams);
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const object = {
          algorithmId: this.algorithmId
        };
        if (this.algorithmParams && !(this.algorithmParams instanceof asn1js__namespace.Any)) {
          object.algorithmParams = this.algorithmParams.toJSON();
        }
        return object;
      }
      isEqual(algorithmIdentifier) {
        if (!(algorithmIdentifier instanceof _AlgorithmIdentifier)) {
          return false;
        }
        if (this.algorithmId !== algorithmIdentifier.algorithmId) {
          return false;
        }
        if (this.algorithmParams) {
          if (algorithmIdentifier.algorithmParams) {
            return JSON.stringify(this.algorithmParams) === JSON.stringify(algorithmIdentifier.algorithmParams);
          }
          return false;
        }
        if (algorithmIdentifier.algorithmParams) {
          return false;
        }
        return true;
      }
    };
    AlgorithmIdentifier.CLASS_NAME = "AlgorithmIdentifier";
    var ALT_NAMES = "altNames";
    var CLEAR_PROPS$1t = [
      ALT_NAMES
    ];
    var AltName = class _AltName extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.altNames = pvutils__namespace.getParametersValue(parameters, ALT_NAMES, _AltName.defaultValues(ALT_NAMES));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ALT_NAMES:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.altNames || EMPTY_STRING,
              value: GeneralName.schema()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1t);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _AltName.schema({
          names: {
            altNames: ALT_NAMES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (ALT_NAMES in asn1.result) {
          this.altNames = Array.from(asn1.result.altNames, (element) => new GeneralName({ schema: element }));
        }
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.altNames, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          altNames: Array.from(this.altNames, (o) => o.toJSON())
        };
      }
    };
    AltName.CLASS_NAME = "AltName";
    var TYPE$3 = "type";
    var VALUES$1 = "values";
    var CLEAR_PROPS$1s = [
      TYPE$3,
      VALUES$1
    ];
    var Attribute = class _Attribute extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.type = pvutils__namespace.getParametersValue(parameters, TYPE$3, _Attribute.defaultValues(TYPE$3));
        this.values = pvutils__namespace.getParametersValue(parameters, VALUES$1, _Attribute.defaultValues(VALUES$1));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TYPE$3:
            return EMPTY_STRING;
          case VALUES$1:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TYPE$3:
            return memberValue === EMPTY_STRING;
          case VALUES$1:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.type || EMPTY_STRING }),
            new asn1js__namespace.Set({
              name: names.setName || EMPTY_STRING,
              value: [
                new asn1js__namespace.Repeated({
                  name: names.values || EMPTY_STRING,
                  value: new asn1js__namespace.Any()
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1s);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _Attribute.schema({
          names: {
            type: TYPE$3,
            values: VALUES$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.type = asn1.result.type.valueBlock.toString();
        this.values = asn1.result.values;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.type }),
            new asn1js__namespace.Set({
              value: this.values
            })
          ]
        });
      }
      toJSON() {
        return {
          type: this.type,
          values: Array.from(this.values, (o) => o.toJSON())
        };
      }
    };
    Attribute.CLASS_NAME = "Attribute";
    var NOT_BEFORE_TIME = "notBeforeTime";
    var NOT_AFTER_TIME = "notAfterTime";
    var CLEAR_PROPS$1r = [
      NOT_BEFORE_TIME,
      NOT_AFTER_TIME
    ];
    var AttCertValidityPeriod = class _AttCertValidityPeriod extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.notBeforeTime = pvutils__namespace.getParametersValue(parameters, NOT_BEFORE_TIME, _AttCertValidityPeriod.defaultValues(NOT_BEFORE_TIME));
        this.notAfterTime = pvutils__namespace.getParametersValue(parameters, NOT_AFTER_TIME, _AttCertValidityPeriod.defaultValues(NOT_AFTER_TIME));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case NOT_BEFORE_TIME:
          case NOT_AFTER_TIME:
            return new Date(0, 0, 0);
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.GeneralizedTime({ name: names.notBeforeTime || EMPTY_STRING }),
            new asn1js__namespace.GeneralizedTime({ name: names.notAfterTime || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1r);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _AttCertValidityPeriod.schema({
          names: {
            notBeforeTime: NOT_BEFORE_TIME,
            notAfterTime: NOT_AFTER_TIME
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.notBeforeTime = asn1.result.notBeforeTime.toDate();
        this.notAfterTime = asn1.result.notAfterTime.toDate();
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.GeneralizedTime({ valueDate: this.notBeforeTime }),
            new asn1js__namespace.GeneralizedTime({ valueDate: this.notAfterTime })
          ]
        });
      }
      toJSON() {
        return {
          notBeforeTime: this.notBeforeTime,
          notAfterTime: this.notAfterTime
        };
      }
    };
    AttCertValidityPeriod.CLASS_NAME = "AttCertValidityPeriod";
    var NAMES = "names";
    var GENERAL_NAMES = "generalNames";
    var GeneralNames = class _GeneralNames extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.names = pvutils__namespace.getParametersValue(parameters, NAMES, _GeneralNames.defaultValues(NAMES));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case "names":
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}, optional = false) {
        const names = pvutils__namespace.getParametersValue(parameters, NAMES, {});
        return new asn1js__namespace.Sequence({
          optional,
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.generalNames || EMPTY_STRING,
              value: GeneralName.schema()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, [
          NAMES,
          GENERAL_NAMES
        ]);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _GeneralNames.schema({
          names: {
            blockName: NAMES,
            generalNames: GENERAL_NAMES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.names = Array.from(asn1.result.generalNames, (element) => new GeneralName({ schema: element }));
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.names, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          names: Array.from(this.names, (o) => o.toJSON())
        };
      }
    };
    GeneralNames.CLASS_NAME = "GeneralNames";
    var id_SubjectDirectoryAttributes = "2.5.29.9";
    var id_SubjectKeyIdentifier = "2.5.29.14";
    var id_KeyUsage = "2.5.29.15";
    var id_PrivateKeyUsagePeriod = "2.5.29.16";
    var id_SubjectAltName = "2.5.29.17";
    var id_IssuerAltName = "2.5.29.18";
    var id_BasicConstraints = "2.5.29.19";
    var id_CRLNumber = "2.5.29.20";
    var id_BaseCRLNumber = "2.5.29.27";
    var id_CRLReason = "2.5.29.21";
    var id_InvalidityDate = "2.5.29.24";
    var id_IssuingDistributionPoint = "2.5.29.28";
    var id_CertificateIssuer = "2.5.29.29";
    var id_NameConstraints = "2.5.29.30";
    var id_CRLDistributionPoints = "2.5.29.31";
    var id_FreshestCRL = "2.5.29.46";
    var id_CertificatePolicies = "2.5.29.32";
    var id_AnyPolicy = "2.5.29.32.0";
    var id_MicrosoftAppPolicies = "1.3.6.1.4.1.311.21.10";
    var id_PolicyMappings = "2.5.29.33";
    var id_AuthorityKeyIdentifier = "2.5.29.35";
    var id_PolicyConstraints = "2.5.29.36";
    var id_ExtKeyUsage = "2.5.29.37";
    var id_InhibitAnyPolicy = "2.5.29.54";
    var id_AuthorityInfoAccess = "1.3.6.1.5.5.7.1.1";
    var id_SubjectInfoAccess = "1.3.6.1.5.5.7.1.11";
    var id_SignedCertificateTimestampList = "1.3.6.1.4.1.11129.2.4.2";
    var id_MicrosoftCertTemplateV1 = "1.3.6.1.4.1.311.20.2";
    var id_MicrosoftPrevCaCertHash = "1.3.6.1.4.1.311.21.2";
    var id_MicrosoftCertTemplateV2 = "1.3.6.1.4.1.311.21.7";
    var id_MicrosoftCaVersion = "1.3.6.1.4.1.311.21.1";
    var id_QCStatements = "1.3.6.1.5.5.7.1.3";
    var id_ContentType_Data = "1.2.840.113549.1.7.1";
    var id_ContentType_SignedData = "1.2.840.113549.1.7.2";
    var id_ContentType_EnvelopedData = "1.2.840.113549.1.7.3";
    var id_ContentType_EncryptedData = "1.2.840.113549.1.7.6";
    var id_eContentType_TSTInfo = "1.2.840.113549.1.9.16.1.4";
    var id_CertBag_X509Certificate = "1.2.840.113549.1.9.22.1";
    var id_CertBag_SDSICertificate = "1.2.840.113549.1.9.22.2";
    var id_CertBag_AttributeCertificate = "1.2.840.113549.1.9.22.3";
    var id_CRLBag_X509CRL = "1.2.840.113549.1.9.23.1";
    var id_pkix = "1.3.6.1.5.5.7";
    var id_ad = `${id_pkix}.48`;
    var id_PKIX_OCSP_Basic = `${id_ad}.1.1`;
    var id_ad_caIssuers = `${id_ad}.2`;
    var id_ad_ocsp = `${id_ad}.1`;
    var id_sha1 = "1.3.14.3.2.26";
    var id_sha256 = "2.16.840.1.101.3.4.2.1";
    var id_sha384 = "2.16.840.1.101.3.4.2.2";
    var id_sha512 = "2.16.840.1.101.3.4.2.3";
    var KEY_IDENTIFIER$1 = "keyIdentifier";
    var AUTHORITY_CERT_ISSUER = "authorityCertIssuer";
    var AUTHORITY_CERT_SERIAL_NUMBER = "authorityCertSerialNumber";
    var CLEAR_PROPS$1q = [
      KEY_IDENTIFIER$1,
      AUTHORITY_CERT_ISSUER,
      AUTHORITY_CERT_SERIAL_NUMBER
    ];
    var AuthorityKeyIdentifier = class _AuthorityKeyIdentifier extends PkiObject {
      constructor(parameters = {}) {
        super();
        if (KEY_IDENTIFIER$1 in parameters) {
          this.keyIdentifier = pvutils__namespace.getParametersValue(parameters, KEY_IDENTIFIER$1, _AuthorityKeyIdentifier.defaultValues(KEY_IDENTIFIER$1));
        }
        if (AUTHORITY_CERT_ISSUER in parameters) {
          this.authorityCertIssuer = pvutils__namespace.getParametersValue(parameters, AUTHORITY_CERT_ISSUER, _AuthorityKeyIdentifier.defaultValues(AUTHORITY_CERT_ISSUER));
        }
        if (AUTHORITY_CERT_SERIAL_NUMBER in parameters) {
          this.authorityCertSerialNumber = pvutils__namespace.getParametersValue(parameters, AUTHORITY_CERT_SERIAL_NUMBER, _AuthorityKeyIdentifier.defaultValues(AUTHORITY_CERT_SERIAL_NUMBER));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case KEY_IDENTIFIER$1:
            return new asn1js__namespace.OctetString();
          case AUTHORITY_CERT_ISSUER:
            return [];
          case AUTHORITY_CERT_SERIAL_NUMBER:
            return new asn1js__namespace.Integer();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Primitive({
              name: names.keyIdentifier || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              }
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [
                new asn1js__namespace.Repeated({
                  name: names.authorityCertIssuer || EMPTY_STRING,
                  value: GeneralName.schema()
                })
              ]
            }),
            new asn1js__namespace.Primitive({
              name: names.authorityCertSerialNumber || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              }
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1q);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _AuthorityKeyIdentifier.schema({
          names: {
            keyIdentifier: KEY_IDENTIFIER$1,
            authorityCertIssuer: AUTHORITY_CERT_ISSUER,
            authorityCertSerialNumber: AUTHORITY_CERT_SERIAL_NUMBER
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (KEY_IDENTIFIER$1 in asn1.result)
          this.keyIdentifier = new asn1js__namespace.OctetString({ valueHex: asn1.result.keyIdentifier.valueBlock.valueHex });
        if (AUTHORITY_CERT_ISSUER in asn1.result)
          this.authorityCertIssuer = Array.from(asn1.result.authorityCertIssuer, (o) => new GeneralName({ schema: o }));
        if (AUTHORITY_CERT_SERIAL_NUMBER in asn1.result)
          this.authorityCertSerialNumber = new asn1js__namespace.Integer({ valueHex: asn1.result.authorityCertSerialNumber.valueBlock.valueHex });
      }
      toSchema() {
        const outputArray = [];
        if (this.keyIdentifier) {
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            valueHex: this.keyIdentifier.valueBlock.valueHexView
          }));
        }
        if (this.authorityCertIssuer) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.authorityCertIssuer, (o) => o.toSchema())
          }));
        }
        if (this.authorityCertSerialNumber) {
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            valueHex: this.authorityCertSerialNumber.valueBlock.valueHexView
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const object = {};
        if (this.keyIdentifier) {
          object.keyIdentifier = this.keyIdentifier.toJSON();
        }
        if (this.authorityCertIssuer) {
          object.authorityCertIssuer = Array.from(this.authorityCertIssuer, (o) => o.toJSON());
        }
        if (this.authorityCertSerialNumber) {
          object.authorityCertSerialNumber = this.authorityCertSerialNumber.toJSON();
        }
        return object;
      }
    };
    AuthorityKeyIdentifier.CLASS_NAME = "AuthorityKeyIdentifier";
    var PATH_LENGTH_CONSTRAINT = "pathLenConstraint";
    var CA = "cA";
    var BasicConstraints = class _BasicConstraints extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.cA = pvutils__namespace.getParametersValue(parameters, CA, false);
        if (PATH_LENGTH_CONSTRAINT in parameters) {
          this.pathLenConstraint = pvutils__namespace.getParametersValue(parameters, PATH_LENGTH_CONSTRAINT, 0);
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case CA:
            return false;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Boolean({
              optional: true,
              name: names.cA || EMPTY_STRING
            }),
            new asn1js__namespace.Integer({
              optional: true,
              name: names.pathLenConstraint || EMPTY_STRING
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, [
          CA,
          PATH_LENGTH_CONSTRAINT
        ]);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _BasicConstraints.schema({
          names: {
            cA: CA,
            pathLenConstraint: PATH_LENGTH_CONSTRAINT
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (CA in asn1.result) {
          this.cA = asn1.result.cA.valueBlock.value;
        }
        if (PATH_LENGTH_CONSTRAINT in asn1.result) {
          if (asn1.result.pathLenConstraint.valueBlock.isHexOnly) {
            this.pathLenConstraint = asn1.result.pathLenConstraint;
          } else {
            this.pathLenConstraint = asn1.result.pathLenConstraint.valueBlock.valueDec;
          }
        }
      }
      toSchema() {
        const outputArray = [];
        if (this.cA !== _BasicConstraints.defaultValues(CA))
          outputArray.push(new asn1js__namespace.Boolean({ value: this.cA }));
        if (PATH_LENGTH_CONSTRAINT in this) {
          if (this.pathLenConstraint instanceof asn1js__namespace.Integer) {
            outputArray.push(this.pathLenConstraint);
          } else {
            outputArray.push(new asn1js__namespace.Integer({ value: this.pathLenConstraint }));
          }
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const object = {};
        if (this.cA !== _BasicConstraints.defaultValues(CA)) {
          object.cA = this.cA;
        }
        if (PATH_LENGTH_CONSTRAINT in this) {
          if (this.pathLenConstraint instanceof asn1js__namespace.Integer) {
            object.pathLenConstraint = this.pathLenConstraint.toJSON();
          } else {
            object.pathLenConstraint = this.pathLenConstraint;
          }
        }
        return object;
      }
    };
    BasicConstraints.CLASS_NAME = "BasicConstraints";
    var CERTIFICATE_INDEX = "certificateIndex";
    var KEY_INDEX = "keyIndex";
    var CAVersion = class _CAVersion extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.certificateIndex = pvutils__namespace.getParametersValue(parameters, CERTIFICATE_INDEX, _CAVersion.defaultValues(CERTIFICATE_INDEX));
        this.keyIndex = pvutils__namespace.getParametersValue(parameters, KEY_INDEX, _CAVersion.defaultValues(KEY_INDEX));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case CERTIFICATE_INDEX:
          case KEY_INDEX:
            return 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema() {
        return new asn1js__namespace.Integer();
      }
      fromSchema(schema) {
        if (schema.constructor.blockName() !== asn1js__namespace.Integer.blockName()) {
          throw new Error("Object's schema was not verified against input data for CAVersion");
        }
        let value = schema.valueBlock.valueHex.slice(0);
        const valueView = new Uint8Array(value);
        switch (true) {
          case value.byteLength < 4:
            {
              const tempValue = new ArrayBuffer(4);
              const tempValueView = new Uint8Array(tempValue);
              tempValueView.set(valueView, 4 - value.byteLength);
              value = tempValue.slice(0);
            }
            break;
          case value.byteLength > 4:
            {
              const tempValue = new ArrayBuffer(4);
              const tempValueView = new Uint8Array(tempValue);
              tempValueView.set(valueView.slice(0, 4));
              value = tempValue.slice(0);
            }
            break;
        }
        const keyIndexBuffer = value.slice(0, 2);
        const keyIndexView8 = new Uint8Array(keyIndexBuffer);
        let temp = keyIndexView8[0];
        keyIndexView8[0] = keyIndexView8[1];
        keyIndexView8[1] = temp;
        const keyIndexView16 = new Uint16Array(keyIndexBuffer);
        this.keyIndex = keyIndexView16[0];
        const certificateIndexBuffer = value.slice(2);
        const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
        temp = certificateIndexView8[0];
        certificateIndexView8[0] = certificateIndexView8[1];
        certificateIndexView8[1] = temp;
        const certificateIndexView16 = new Uint16Array(certificateIndexBuffer);
        this.certificateIndex = certificateIndexView16[0];
      }
      toSchema() {
        const certificateIndexBuffer = new ArrayBuffer(2);
        const certificateIndexView = new Uint16Array(certificateIndexBuffer);
        certificateIndexView[0] = this.certificateIndex;
        const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
        let temp = certificateIndexView8[0];
        certificateIndexView8[0] = certificateIndexView8[1];
        certificateIndexView8[1] = temp;
        const keyIndexBuffer = new ArrayBuffer(2);
        const keyIndexView = new Uint16Array(keyIndexBuffer);
        keyIndexView[0] = this.keyIndex;
        const keyIndexView8 = new Uint8Array(keyIndexBuffer);
        temp = keyIndexView8[0];
        keyIndexView8[0] = keyIndexView8[1];
        keyIndexView8[1] = temp;
        return new asn1js__namespace.Integer({
          valueHex: pvutils__namespace.utilConcatBuf(keyIndexBuffer, certificateIndexBuffer)
        });
      }
      toJSON() {
        return {
          certificateIndex: this.certificateIndex,
          keyIndex: this.keyIndex
        };
      }
    };
    CAVersion.CLASS_NAME = "CAVersion";
    var POLICY_QUALIFIER_ID = "policyQualifierId";
    var QUALIFIER = "qualifier";
    var CLEAR_PROPS$1p = [
      POLICY_QUALIFIER_ID,
      QUALIFIER
    ];
    var PolicyQualifierInfo = class _PolicyQualifierInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.policyQualifierId = pvutils__namespace.getParametersValue(parameters, POLICY_QUALIFIER_ID, _PolicyQualifierInfo.defaultValues(POLICY_QUALIFIER_ID));
        this.qualifier = pvutils__namespace.getParametersValue(parameters, QUALIFIER, _PolicyQualifierInfo.defaultValues(QUALIFIER));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case POLICY_QUALIFIER_ID:
            return EMPTY_STRING;
          case QUALIFIER:
            return new asn1js__namespace.Any();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.policyQualifierId || EMPTY_STRING }),
            new asn1js__namespace.Any({ name: names.qualifier || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1p);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PolicyQualifierInfo.schema({
          names: {
            policyQualifierId: POLICY_QUALIFIER_ID,
            qualifier: QUALIFIER
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.policyQualifierId = asn1.result.policyQualifierId.valueBlock.toString();
        this.qualifier = asn1.result.qualifier;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.policyQualifierId }),
            this.qualifier
          ]
        });
      }
      toJSON() {
        return {
          policyQualifierId: this.policyQualifierId,
          qualifier: this.qualifier.toJSON()
        };
      }
    };
    PolicyQualifierInfo.CLASS_NAME = "PolicyQualifierInfo";
    var POLICY_IDENTIFIER = "policyIdentifier";
    var POLICY_QUALIFIERS = "policyQualifiers";
    var CLEAR_PROPS$1o = [
      POLICY_IDENTIFIER,
      POLICY_QUALIFIERS
    ];
    var PolicyInformation = class _PolicyInformation extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.policyIdentifier = pvutils__namespace.getParametersValue(parameters, POLICY_IDENTIFIER, _PolicyInformation.defaultValues(POLICY_IDENTIFIER));
        if (POLICY_QUALIFIERS in parameters) {
          this.policyQualifiers = pvutils__namespace.getParametersValue(parameters, POLICY_QUALIFIERS, _PolicyInformation.defaultValues(POLICY_QUALIFIERS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case POLICY_IDENTIFIER:
            return EMPTY_STRING;
          case POLICY_QUALIFIERS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.policyIdentifier || EMPTY_STRING }),
            new asn1js__namespace.Sequence({
              optional: true,
              value: [
                new asn1js__namespace.Repeated({
                  name: names.policyQualifiers || EMPTY_STRING,
                  value: PolicyQualifierInfo.schema()
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1o);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PolicyInformation.schema({
          names: {
            policyIdentifier: POLICY_IDENTIFIER,
            policyQualifiers: POLICY_QUALIFIERS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.policyIdentifier = asn1.result.policyIdentifier.valueBlock.toString();
        if (POLICY_QUALIFIERS in asn1.result) {
          this.policyQualifiers = Array.from(asn1.result.policyQualifiers, (element) => new PolicyQualifierInfo({ schema: element }));
        }
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.ObjectIdentifier({ value: this.policyIdentifier }));
        if (this.policyQualifiers) {
          outputArray.push(new asn1js__namespace.Sequence({
            value: Array.from(this.policyQualifiers, (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          policyIdentifier: this.policyIdentifier
        };
        if (this.policyQualifiers)
          res.policyQualifiers = Array.from(this.policyQualifiers, (o) => o.toJSON());
        return res;
      }
    };
    PolicyInformation.CLASS_NAME = "PolicyInformation";
    var CERTIFICATE_POLICIES = "certificatePolicies";
    var CLEAR_PROPS$1n = [
      CERTIFICATE_POLICIES
    ];
    var CertificatePolicies = class _CertificatePolicies extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.certificatePolicies = pvutils__namespace.getParametersValue(parameters, CERTIFICATE_POLICIES, _CertificatePolicies.defaultValues(CERTIFICATE_POLICIES));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case CERTIFICATE_POLICIES:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.certificatePolicies || EMPTY_STRING,
              value: PolicyInformation.schema()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1n);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _CertificatePolicies.schema({
          names: {
            certificatePolicies: CERTIFICATE_POLICIES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.certificatePolicies = Array.from(asn1.result.certificatePolicies, (element) => new PolicyInformation({ schema: element }));
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.certificatePolicies, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          certificatePolicies: Array.from(this.certificatePolicies, (o) => o.toJSON())
        };
      }
    };
    CertificatePolicies.CLASS_NAME = "CertificatePolicies";
    var TEMPLATE_ID = "templateID";
    var TEMPLATE_MAJOR_VERSION = "templateMajorVersion";
    var TEMPLATE_MINOR_VERSION = "templateMinorVersion";
    var CLEAR_PROPS$1m = [
      TEMPLATE_ID,
      TEMPLATE_MAJOR_VERSION,
      TEMPLATE_MINOR_VERSION
    ];
    var CertificateTemplate = class _CertificateTemplate extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.templateID = pvutils__namespace.getParametersValue(parameters, TEMPLATE_ID, _CertificateTemplate.defaultValues(TEMPLATE_ID));
        if (TEMPLATE_MAJOR_VERSION in parameters) {
          this.templateMajorVersion = pvutils__namespace.getParametersValue(parameters, TEMPLATE_MAJOR_VERSION, _CertificateTemplate.defaultValues(TEMPLATE_MAJOR_VERSION));
        }
        if (TEMPLATE_MINOR_VERSION in parameters) {
          this.templateMinorVersion = pvutils__namespace.getParametersValue(parameters, TEMPLATE_MINOR_VERSION, _CertificateTemplate.defaultValues(TEMPLATE_MINOR_VERSION));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TEMPLATE_ID:
            return EMPTY_STRING;
          case TEMPLATE_MAJOR_VERSION:
          case TEMPLATE_MINOR_VERSION:
            return 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.templateID || EMPTY_STRING }),
            new asn1js__namespace.Integer({
              name: names.templateMajorVersion || EMPTY_STRING,
              optional: true
            }),
            new asn1js__namespace.Integer({
              name: names.templateMinorVersion || EMPTY_STRING,
              optional: true
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1m);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _CertificateTemplate.schema({
          names: {
            templateID: TEMPLATE_ID,
            templateMajorVersion: TEMPLATE_MAJOR_VERSION,
            templateMinorVersion: TEMPLATE_MINOR_VERSION
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.templateID = asn1.result.templateID.valueBlock.toString();
        if (TEMPLATE_MAJOR_VERSION in asn1.result) {
          this.templateMajorVersion = asn1.result.templateMajorVersion.valueBlock.valueDec;
        }
        if (TEMPLATE_MINOR_VERSION in asn1.result) {
          this.templateMinorVersion = asn1.result.templateMinorVersion.valueBlock.valueDec;
        }
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.ObjectIdentifier({ value: this.templateID }));
        if (TEMPLATE_MAJOR_VERSION in this) {
          outputArray.push(new asn1js__namespace.Integer({ value: this.templateMajorVersion }));
        }
        if (TEMPLATE_MINOR_VERSION in this) {
          outputArray.push(new asn1js__namespace.Integer({ value: this.templateMinorVersion }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          templateID: this.templateID
        };
        if (TEMPLATE_MAJOR_VERSION in this)
          res.templateMajorVersion = this.templateMajorVersion;
        if (TEMPLATE_MINOR_VERSION in this)
          res.templateMinorVersion = this.templateMinorVersion;
        return res;
      }
    };
    var DISTRIBUTION_POINT$1 = "distributionPoint";
    var DISTRIBUTION_POINT_NAMES$1 = "distributionPointNames";
    var REASONS = "reasons";
    var CRL_ISSUER = "cRLIssuer";
    var CRL_ISSUER_NAMES = "cRLIssuerNames";
    var CLEAR_PROPS$1l = [
      DISTRIBUTION_POINT$1,
      DISTRIBUTION_POINT_NAMES$1,
      REASONS,
      CRL_ISSUER,
      CRL_ISSUER_NAMES
    ];
    var DistributionPoint = class _DistributionPoint extends PkiObject {
      constructor(parameters = {}) {
        super();
        if (DISTRIBUTION_POINT$1 in parameters) {
          this.distributionPoint = pvutils__namespace.getParametersValue(parameters, DISTRIBUTION_POINT$1, _DistributionPoint.defaultValues(DISTRIBUTION_POINT$1));
        }
        if (REASONS in parameters) {
          this.reasons = pvutils__namespace.getParametersValue(parameters, REASONS, _DistributionPoint.defaultValues(REASONS));
        }
        if (CRL_ISSUER in parameters) {
          this.cRLIssuer = pvutils__namespace.getParametersValue(parameters, CRL_ISSUER, _DistributionPoint.defaultValues(CRL_ISSUER));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case DISTRIBUTION_POINT$1:
            return [];
          case REASONS:
            return new asn1js__namespace.BitString();
          case CRL_ISSUER:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                new asn1js__namespace.Choice({
                  value: [
                    new asn1js__namespace.Constructed({
                      name: names.distributionPoint || EMPTY_STRING,
                      optional: true,
                      idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                      },
                      value: [
                        new asn1js__namespace.Repeated({
                          name: names.distributionPointNames || EMPTY_STRING,
                          value: GeneralName.schema()
                        })
                      ]
                    }),
                    new asn1js__namespace.Constructed({
                      name: names.distributionPoint || EMPTY_STRING,
                      optional: true,
                      idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                      },
                      value: RelativeDistinguishedNames.schema().valueBlock.value
                    })
                  ]
                })
              ]
            }),
            new asn1js__namespace.Primitive({
              name: names.reasons || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              }
            }),
            new asn1js__namespace.Constructed({
              name: names.cRLIssuer || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: [
                new asn1js__namespace.Repeated({
                  name: names.cRLIssuerNames || EMPTY_STRING,
                  value: GeneralName.schema()
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1l);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _DistributionPoint.schema({
          names: {
            distributionPoint: DISTRIBUTION_POINT$1,
            distributionPointNames: DISTRIBUTION_POINT_NAMES$1,
            reasons: REASONS,
            cRLIssuer: CRL_ISSUER,
            cRLIssuerNames: CRL_ISSUER_NAMES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (DISTRIBUTION_POINT$1 in asn1.result) {
          if (asn1.result.distributionPoint.idBlock.tagNumber === 0) {
            this.distributionPoint = Array.from(asn1.result.distributionPointNames, (element) => new GeneralName({ schema: element }));
          }
          if (asn1.result.distributionPoint.idBlock.tagNumber === 1) {
            this.distributionPoint = new RelativeDistinguishedNames({
              schema: new asn1js__namespace.Sequence({
                value: asn1.result.distributionPoint.valueBlock.value
              })
            });
          }
        }
        if (REASONS in asn1.result) {
          this.reasons = new asn1js__namespace.BitString({ valueHex: asn1.result.reasons.valueBlock.valueHex });
        }
        if (CRL_ISSUER in asn1.result) {
          this.cRLIssuer = Array.from(asn1.result.cRLIssuerNames, (element) => new GeneralName({ schema: element }));
        }
      }
      toSchema() {
        const outputArray = [];
        if (this.distributionPoint) {
          let internalValue;
          if (this.distributionPoint instanceof Array) {
            internalValue = new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: Array.from(this.distributionPoint, (o) => o.toSchema())
            });
          } else {
            internalValue = new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [this.distributionPoint.toSchema()]
            });
          }
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [internalValue]
          }));
        }
        if (this.reasons) {
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            valueHex: this.reasons.valueBlock.valueHexView
          }));
        }
        if (this.cRLIssuer) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: Array.from(this.cRLIssuer, (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const object = {};
        if (this.distributionPoint) {
          if (this.distributionPoint instanceof Array) {
            object.distributionPoint = Array.from(this.distributionPoint, (o) => o.toJSON());
          } else {
            object.distributionPoint = this.distributionPoint.toJSON();
          }
        }
        if (this.reasons) {
          object.reasons = this.reasons.toJSON();
        }
        if (this.cRLIssuer) {
          object.cRLIssuer = Array.from(this.cRLIssuer, (o) => o.toJSON());
        }
        return object;
      }
    };
    DistributionPoint.CLASS_NAME = "DistributionPoint";
    var DISTRIBUTION_POINTS = "distributionPoints";
    var CLEAR_PROPS$1k = [
      DISTRIBUTION_POINTS
    ];
    var CRLDistributionPoints = class _CRLDistributionPoints extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.distributionPoints = pvutils__namespace.getParametersValue(parameters, DISTRIBUTION_POINTS, _CRLDistributionPoints.defaultValues(DISTRIBUTION_POINTS));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case DISTRIBUTION_POINTS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.distributionPoints || EMPTY_STRING,
              value: DistributionPoint.schema()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1k);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _CRLDistributionPoints.schema({
          names: {
            distributionPoints: DISTRIBUTION_POINTS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.distributionPoints = Array.from(asn1.result.distributionPoints, (element) => new DistributionPoint({ schema: element }));
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.distributionPoints, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          distributionPoints: Array.from(this.distributionPoints, (o) => o.toJSON())
        };
      }
    };
    CRLDistributionPoints.CLASS_NAME = "CRLDistributionPoints";
    var KEY_PURPOSES = "keyPurposes";
    var CLEAR_PROPS$1j = [
      KEY_PURPOSES
    ];
    var ExtKeyUsage = class _ExtKeyUsage extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.keyPurposes = pvutils__namespace.getParametersValue(parameters, KEY_PURPOSES, _ExtKeyUsage.defaultValues(KEY_PURPOSES));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case KEY_PURPOSES:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.keyPurposes || EMPTY_STRING,
              value: new asn1js__namespace.ObjectIdentifier()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1j);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _ExtKeyUsage.schema({
          names: {
            keyPurposes: KEY_PURPOSES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.keyPurposes = Array.from(asn1.result.keyPurposes, (element) => element.valueBlock.toString());
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.keyPurposes, (element) => new asn1js__namespace.ObjectIdentifier({ value: element }))
        });
      }
      toJSON() {
        return {
          keyPurposes: Array.from(this.keyPurposes)
        };
      }
    };
    ExtKeyUsage.CLASS_NAME = "ExtKeyUsage";
    var ACCESS_DESCRIPTIONS = "accessDescriptions";
    var InfoAccess = class _InfoAccess extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.accessDescriptions = pvutils__namespace.getParametersValue(parameters, ACCESS_DESCRIPTIONS, _InfoAccess.defaultValues(ACCESS_DESCRIPTIONS));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ACCESS_DESCRIPTIONS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.accessDescriptions || EMPTY_STRING,
              value: AccessDescription.schema()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, [
          ACCESS_DESCRIPTIONS
        ]);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _InfoAccess.schema({
          names: {
            accessDescriptions: ACCESS_DESCRIPTIONS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.accessDescriptions = Array.from(asn1.result.accessDescriptions, (element) => new AccessDescription({ schema: element }));
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.accessDescriptions, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          accessDescriptions: Array.from(this.accessDescriptions, (o) => o.toJSON())
        };
      }
    };
    InfoAccess.CLASS_NAME = "InfoAccess";
    var DISTRIBUTION_POINT = "distributionPoint";
    var DISTRIBUTION_POINT_NAMES = "distributionPointNames";
    var ONLY_CONTAINS_USER_CERTS = "onlyContainsUserCerts";
    var ONLY_CONTAINS_CA_CERTS = "onlyContainsCACerts";
    var ONLY_SOME_REASON = "onlySomeReasons";
    var INDIRECT_CRL = "indirectCRL";
    var ONLY_CONTAINS_ATTRIBUTE_CERTS = "onlyContainsAttributeCerts";
    var CLEAR_PROPS$1i = [
      DISTRIBUTION_POINT,
      DISTRIBUTION_POINT_NAMES,
      ONLY_CONTAINS_USER_CERTS,
      ONLY_CONTAINS_CA_CERTS,
      ONLY_SOME_REASON,
      INDIRECT_CRL,
      ONLY_CONTAINS_ATTRIBUTE_CERTS
    ];
    var IssuingDistributionPoint = class _IssuingDistributionPoint extends PkiObject {
      constructor(parameters = {}) {
        super();
        if (DISTRIBUTION_POINT in parameters) {
          this.distributionPoint = pvutils__namespace.getParametersValue(parameters, DISTRIBUTION_POINT, _IssuingDistributionPoint.defaultValues(DISTRIBUTION_POINT));
        }
        this.onlyContainsUserCerts = pvutils__namespace.getParametersValue(parameters, ONLY_CONTAINS_USER_CERTS, _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS));
        this.onlyContainsCACerts = pvutils__namespace.getParametersValue(parameters, ONLY_CONTAINS_CA_CERTS, _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS));
        if (ONLY_SOME_REASON in parameters) {
          this.onlySomeReasons = pvutils__namespace.getParametersValue(parameters, ONLY_SOME_REASON, _IssuingDistributionPoint.defaultValues(ONLY_SOME_REASON));
        }
        this.indirectCRL = pvutils__namespace.getParametersValue(parameters, INDIRECT_CRL, _IssuingDistributionPoint.defaultValues(INDIRECT_CRL));
        this.onlyContainsAttributeCerts = pvutils__namespace.getParametersValue(parameters, ONLY_CONTAINS_ATTRIBUTE_CERTS, _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case DISTRIBUTION_POINT:
            return [];
          case ONLY_CONTAINS_USER_CERTS:
            return false;
          case ONLY_CONTAINS_CA_CERTS:
            return false;
          case ONLY_SOME_REASON:
            return 0;
          case INDIRECT_CRL:
            return false;
          case ONLY_CONTAINS_ATTRIBUTE_CERTS:
            return false;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                new asn1js__namespace.Choice({
                  value: [
                    new asn1js__namespace.Constructed({
                      name: names.distributionPoint || EMPTY_STRING,
                      idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                      },
                      value: [
                        new asn1js__namespace.Repeated({
                          name: names.distributionPointNames || EMPTY_STRING,
                          value: GeneralName.schema()
                        })
                      ]
                    }),
                    new asn1js__namespace.Constructed({
                      name: names.distributionPoint || EMPTY_STRING,
                      idBlock: {
                        tagClass: 3,
                        tagNumber: 1
                      },
                      value: RelativeDistinguishedNames.schema().valueBlock.value
                    })
                  ]
                })
              ]
            }),
            new asn1js__namespace.Primitive({
              name: names.onlyContainsUserCerts || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              }
            }),
            new asn1js__namespace.Primitive({
              name: names.onlyContainsCACerts || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              }
            }),
            new asn1js__namespace.Primitive({
              name: names.onlySomeReasons || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 3
              }
            }),
            new asn1js__namespace.Primitive({
              name: names.indirectCRL || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 4
              }
            }),
            new asn1js__namespace.Primitive({
              name: names.onlyContainsAttributeCerts || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 5
              }
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1i);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _IssuingDistributionPoint.schema({
          names: {
            distributionPoint: DISTRIBUTION_POINT,
            distributionPointNames: DISTRIBUTION_POINT_NAMES,
            onlyContainsUserCerts: ONLY_CONTAINS_USER_CERTS,
            onlyContainsCACerts: ONLY_CONTAINS_CA_CERTS,
            onlySomeReasons: ONLY_SOME_REASON,
            indirectCRL: INDIRECT_CRL,
            onlyContainsAttributeCerts: ONLY_CONTAINS_ATTRIBUTE_CERTS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (DISTRIBUTION_POINT in asn1.result) {
          switch (true) {
            case asn1.result.distributionPoint.idBlock.tagNumber === 0:
              this.distributionPoint = Array.from(asn1.result.distributionPointNames, (element) => new GeneralName({ schema: element }));
              break;
            case asn1.result.distributionPoint.idBlock.tagNumber === 1:
              {
                this.distributionPoint = new RelativeDistinguishedNames({
                  schema: new asn1js__namespace.Sequence({
                    value: asn1.result.distributionPoint.valueBlock.value
                  })
                });
              }
              break;
            default:
              throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}");
          }
        }
        if (ONLY_CONTAINS_USER_CERTS in asn1.result) {
          const view = new Uint8Array(asn1.result.onlyContainsUserCerts.valueBlock.valueHex);
          this.onlyContainsUserCerts = view[0] !== 0;
        }
        if (ONLY_CONTAINS_CA_CERTS in asn1.result) {
          const view = new Uint8Array(asn1.result.onlyContainsCACerts.valueBlock.valueHex);
          this.onlyContainsCACerts = view[0] !== 0;
        }
        if (ONLY_SOME_REASON in asn1.result) {
          const view = new Uint8Array(asn1.result.onlySomeReasons.valueBlock.valueHex);
          this.onlySomeReasons = view[0];
        }
        if (INDIRECT_CRL in asn1.result) {
          const view = new Uint8Array(asn1.result.indirectCRL.valueBlock.valueHex);
          this.indirectCRL = view[0] !== 0;
        }
        if (ONLY_CONTAINS_ATTRIBUTE_CERTS in asn1.result) {
          const view = new Uint8Array(asn1.result.onlyContainsAttributeCerts.valueBlock.valueHex);
          this.onlyContainsAttributeCerts = view[0] !== 0;
        }
      }
      toSchema() {
        const outputArray = [];
        if (this.distributionPoint) {
          let value;
          if (this.distributionPoint instanceof Array) {
            value = new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: Array.from(this.distributionPoint, (o) => o.toSchema())
            });
          } else {
            value = this.distributionPoint.toSchema();
            value.idBlock.tagClass = 3;
            value.idBlock.tagNumber = 1;
          }
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [value]
          }));
        }
        if (this.onlyContainsUserCerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS)) {
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            valueHex: new Uint8Array([255]).buffer
          }));
        }
        if (this.onlyContainsCACerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS)) {
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            valueHex: new Uint8Array([255]).buffer
          }));
        }
        if (this.onlySomeReasons !== void 0) {
          const buffer = new ArrayBuffer(1);
          const view = new Uint8Array(buffer);
          view[0] = this.onlySomeReasons;
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            valueHex: buffer
          }));
        }
        if (this.indirectCRL !== _IssuingDistributionPoint.defaultValues(INDIRECT_CRL)) {
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 4
            },
            valueHex: new Uint8Array([255]).buffer
          }));
        }
        if (this.onlyContainsAttributeCerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS)) {
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 5
            },
            valueHex: new Uint8Array([255]).buffer
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const obj = {};
        if (this.distributionPoint) {
          if (this.distributionPoint instanceof Array) {
            obj.distributionPoint = Array.from(this.distributionPoint, (o) => o.toJSON());
          } else {
            obj.distributionPoint = this.distributionPoint.toJSON();
          }
        }
        if (this.onlyContainsUserCerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_USER_CERTS)) {
          obj.onlyContainsUserCerts = this.onlyContainsUserCerts;
        }
        if (this.onlyContainsCACerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_CA_CERTS)) {
          obj.onlyContainsCACerts = this.onlyContainsCACerts;
        }
        if (ONLY_SOME_REASON in this) {
          obj.onlySomeReasons = this.onlySomeReasons;
        }
        if (this.indirectCRL !== _IssuingDistributionPoint.defaultValues(INDIRECT_CRL)) {
          obj.indirectCRL = this.indirectCRL;
        }
        if (this.onlyContainsAttributeCerts !== _IssuingDistributionPoint.defaultValues(ONLY_CONTAINS_ATTRIBUTE_CERTS)) {
          obj.onlyContainsAttributeCerts = this.onlyContainsAttributeCerts;
        }
        return obj;
      }
    };
    IssuingDistributionPoint.CLASS_NAME = "IssuingDistributionPoint";
    var BASE = "base";
    var MINIMUM = "minimum";
    var MAXIMUM = "maximum";
    var CLEAR_PROPS$1h = [
      BASE,
      MINIMUM,
      MAXIMUM
    ];
    var GeneralSubtree = class _GeneralSubtree extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.base = pvutils__namespace.getParametersValue(parameters, BASE, _GeneralSubtree.defaultValues(BASE));
        this.minimum = pvutils__namespace.getParametersValue(parameters, MINIMUM, _GeneralSubtree.defaultValues(MINIMUM));
        if (MAXIMUM in parameters) {
          this.maximum = pvutils__namespace.getParametersValue(parameters, MAXIMUM, _GeneralSubtree.defaultValues(MAXIMUM));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case BASE:
            return new GeneralName();
          case MINIMUM:
            return 0;
          case MAXIMUM:
            return 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            GeneralName.schema(names.base || {}),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.Integer({ name: names.minimum || EMPTY_STRING })]
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [new asn1js__namespace.Integer({ name: names.maximum || EMPTY_STRING })]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1h);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _GeneralSubtree.schema({
          names: {
            base: {
              names: {
                blockName: BASE
              }
            },
            minimum: MINIMUM,
            maximum: MAXIMUM
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.base = new GeneralName({ schema: asn1.result.base });
        if (MINIMUM in asn1.result) {
          if (asn1.result.minimum.valueBlock.isHexOnly)
            this.minimum = asn1.result.minimum;
          else
            this.minimum = asn1.result.minimum.valueBlock.valueDec;
        }
        if (MAXIMUM in asn1.result) {
          if (asn1.result.maximum.valueBlock.isHexOnly)
            this.maximum = asn1.result.maximum;
          else
            this.maximum = asn1.result.maximum.valueBlock.valueDec;
        }
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(this.base.toSchema());
        if (this.minimum !== 0) {
          let valueMinimum = 0;
          if (this.minimum instanceof asn1js__namespace.Integer) {
            valueMinimum = this.minimum;
          } else {
            valueMinimum = new asn1js__namespace.Integer({ value: this.minimum });
          }
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [valueMinimum]
          }));
        }
        if (MAXIMUM in this) {
          let valueMaximum = 0;
          if (this.maximum instanceof asn1js__namespace.Integer) {
            valueMaximum = this.maximum;
          } else {
            valueMaximum = new asn1js__namespace.Integer({ value: this.maximum });
          }
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [valueMaximum]
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          base: this.base.toJSON()
        };
        if (this.minimum !== 0) {
          if (typeof this.minimum === "number") {
            res.minimum = this.minimum;
          } else {
            res.minimum = this.minimum.toJSON();
          }
        }
        if (this.maximum !== void 0) {
          if (typeof this.maximum === "number") {
            res.maximum = this.maximum;
          } else {
            res.maximum = this.maximum.toJSON();
          }
        }
        return res;
      }
    };
    GeneralSubtree.CLASS_NAME = "GeneralSubtree";
    var PERMITTED_SUBTREES = "permittedSubtrees";
    var EXCLUDED_SUBTREES = "excludedSubtrees";
    var CLEAR_PROPS$1g = [
      PERMITTED_SUBTREES,
      EXCLUDED_SUBTREES
    ];
    var NameConstraints = class _NameConstraints extends PkiObject {
      constructor(parameters = {}) {
        super();
        if (PERMITTED_SUBTREES in parameters) {
          this.permittedSubtrees = pvutils__namespace.getParametersValue(parameters, PERMITTED_SUBTREES, _NameConstraints.defaultValues(PERMITTED_SUBTREES));
        }
        if (EXCLUDED_SUBTREES in parameters) {
          this.excludedSubtrees = pvutils__namespace.getParametersValue(parameters, EXCLUDED_SUBTREES, _NameConstraints.defaultValues(EXCLUDED_SUBTREES));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case PERMITTED_SUBTREES:
          case EXCLUDED_SUBTREES:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                new asn1js__namespace.Repeated({
                  name: names.permittedSubtrees || EMPTY_STRING,
                  value: GeneralSubtree.schema()
                })
              ]
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [
                new asn1js__namespace.Repeated({
                  name: names.excludedSubtrees || EMPTY_STRING,
                  value: GeneralSubtree.schema()
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1g);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _NameConstraints.schema({
          names: {
            permittedSubtrees: PERMITTED_SUBTREES,
            excludedSubtrees: EXCLUDED_SUBTREES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (PERMITTED_SUBTREES in asn1.result)
          this.permittedSubtrees = Array.from(asn1.result.permittedSubtrees, (element) => new GeneralSubtree({ schema: element }));
        if (EXCLUDED_SUBTREES in asn1.result)
          this.excludedSubtrees = Array.from(asn1.result.excludedSubtrees, (element) => new GeneralSubtree({ schema: element }));
      }
      toSchema() {
        const outputArray = [];
        if (this.permittedSubtrees) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: Array.from(this.permittedSubtrees, (o) => o.toSchema())
          }));
        }
        if (this.excludedSubtrees) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.excludedSubtrees, (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const object = {};
        if (this.permittedSubtrees) {
          object.permittedSubtrees = Array.from(this.permittedSubtrees, (o) => o.toJSON());
        }
        if (this.excludedSubtrees) {
          object.excludedSubtrees = Array.from(this.excludedSubtrees, (o) => o.toJSON());
        }
        return object;
      }
    };
    NameConstraints.CLASS_NAME = "NameConstraints";
    var REQUIRE_EXPLICIT_POLICY = "requireExplicitPolicy";
    var INHIBIT_POLICY_MAPPING = "inhibitPolicyMapping";
    var CLEAR_PROPS$1f = [
      REQUIRE_EXPLICIT_POLICY,
      INHIBIT_POLICY_MAPPING
    ];
    var PolicyConstraints = class _PolicyConstraints extends PkiObject {
      constructor(parameters = {}) {
        super();
        if (REQUIRE_EXPLICIT_POLICY in parameters) {
          this.requireExplicitPolicy = pvutils__namespace.getParametersValue(parameters, REQUIRE_EXPLICIT_POLICY, _PolicyConstraints.defaultValues(REQUIRE_EXPLICIT_POLICY));
        }
        if (INHIBIT_POLICY_MAPPING in parameters) {
          this.inhibitPolicyMapping = pvutils__namespace.getParametersValue(parameters, INHIBIT_POLICY_MAPPING, _PolicyConstraints.defaultValues(INHIBIT_POLICY_MAPPING));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case REQUIRE_EXPLICIT_POLICY:
            return 0;
          case INHIBIT_POLICY_MAPPING:
            return 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Primitive({
              name: names.requireExplicitPolicy || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              }
            }),
            new asn1js__namespace.Primitive({
              name: names.inhibitPolicyMapping || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              }
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1f);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PolicyConstraints.schema({
          names: {
            requireExplicitPolicy: REQUIRE_EXPLICIT_POLICY,
            inhibitPolicyMapping: INHIBIT_POLICY_MAPPING
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (REQUIRE_EXPLICIT_POLICY in asn1.result) {
          const field1 = asn1.result.requireExplicitPolicy;
          field1.idBlock.tagClass = 1;
          field1.idBlock.tagNumber = 2;
          const ber1 = field1.toBER(false);
          const int1 = asn1js__namespace.fromBER(ber1);
          AsnError.assert(int1, "Integer");
          this.requireExplicitPolicy = int1.result.valueBlock.valueDec;
        }
        if (INHIBIT_POLICY_MAPPING in asn1.result) {
          const field2 = asn1.result.inhibitPolicyMapping;
          field2.idBlock.tagClass = 1;
          field2.idBlock.tagNumber = 2;
          const ber2 = field2.toBER(false);
          const int2 = asn1js__namespace.fromBER(ber2);
          AsnError.assert(int2, "Integer");
          this.inhibitPolicyMapping = int2.result.valueBlock.valueDec;
        }
      }
      toSchema() {
        const outputArray = [];
        if (REQUIRE_EXPLICIT_POLICY in this) {
          const int1 = new asn1js__namespace.Integer({ value: this.requireExplicitPolicy });
          int1.idBlock.tagClass = 3;
          int1.idBlock.tagNumber = 0;
          outputArray.push(int1);
        }
        if (INHIBIT_POLICY_MAPPING in this) {
          const int2 = new asn1js__namespace.Integer({ value: this.inhibitPolicyMapping });
          int2.idBlock.tagClass = 3;
          int2.idBlock.tagNumber = 1;
          outputArray.push(int2);
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {};
        if (REQUIRE_EXPLICIT_POLICY in this) {
          res.requireExplicitPolicy = this.requireExplicitPolicy;
        }
        if (INHIBIT_POLICY_MAPPING in this) {
          res.inhibitPolicyMapping = this.inhibitPolicyMapping;
        }
        return res;
      }
    };
    PolicyConstraints.CLASS_NAME = "PolicyConstraints";
    var ISSUER_DOMAIN_POLICY = "issuerDomainPolicy";
    var SUBJECT_DOMAIN_POLICY = "subjectDomainPolicy";
    var CLEAR_PROPS$1e = [
      ISSUER_DOMAIN_POLICY,
      SUBJECT_DOMAIN_POLICY
    ];
    var PolicyMapping = class _PolicyMapping extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.issuerDomainPolicy = pvutils__namespace.getParametersValue(parameters, ISSUER_DOMAIN_POLICY, _PolicyMapping.defaultValues(ISSUER_DOMAIN_POLICY));
        this.subjectDomainPolicy = pvutils__namespace.getParametersValue(parameters, SUBJECT_DOMAIN_POLICY, _PolicyMapping.defaultValues(SUBJECT_DOMAIN_POLICY));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ISSUER_DOMAIN_POLICY:
            return EMPTY_STRING;
          case SUBJECT_DOMAIN_POLICY:
            return EMPTY_STRING;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.issuerDomainPolicy || EMPTY_STRING }),
            new asn1js__namespace.ObjectIdentifier({ name: names.subjectDomainPolicy || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1e);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PolicyMapping.schema({
          names: {
            issuerDomainPolicy: ISSUER_DOMAIN_POLICY,
            subjectDomainPolicy: SUBJECT_DOMAIN_POLICY
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.issuerDomainPolicy = asn1.result.issuerDomainPolicy.valueBlock.toString();
        this.subjectDomainPolicy = asn1.result.subjectDomainPolicy.valueBlock.toString();
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.issuerDomainPolicy }),
            new asn1js__namespace.ObjectIdentifier({ value: this.subjectDomainPolicy })
          ]
        });
      }
      toJSON() {
        return {
          issuerDomainPolicy: this.issuerDomainPolicy,
          subjectDomainPolicy: this.subjectDomainPolicy
        };
      }
    };
    PolicyMapping.CLASS_NAME = "PolicyMapping";
    var MAPPINGS = "mappings";
    var CLEAR_PROPS$1d = [
      MAPPINGS
    ];
    var PolicyMappings = class _PolicyMappings extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.mappings = pvutils__namespace.getParametersValue(parameters, MAPPINGS, _PolicyMappings.defaultValues(MAPPINGS));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case MAPPINGS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.mappings || EMPTY_STRING,
              value: PolicyMapping.schema()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1d);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PolicyMappings.schema({
          names: {
            mappings: MAPPINGS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.mappings = Array.from(asn1.result.mappings, (element) => new PolicyMapping({ schema: element }));
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.mappings, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          mappings: Array.from(this.mappings, (o) => o.toJSON())
        };
      }
    };
    PolicyMappings.CLASS_NAME = "PolicyMappings";
    var NOT_BEFORE$1 = "notBefore";
    var NOT_AFTER$1 = "notAfter";
    var CLEAR_PROPS$1c = [
      NOT_BEFORE$1,
      NOT_AFTER$1
    ];
    var PrivateKeyUsagePeriod = class _PrivateKeyUsagePeriod extends PkiObject {
      constructor(parameters = {}) {
        super();
        if (NOT_BEFORE$1 in parameters) {
          this.notBefore = pvutils__namespace.getParametersValue(parameters, NOT_BEFORE$1, _PrivateKeyUsagePeriod.defaultValues(NOT_BEFORE$1));
        }
        if (NOT_AFTER$1 in parameters) {
          this.notAfter = pvutils__namespace.getParametersValue(parameters, NOT_AFTER$1, _PrivateKeyUsagePeriod.defaultValues(NOT_AFTER$1));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case NOT_BEFORE$1:
            return /* @__PURE__ */ new Date();
          case NOT_AFTER$1:
            return /* @__PURE__ */ new Date();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Primitive({
              name: names.notBefore || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              }
            }),
            new asn1js__namespace.Primitive({
              name: names.notAfter || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              }
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1c);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PrivateKeyUsagePeriod.schema({
          names: {
            notBefore: NOT_BEFORE$1,
            notAfter: NOT_AFTER$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (NOT_BEFORE$1 in asn1.result) {
          const localNotBefore = new asn1js__namespace.GeneralizedTime();
          localNotBefore.fromBuffer(asn1.result.notBefore.valueBlock.valueHex);
          this.notBefore = localNotBefore.toDate();
        }
        if (NOT_AFTER$1 in asn1.result) {
          const localNotAfter = new asn1js__namespace.GeneralizedTime({ valueHex: asn1.result.notAfter.valueBlock.valueHex });
          localNotAfter.fromBuffer(asn1.result.notAfter.valueBlock.valueHex);
          this.notAfter = localNotAfter.toDate();
        }
      }
      toSchema() {
        const outputArray = [];
        if (NOT_BEFORE$1 in this) {
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            valueHex: new asn1js__namespace.GeneralizedTime({ valueDate: this.notBefore }).valueBlock.valueHexView
          }));
        }
        if (NOT_AFTER$1 in this) {
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            valueHex: new asn1js__namespace.GeneralizedTime({ valueDate: this.notAfter }).valueBlock.valueHexView
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {};
        if (this.notBefore) {
          res.notBefore = this.notBefore;
        }
        if (this.notAfter) {
          res.notAfter = this.notAfter;
        }
        return res;
      }
    };
    PrivateKeyUsagePeriod.CLASS_NAME = "PrivateKeyUsagePeriod";
    var ID = "id";
    var TYPE$2 = "type";
    var VALUES = "values";
    var QC_STATEMENT_CLEAR_PROPS = [
      ID,
      TYPE$2
    ];
    var QC_STATEMENTS_CLEAR_PROPS = [
      VALUES
    ];
    var QCStatement = class _QCStatement extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.id = pvutils__namespace.getParametersValue(parameters, ID, _QCStatement.defaultValues(ID));
        if (TYPE$2 in parameters) {
          this.type = pvutils__namespace.getParametersValue(parameters, TYPE$2, _QCStatement.defaultValues(TYPE$2));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ID:
            return EMPTY_STRING;
          case TYPE$2:
            return new asn1js__namespace.Null();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ID:
            return memberValue === EMPTY_STRING;
          case TYPE$2:
            return memberValue instanceof asn1js__namespace.Null;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.id || EMPTY_STRING }),
            new asn1js__namespace.Any({
              name: names.type || EMPTY_STRING,
              optional: true
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, QC_STATEMENT_CLEAR_PROPS);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _QCStatement.schema({
          names: {
            id: ID,
            type: TYPE$2
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.id = asn1.result.id.valueBlock.toString();
        if (TYPE$2 in asn1.result)
          this.type = asn1.result.type;
      }
      toSchema() {
        const value = [
          new asn1js__namespace.ObjectIdentifier({ value: this.id })
        ];
        if (TYPE$2 in this)
          value.push(this.type);
        return new asn1js__namespace.Sequence({
          value
        });
      }
      toJSON() {
        const object = {
          id: this.id
        };
        if (this.type) {
          object.type = this.type.toJSON();
        }
        return object;
      }
    };
    QCStatement.CLASS_NAME = "QCStatement";
    var QCStatements = class _QCStatements extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.values = pvutils__namespace.getParametersValue(parameters, VALUES, _QCStatements.defaultValues(VALUES));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VALUES:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VALUES:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.values || EMPTY_STRING,
              value: QCStatement.schema(names.value || {})
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, QC_STATEMENTS_CLEAR_PROPS);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _QCStatements.schema({
          names: {
            values: VALUES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.values = Array.from(asn1.result.values, (element) => new QCStatement({ schema: element }));
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.values, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          values: Array.from(this.values, (o) => o.toJSON())
        };
      }
    };
    QCStatements.CLASS_NAME = "QCStatements";
    var _a;
    var ECNamedCurves = class {
      static register(name, id, size) {
        this.namedCurves[name.toLowerCase()] = this.namedCurves[id] = { name, id, size };
      }
      static find(nameOrId) {
        return this.namedCurves[nameOrId.toLowerCase()] || null;
      }
    };
    _a = ECNamedCurves;
    ECNamedCurves.namedCurves = {};
    (() => {
      _a.register("P-256", "1.2.840.10045.3.1.7", 32);
      _a.register("P-384", "1.3.132.0.34", 48);
      _a.register("P-521", "1.3.132.0.35", 66);
      _a.register("brainpoolP256r1", "1.3.36.3.3.2.8.1.1.7", 32);
      _a.register("brainpoolP384r1", "1.3.36.3.3.2.8.1.1.11", 48);
      _a.register("brainpoolP512r1", "1.3.36.3.3.2.8.1.1.13", 64);
    })();
    var X = "x";
    var Y = "y";
    var NAMED_CURVE$1 = "namedCurve";
    var ECPublicKey = class _ECPublicKey extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.x = pvutils__namespace.getParametersValue(parameters, X, _ECPublicKey.defaultValues(X));
        this.y = pvutils__namespace.getParametersValue(parameters, Y, _ECPublicKey.defaultValues(Y));
        this.namedCurve = pvutils__namespace.getParametersValue(parameters, NAMED_CURVE$1, _ECPublicKey.defaultValues(NAMED_CURVE$1));
        if (parameters.json) {
          this.fromJSON(parameters.json);
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case X:
          case Y:
            return EMPTY_BUFFER;
          case NAMED_CURVE$1:
            return EMPTY_STRING;
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case X:
          case Y:
            return memberValue instanceof ArrayBuffer && pvutils__namespace.isEqualBuffer(memberValue, _ECPublicKey.defaultValues(memberName));
          case NAMED_CURVE$1:
            return typeof memberValue === "string" && memberValue === _ECPublicKey.defaultValues(memberName);
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema() {
        return new asn1js__namespace.RawData();
      }
      fromSchema(schema1) {
        const view = pvtsutils.BufferSourceConverter.toUint8Array(schema1);
        if (view[0] !== 4) {
          throw new Error("Object's schema was not verified against input data for ECPublicKey");
        }
        const namedCurve = ECNamedCurves.find(this.namedCurve);
        if (!namedCurve) {
          throw new Error(`Incorrect curve OID: ${this.namedCurve}`);
        }
        const coordinateLength = namedCurve.size;
        if (view.byteLength !== coordinateLength * 2 + 1) {
          throw new Error("Object's schema was not verified against input data for ECPublicKey");
        }
        this.namedCurve = namedCurve.name;
        this.x = view.slice(1, coordinateLength + 1).buffer;
        this.y = view.slice(1 + coordinateLength, coordinateLength * 2 + 1).buffer;
      }
      toSchema() {
        return new asn1js__namespace.RawData({
          data: pvutils__namespace.utilConcatBuf(new Uint8Array([4]).buffer, this.x, this.y)
        });
      }
      toJSON() {
        const namedCurve = ECNamedCurves.find(this.namedCurve);
        return {
          crv: namedCurve ? namedCurve.name : this.namedCurve,
          x: pvutils__namespace.toBase64(pvutils__namespace.arrayBufferToString(this.x), true, true, false),
          y: pvutils__namespace.toBase64(pvutils__namespace.arrayBufferToString(this.y), true, true, false)
        };
      }
      fromJSON(json) {
        ParameterError.assert("json", json, "crv", "x", "y");
        let coordinateLength = 0;
        const namedCurve = ECNamedCurves.find(json.crv);
        if (namedCurve) {
          this.namedCurve = namedCurve.id;
          coordinateLength = namedCurve.size;
        }
        const xConvertBuffer = pvutils__namespace.stringToArrayBuffer(pvutils__namespace.fromBase64(json.x, true));
        if (xConvertBuffer.byteLength < coordinateLength) {
          this.x = new ArrayBuffer(coordinateLength);
          const view = new Uint8Array(this.x);
          const convertBufferView = new Uint8Array(xConvertBuffer);
          view.set(convertBufferView, 1);
        } else {
          this.x = xConvertBuffer.slice(0, coordinateLength);
        }
        const yConvertBuffer = pvutils__namespace.stringToArrayBuffer(pvutils__namespace.fromBase64(json.y, true));
        if (yConvertBuffer.byteLength < coordinateLength) {
          this.y = new ArrayBuffer(coordinateLength);
          const view = new Uint8Array(this.y);
          const convertBufferView = new Uint8Array(yConvertBuffer);
          view.set(convertBufferView, 1);
        } else {
          this.y = yConvertBuffer.slice(0, coordinateLength);
        }
      }
    };
    ECPublicKey.CLASS_NAME = "ECPublicKey";
    var MODULUS$1 = "modulus";
    var PUBLIC_EXPONENT$1 = "publicExponent";
    var CLEAR_PROPS$1b = [MODULUS$1, PUBLIC_EXPONENT$1];
    var RSAPublicKey = class _RSAPublicKey extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.modulus = pvutils__namespace.getParametersValue(parameters, MODULUS$1, _RSAPublicKey.defaultValues(MODULUS$1));
        this.publicExponent = pvutils__namespace.getParametersValue(parameters, PUBLIC_EXPONENT$1, _RSAPublicKey.defaultValues(PUBLIC_EXPONENT$1));
        if (parameters.json) {
          this.fromJSON(parameters.json);
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case MODULUS$1:
            return new asn1js__namespace.Integer();
          case PUBLIC_EXPONENT$1:
            return new asn1js__namespace.Integer();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.modulus || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.publicExponent || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1b);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RSAPublicKey.schema({
          names: {
            modulus: MODULUS$1,
            publicExponent: PUBLIC_EXPONENT$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.modulus = asn1.result.modulus.convertFromDER(256);
        this.publicExponent = asn1.result.publicExponent;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.modulus.convertToDER(),
            this.publicExponent
          ]
        });
      }
      toJSON() {
        return {
          n: pvtsutils__namespace.Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),
          e: pvtsutils__namespace.Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView)
        };
      }
      fromJSON(json) {
        ParameterError.assert("json", json, "n", "e");
        const array = pvutils__namespace.stringToArrayBuffer(pvutils__namespace.fromBase64(json.n, true));
        this.modulus = new asn1js__namespace.Integer({ valueHex: array.slice(0, Math.pow(2, pvutils__namespace.nearestPowerOf2(array.byteLength))) });
        this.publicExponent = new asn1js__namespace.Integer({ valueHex: pvutils__namespace.stringToArrayBuffer(pvutils__namespace.fromBase64(json.e, true)).slice(0, 3) });
      }
    };
    RSAPublicKey.CLASS_NAME = "RSAPublicKey";
    var ALGORITHM$1 = "algorithm";
    var SUBJECT_PUBLIC_KEY = "subjectPublicKey";
    var CLEAR_PROPS$1a = [ALGORITHM$1, SUBJECT_PUBLIC_KEY];
    var PublicKeyInfo = class _PublicKeyInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.algorithm = pvutils__namespace.getParametersValue(parameters, ALGORITHM$1, _PublicKeyInfo.defaultValues(ALGORITHM$1));
        this.subjectPublicKey = pvutils__namespace.getParametersValue(parameters, SUBJECT_PUBLIC_KEY, _PublicKeyInfo.defaultValues(SUBJECT_PUBLIC_KEY));
        const parsedKey = pvutils__namespace.getParametersValue(parameters, "parsedKey", null);
        if (parsedKey) {
          this.parsedKey = parsedKey;
        }
        if (parameters.json) {
          this.fromJSON(parameters.json);
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      get parsedKey() {
        if (this._parsedKey === void 0) {
          switch (this.algorithm.algorithmId) {
            case "1.2.840.10045.2.1":
              if ("algorithmParams" in this.algorithm) {
                if (this.algorithm.algorithmParams.constructor.blockName() === asn1js__namespace.ObjectIdentifier.blockName()) {
                  try {
                    this._parsedKey = new ECPublicKey({
                      namedCurve: this.algorithm.algorithmParams.valueBlock.toString(),
                      schema: this.subjectPublicKey.valueBlock.valueHexView
                    });
                  } catch (ex) {
                  }
                }
              }
              break;
            case "1.2.840.113549.1.1.1":
              {
                const publicKeyASN1 = asn1js__namespace.fromBER(this.subjectPublicKey.valueBlock.valueHexView);
                if (publicKeyASN1.offset !== -1) {
                  try {
                    this._parsedKey = new RSAPublicKey({ schema: publicKeyASN1.result });
                  } catch (ex) {
                  }
                }
              }
              break;
          }
          this._parsedKey || (this._parsedKey = null);
        }
        return this._parsedKey || void 0;
      }
      set parsedKey(value) {
        this._parsedKey = value;
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ALGORITHM$1:
            return new AlgorithmIdentifier();
          case SUBJECT_PUBLIC_KEY:
            return new asn1js__namespace.BitString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            AlgorithmIdentifier.schema(names.algorithm || {}),
            new asn1js__namespace.BitString({ name: names.subjectPublicKey || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1a);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PublicKeyInfo.schema({
          names: {
            algorithm: {
              names: {
                blockName: ALGORITHM$1
              }
            },
            subjectPublicKey: SUBJECT_PUBLIC_KEY
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.algorithm = new AlgorithmIdentifier({ schema: asn1.result.algorithm });
        this.subjectPublicKey = asn1.result.subjectPublicKey;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.algorithm.toSchema(),
            this.subjectPublicKey
          ]
        });
      }
      toJSON() {
        if (!this.parsedKey) {
          return {
            algorithm: this.algorithm.toJSON(),
            subjectPublicKey: this.subjectPublicKey.toJSON()
          };
        }
        const jwk = {};
        switch (this.algorithm.algorithmId) {
          case "1.2.840.10045.2.1":
            jwk.kty = "EC";
            break;
          case "1.2.840.113549.1.1.1":
            jwk.kty = "RSA";
            break;
        }
        const publicKeyJWK = this.parsedKey.toJSON();
        Object.assign(jwk, publicKeyJWK);
        return jwk;
      }
      fromJSON(json) {
        if ("kty" in json) {
          switch (json.kty.toUpperCase()) {
            case "EC":
              this.parsedKey = new ECPublicKey({ json });
              this.algorithm = new AlgorithmIdentifier({
                algorithmId: "1.2.840.10045.2.1",
                algorithmParams: new asn1js__namespace.ObjectIdentifier({ value: this.parsedKey.namedCurve })
              });
              break;
            case "RSA":
              this.parsedKey = new RSAPublicKey({ json });
              this.algorithm = new AlgorithmIdentifier({
                algorithmId: "1.2.840.113549.1.1.1",
                algorithmParams: new asn1js__namespace.Null()
              });
              break;
            default:
              throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
          }
          this.subjectPublicKey = new asn1js__namespace.BitString({ valueHex: this.parsedKey.toSchema().toBER(false) });
        }
      }
      async importKey(publicKey, crypto2 = getCrypto(true)) {
        try {
          if (!publicKey) {
            throw new Error("Need to provide publicKey input parameter");
          }
          const exportedKey = await crypto2.exportKey("spki", publicKey);
          const asn1 = asn1js__namespace.fromBER(exportedKey);
          try {
            this.fromSchema(asn1.result);
          } catch (exception) {
            throw new Error("Error during initializing object from schema");
          }
        } catch (e) {
          const message3 = e instanceof Error ? e.message : `${e}`;
          throw new Error(`Error during exporting public key: ${message3}`);
        }
      }
    };
    PublicKeyInfo.CLASS_NAME = "PublicKeyInfo";
    var VERSION$l = "version";
    var PRIVATE_KEY$1 = "privateKey";
    var NAMED_CURVE = "namedCurve";
    var PUBLIC_KEY$1 = "publicKey";
    var CLEAR_PROPS$19 = [
      VERSION$l,
      PRIVATE_KEY$1,
      NAMED_CURVE,
      PUBLIC_KEY$1
    ];
    var ECPrivateKey = class _ECPrivateKey extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$l, _ECPrivateKey.defaultValues(VERSION$l));
        this.privateKey = pvutils__namespace.getParametersValue(parameters, PRIVATE_KEY$1, _ECPrivateKey.defaultValues(PRIVATE_KEY$1));
        if (NAMED_CURVE in parameters) {
          this.namedCurve = pvutils__namespace.getParametersValue(parameters, NAMED_CURVE, _ECPrivateKey.defaultValues(NAMED_CURVE));
        }
        if (PUBLIC_KEY$1 in parameters) {
          this.publicKey = pvutils__namespace.getParametersValue(parameters, PUBLIC_KEY$1, _ECPrivateKey.defaultValues(PUBLIC_KEY$1));
        }
        if (parameters.json) {
          this.fromJSON(parameters.json);
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$l:
            return 1;
          case PRIVATE_KEY$1:
            return new asn1js__namespace.OctetString();
          case NAMED_CURVE:
            return EMPTY_STRING;
          case PUBLIC_KEY$1:
            return new ECPublicKey();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$l:
            return memberValue === _ECPrivateKey.defaultValues(memberName);
          case PRIVATE_KEY$1:
            return memberValue.isEqual(_ECPrivateKey.defaultValues(memberName));
          case NAMED_CURVE:
            return memberValue === EMPTY_STRING;
          case PUBLIC_KEY$1:
            return ECPublicKey.compareWithDefault(NAMED_CURVE, memberValue.namedCurve) && ECPublicKey.compareWithDefault("x", memberValue.x) && ECPublicKey.compareWithDefault("y", memberValue.y);
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || EMPTY_STRING }),
            new asn1js__namespace.OctetString({ name: names.privateKey || EMPTY_STRING }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                new asn1js__namespace.ObjectIdentifier({ name: names.namedCurve || EMPTY_STRING })
              ]
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [
                new asn1js__namespace.BitString({ name: names.publicKey || EMPTY_STRING })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$19);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _ECPrivateKey.schema({
          names: {
            version: VERSION$l,
            privateKey: PRIVATE_KEY$1,
            namedCurve: NAMED_CURVE,
            publicKey: PUBLIC_KEY$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.privateKey = asn1.result.privateKey;
        if (NAMED_CURVE in asn1.result) {
          this.namedCurve = asn1.result.namedCurve.valueBlock.toString();
        }
        if (PUBLIC_KEY$1 in asn1.result) {
          const publicKeyData = { schema: asn1.result.publicKey.valueBlock.valueHex };
          if (NAMED_CURVE in this) {
            publicKeyData.namedCurve = this.namedCurve;
          }
          this.publicKey = new ECPublicKey(publicKeyData);
        }
      }
      toSchema() {
        const outputArray = [
          new asn1js__namespace.Integer({ value: this.version }),
          this.privateKey
        ];
        if (this.namedCurve) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [
              new asn1js__namespace.ObjectIdentifier({ value: this.namedCurve })
            ]
          }));
        }
        if (this.publicKey) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [
              new asn1js__namespace.BitString({ valueHex: this.publicKey.toSchema().toBER(false) })
            ]
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        if (!this.namedCurve || _ECPrivateKey.compareWithDefault(NAMED_CURVE, this.namedCurve)) {
          throw new Error('Not enough information for making JSON: absent "namedCurve" value');
        }
        const curve = ECNamedCurves.find(this.namedCurve);
        const privateKeyJSON = {
          crv: curve ? curve.name : this.namedCurve,
          d: pvtsutils__namespace.Convert.ToBase64Url(this.privateKey.valueBlock.valueHexView)
        };
        if (this.publicKey) {
          const publicKeyJSON = this.publicKey.toJSON();
          privateKeyJSON.x = publicKeyJSON.x;
          privateKeyJSON.y = publicKeyJSON.y;
        }
        return privateKeyJSON;
      }
      fromJSON(json) {
        ParameterError.assert("json", json, "crv", "d");
        let coordinateLength = 0;
        const curve = ECNamedCurves.find(json.crv);
        if (curve) {
          this.namedCurve = curve.id;
          coordinateLength = curve.size;
        }
        const convertBuffer = pvtsutils__namespace.Convert.FromBase64Url(json.d);
        if (convertBuffer.byteLength < coordinateLength) {
          const buffer = new ArrayBuffer(coordinateLength);
          const view = new Uint8Array(buffer);
          const convertBufferView = new Uint8Array(convertBuffer);
          view.set(convertBufferView, 1);
          this.privateKey = new asn1js__namespace.OctetString({ valueHex: buffer });
        } else {
          this.privateKey = new asn1js__namespace.OctetString({ valueHex: convertBuffer.slice(0, coordinateLength) });
        }
        if (json.x && json.y) {
          this.publicKey = new ECPublicKey({ json });
        }
      }
    };
    ECPrivateKey.CLASS_NAME = "ECPrivateKey";
    var PRIME = "prime";
    var EXPONENT = "exponent";
    var COEFFICIENT$1 = "coefficient";
    var CLEAR_PROPS$18 = [
      PRIME,
      EXPONENT,
      COEFFICIENT$1
    ];
    var OtherPrimeInfo = class _OtherPrimeInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.prime = pvutils__namespace.getParametersValue(parameters, PRIME, _OtherPrimeInfo.defaultValues(PRIME));
        this.exponent = pvutils__namespace.getParametersValue(parameters, EXPONENT, _OtherPrimeInfo.defaultValues(EXPONENT));
        this.coefficient = pvutils__namespace.getParametersValue(parameters, COEFFICIENT$1, _OtherPrimeInfo.defaultValues(COEFFICIENT$1));
        if (parameters.json) {
          this.fromJSON(parameters.json);
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case PRIME:
            return new asn1js__namespace.Integer();
          case EXPONENT:
            return new asn1js__namespace.Integer();
          case COEFFICIENT$1:
            return new asn1js__namespace.Integer();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.prime || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.exponent || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.coefficient || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$18);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _OtherPrimeInfo.schema({
          names: {
            prime: PRIME,
            exponent: EXPONENT,
            coefficient: COEFFICIENT$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.prime = asn1.result.prime.convertFromDER();
        this.exponent = asn1.result.exponent.convertFromDER();
        this.coefficient = asn1.result.coefficient.convertFromDER();
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.prime.convertToDER(),
            this.exponent.convertToDER(),
            this.coefficient.convertToDER()
          ]
        });
      }
      toJSON() {
        return {
          r: pvtsutils__namespace.Convert.ToBase64Url(this.prime.valueBlock.valueHexView),
          d: pvtsutils__namespace.Convert.ToBase64Url(this.exponent.valueBlock.valueHexView),
          t: pvtsutils__namespace.Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)
        };
      }
      fromJSON(json) {
        ParameterError.assert("json", json, "r", "d", "r");
        this.prime = new asn1js__namespace.Integer({ valueHex: pvtsutils__namespace.Convert.FromBase64Url(json.r) });
        this.exponent = new asn1js__namespace.Integer({ valueHex: pvtsutils__namespace.Convert.FromBase64Url(json.d) });
        this.coefficient = new asn1js__namespace.Integer({ valueHex: pvtsutils__namespace.Convert.FromBase64Url(json.t) });
      }
    };
    OtherPrimeInfo.CLASS_NAME = "OtherPrimeInfo";
    var VERSION$k = "version";
    var MODULUS = "modulus";
    var PUBLIC_EXPONENT = "publicExponent";
    var PRIVATE_EXPONENT = "privateExponent";
    var PRIME1 = "prime1";
    var PRIME2 = "prime2";
    var EXPONENT1 = "exponent1";
    var EXPONENT2 = "exponent2";
    var COEFFICIENT = "coefficient";
    var OTHER_PRIME_INFOS = "otherPrimeInfos";
    var CLEAR_PROPS$17 = [
      VERSION$k,
      MODULUS,
      PUBLIC_EXPONENT,
      PRIVATE_EXPONENT,
      PRIME1,
      PRIME2,
      EXPONENT1,
      EXPONENT2,
      COEFFICIENT,
      OTHER_PRIME_INFOS
    ];
    var RSAPrivateKey = class _RSAPrivateKey extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$k, _RSAPrivateKey.defaultValues(VERSION$k));
        this.modulus = pvutils__namespace.getParametersValue(parameters, MODULUS, _RSAPrivateKey.defaultValues(MODULUS));
        this.publicExponent = pvutils__namespace.getParametersValue(parameters, PUBLIC_EXPONENT, _RSAPrivateKey.defaultValues(PUBLIC_EXPONENT));
        this.privateExponent = pvutils__namespace.getParametersValue(parameters, PRIVATE_EXPONENT, _RSAPrivateKey.defaultValues(PRIVATE_EXPONENT));
        this.prime1 = pvutils__namespace.getParametersValue(parameters, PRIME1, _RSAPrivateKey.defaultValues(PRIME1));
        this.prime2 = pvutils__namespace.getParametersValue(parameters, PRIME2, _RSAPrivateKey.defaultValues(PRIME2));
        this.exponent1 = pvutils__namespace.getParametersValue(parameters, EXPONENT1, _RSAPrivateKey.defaultValues(EXPONENT1));
        this.exponent2 = pvutils__namespace.getParametersValue(parameters, EXPONENT2, _RSAPrivateKey.defaultValues(EXPONENT2));
        this.coefficient = pvutils__namespace.getParametersValue(parameters, COEFFICIENT, _RSAPrivateKey.defaultValues(COEFFICIENT));
        if (OTHER_PRIME_INFOS in parameters) {
          this.otherPrimeInfos = pvutils__namespace.getParametersValue(parameters, OTHER_PRIME_INFOS, _RSAPrivateKey.defaultValues(OTHER_PRIME_INFOS));
        }
        if (parameters.json) {
          this.fromJSON(parameters.json);
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$k:
            return 0;
          case MODULUS:
            return new asn1js__namespace.Integer();
          case PUBLIC_EXPONENT:
            return new asn1js__namespace.Integer();
          case PRIVATE_EXPONENT:
            return new asn1js__namespace.Integer();
          case PRIME1:
            return new asn1js__namespace.Integer();
          case PRIME2:
            return new asn1js__namespace.Integer();
          case EXPONENT1:
            return new asn1js__namespace.Integer();
          case EXPONENT2:
            return new asn1js__namespace.Integer();
          case COEFFICIENT:
            return new asn1js__namespace.Integer();
          case OTHER_PRIME_INFOS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.modulus || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.publicExponent || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.privateExponent || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.prime1 || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.prime2 || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.exponent1 || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.exponent2 || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.coefficient || EMPTY_STRING }),
            new asn1js__namespace.Sequence({
              optional: true,
              value: [
                new asn1js__namespace.Repeated({
                  name: names.otherPrimeInfosName || EMPTY_STRING,
                  value: OtherPrimeInfo.schema(names.otherPrimeInfo || {})
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$17);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RSAPrivateKey.schema({
          names: {
            version: VERSION$k,
            modulus: MODULUS,
            publicExponent: PUBLIC_EXPONENT,
            privateExponent: PRIVATE_EXPONENT,
            prime1: PRIME1,
            prime2: PRIME2,
            exponent1: EXPONENT1,
            exponent2: EXPONENT2,
            coefficient: COEFFICIENT,
            otherPrimeInfo: {
              names: {
                blockName: OTHER_PRIME_INFOS
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.modulus = asn1.result.modulus.convertFromDER(256);
        this.publicExponent = asn1.result.publicExponent;
        this.privateExponent = asn1.result.privateExponent.convertFromDER(256);
        this.prime1 = asn1.result.prime1.convertFromDER(128);
        this.prime2 = asn1.result.prime2.convertFromDER(128);
        this.exponent1 = asn1.result.exponent1.convertFromDER(128);
        this.exponent2 = asn1.result.exponent2.convertFromDER(128);
        this.coefficient = asn1.result.coefficient.convertFromDER(128);
        if (OTHER_PRIME_INFOS in asn1.result)
          this.otherPrimeInfos = Array.from(asn1.result.otherPrimeInfos, (element) => new OtherPrimeInfo({ schema: element }));
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
        outputArray.push(this.modulus.convertToDER());
        outputArray.push(this.publicExponent);
        outputArray.push(this.privateExponent.convertToDER());
        outputArray.push(this.prime1.convertToDER());
        outputArray.push(this.prime2.convertToDER());
        outputArray.push(this.exponent1.convertToDER());
        outputArray.push(this.exponent2.convertToDER());
        outputArray.push(this.coefficient.convertToDER());
        if (this.otherPrimeInfos) {
          outputArray.push(new asn1js__namespace.Sequence({
            value: Array.from(this.otherPrimeInfos, (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const jwk = {
          n: pvtsutils__namespace.Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),
          e: pvtsutils__namespace.Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView),
          d: pvtsutils__namespace.Convert.ToBase64Url(this.privateExponent.valueBlock.valueHexView),
          p: pvtsutils__namespace.Convert.ToBase64Url(this.prime1.valueBlock.valueHexView),
          q: pvtsutils__namespace.Convert.ToBase64Url(this.prime2.valueBlock.valueHexView),
          dp: pvtsutils__namespace.Convert.ToBase64Url(this.exponent1.valueBlock.valueHexView),
          dq: pvtsutils__namespace.Convert.ToBase64Url(this.exponent2.valueBlock.valueHexView),
          qi: pvtsutils__namespace.Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)
        };
        if (this.otherPrimeInfos) {
          jwk.oth = Array.from(this.otherPrimeInfos, (o) => o.toJSON());
        }
        return jwk;
      }
      fromJSON(json) {
        ParameterError.assert("json", json, "n", "e", "d", "p", "q", "dp", "dq", "qi");
        this.modulus = new asn1js__namespace.Integer({ valueHex: pvtsutils__namespace.Convert.FromBase64Url(json.n) });
        this.publicExponent = new asn1js__namespace.Integer({ valueHex: pvtsutils__namespace.Convert.FromBase64Url(json.e) });
        this.privateExponent = new asn1js__namespace.Integer({ valueHex: pvtsutils__namespace.Convert.FromBase64Url(json.d) });
        this.prime1 = new asn1js__namespace.Integer({ valueHex: pvtsutils__namespace.Convert.FromBase64Url(json.p) });
        this.prime2 = new asn1js__namespace.Integer({ valueHex: pvtsutils__namespace.Convert.FromBase64Url(json.q) });
        this.exponent1 = new asn1js__namespace.Integer({ valueHex: pvtsutils__namespace.Convert.FromBase64Url(json.dp) });
        this.exponent2 = new asn1js__namespace.Integer({ valueHex: pvtsutils__namespace.Convert.FromBase64Url(json.dq) });
        this.coefficient = new asn1js__namespace.Integer({ valueHex: pvtsutils__namespace.Convert.FromBase64Url(json.qi) });
        if (json.oth) {
          this.otherPrimeInfos = Array.from(json.oth, (element) => new OtherPrimeInfo({ json: element }));
        }
      }
    };
    RSAPrivateKey.CLASS_NAME = "RSAPrivateKey";
    var VERSION$j = "version";
    var PRIVATE_KEY_ALGORITHM = "privateKeyAlgorithm";
    var PRIVATE_KEY = "privateKey";
    var ATTRIBUTES$5 = "attributes";
    var PARSED_KEY = "parsedKey";
    var CLEAR_PROPS$16 = [
      VERSION$j,
      PRIVATE_KEY_ALGORITHM,
      PRIVATE_KEY,
      ATTRIBUTES$5
    ];
    var PrivateKeyInfo = class _PrivateKeyInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$j, _PrivateKeyInfo.defaultValues(VERSION$j));
        this.privateKeyAlgorithm = pvutils__namespace.getParametersValue(parameters, PRIVATE_KEY_ALGORITHM, _PrivateKeyInfo.defaultValues(PRIVATE_KEY_ALGORITHM));
        this.privateKey = pvutils__namespace.getParametersValue(parameters, PRIVATE_KEY, _PrivateKeyInfo.defaultValues(PRIVATE_KEY));
        if (ATTRIBUTES$5 in parameters) {
          this.attributes = pvutils__namespace.getParametersValue(parameters, ATTRIBUTES$5, _PrivateKeyInfo.defaultValues(ATTRIBUTES$5));
        }
        if (PARSED_KEY in parameters) {
          this.parsedKey = pvutils__namespace.getParametersValue(parameters, PARSED_KEY, _PrivateKeyInfo.defaultValues(PARSED_KEY));
        }
        if (parameters.json) {
          this.fromJSON(parameters.json);
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$j:
            return 0;
          case PRIVATE_KEY_ALGORITHM:
            return new AlgorithmIdentifier();
          case PRIVATE_KEY:
            return new asn1js__namespace.OctetString();
          case ATTRIBUTES$5:
            return [];
          case PARSED_KEY:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || EMPTY_STRING }),
            AlgorithmIdentifier.schema(names.privateKeyAlgorithm || {}),
            new asn1js__namespace.OctetString({ name: names.privateKey || EMPTY_STRING }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                new asn1js__namespace.Repeated({
                  name: names.attributes || EMPTY_STRING,
                  value: Attribute.schema()
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$16);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PrivateKeyInfo.schema({
          names: {
            version: VERSION$j,
            privateKeyAlgorithm: {
              names: {
                blockName: PRIVATE_KEY_ALGORITHM
              }
            },
            privateKey: PRIVATE_KEY,
            attributes: ATTRIBUTES$5
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.privateKeyAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.privateKeyAlgorithm });
        this.privateKey = asn1.result.privateKey;
        if (ATTRIBUTES$5 in asn1.result)
          this.attributes = Array.from(asn1.result.attributes, (element) => new Attribute({ schema: element }));
        switch (this.privateKeyAlgorithm.algorithmId) {
          case "1.2.840.113549.1.1.1":
            {
              const privateKeyASN1 = asn1js__namespace.fromBER(this.privateKey.valueBlock.valueHexView);
              if (privateKeyASN1.offset !== -1)
                this.parsedKey = new RSAPrivateKey({ schema: privateKeyASN1.result });
            }
            break;
          case "1.2.840.10045.2.1":
            if ("algorithmParams" in this.privateKeyAlgorithm) {
              if (this.privateKeyAlgorithm.algorithmParams instanceof asn1js__namespace.ObjectIdentifier) {
                const privateKeyASN1 = asn1js__namespace.fromBER(this.privateKey.valueBlock.valueHexView);
                if (privateKeyASN1.offset !== -1) {
                  this.parsedKey = new ECPrivateKey({
                    namedCurve: this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),
                    schema: privateKeyASN1.result
                  });
                }
              }
            }
            break;
        }
      }
      toSchema() {
        const outputArray = [
          new asn1js__namespace.Integer({ value: this.version }),
          this.privateKeyAlgorithm.toSchema(),
          this.privateKey
        ];
        if (this.attributes) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: Array.from(this.attributes, (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        if (!this.parsedKey) {
          const object = {
            version: this.version,
            privateKeyAlgorithm: this.privateKeyAlgorithm.toJSON(),
            privateKey: this.privateKey.toJSON()
          };
          if (this.attributes) {
            object.attributes = Array.from(this.attributes, (o) => o.toJSON());
          }
          return object;
        }
        const jwk = {};
        switch (this.privateKeyAlgorithm.algorithmId) {
          case "1.2.840.10045.2.1":
            jwk.kty = "EC";
            break;
          case "1.2.840.113549.1.1.1":
            jwk.kty = "RSA";
            break;
        }
        const publicKeyJWK = this.parsedKey.toJSON();
        Object.assign(jwk, publicKeyJWK);
        return jwk;
      }
      fromJSON(json) {
        if ("kty" in json) {
          switch (json.kty.toUpperCase()) {
            case "EC":
              this.parsedKey = new ECPrivateKey({ json });
              this.privateKeyAlgorithm = new AlgorithmIdentifier({
                algorithmId: "1.2.840.10045.2.1",
                algorithmParams: new asn1js__namespace.ObjectIdentifier({ value: this.parsedKey.namedCurve })
              });
              break;
            case "RSA":
              this.parsedKey = new RSAPrivateKey({ json });
              this.privateKeyAlgorithm = new AlgorithmIdentifier({
                algorithmId: "1.2.840.113549.1.1.1",
                algorithmParams: new asn1js__namespace.Null()
              });
              break;
            default:
              throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
          }
          this.privateKey = new asn1js__namespace.OctetString({ valueHex: this.parsedKey.toSchema().toBER(false) });
        }
      }
    };
    PrivateKeyInfo.CLASS_NAME = "PrivateKeyInfo";
    var CONTENT_TYPE$1 = "contentType";
    var CONTENT_ENCRYPTION_ALGORITHM = "contentEncryptionAlgorithm";
    var ENCRYPTED_CONTENT = "encryptedContent";
    var CLEAR_PROPS$15 = [
      CONTENT_TYPE$1,
      CONTENT_ENCRYPTION_ALGORITHM,
      ENCRYPTED_CONTENT
    ];
    var PIECE_SIZE = 1024;
    var EncryptedContentInfo = class _EncryptedContentInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.contentType = pvutils__namespace.getParametersValue(parameters, CONTENT_TYPE$1, _EncryptedContentInfo.defaultValues(CONTENT_TYPE$1));
        this.contentEncryptionAlgorithm = pvutils__namespace.getParametersValue(parameters, CONTENT_ENCRYPTION_ALGORITHM, _EncryptedContentInfo.defaultValues(CONTENT_ENCRYPTION_ALGORITHM));
        if (ENCRYPTED_CONTENT in parameters && parameters.encryptedContent) {
          this.encryptedContent = parameters.encryptedContent;
          if (this.encryptedContent.idBlock.tagClass === 1 && this.encryptedContent.idBlock.tagNumber === 4) {
            if (this.encryptedContent.idBlock.isConstructed === false && !parameters.disableSplit) {
              const constrString = new asn1js__namespace.OctetString({
                idBlock: { isConstructed: true },
                isConstructed: true
              });
              let offset = 0;
              const valueHex = this.encryptedContent.valueBlock.valueHexView.slice().buffer;
              let length = valueHex.byteLength;
              while (length > 0) {
                const pieceView = new Uint8Array(valueHex, offset, offset + PIECE_SIZE > valueHex.byteLength ? valueHex.byteLength - offset : PIECE_SIZE);
                const _array = new ArrayBuffer(pieceView.length);
                const _view = new Uint8Array(_array);
                for (let i = 0; i < _view.length; i++)
                  _view[i] = pieceView[i];
                constrString.valueBlock.value.push(new asn1js__namespace.OctetString({ valueHex: _array }));
                length -= pieceView.length;
                offset += pieceView.length;
              }
              this.encryptedContent = constrString;
            }
          }
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case CONTENT_TYPE$1:
            return EMPTY_STRING;
          case CONTENT_ENCRYPTION_ALGORITHM:
            return new AlgorithmIdentifier();
          case ENCRYPTED_CONTENT:
            return new asn1js__namespace.OctetString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CONTENT_TYPE$1:
            return memberValue === EMPTY_STRING;
          case CONTENT_ENCRYPTION_ALGORITHM:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case ENCRYPTED_CONTENT:
            return memberValue.isEqual(_EncryptedContentInfo.defaultValues(ENCRYPTED_CONTENT));
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.contentType || EMPTY_STRING }),
            AlgorithmIdentifier.schema(names.contentEncryptionAlgorithm || {}),
            new asn1js__namespace.Choice({
              value: [
                new asn1js__namespace.Constructed({
                  name: names.encryptedContent || EMPTY_STRING,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  },
                  value: [
                    new asn1js__namespace.Repeated({
                      value: new asn1js__namespace.OctetString()
                    })
                  ]
                }),
                new asn1js__namespace.Primitive({
                  name: names.encryptedContent || EMPTY_STRING,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  }
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$15);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _EncryptedContentInfo.schema({
          names: {
            contentType: CONTENT_TYPE$1,
            contentEncryptionAlgorithm: {
              names: {
                blockName: CONTENT_ENCRYPTION_ALGORITHM
              }
            },
            encryptedContent: ENCRYPTED_CONTENT
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.contentType = asn1.result.contentType.valueBlock.toString();
        this.contentEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.contentEncryptionAlgorithm });
        if (ENCRYPTED_CONTENT in asn1.result) {
          this.encryptedContent = asn1.result.encryptedContent;
          this.encryptedContent.idBlock.tagClass = 1;
          this.encryptedContent.idBlock.tagNumber = 4;
        }
      }
      toSchema() {
        const sequenceLengthBlock = {
          isIndefiniteForm: false
        };
        const outputArray = [];
        outputArray.push(new asn1js__namespace.ObjectIdentifier({ value: this.contentType }));
        outputArray.push(this.contentEncryptionAlgorithm.toSchema());
        if (this.encryptedContent) {
          sequenceLengthBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
          const encryptedValue = this.encryptedContent;
          encryptedValue.idBlock.tagClass = 3;
          encryptedValue.idBlock.tagNumber = 0;
          encryptedValue.lenBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;
          outputArray.push(encryptedValue);
        }
        return new asn1js__namespace.Sequence({
          lenBlock: sequenceLengthBlock,
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          contentType: this.contentType,
          contentEncryptionAlgorithm: this.contentEncryptionAlgorithm.toJSON()
        };
        if (this.encryptedContent) {
          res.encryptedContent = this.encryptedContent.toJSON();
        }
        return res;
      }
      getEncryptedContent() {
        if (!this.encryptedContent) {
          throw new Error("Parameter 'encryptedContent' is undefined");
        }
        return asn1js__namespace.OctetString.prototype.getValue.call(this.encryptedContent);
      }
    };
    EncryptedContentInfo.CLASS_NAME = "EncryptedContentInfo";
    var HASH_ALGORITHM$4 = "hashAlgorithm";
    var MASK_GEN_ALGORITHM$1 = "maskGenAlgorithm";
    var SALT_LENGTH = "saltLength";
    var TRAILER_FIELD = "trailerField";
    var CLEAR_PROPS$14 = [
      HASH_ALGORITHM$4,
      MASK_GEN_ALGORITHM$1,
      SALT_LENGTH,
      TRAILER_FIELD
    ];
    var RSASSAPSSParams = class _RSASSAPSSParams extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.hashAlgorithm = pvutils__namespace.getParametersValue(parameters, HASH_ALGORITHM$4, _RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4));
        this.maskGenAlgorithm = pvutils__namespace.getParametersValue(parameters, MASK_GEN_ALGORITHM$1, _RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1));
        this.saltLength = pvutils__namespace.getParametersValue(parameters, SALT_LENGTH, _RSASSAPSSParams.defaultValues(SALT_LENGTH));
        this.trailerField = pvutils__namespace.getParametersValue(parameters, TRAILER_FIELD, _RSASSAPSSParams.defaultValues(TRAILER_FIELD));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case HASH_ALGORITHM$4:
            return new AlgorithmIdentifier({
              algorithmId: "1.3.14.3.2.26",
              algorithmParams: new asn1js__namespace.Null()
            });
          case MASK_GEN_ALGORITHM$1:
            return new AlgorithmIdentifier({
              algorithmId: "1.2.840.113549.1.1.8",
              algorithmParams: new AlgorithmIdentifier({
                algorithmId: "1.3.14.3.2.26",
                algorithmParams: new asn1js__namespace.Null()
              }).toSchema()
            });
          case SALT_LENGTH:
            return 20;
          case TRAILER_FIELD:
            return 1;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              optional: true,
              value: [AlgorithmIdentifier.schema(names.hashAlgorithm || {})]
            }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              optional: true,
              value: [AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})]
            }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              optional: true,
              value: [new asn1js__namespace.Integer({ name: names.saltLength || EMPTY_STRING })]
            }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 3
              },
              optional: true,
              value: [new asn1js__namespace.Integer({ name: names.trailerField || EMPTY_STRING })]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$14);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RSASSAPSSParams.schema({
          names: {
            hashAlgorithm: {
              names: {
                blockName: HASH_ALGORITHM$4
              }
            },
            maskGenAlgorithm: {
              names: {
                blockName: MASK_GEN_ALGORITHM$1
              }
            },
            saltLength: SALT_LENGTH,
            trailerField: TRAILER_FIELD
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (HASH_ALGORITHM$4 in asn1.result)
          this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
        if (MASK_GEN_ALGORITHM$1 in asn1.result)
          this.maskGenAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.maskGenAlgorithm });
        if (SALT_LENGTH in asn1.result)
          this.saltLength = asn1.result.saltLength.valueBlock.valueDec;
        if (TRAILER_FIELD in asn1.result)
          this.trailerField = asn1.result.trailerField.valueBlock.valueDec;
      }
      toSchema() {
        const outputArray = [];
        if (!this.hashAlgorithm.isEqual(_RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4))) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.hashAlgorithm.toSchema()]
          }));
        }
        if (!this.maskGenAlgorithm.isEqual(_RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1))) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [this.maskGenAlgorithm.toSchema()]
          }));
        }
        if (this.saltLength !== _RSASSAPSSParams.defaultValues(SALT_LENGTH)) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: [new asn1js__namespace.Integer({ value: this.saltLength })]
          }));
        }
        if (this.trailerField !== _RSASSAPSSParams.defaultValues(TRAILER_FIELD)) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            value: [new asn1js__namespace.Integer({ value: this.trailerField })]
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {};
        if (!this.hashAlgorithm.isEqual(_RSASSAPSSParams.defaultValues(HASH_ALGORITHM$4))) {
          res.hashAlgorithm = this.hashAlgorithm.toJSON();
        }
        if (!this.maskGenAlgorithm.isEqual(_RSASSAPSSParams.defaultValues(MASK_GEN_ALGORITHM$1))) {
          res.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();
        }
        if (this.saltLength !== _RSASSAPSSParams.defaultValues(SALT_LENGTH)) {
          res.saltLength = this.saltLength;
        }
        if (this.trailerField !== _RSASSAPSSParams.defaultValues(TRAILER_FIELD)) {
          res.trailerField = this.trailerField;
        }
        return res;
      }
    };
    RSASSAPSSParams.CLASS_NAME = "RSASSAPSSParams";
    var SALT = "salt";
    var ITERATION_COUNT = "iterationCount";
    var KEY_LENGTH = "keyLength";
    var PRF = "prf";
    var CLEAR_PROPS$13 = [
      SALT,
      ITERATION_COUNT,
      KEY_LENGTH,
      PRF
    ];
    var PBKDF2Params = class _PBKDF2Params extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.salt = pvutils__namespace.getParametersValue(parameters, SALT, _PBKDF2Params.defaultValues(SALT));
        this.iterationCount = pvutils__namespace.getParametersValue(parameters, ITERATION_COUNT, _PBKDF2Params.defaultValues(ITERATION_COUNT));
        if (KEY_LENGTH in parameters) {
          this.keyLength = pvutils__namespace.getParametersValue(parameters, KEY_LENGTH, _PBKDF2Params.defaultValues(KEY_LENGTH));
        }
        if (PRF in parameters) {
          this.prf = pvutils__namespace.getParametersValue(parameters, PRF, _PBKDF2Params.defaultValues(PRF));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case SALT:
            return {};
          case ITERATION_COUNT:
            return -1;
          case KEY_LENGTH:
            return 0;
          case PRF:
            return new AlgorithmIdentifier({
              algorithmId: "1.3.14.3.2.26",
              algorithmParams: new asn1js__namespace.Null()
            });
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Choice({
              value: [
                new asn1js__namespace.OctetString({ name: names.saltPrimitive || EMPTY_STRING }),
                AlgorithmIdentifier.schema(names.saltConstructed || {})
              ]
            }),
            new asn1js__namespace.Integer({ name: names.iterationCount || EMPTY_STRING }),
            new asn1js__namespace.Integer({
              name: names.keyLength || EMPTY_STRING,
              optional: true
            }),
            AlgorithmIdentifier.schema(names.prf || {
              names: {
                optional: true
              }
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$13);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PBKDF2Params.schema({
          names: {
            saltPrimitive: SALT,
            saltConstructed: {
              names: {
                blockName: SALT
              }
            },
            iterationCount: ITERATION_COUNT,
            keyLength: KEY_LENGTH,
            prf: {
              names: {
                blockName: PRF,
                optional: true
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.salt = asn1.result.salt;
        this.iterationCount = asn1.result.iterationCount.valueBlock.valueDec;
        if (KEY_LENGTH in asn1.result)
          this.keyLength = asn1.result.keyLength.valueBlock.valueDec;
        if (PRF in asn1.result)
          this.prf = new AlgorithmIdentifier({ schema: asn1.result.prf });
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(this.salt);
        outputArray.push(new asn1js__namespace.Integer({ value: this.iterationCount }));
        if (KEY_LENGTH in this) {
          if (_PBKDF2Params.defaultValues(KEY_LENGTH) !== this.keyLength)
            outputArray.push(new asn1js__namespace.Integer({ value: this.keyLength }));
        }
        if (this.prf) {
          if (_PBKDF2Params.defaultValues(PRF).isEqual(this.prf) === false)
            outputArray.push(this.prf.toSchema());
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          salt: this.salt.toJSON(),
          iterationCount: this.iterationCount
        };
        if (KEY_LENGTH in this) {
          if (_PBKDF2Params.defaultValues(KEY_LENGTH) !== this.keyLength)
            res.keyLength = this.keyLength;
        }
        if (this.prf) {
          if (_PBKDF2Params.defaultValues(PRF).isEqual(this.prf) === false)
            res.prf = this.prf.toJSON();
        }
        return res;
      }
    };
    PBKDF2Params.CLASS_NAME = "PBKDF2Params";
    var KEY_DERIVATION_FUNC = "keyDerivationFunc";
    var ENCRYPTION_SCHEME = "encryptionScheme";
    var CLEAR_PROPS$12 = [
      KEY_DERIVATION_FUNC,
      ENCRYPTION_SCHEME
    ];
    var PBES2Params = class _PBES2Params extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.keyDerivationFunc = pvutils__namespace.getParametersValue(parameters, KEY_DERIVATION_FUNC, _PBES2Params.defaultValues(KEY_DERIVATION_FUNC));
        this.encryptionScheme = pvutils__namespace.getParametersValue(parameters, ENCRYPTION_SCHEME, _PBES2Params.defaultValues(ENCRYPTION_SCHEME));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case KEY_DERIVATION_FUNC:
            return new AlgorithmIdentifier();
          case ENCRYPTION_SCHEME:
            return new AlgorithmIdentifier();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            AlgorithmIdentifier.schema(names.keyDerivationFunc || {}),
            AlgorithmIdentifier.schema(names.encryptionScheme || {})
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$12);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PBES2Params.schema({
          names: {
            keyDerivationFunc: {
              names: {
                blockName: KEY_DERIVATION_FUNC
              }
            },
            encryptionScheme: {
              names: {
                blockName: ENCRYPTION_SCHEME
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.keyDerivationFunc = new AlgorithmIdentifier({ schema: asn1.result.keyDerivationFunc });
        this.encryptionScheme = new AlgorithmIdentifier({ schema: asn1.result.encryptionScheme });
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.keyDerivationFunc.toSchema(),
            this.encryptionScheme.toSchema()
          ]
        });
      }
      toJSON() {
        return {
          keyDerivationFunc: this.keyDerivationFunc.toJSON(),
          encryptionScheme: this.encryptionScheme.toJSON()
        };
      }
    };
    PBES2Params.CLASS_NAME = "PBES2Params";
    var AbstractCryptoEngine = class {
      constructor(parameters) {
        this.crypto = parameters.crypto;
        this.subtle = "webkitSubtle" in parameters.crypto ? parameters.crypto.webkitSubtle : parameters.crypto.subtle;
        this.name = pvutils__namespace.getParametersValue(parameters, "name", EMPTY_STRING);
      }
      async encrypt(...args) {
        return this.subtle.encrypt(...args);
      }
      async decrypt(...args) {
        return this.subtle.decrypt(...args);
      }
      sign(...args) {
        return this.subtle.sign(...args);
      }
      async verify(...args) {
        return this.subtle.verify(...args);
      }
      async digest(...args) {
        return this.subtle.digest(...args);
      }
      async generateKey(...args) {
        return this.subtle.generateKey(...args);
      }
      async deriveKey(...args) {
        return this.subtle.deriveKey(...args);
      }
      async deriveBits(...args) {
        return this.subtle.deriveBits(...args);
      }
      async wrapKey(...args) {
        return this.subtle.wrapKey(...args);
      }
      async unwrapKey(...args) {
        return this.subtle.unwrapKey(...args);
      }
      exportKey(...args) {
        return this.subtle.exportKey(...args);
      }
      importKey(...args) {
        return this.subtle.importKey(...args);
      }
      getRandomValues(array) {
        return this.crypto.getRandomValues(array);
      }
    };
    async function makePKCS12B2Key(cryptoEngine, hashAlgorithm, keyLength, password, salt, iterationCount) {
      let u;
      let v;
      const result = [];
      switch (hashAlgorithm.toUpperCase()) {
        case "SHA-1":
          u = 20;
          v = 64;
          break;
        case "SHA-256":
          u = 32;
          v = 64;
          break;
        case "SHA-384":
          u = 48;
          v = 128;
          break;
        case "SHA-512":
          u = 64;
          v = 128;
          break;
        default:
          throw new Error("Unsupported hashing algorithm");
      }
      const passwordViewInitial = new Uint8Array(password);
      const passwordTransformed = new ArrayBuffer(password.byteLength * 2 + 2);
      const passwordTransformedView = new Uint8Array(passwordTransformed);
      for (let i = 0; i < passwordViewInitial.length; i++) {
        passwordTransformedView[i * 2] = 0;
        passwordTransformedView[i * 2 + 1] = passwordViewInitial[i];
      }
      passwordTransformedView[passwordTransformedView.length - 2] = 0;
      passwordTransformedView[passwordTransformedView.length - 1] = 0;
      password = passwordTransformed.slice(0);
      const D = new ArrayBuffer(v);
      const dView = new Uint8Array(D);
      for (let i = 0; i < D.byteLength; i++)
        dView[i] = 3;
      const saltLength = salt.byteLength;
      const sLen = v * Math.ceil(saltLength / v);
      const S = new ArrayBuffer(sLen);
      const sView = new Uint8Array(S);
      const saltView = new Uint8Array(salt);
      for (let i = 0; i < sLen; i++)
        sView[i] = saltView[i % saltLength];
      const passwordLength = password.byteLength;
      const pLen = v * Math.ceil(passwordLength / v);
      const P = new ArrayBuffer(pLen);
      const pView = new Uint8Array(P);
      const passwordView = new Uint8Array(password);
      for (let i = 0; i < pLen; i++)
        pView[i] = passwordView[i % passwordLength];
      const sPlusPLength = S.byteLength + P.byteLength;
      let I = new ArrayBuffer(sPlusPLength);
      let iView = new Uint8Array(I);
      iView.set(sView);
      iView.set(pView, sView.length);
      const c = Math.ceil((keyLength >> 3) / u);
      let internalSequence = Promise.resolve(I);
      for (let i = 0; i <= c; i++) {
        internalSequence = internalSequence.then((_I) => {
          const dAndI = new ArrayBuffer(D.byteLength + _I.byteLength);
          const dAndIView = new Uint8Array(dAndI);
          dAndIView.set(dView);
          dAndIView.set(iView, dView.length);
          return dAndI;
        });
        for (let j = 0; j < iterationCount; j++)
          internalSequence = internalSequence.then((roundBuffer) => cryptoEngine.digest({ name: hashAlgorithm }, new Uint8Array(roundBuffer)));
        internalSequence = internalSequence.then((roundBuffer) => {
          const B = new ArrayBuffer(v);
          const bView = new Uint8Array(B);
          for (let j = 0; j < B.byteLength; j++)
            bView[j] = roundBuffer[j % roundBuffer.byteLength];
          const k = Math.ceil(saltLength / v) + Math.ceil(passwordLength / v);
          const iRound = [];
          let sliceStart = 0;
          let sliceLength = v;
          for (let j = 0; j < k; j++) {
            const chunk = Array.from(new Uint8Array(I.slice(sliceStart, sliceStart + sliceLength)));
            sliceStart += v;
            if (sliceStart + v > I.byteLength)
              sliceLength = I.byteLength - sliceStart;
            let x = 511;
            for (let l = B.byteLength - 1; l >= 0; l--) {
              x >>= 8;
              x += bView[l] + chunk[l];
              chunk[l] = x & 255;
            }
            iRound.push(...chunk);
          }
          I = new ArrayBuffer(iRound.length);
          iView = new Uint8Array(I);
          iView.set(iRound);
          result.push(...new Uint8Array(roundBuffer));
          return I;
        });
      }
      internalSequence = internalSequence.then(() => {
        const resultBuffer = new ArrayBuffer(keyLength >> 3);
        const resultView = new Uint8Array(resultBuffer);
        resultView.set(new Uint8Array(result).slice(0, keyLength >> 3));
        return resultBuffer;
      });
      return internalSequence;
    }
    function prepareAlgorithm(data) {
      const res = typeof data === "string" ? { name: data } : data;
      if ("hash" in res) {
        return {
          ...res,
          hash: prepareAlgorithm(res.hash)
        };
      }
      return res;
    }
    var CryptoEngine2 = class extends AbstractCryptoEngine {
      async importKey(format, keyData, algorithm, extractable, keyUsages) {
        var _a2, _b, _c, _d, _e, _f;
        let jwk = {};
        const alg = prepareAlgorithm(algorithm);
        switch (format.toLowerCase()) {
          case "raw":
            return this.subtle.importKey("raw", keyData, algorithm, extractable, keyUsages);
          case "spki":
            {
              const asn1 = asn1js__namespace.fromBER(pvtsutils__namespace.BufferSourceConverter.toArrayBuffer(keyData));
              AsnError.assert(asn1, "keyData");
              const publicKeyInfo = new PublicKeyInfo();
              try {
                publicKeyInfo.fromSchema(asn1.result);
              } catch {
                throw new ArgumentError("Incorrect keyData");
              }
              switch (alg.name.toUpperCase()) {
                case "RSA-PSS": {
                  if (!alg.hash) {
                    throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
                  }
                  switch (alg.hash.name.toUpperCase()) {
                    case "SHA-1":
                      jwk.alg = "PS1";
                      break;
                    case "SHA-256":
                      jwk.alg = "PS256";
                      break;
                    case "SHA-384":
                      jwk.alg = "PS384";
                      break;
                    case "SHA-512":
                      jwk.alg = "PS512";
                      break;
                    default:
                      throw new Error(`Incorrect hash algorithm: ${alg.hash.name.toUpperCase()}`);
                  }
                }
                case "RSASSA-PKCS1-V1_5":
                  {
                    keyUsages = ["verify"];
                    jwk.kty = "RSA";
                    jwk.ext = extractable;
                    jwk.key_ops = keyUsages;
                    if (publicKeyInfo.algorithm.algorithmId !== "1.2.840.113549.1.1.1")
                      throw new Error(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
                    if (!jwk.alg) {
                      if (!alg.hash) {
                        throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
                      }
                      switch (alg.hash.name.toUpperCase()) {
                        case "SHA-1":
                          jwk.alg = "RS1";
                          break;
                        case "SHA-256":
                          jwk.alg = "RS256";
                          break;
                        case "SHA-384":
                          jwk.alg = "RS384";
                          break;
                        case "SHA-512":
                          jwk.alg = "RS512";
                          break;
                        default:
                          throw new Error(`Incorrect hash algorithm: ${alg.hash.name.toUpperCase()}`);
                      }
                    }
                    const publicKeyJSON = publicKeyInfo.toJSON();
                    Object.assign(jwk, publicKeyJSON);
                  }
                  break;
                case "ECDSA":
                  keyUsages = ["verify"];
                case "ECDH":
                  {
                    jwk = {
                      kty: "EC",
                      ext: extractable,
                      key_ops: keyUsages
                    };
                    if (publicKeyInfo.algorithm.algorithmId !== "1.2.840.10045.2.1") {
                      throw new Error(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
                    }
                    const publicKeyJSON = publicKeyInfo.toJSON();
                    Object.assign(jwk, publicKeyJSON);
                  }
                  break;
                case "RSA-OAEP":
                  {
                    jwk.kty = "RSA";
                    jwk.ext = extractable;
                    jwk.key_ops = keyUsages;
                    if (this.name.toLowerCase() === "safari")
                      jwk.alg = "RSA-OAEP";
                    else {
                      if (!alg.hash) {
                        throw new ParameterError("hash", "algorithm.hash", "Incorrect hash algorithm: Hash algorithm is missed");
                      }
                      switch (alg.hash.name.toUpperCase()) {
                        case "SHA-1":
                          jwk.alg = "RSA-OAEP";
                          break;
                        case "SHA-256":
                          jwk.alg = "RSA-OAEP-256";
                          break;
                        case "SHA-384":
                          jwk.alg = "RSA-OAEP-384";
                          break;
                        case "SHA-512":
                          jwk.alg = "RSA-OAEP-512";
                          break;
                        default:
                          throw new Error(`Incorrect hash algorithm: ${alg.hash.name.toUpperCase()}`);
                      }
                    }
                    const publicKeyJSON = publicKeyInfo.toJSON();
                    Object.assign(jwk, publicKeyJSON);
                  }
                  break;
                case "RSAES-PKCS1-V1_5":
                  {
                    jwk.kty = "RSA";
                    jwk.ext = extractable;
                    jwk.key_ops = keyUsages;
                    jwk.alg = "PS1";
                    const publicKeyJSON = publicKeyInfo.toJSON();
                    Object.assign(jwk, publicKeyJSON);
                  }
                  break;
                default:
                  throw new Error(`Incorrect algorithm name: ${alg.name.toUpperCase()}`);
              }
            }
            break;
          case "pkcs8":
            {
              const privateKeyInfo = new PrivateKeyInfo();
              const asn1 = asn1js__namespace.fromBER(pvtsutils__namespace.BufferSourceConverter.toArrayBuffer(keyData));
              AsnError.assert(asn1, "keyData");
              try {
                privateKeyInfo.fromSchema(asn1.result);
              } catch (ex) {
                throw new Error("Incorrect keyData");
              }
              if (!privateKeyInfo.parsedKey)
                throw new Error("Incorrect keyData");
              switch (alg.name.toUpperCase()) {
                case "RSA-PSS": {
                  switch ((_a2 = alg.hash) === null || _a2 === void 0 ? void 0 : _a2.name.toUpperCase()) {
                    case "SHA-1":
                      jwk.alg = "PS1";
                      break;
                    case "SHA-256":
                      jwk.alg = "PS256";
                      break;
                    case "SHA-384":
                      jwk.alg = "PS384";
                      break;
                    case "SHA-512":
                      jwk.alg = "PS512";
                      break;
                    default:
                      throw new Error(`Incorrect hash algorithm: ${(_b = alg.hash) === null || _b === void 0 ? void 0 : _b.name.toUpperCase()}`);
                  }
                }
                case "RSASSA-PKCS1-V1_5":
                  {
                    keyUsages = ["sign"];
                    jwk.kty = "RSA";
                    jwk.ext = extractable;
                    jwk.key_ops = keyUsages;
                    if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.113549.1.1.1")
                      throw new Error(`Incorrect private key algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
                    if ("alg" in jwk === false) {
                      switch ((_c = alg.hash) === null || _c === void 0 ? void 0 : _c.name.toUpperCase()) {
                        case "SHA-1":
                          jwk.alg = "RS1";
                          break;
                        case "SHA-256":
                          jwk.alg = "RS256";
                          break;
                        case "SHA-384":
                          jwk.alg = "RS384";
                          break;
                        case "SHA-512":
                          jwk.alg = "RS512";
                          break;
                        default:
                          throw new Error(`Incorrect hash algorithm: ${(_d = alg.hash) === null || _d === void 0 ? void 0 : _d.name.toUpperCase()}`);
                      }
                    }
                    const privateKeyJSON = privateKeyInfo.toJSON();
                    Object.assign(jwk, privateKeyJSON);
                  }
                  break;
                case "ECDSA":
                  keyUsages = ["sign"];
                case "ECDH":
                  {
                    jwk = {
                      kty: "EC",
                      ext: extractable,
                      key_ops: keyUsages
                    };
                    if (privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.10045.2.1")
                      throw new Error(`Incorrect algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
                    const privateKeyJSON = privateKeyInfo.toJSON();
                    Object.assign(jwk, privateKeyJSON);
                  }
                  break;
                case "RSA-OAEP":
                  {
                    jwk.kty = "RSA";
                    jwk.ext = extractable;
                    jwk.key_ops = keyUsages;
                    if (this.name.toLowerCase() === "safari")
                      jwk.alg = "RSA-OAEP";
                    else {
                      switch ((_e = alg.hash) === null || _e === void 0 ? void 0 : _e.name.toUpperCase()) {
                        case "SHA-1":
                          jwk.alg = "RSA-OAEP";
                          break;
                        case "SHA-256":
                          jwk.alg = "RSA-OAEP-256";
                          break;
                        case "SHA-384":
                          jwk.alg = "RSA-OAEP-384";
                          break;
                        case "SHA-512":
                          jwk.alg = "RSA-OAEP-512";
                          break;
                        default:
                          throw new Error(`Incorrect hash algorithm: ${(_f = alg.hash) === null || _f === void 0 ? void 0 : _f.name.toUpperCase()}`);
                      }
                    }
                    const privateKeyJSON = privateKeyInfo.toJSON();
                    Object.assign(jwk, privateKeyJSON);
                  }
                  break;
                case "RSAES-PKCS1-V1_5":
                  {
                    keyUsages = ["decrypt"];
                    jwk.kty = "RSA";
                    jwk.ext = extractable;
                    jwk.key_ops = keyUsages;
                    jwk.alg = "PS1";
                    const privateKeyJSON = privateKeyInfo.toJSON();
                    Object.assign(jwk, privateKeyJSON);
                  }
                  break;
                default:
                  throw new Error(`Incorrect algorithm name: ${alg.name.toUpperCase()}`);
              }
            }
            break;
          case "jwk":
            jwk = keyData;
            break;
          default:
            throw new Error(`Incorrect format: ${format}`);
        }
        if (this.name.toLowerCase() === "safari") {
          try {
            return this.subtle.importKey("jwk", pvutils__namespace.stringToArrayBuffer(JSON.stringify(jwk)), algorithm, extractable, keyUsages);
          } catch {
            return this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages);
          }
        }
        return this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages);
      }
      async exportKey(format, key) {
        let jwk = await this.subtle.exportKey("jwk", key);
        if (this.name.toLowerCase() === "safari") {
          if (jwk instanceof ArrayBuffer) {
            jwk = JSON.parse(pvutils__namespace.arrayBufferToString(jwk));
          }
        }
        switch (format.toLowerCase()) {
          case "raw":
            return this.subtle.exportKey("raw", key);
          case "spki": {
            const publicKeyInfo = new PublicKeyInfo();
            try {
              publicKeyInfo.fromJSON(jwk);
            } catch (ex) {
              throw new Error("Incorrect key data");
            }
            return publicKeyInfo.toSchema().toBER(false);
          }
          case "pkcs8": {
            const privateKeyInfo = new PrivateKeyInfo();
            try {
              privateKeyInfo.fromJSON(jwk);
            } catch (ex) {
              throw new Error("Incorrect key data");
            }
            return privateKeyInfo.toSchema().toBER(false);
          }
          case "jwk":
            return jwk;
          default:
            throw new Error(`Incorrect format: ${format}`);
        }
      }
      async convert(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages) {
        if (inputFormat.toLowerCase() === outputFormat.toLowerCase()) {
          return keyData;
        }
        const key = await this.importKey(inputFormat, keyData, algorithm, extractable, keyUsages);
        return this.exportKey(outputFormat, key);
      }
      getAlgorithmByOID(oid, safety = false, target2) {
        switch (oid) {
          case "1.2.840.113549.1.1.1":
            return {
              name: "RSAES-PKCS1-v1_5"
            };
          case "1.2.840.113549.1.1.5":
            return {
              name: "RSASSA-PKCS1-v1_5",
              hash: {
                name: "SHA-1"
              }
            };
          case "1.2.840.113549.1.1.11":
            return {
              name: "RSASSA-PKCS1-v1_5",
              hash: {
                name: "SHA-256"
              }
            };
          case "1.2.840.113549.1.1.12":
            return {
              name: "RSASSA-PKCS1-v1_5",
              hash: {
                name: "SHA-384"
              }
            };
          case "1.2.840.113549.1.1.13":
            return {
              name: "RSASSA-PKCS1-v1_5",
              hash: {
                name: "SHA-512"
              }
            };
          case "1.2.840.113549.1.1.10":
            return {
              name: "RSA-PSS"
            };
          case "1.2.840.113549.1.1.7":
            return {
              name: "RSA-OAEP"
            };
          case "1.2.840.10045.2.1":
          case "1.2.840.10045.4.1":
            return {
              name: "ECDSA",
              hash: {
                name: "SHA-1"
              }
            };
          case "1.2.840.10045.4.3.2":
            return {
              name: "ECDSA",
              hash: {
                name: "SHA-256"
              }
            };
          case "1.2.840.10045.4.3.3":
            return {
              name: "ECDSA",
              hash: {
                name: "SHA-384"
              }
            };
          case "1.2.840.10045.4.3.4":
            return {
              name: "ECDSA",
              hash: {
                name: "SHA-512"
              }
            };
          case "1.3.133.16.840.63.0.2":
            return {
              name: "ECDH",
              kdf: "SHA-1"
            };
          case "1.3.132.1.11.1":
            return {
              name: "ECDH",
              kdf: "SHA-256"
            };
          case "1.3.132.1.11.2":
            return {
              name: "ECDH",
              kdf: "SHA-384"
            };
          case "1.3.132.1.11.3":
            return {
              name: "ECDH",
              kdf: "SHA-512"
            };
          case "2.16.840.1.101.3.4.1.2":
            return {
              name: "AES-CBC",
              length: 128
            };
          case "2.16.840.1.101.3.4.1.22":
            return {
              name: "AES-CBC",
              length: 192
            };
          case "2.16.840.1.101.3.4.1.42":
            return {
              name: "AES-CBC",
              length: 256
            };
          case "2.16.840.1.101.3.4.1.6":
            return {
              name: "AES-GCM",
              length: 128
            };
          case "2.16.840.1.101.3.4.1.26":
            return {
              name: "AES-GCM",
              length: 192
            };
          case "2.16.840.1.101.3.4.1.46":
            return {
              name: "AES-GCM",
              length: 256
            };
          case "2.16.840.1.101.3.4.1.4":
            return {
              name: "AES-CFB",
              length: 128
            };
          case "2.16.840.1.101.3.4.1.24":
            return {
              name: "AES-CFB",
              length: 192
            };
          case "2.16.840.1.101.3.4.1.44":
            return {
              name: "AES-CFB",
              length: 256
            };
          case "2.16.840.1.101.3.4.1.5":
            return {
              name: "AES-KW",
              length: 128
            };
          case "2.16.840.1.101.3.4.1.25":
            return {
              name: "AES-KW",
              length: 192
            };
          case "2.16.840.1.101.3.4.1.45":
            return {
              name: "AES-KW",
              length: 256
            };
          case "1.2.840.113549.2.7":
            return {
              name: "HMAC",
              hash: {
                name: "SHA-1"
              }
            };
          case "1.2.840.113549.2.9":
            return {
              name: "HMAC",
              hash: {
                name: "SHA-256"
              }
            };
          case "1.2.840.113549.2.10":
            return {
              name: "HMAC",
              hash: {
                name: "SHA-384"
              }
            };
          case "1.2.840.113549.2.11":
            return {
              name: "HMAC",
              hash: {
                name: "SHA-512"
              }
            };
          case "1.2.840.113549.1.9.16.3.5":
            return {
              name: "DH"
            };
          case "1.3.14.3.2.26":
            return {
              name: "SHA-1"
            };
          case "2.16.840.1.101.3.4.2.1":
            return {
              name: "SHA-256"
            };
          case "2.16.840.1.101.3.4.2.2":
            return {
              name: "SHA-384"
            };
          case "2.16.840.1.101.3.4.2.3":
            return {
              name: "SHA-512"
            };
          case "1.2.840.113549.1.5.12":
            return {
              name: "PBKDF2"
            };
          case "1.2.840.10045.3.1.7":
            return {
              name: "P-256"
            };
          case "1.3.132.0.34":
            return {
              name: "P-384"
            };
          case "1.3.132.0.35":
            return {
              name: "P-521"
            };
        }
        if (safety) {
          throw new Error(`Unsupported algorithm identifier ${target2 ? `for ${target2} ` : EMPTY_STRING}: ${oid}`);
        }
        return {};
      }
      getOIDByAlgorithm(algorithm, safety = false, target2) {
        let result = EMPTY_STRING;
        switch (algorithm.name.toUpperCase()) {
          case "RSAES-PKCS1-V1_5":
            result = "1.2.840.113549.1.1.1";
            break;
          case "RSASSA-PKCS1-V1_5":
            switch (algorithm.hash.name.toUpperCase()) {
              case "SHA-1":
                result = "1.2.840.113549.1.1.5";
                break;
              case "SHA-256":
                result = "1.2.840.113549.1.1.11";
                break;
              case "SHA-384":
                result = "1.2.840.113549.1.1.12";
                break;
              case "SHA-512":
                result = "1.2.840.113549.1.1.13";
                break;
            }
            break;
          case "RSA-PSS":
            result = "1.2.840.113549.1.1.10";
            break;
          case "RSA-OAEP":
            result = "1.2.840.113549.1.1.7";
            break;
          case "ECDSA":
            switch (algorithm.hash.name.toUpperCase()) {
              case "SHA-1":
                result = "1.2.840.10045.4.1";
                break;
              case "SHA-256":
                result = "1.2.840.10045.4.3.2";
                break;
              case "SHA-384":
                result = "1.2.840.10045.4.3.3";
                break;
              case "SHA-512":
                result = "1.2.840.10045.4.3.4";
                break;
            }
            break;
          case "ECDH":
            switch (algorithm.kdf.toUpperCase()) {
              case "SHA-1":
                result = "1.3.133.16.840.63.0.2";
                break;
              case "SHA-256":
                result = "1.3.132.1.11.1";
                break;
              case "SHA-384":
                result = "1.3.132.1.11.2";
                break;
              case "SHA-512":
                result = "1.3.132.1.11.3";
                break;
            }
            break;
          case "AES-CTR":
            break;
          case "AES-CBC":
            switch (algorithm.length) {
              case 128:
                result = "2.16.840.1.101.3.4.1.2";
                break;
              case 192:
                result = "2.16.840.1.101.3.4.1.22";
                break;
              case 256:
                result = "2.16.840.1.101.3.4.1.42";
                break;
            }
            break;
          case "AES-CMAC":
            break;
          case "AES-GCM":
            switch (algorithm.length) {
              case 128:
                result = "2.16.840.1.101.3.4.1.6";
                break;
              case 192:
                result = "2.16.840.1.101.3.4.1.26";
                break;
              case 256:
                result = "2.16.840.1.101.3.4.1.46";
                break;
            }
            break;
          case "AES-CFB":
            switch (algorithm.length) {
              case 128:
                result = "2.16.840.1.101.3.4.1.4";
                break;
              case 192:
                result = "2.16.840.1.101.3.4.1.24";
                break;
              case 256:
                result = "2.16.840.1.101.3.4.1.44";
                break;
            }
            break;
          case "AES-KW":
            switch (algorithm.length) {
              case 128:
                result = "2.16.840.1.101.3.4.1.5";
                break;
              case 192:
                result = "2.16.840.1.101.3.4.1.25";
                break;
              case 256:
                result = "2.16.840.1.101.3.4.1.45";
                break;
            }
            break;
          case "HMAC":
            switch (algorithm.hash.name.toUpperCase()) {
              case "SHA-1":
                result = "1.2.840.113549.2.7";
                break;
              case "SHA-256":
                result = "1.2.840.113549.2.9";
                break;
              case "SHA-384":
                result = "1.2.840.113549.2.10";
                break;
              case "SHA-512":
                result = "1.2.840.113549.2.11";
                break;
            }
            break;
          case "DH":
            result = "1.2.840.113549.1.9.16.3.5";
            break;
          case "SHA-1":
            result = "1.3.14.3.2.26";
            break;
          case "SHA-256":
            result = "2.16.840.1.101.3.4.2.1";
            break;
          case "SHA-384":
            result = "2.16.840.1.101.3.4.2.2";
            break;
          case "SHA-512":
            result = "2.16.840.1.101.3.4.2.3";
            break;
          case "CONCAT":
            break;
          case "HKDF":
            break;
          case "PBKDF2":
            result = "1.2.840.113549.1.5.12";
            break;
          case "P-256":
            result = "1.2.840.10045.3.1.7";
            break;
          case "P-384":
            result = "1.3.132.0.34";
            break;
          case "P-521":
            result = "1.3.132.0.35";
            break;
        }
        if (!result && safety) {
          throw new Error(`Unsupported algorithm ${target2 ? `for ${target2} ` : EMPTY_STRING}: ${algorithm.name}`);
        }
        return result;
      }
      getAlgorithmParameters(algorithmName, operation) {
        let result = {
          algorithm: {},
          usages: []
        };
        switch (algorithmName.toUpperCase()) {
          case "RSAES-PKCS1-V1_5":
          case "RSASSA-PKCS1-V1_5":
            switch (operation.toLowerCase()) {
              case "generatekey":
                result = {
                  algorithm: {
                    name: "RSASSA-PKCS1-v1_5",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["sign", "verify"]
                };
                break;
              case "verify":
              case "sign":
              case "importkey":
                result = {
                  algorithm: {
                    name: "RSASSA-PKCS1-v1_5",
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["verify"]
                };
                break;
              case "exportkey":
              default:
                return {
                  algorithm: {
                    name: "RSASSA-PKCS1-v1_5"
                  },
                  usages: []
                };
            }
            break;
          case "RSA-PSS":
            switch (operation.toLowerCase()) {
              case "sign":
              case "verify":
                result = {
                  algorithm: {
                    name: "RSA-PSS",
                    hash: {
                      name: "SHA-1"
                    },
                    saltLength: 20
                  },
                  usages: ["sign", "verify"]
                };
                break;
              case "generatekey":
                result = {
                  algorithm: {
                    name: "RSA-PSS",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: {
                      name: "SHA-1"
                    }
                  },
                  usages: ["sign", "verify"]
                };
                break;
              case "importkey":
                result = {
                  algorithm: {
                    name: "RSA-PSS",
                    hash: {
                      name: "SHA-1"
                    }
                  },
                  usages: ["verify"]
                };
                break;
              case "exportkey":
              default:
                return {
                  algorithm: {
                    name: "RSA-PSS"
                  },
                  usages: []
                };
            }
            break;
          case "RSA-OAEP":
            switch (operation.toLowerCase()) {
              case "encrypt":
              case "decrypt":
                result = {
                  algorithm: {
                    name: "RSA-OAEP"
                  },
                  usages: ["encrypt", "decrypt"]
                };
                break;
              case "generatekey":
                result = {
                  algorithm: {
                    name: "RSA-OAEP",
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              case "importkey":
                result = {
                  algorithm: {
                    name: "RSA-OAEP",
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["encrypt"]
                };
                break;
              case "exportkey":
              default:
                return {
                  algorithm: {
                    name: "RSA-OAEP"
                  },
                  usages: []
                };
            }
            break;
          case "ECDSA":
            switch (operation.toLowerCase()) {
              case "generatekey":
                result = {
                  algorithm: {
                    name: "ECDSA",
                    namedCurve: "P-256"
                  },
                  usages: ["sign", "verify"]
                };
                break;
              case "importkey":
                result = {
                  algorithm: {
                    name: "ECDSA",
                    namedCurve: "P-256"
                  },
                  usages: ["verify"]
                };
                break;
              case "verify":
              case "sign":
                result = {
                  algorithm: {
                    name: "ECDSA",
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["sign"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "ECDSA"
                  },
                  usages: []
                };
            }
            break;
          case "ECDH":
            switch (operation.toLowerCase()) {
              case "exportkey":
              case "importkey":
              case "generatekey":
                result = {
                  algorithm: {
                    name: "ECDH",
                    namedCurve: "P-256"
                  },
                  usages: ["deriveKey", "deriveBits"]
                };
                break;
              case "derivekey":
              case "derivebits":
                result = {
                  algorithm: {
                    name: "ECDH",
                    namedCurve: "P-256",
                    public: []
                  },
                  usages: ["encrypt", "decrypt"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "ECDH"
                  },
                  usages: []
                };
            }
            break;
          case "AES-CTR":
            switch (operation.toLowerCase()) {
              case "importkey":
              case "exportkey":
              case "generatekey":
                result = {
                  algorithm: {
                    name: "AES-CTR",
                    length: 256
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              case "decrypt":
              case "encrypt":
                result = {
                  algorithm: {
                    name: "AES-CTR",
                    counter: new Uint8Array(16),
                    length: 10
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "AES-CTR"
                  },
                  usages: []
                };
            }
            break;
          case "AES-CBC":
            switch (operation.toLowerCase()) {
              case "importkey":
              case "exportkey":
              case "generatekey":
                result = {
                  algorithm: {
                    name: "AES-CBC",
                    length: 256
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              case "decrypt":
              case "encrypt":
                result = {
                  algorithm: {
                    name: "AES-CBC",
                    iv: this.getRandomValues(new Uint8Array(16))
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "AES-CBC"
                  },
                  usages: []
                };
            }
            break;
          case "AES-GCM":
            switch (operation.toLowerCase()) {
              case "importkey":
              case "exportkey":
              case "generatekey":
                result = {
                  algorithm: {
                    name: "AES-GCM",
                    length: 256
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              case "decrypt":
              case "encrypt":
                result = {
                  algorithm: {
                    name: "AES-GCM",
                    iv: this.getRandomValues(new Uint8Array(16))
                  },
                  usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "AES-GCM"
                  },
                  usages: []
                };
            }
            break;
          case "AES-KW":
            switch (operation.toLowerCase()) {
              case "importkey":
              case "exportkey":
              case "generatekey":
              case "wrapkey":
              case "unwrapkey":
                result = {
                  algorithm: {
                    name: "AES-KW",
                    length: 256
                  },
                  usages: ["wrapKey", "unwrapKey"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "AES-KW"
                  },
                  usages: []
                };
            }
            break;
          case "HMAC":
            switch (operation.toLowerCase()) {
              case "sign":
              case "verify":
                result = {
                  algorithm: {
                    name: "HMAC"
                  },
                  usages: ["sign", "verify"]
                };
                break;
              case "importkey":
              case "exportkey":
              case "generatekey":
                result = {
                  algorithm: {
                    name: "HMAC",
                    length: 32,
                    hash: {
                      name: "SHA-256"
                    }
                  },
                  usages: ["sign", "verify"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "HMAC"
                  },
                  usages: []
                };
            }
            break;
          case "HKDF":
            switch (operation.toLowerCase()) {
              case "derivekey":
                result = {
                  algorithm: {
                    name: "HKDF",
                    hash: "SHA-256",
                    salt: new Uint8Array([]),
                    info: new Uint8Array([])
                  },
                  usages: ["encrypt", "decrypt"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "HKDF"
                  },
                  usages: []
                };
            }
            break;
          case "PBKDF2":
            switch (operation.toLowerCase()) {
              case "derivekey":
                result = {
                  algorithm: {
                    name: "PBKDF2",
                    hash: { name: "SHA-256" },
                    salt: new Uint8Array([]),
                    iterations: 1e4
                  },
                  usages: ["encrypt", "decrypt"]
                };
                break;
              default:
                return {
                  algorithm: {
                    name: "PBKDF2"
                  },
                  usages: []
                };
            }
            break;
        }
        return result;
      }
      getHashAlgorithm(signatureAlgorithm) {
        let result = EMPTY_STRING;
        switch (signatureAlgorithm.algorithmId) {
          case "1.2.840.10045.4.1":
          case "1.2.840.113549.1.1.5":
            result = "SHA-1";
            break;
          case "1.2.840.10045.4.3.2":
          case "1.2.840.113549.1.1.11":
            result = "SHA-256";
            break;
          case "1.2.840.10045.4.3.3":
          case "1.2.840.113549.1.1.12":
            result = "SHA-384";
            break;
          case "1.2.840.10045.4.3.4":
          case "1.2.840.113549.1.1.13":
            result = "SHA-512";
            break;
          case "1.2.840.113549.1.1.10":
            {
              try {
                const params = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });
                if (params.hashAlgorithm) {
                  const algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);
                  if ("name" in algorithm) {
                    result = algorithm.name;
                  } else {
                    return EMPTY_STRING;
                  }
                } else
                  result = "SHA-1";
              } catch {
              }
            }
            break;
        }
        return result;
      }
      async encryptEncryptedContentInfo(parameters) {
        ParameterError.assert(parameters, "password", "contentEncryptionAlgorithm", "hmacHashAlgorithm", "iterationCount", "contentToEncrypt", "contentToEncrypt", "contentType");
        const contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm, true, "contentEncryptionAlgorithm");
        const pbkdf2OID = this.getOIDByAlgorithm({
          name: "PBKDF2"
        }, true, "PBKDF2");
        const hmacOID = this.getOIDByAlgorithm({
          name: "HMAC",
          hash: {
            name: parameters.hmacHashAlgorithm
          }
        }, true, "hmacHashAlgorithm");
        const ivBuffer = new ArrayBuffer(16);
        const ivView = new Uint8Array(ivBuffer);
        this.getRandomValues(ivView);
        const saltBuffer = new ArrayBuffer(64);
        const saltView = new Uint8Array(saltBuffer);
        this.getRandomValues(saltView);
        const contentView = new Uint8Array(parameters.contentToEncrypt);
        const pbkdf2Params = new PBKDF2Params({
          salt: new asn1js__namespace.OctetString({ valueHex: saltBuffer }),
          iterationCount: parameters.iterationCount,
          prf: new AlgorithmIdentifier({
            algorithmId: hmacOID,
            algorithmParams: new asn1js__namespace.Null()
          })
        });
        const passwordView = new Uint8Array(parameters.password);
        const pbkdfKey = await this.importKey("raw", passwordView, "PBKDF2", false, ["deriveKey"]);
        const derivedKey = await this.deriveKey({
          name: "PBKDF2",
          hash: {
            name: parameters.hmacHashAlgorithm
          },
          salt: saltView,
          iterations: parameters.iterationCount
        }, pbkdfKey, parameters.contentEncryptionAlgorithm, false, ["encrypt"]);
        const encryptedData = await this.encrypt({
          name: parameters.contentEncryptionAlgorithm.name,
          iv: ivView
        }, derivedKey, contentView);
        const pbes2Parameters = new PBES2Params({
          keyDerivationFunc: new AlgorithmIdentifier({
            algorithmId: pbkdf2OID,
            algorithmParams: pbkdf2Params.toSchema()
          }),
          encryptionScheme: new AlgorithmIdentifier({
            algorithmId: contentEncryptionOID,
            algorithmParams: new asn1js__namespace.OctetString({ valueHex: ivBuffer })
          })
        });
        return new EncryptedContentInfo({
          contentType: parameters.contentType,
          contentEncryptionAlgorithm: new AlgorithmIdentifier({
            algorithmId: "1.2.840.113549.1.5.13",
            algorithmParams: pbes2Parameters.toSchema()
          }),
          encryptedContent: new asn1js__namespace.OctetString({ valueHex: encryptedData })
        });
      }
      async decryptEncryptedContentInfo(parameters) {
        ParameterError.assert(parameters, "password", "encryptedContentInfo");
        if (parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== "1.2.840.113549.1.5.13")
          throw new Error(`Unknown "contentEncryptionAlgorithm": ${parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
        let pbes2Parameters;
        try {
          pbes2Parameters = new PBES2Params({ schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams });
        } catch (ex) {
          throw new Error('Incorrectly encoded "pbes2Parameters"');
        }
        let pbkdf2Params;
        try {
          pbkdf2Params = new PBKDF2Params({ schema: pbes2Parameters.keyDerivationFunc.algorithmParams });
        } catch (ex) {
          throw new Error('Incorrectly encoded "pbkdf2Params"');
        }
        const contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId, true);
        const ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;
        const ivView = new Uint8Array(ivBuffer);
        const saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;
        const saltView = new Uint8Array(saltBuffer);
        const iterationCount = pbkdf2Params.iterationCount;
        let hmacHashAlgorithm = "SHA-1";
        if (pbkdf2Params.prf) {
          const algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true);
          hmacHashAlgorithm = algorithm.hash.name;
        }
        const pbkdfKey = await this.importKey("raw", parameters.password, "PBKDF2", false, ["deriveKey"]);
        const result = await this.deriveKey({
          name: "PBKDF2",
          hash: {
            name: hmacHashAlgorithm
          },
          salt: saltView,
          iterations: iterationCount
        }, pbkdfKey, contentEncryptionAlgorithm, false, ["decrypt"]);
        const dataBuffer = parameters.encryptedContentInfo.getEncryptedContent();
        return this.decrypt({
          name: contentEncryptionAlgorithm.name,
          iv: ivView
        }, result, dataBuffer);
      }
      async stampDataWithPassword(parameters) {
        if (parameters instanceof Object === false)
          throw new Error('Parameters must have type "Object"');
        ParameterError.assert(parameters, "password", "hashAlgorithm", "iterationCount", "salt", "contentToStamp");
        let length;
        switch (parameters.hashAlgorithm.toLowerCase()) {
          case "sha-1":
            length = 160;
            break;
          case "sha-256":
            length = 256;
            break;
          case "sha-384":
            length = 384;
            break;
          case "sha-512":
            length = 512;
            break;
          default:
            throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
        }
        const hmacAlgorithm = {
          name: "HMAC",
          length,
          hash: {
            name: parameters.hashAlgorithm
          }
        };
        const pkcsKey = await makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount);
        const hmacKey = await this.importKey("raw", new Uint8Array(pkcsKey), hmacAlgorithm, false, ["sign"]);
        return this.sign(hmacAlgorithm, hmacKey, new Uint8Array(parameters.contentToStamp));
      }
      async verifyDataStampedWithPassword(parameters) {
        ParameterError.assert(parameters, "password", "hashAlgorithm", "salt", "iterationCount", "contentToVerify", "signatureToVerify");
        let length = 0;
        switch (parameters.hashAlgorithm.toLowerCase()) {
          case "sha-1":
            length = 160;
            break;
          case "sha-256":
            length = 256;
            break;
          case "sha-384":
            length = 384;
            break;
          case "sha-512":
            length = 512;
            break;
          default:
            throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
        }
        const hmacAlgorithm = {
          name: "HMAC",
          length,
          hash: {
            name: parameters.hashAlgorithm
          }
        };
        const pkcsKey = await makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount);
        const hmacKey = await this.importKey("raw", new Uint8Array(pkcsKey), hmacAlgorithm, false, ["verify"]);
        return this.verify(hmacAlgorithm, hmacKey, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify));
      }
      async getSignatureParameters(privateKey, hashAlgorithm = "SHA-1") {
        this.getOIDByAlgorithm({ name: hashAlgorithm }, true, "hashAlgorithm");
        const signatureAlgorithm = new AlgorithmIdentifier();
        const parameters = this.getAlgorithmParameters(privateKey.algorithm.name, "sign");
        if (!Object.keys(parameters.algorithm).length) {
          throw new Error("Parameter 'algorithm' is empty");
        }
        const algorithm = parameters.algorithm;
        algorithm.hash.name = hashAlgorithm;
        switch (privateKey.algorithm.name.toUpperCase()) {
          case "RSASSA-PKCS1-V1_5":
          case "ECDSA":
            signatureAlgorithm.algorithmId = this.getOIDByAlgorithm(algorithm, true);
            break;
          case "RSA-PSS":
            {
              switch (hashAlgorithm.toUpperCase()) {
                case "SHA-256":
                  algorithm.saltLength = 32;
                  break;
                case "SHA-384":
                  algorithm.saltLength = 48;
                  break;
                case "SHA-512":
                  algorithm.saltLength = 64;
                  break;
              }
              const paramsObject = {};
              if (hashAlgorithm.toUpperCase() !== "SHA-1") {
                const hashAlgorithmOID = this.getOIDByAlgorithm({ name: hashAlgorithm }, true, "hashAlgorithm");
                paramsObject.hashAlgorithm = new AlgorithmIdentifier({
                  algorithmId: hashAlgorithmOID,
                  algorithmParams: new asn1js__namespace.Null()
                });
                paramsObject.maskGenAlgorithm = new AlgorithmIdentifier({
                  algorithmId: "1.2.840.113549.1.1.8",
                  algorithmParams: paramsObject.hashAlgorithm.toSchema()
                });
              }
              if (algorithm.saltLength !== 20)
                paramsObject.saltLength = algorithm.saltLength;
              const pssParameters = new RSASSAPSSParams(paramsObject);
              signatureAlgorithm.algorithmId = "1.2.840.113549.1.1.10";
              signatureAlgorithm.algorithmParams = pssParameters.toSchema();
            }
            break;
          default:
            throw new Error(`Unsupported signature algorithm: ${privateKey.algorithm.name}`);
        }
        return {
          signatureAlgorithm,
          parameters
        };
      }
      async signWithPrivateKey(data, privateKey, parameters) {
        const signature = await this.sign(parameters.algorithm, privateKey, data);
        if (parameters.algorithm.name === "ECDSA") {
          return createCMSECDSASignature(signature);
        }
        return signature;
      }
      fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm) {
        const parameters = {};
        const shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
        if (shaAlgorithm === EMPTY_STRING)
          throw new Error(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
        let algorithmId;
        if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10")
          algorithmId = signatureAlgorithm.algorithmId;
        else
          algorithmId = publicKeyInfo.algorithm.algorithmId;
        const algorithmObject = this.getAlgorithmByOID(algorithmId, true);
        parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importKey");
        if ("hash" in parameters.algorithm.algorithm)
          parameters.algorithm.algorithm.hash.name = shaAlgorithm;
        if (algorithmObject.name === "ECDSA") {
          const publicKeyAlgorithm = publicKeyInfo.algorithm;
          if (!publicKeyAlgorithm.algorithmParams) {
            throw new Error("Algorithm parameters for ECDSA public key are missed");
          }
          const publicKeyAlgorithmParams = publicKeyAlgorithm.algorithmParams;
          if ("idBlock" in publicKeyAlgorithm.algorithmParams) {
            if (!(publicKeyAlgorithmParams.idBlock.tagClass === 1 && publicKeyAlgorithmParams.idBlock.tagNumber === 6)) {
              throw new Error("Incorrect type for ECDSA public key parameters");
            }
          }
          const curveObject = this.getAlgorithmByOID(publicKeyAlgorithmParams.valueBlock.toString(), true);
          parameters.algorithm.algorithm.namedCurve = curveObject.name;
        }
        return parameters;
      }
      async getPublicKey(publicKeyInfo, signatureAlgorithm, parameters) {
        if (!parameters) {
          parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);
        }
        const publicKeyInfoBuffer = publicKeyInfo.toSchema().toBER(false);
        return this.importKey("spki", publicKeyInfoBuffer, parameters.algorithm.algorithm, true, parameters.algorithm.usages);
      }
      async verifyWithPublicKey(data, signature, publicKeyInfo, signatureAlgorithm, shaAlgorithm) {
        let publicKey;
        if (!shaAlgorithm) {
          shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
          if (!shaAlgorithm)
            throw new Error(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
          publicKey = await this.getPublicKey(publicKeyInfo, signatureAlgorithm);
        } else {
          const parameters = {};
          let algorithmId;
          if (signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10")
            algorithmId = signatureAlgorithm.algorithmId;
          else
            algorithmId = publicKeyInfo.algorithm.algorithmId;
          const algorithmObject = this.getAlgorithmByOID(algorithmId, true);
          parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importKey");
          if ("hash" in parameters.algorithm.algorithm)
            parameters.algorithm.algorithm.hash.name = shaAlgorithm;
          if (algorithmObject.name === "ECDSA") {
            let algorithmParamsChecked = false;
            if ("algorithmParams" in publicKeyInfo.algorithm === true) {
              if ("idBlock" in publicKeyInfo.algorithm.algorithmParams) {
                if (publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1 && publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6)
                  algorithmParamsChecked = true;
              }
            }
            if (algorithmParamsChecked === false) {
              throw new Error("Incorrect type for ECDSA public key parameters");
            }
            const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString(), true);
            parameters.algorithm.algorithm.namedCurve = curveObject.name;
          }
          publicKey = await this.getPublicKey(publicKeyInfo, null, parameters);
        }
        const algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, "verify");
        if ("hash" in algorithm.algorithm)
          algorithm.algorithm.hash.name = shaAlgorithm;
        let signatureValue = signature.valueBlock.valueHexView;
        if (publicKey.algorithm.name === "ECDSA") {
          const namedCurve = ECNamedCurves.find(publicKey.algorithm.namedCurve);
          if (!namedCurve) {
            throw new Error("Unsupported named curve in use");
          }
          const asn1 = asn1js__namespace.fromBER(signatureValue);
          AsnError.assert(asn1, "Signature value");
          signatureValue = createECDSASignatureFromCMS(asn1.result, namedCurve.size);
        }
        if (publicKey.algorithm.name === "RSA-PSS") {
          const pssParameters = new RSASSAPSSParams({ schema: signatureAlgorithm.algorithmParams });
          if ("saltLength" in pssParameters)
            algorithm.algorithm.saltLength = pssParameters.saltLength;
          else
            algorithm.algorithm.saltLength = 20;
          let hashAlgo = "SHA-1";
          if ("hashAlgorithm" in pssParameters) {
            const hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId, true);
            hashAlgo = hashAlgorithm.name;
          }
          algorithm.algorithm.hash.name = hashAlgo;
        }
        return this.verify(algorithm.algorithm, publicKey, signatureValue, data);
      }
    };
    exports.engine = {
      name: "none",
      crypto: null
    };
    function isCryptoEngine(engine) {
      return engine && typeof engine === "object" && "crypto" in engine ? true : false;
    }
    function setEngine2(name, ...args) {
      let crypto2 = null;
      if (args.length < 2) {
        if (args.length) {
          crypto2 = args[0];
        } else {
          crypto2 = typeof self !== "undefined" && self.crypto ? new CryptoEngine2({ name: "browser", crypto: self.crypto }) : null;
        }
      } else {
        const cryptoArg = args[0];
        const subtleArg = args[1];
        if (isCryptoEngine(subtleArg)) {
          crypto2 = subtleArg;
        } else if (isCryptoEngine(cryptoArg)) {
          crypto2 = cryptoArg;
        } else if ("subtle" in cryptoArg && "getRandomValues" in cryptoArg) {
          crypto2 = new CryptoEngine2({
            crypto: cryptoArg
          });
        }
      }
      if (typeof process !== "undefined" && "pid" in process && typeof global !== "undefined" && typeof window === "undefined") {
        if (typeof global[process.pid] === "undefined") {
          global[process.pid] = {};
        } else {
          if (typeof global[process.pid] !== "object") {
            throw new Error(`Name global.${process.pid} already exists and it is not an object`);
          }
        }
        if (typeof global[process.pid].pkijs === "undefined") {
          global[process.pid].pkijs = {};
        } else {
          if (typeof global[process.pid].pkijs !== "object") {
            throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);
          }
        }
        global[process.pid].pkijs.engine = {
          name,
          crypto: crypto2
        };
      } else {
        exports.engine = {
          name,
          crypto: crypto2
        };
      }
    }
    function getEngine() {
      if (typeof process !== "undefined" && "pid" in process && typeof global !== "undefined" && typeof window === "undefined") {
        let _engine;
        try {
          _engine = global[process.pid].pkijs.engine;
        } catch (ex) {
          throw new Error("Please call 'setEngine' before call to 'getEngine'");
        }
        return _engine;
      }
      return exports.engine;
    }
    function getCrypto(safety = false) {
      const _engine = getEngine();
      if (!_engine.crypto && safety) {
        throw new Error("Unable to create WebCrypto object");
      }
      return _engine.crypto;
    }
    function getRandomValues2(view) {
      return getCrypto(true).getRandomValues(view);
    }
    function getOIDByAlgorithm(algorithm, safety, target2) {
      return getCrypto(true).getOIDByAlgorithm(algorithm, safety, target2);
    }
    function getAlgorithmParameters(algorithmName, operation) {
      return getCrypto(true).getAlgorithmParameters(algorithmName, operation);
    }
    function createCMSECDSASignature(signatureBuffer) {
      if (signatureBuffer.byteLength % 2 !== 0)
        return EMPTY_BUFFER;
      const length = signatureBuffer.byteLength / 2;
      const rBuffer = new ArrayBuffer(length);
      const rView = new Uint8Array(rBuffer);
      rView.set(new Uint8Array(signatureBuffer, 0, length));
      const rInteger = new asn1js__namespace.Integer({ valueHex: rBuffer });
      const sBuffer = new ArrayBuffer(length);
      const sView = new Uint8Array(sBuffer);
      sView.set(new Uint8Array(signatureBuffer, length, length));
      const sInteger = new asn1js__namespace.Integer({ valueHex: sBuffer });
      return new asn1js__namespace.Sequence({
        value: [
          rInteger.convertToDER(),
          sInteger.convertToDER()
        ]
      }).toBER(false);
    }
    function createECDSASignatureFromCMS(cmsSignature, pointSize) {
      if (!(cmsSignature instanceof asn1js__namespace.Sequence && cmsSignature.valueBlock.value.length === 2 && cmsSignature.valueBlock.value[0] instanceof asn1js__namespace.Integer && cmsSignature.valueBlock.value[1] instanceof asn1js__namespace.Integer))
        return EMPTY_BUFFER;
      const rValueView = cmsSignature.valueBlock.value[0].convertFromDER().valueBlock.valueHexView;
      const sValueView = cmsSignature.valueBlock.value[1].convertFromDER().valueBlock.valueHexView;
      const res = new Uint8Array(pointSize * 2);
      res.set(rValueView, pointSize - rValueView.byteLength);
      res.set(sValueView, 2 * pointSize - sValueView.byteLength);
      return res.buffer;
    }
    function getAlgorithmByOID(oid, safety = false, target2) {
      return getCrypto(true).getAlgorithmByOID(oid, safety, target2);
    }
    function getHashAlgorithm(signatureAlgorithm) {
      return getCrypto(true).getHashAlgorithm(signatureAlgorithm);
    }
    async function kdfWithCounter(hashFunction, zBuffer, Counter, SharedInfo, crypto2) {
      switch (hashFunction.toUpperCase()) {
        case "SHA-1":
        case "SHA-256":
        case "SHA-384":
        case "SHA-512":
          break;
        default:
          throw new ArgumentError(`Unknown hash function: ${hashFunction}`);
      }
      ArgumentError.assert(zBuffer, "zBuffer", "ArrayBuffer");
      if (zBuffer.byteLength === 0)
        throw new ArgumentError("'zBuffer' has zero length, error");
      ArgumentError.assert(SharedInfo, "SharedInfo", "ArrayBuffer");
      if (Counter > 255)
        throw new ArgumentError("Please set 'Counter' argument to value less or equal to 255");
      const counterBuffer = new ArrayBuffer(4);
      const counterView = new Uint8Array(counterBuffer);
      counterView[0] = 0;
      counterView[1] = 0;
      counterView[2] = 0;
      counterView[3] = Counter;
      let combinedBuffer = EMPTY_BUFFER;
      combinedBuffer = pvutils__namespace.utilConcatBuf(combinedBuffer, zBuffer);
      combinedBuffer = pvutils__namespace.utilConcatBuf(combinedBuffer, counterBuffer);
      combinedBuffer = pvutils__namespace.utilConcatBuf(combinedBuffer, SharedInfo);
      const result = await crypto2.digest({ name: hashFunction }, combinedBuffer);
      return {
        counter: Counter,
        result
      };
    }
    async function kdf(hashFunction, Zbuffer, keydatalen, SharedInfo, crypto2 = getCrypto(true)) {
      let hashLength = 0;
      let maxCounter = 1;
      switch (hashFunction.toUpperCase()) {
        case "SHA-1":
          hashLength = 160;
          break;
        case "SHA-256":
          hashLength = 256;
          break;
        case "SHA-384":
          hashLength = 384;
          break;
        case "SHA-512":
          hashLength = 512;
          break;
        default:
          throw new ArgumentError(`Unknown hash function: ${hashFunction}`);
      }
      ArgumentError.assert(Zbuffer, "Zbuffer", "ArrayBuffer");
      if (Zbuffer.byteLength === 0)
        throw new ArgumentError("'Zbuffer' has zero length, error");
      ArgumentError.assert(SharedInfo, "SharedInfo", "ArrayBuffer");
      const quotient = keydatalen / hashLength;
      if (Math.floor(quotient) > 0) {
        maxCounter = Math.floor(quotient);
        if (quotient - maxCounter > 0)
          maxCounter++;
      }
      const incomingResult = [];
      for (let i = 1; i <= maxCounter; i++)
        incomingResult.push(await kdfWithCounter(hashFunction, Zbuffer, i, SharedInfo, crypto2));
      let combinedBuffer = EMPTY_BUFFER;
      let currentCounter = 1;
      let found = true;
      while (found) {
        found = false;
        for (const result of incomingResult) {
          if (result.counter === currentCounter) {
            combinedBuffer = pvutils__namespace.utilConcatBuf(combinedBuffer, result.result);
            found = true;
            break;
          }
        }
        currentCounter++;
      }
      keydatalen >>= 3;
      if (combinedBuffer.byteLength > keydatalen) {
        const newBuffer = new ArrayBuffer(keydatalen);
        const newView = new Uint8Array(newBuffer);
        const combinedView = new Uint8Array(combinedBuffer);
        for (let i = 0; i < keydatalen; i++)
          newView[i] = combinedView[i];
        return newBuffer;
      }
      return combinedBuffer;
    }
    var VERSION$i = "version";
    var LOG_ID = "logID";
    var EXTENSIONS$6 = "extensions";
    var TIMESTAMP = "timestamp";
    var HASH_ALGORITHM$3 = "hashAlgorithm";
    var SIGNATURE_ALGORITHM$8 = "signatureAlgorithm";
    var SIGNATURE$7 = "signature";
    var NONE = "none";
    var MD5 = "md5";
    var SHA1 = "sha1";
    var SHA224 = "sha224";
    var SHA256 = "sha256";
    var SHA384 = "sha384";
    var SHA512 = "sha512";
    var ANONYMOUS = "anonymous";
    var RSA = "rsa";
    var DSA = "dsa";
    var ECDSA = "ecdsa";
    var SignedCertificateTimestamp = class _SignedCertificateTimestamp extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$i, _SignedCertificateTimestamp.defaultValues(VERSION$i));
        this.logID = pvutils__namespace.getParametersValue(parameters, LOG_ID, _SignedCertificateTimestamp.defaultValues(LOG_ID));
        this.timestamp = pvutils__namespace.getParametersValue(parameters, TIMESTAMP, _SignedCertificateTimestamp.defaultValues(TIMESTAMP));
        this.extensions = pvutils__namespace.getParametersValue(parameters, EXTENSIONS$6, _SignedCertificateTimestamp.defaultValues(EXTENSIONS$6));
        this.hashAlgorithm = pvutils__namespace.getParametersValue(parameters, HASH_ALGORITHM$3, _SignedCertificateTimestamp.defaultValues(HASH_ALGORITHM$3));
        this.signatureAlgorithm = pvutils__namespace.getParametersValue(parameters, SIGNATURE_ALGORITHM$8, _SignedCertificateTimestamp.defaultValues(SIGNATURE_ALGORITHM$8));
        this.signature = pvutils__namespace.getParametersValue(parameters, SIGNATURE$7, _SignedCertificateTimestamp.defaultValues(SIGNATURE$7));
        if ("stream" in parameters && parameters.stream) {
          this.fromStream(parameters.stream);
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$i:
            return 0;
          case LOG_ID:
          case EXTENSIONS$6:
            return EMPTY_BUFFER;
          case TIMESTAMP:
            return /* @__PURE__ */ new Date(0);
          case HASH_ALGORITHM$3:
          case SIGNATURE_ALGORITHM$8:
            return EMPTY_STRING;
          case SIGNATURE$7:
            return new asn1js__namespace.Any();
          default:
            return super.defaultValues(memberName);
        }
      }
      fromSchema(schema) {
        if (schema instanceof asn1js__namespace.RawData === false)
          throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");
        const seqStream = new bs__namespace.SeqStream({
          stream: new bs__namespace.ByteStream({
            buffer: schema.data
          })
        });
        this.fromStream(seqStream);
      }
      fromStream(stream) {
        const blockLength = stream.getUint16();
        this.version = stream.getBlock(1)[0];
        if (this.version === 0) {
          this.logID = new Uint8Array(stream.getBlock(32)).buffer.slice(0);
          this.timestamp = new Date(pvutils__namespace.utilFromBase(new Uint8Array(stream.getBlock(8)), 8));
          const extensionsLength = stream.getUint16();
          this.extensions = new Uint8Array(stream.getBlock(extensionsLength)).buffer.slice(0);
          switch (stream.getBlock(1)[0]) {
            case 0:
              this.hashAlgorithm = NONE;
              break;
            case 1:
              this.hashAlgorithm = MD5;
              break;
            case 2:
              this.hashAlgorithm = SHA1;
              break;
            case 3:
              this.hashAlgorithm = SHA224;
              break;
            case 4:
              this.hashAlgorithm = SHA256;
              break;
            case 5:
              this.hashAlgorithm = SHA384;
              break;
            case 6:
              this.hashAlgorithm = SHA512;
              break;
            default:
              throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
          }
          switch (stream.getBlock(1)[0]) {
            case 0:
              this.signatureAlgorithm = ANONYMOUS;
              break;
            case 1:
              this.signatureAlgorithm = RSA;
              break;
            case 2:
              this.signatureAlgorithm = DSA;
              break;
            case 3:
              this.signatureAlgorithm = ECDSA;
              break;
            default:
              throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
          }
          const signatureLength = stream.getUint16();
          const signatureData = new Uint8Array(stream.getBlock(signatureLength)).buffer.slice(0);
          const asn1 = asn1js__namespace.fromBER(signatureData);
          AsnError.assert(asn1, "SignedCertificateTimestamp");
          this.signature = asn1.result;
          if (blockLength !== 47 + extensionsLength + signatureLength) {
            throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
          }
        }
      }
      toSchema() {
        const stream = this.toStream();
        return new asn1js__namespace.RawData({ data: stream.stream.buffer });
      }
      toStream() {
        const stream = new bs__namespace.SeqStream();
        stream.appendUint16(47 + this.extensions.byteLength + this.signature.valueBeforeDecodeView.byteLength);
        stream.appendChar(this.version);
        stream.appendView(new Uint8Array(this.logID));
        const timeBuffer = new ArrayBuffer(8);
        const timeView = new Uint8Array(timeBuffer);
        const baseArray = pvutils__namespace.utilToBase(this.timestamp.valueOf(), 8);
        timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
        stream.appendView(timeView);
        stream.appendUint16(this.extensions.byteLength);
        if (this.extensions.byteLength)
          stream.appendView(new Uint8Array(this.extensions));
        let _hashAlgorithm;
        switch (this.hashAlgorithm.toLowerCase()) {
          case NONE:
            _hashAlgorithm = 0;
            break;
          case MD5:
            _hashAlgorithm = 1;
            break;
          case SHA1:
            _hashAlgorithm = 2;
            break;
          case SHA224:
            _hashAlgorithm = 3;
            break;
          case SHA256:
            _hashAlgorithm = 4;
            break;
          case SHA384:
            _hashAlgorithm = 5;
            break;
          case SHA512:
            _hashAlgorithm = 6;
            break;
          default:
            throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`);
        }
        stream.appendChar(_hashAlgorithm);
        let _signatureAlgorithm;
        switch (this.signatureAlgorithm.toLowerCase()) {
          case ANONYMOUS:
            _signatureAlgorithm = 0;
            break;
          case RSA:
            _signatureAlgorithm = 1;
            break;
          case DSA:
            _signatureAlgorithm = 2;
            break;
          case ECDSA:
            _signatureAlgorithm = 3;
            break;
          default:
            throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`);
        }
        stream.appendChar(_signatureAlgorithm);
        const _signature = this.signature.toBER(false);
        stream.appendUint16(_signature.byteLength);
        stream.appendView(new Uint8Array(_signature));
        return stream;
      }
      toJSON() {
        return {
          version: this.version,
          logID: pvutils__namespace.bufferToHexCodes(this.logID),
          timestamp: this.timestamp,
          extensions: pvutils__namespace.bufferToHexCodes(this.extensions),
          hashAlgorithm: this.hashAlgorithm,
          signatureAlgorithm: this.signatureAlgorithm,
          signature: this.signature.toJSON()
        };
      }
      async verify(logs, data, dataType = 0, crypto2 = getCrypto(true)) {
        const logId = pvutils__namespace.toBase64(pvutils__namespace.arrayBufferToString(this.logID));
        let publicKeyBase64 = null;
        const stream = new bs__namespace.SeqStream();
        for (const log of logs) {
          if (log.log_id === logId) {
            publicKeyBase64 = log.key;
            break;
          }
        }
        if (!publicKeyBase64) {
          throw new Error(`Public key not found for CT with logId: ${logId}`);
        }
        const pki = pvutils__namespace.stringToArrayBuffer(pvutils__namespace.fromBase64(publicKeyBase64));
        const publicKeyInfo = PublicKeyInfo.fromBER(pki);
        stream.appendChar(0);
        stream.appendChar(0);
        const timeBuffer = new ArrayBuffer(8);
        const timeView = new Uint8Array(timeBuffer);
        const baseArray = pvutils__namespace.utilToBase(this.timestamp.valueOf(), 8);
        timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
        stream.appendView(timeView);
        stream.appendUint16(dataType);
        if (dataType === 0)
          stream.appendUint24(data.byteLength);
        stream.appendView(new Uint8Array(data));
        stream.appendUint16(this.extensions.byteLength);
        if (this.extensions.byteLength !== 0)
          stream.appendView(new Uint8Array(this.extensions));
        return crypto2.verifyWithPublicKey(stream.buffer.slice(0, stream.length), new asn1js__namespace.OctetString({ valueHex: this.signature.toBER(false) }), publicKeyInfo, { algorithmId: EMPTY_STRING }, "SHA-256");
      }
    };
    SignedCertificateTimestamp.CLASS_NAME = "SignedCertificateTimestamp";
    async function verifySCTsForCertificate(certificate, issuerCertificate, logs, index = -1, crypto2 = getCrypto(true)) {
      let parsedValue = null;
      const stream = new bs__namespace.SeqStream();
      for (let i = 0; certificate.extensions && i < certificate.extensions.length; i++) {
        switch (certificate.extensions[i].extnID) {
          case id_SignedCertificateTimestampList:
            {
              parsedValue = certificate.extensions[i].parsedValue;
              if (!parsedValue || parsedValue.timestamps.length === 0)
                throw new Error("Nothing to verify in the certificate");
              certificate.extensions.splice(i, 1);
            }
            break;
        }
      }
      if (parsedValue === null)
        throw new Error("No SignedCertificateTimestampList extension in the specified certificate");
      const tbs = certificate.encodeTBS().toBER();
      const issuerId = await crypto2.digest({ name: "SHA-256" }, new Uint8Array(issuerCertificate.subjectPublicKeyInfo.toSchema().toBER(false)));
      stream.appendView(new Uint8Array(issuerId));
      stream.appendUint24(tbs.byteLength);
      stream.appendView(new Uint8Array(tbs));
      const preCert = stream.stream.slice(0, stream.length);
      if (index === -1) {
        const verifyArray = [];
        for (const timestamp of parsedValue.timestamps) {
          const verifyResult = await timestamp.verify(logs, preCert.buffer, 1, crypto2);
          verifyArray.push(verifyResult);
        }
        return verifyArray;
      }
      if (index >= parsedValue.timestamps.length)
        index = parsedValue.timestamps.length - 1;
      return [await parsedValue.timestamps[index].verify(logs, preCert.buffer, 1, crypto2)];
    }
    var TIMESTAMPS = "timestamps";
    var SignedCertificateTimestampList = class _SignedCertificateTimestampList extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.timestamps = pvutils__namespace.getParametersValue(parameters, TIMESTAMPS, _SignedCertificateTimestampList.defaultValues(TIMESTAMPS));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TIMESTAMPS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TIMESTAMPS:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        var _a2;
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        (_a2 = names.optional) !== null && _a2 !== void 0 ? _a2 : names.optional = false;
        return new asn1js__namespace.OctetString({
          name: names.blockName || "SignedCertificateTimestampList",
          optional: names.optional
        });
      }
      fromSchema(schema) {
        if (schema instanceof asn1js__namespace.OctetString === false) {
          throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
        }
        const seqStream = new bs__namespace.SeqStream({
          stream: new bs__namespace.ByteStream({
            buffer: schema.valueBlock.valueHex
          })
        });
        const dataLength = seqStream.getUint16();
        if (dataLength !== seqStream.length) {
          throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
        }
        while (seqStream.length) {
          this.timestamps.push(new SignedCertificateTimestamp({ stream: seqStream }));
        }
      }
      toSchema() {
        const stream = new bs__namespace.SeqStream();
        let overallLength = 0;
        const timestampsData = [];
        for (const timestamp of this.timestamps) {
          const timestampStream = timestamp.toStream();
          timestampsData.push(timestampStream);
          overallLength += timestampStream.stream.buffer.byteLength;
        }
        stream.appendUint16(overallLength);
        for (const timestamp of timestampsData) {
          stream.appendView(timestamp.stream.view);
        }
        return new asn1js__namespace.OctetString({ valueHex: stream.stream.buffer.slice(0) });
      }
      toJSON() {
        return {
          timestamps: Array.from(this.timestamps, (o) => o.toJSON())
        };
      }
    };
    SignedCertificateTimestampList.CLASS_NAME = "SignedCertificateTimestampList";
    var ATTRIBUTES$4 = "attributes";
    var CLEAR_PROPS$11 = [
      ATTRIBUTES$4
    ];
    var SubjectDirectoryAttributes = class _SubjectDirectoryAttributes extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.attributes = pvutils__namespace.getParametersValue(parameters, ATTRIBUTES$4, _SubjectDirectoryAttributes.defaultValues(ATTRIBUTES$4));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ATTRIBUTES$4:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.attributes || EMPTY_STRING,
              value: Attribute.schema()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$11);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _SubjectDirectoryAttributes.schema({
          names: {
            attributes: ATTRIBUTES$4
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.attributes = Array.from(asn1.result.attributes, (element) => new Attribute({ schema: element }));
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.attributes, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          attributes: Array.from(this.attributes, (o) => o.toJSON())
        };
      }
    };
    SubjectDirectoryAttributes.CLASS_NAME = "SubjectDirectoryAttributes";
    var ExtensionValueFactory = class _ExtensionValueFactory {
      static getItems() {
        if (!this.types) {
          this.types = {};
          _ExtensionValueFactory.register(id_SubjectAltName, "SubjectAltName", AltName);
          _ExtensionValueFactory.register(id_IssuerAltName, "IssuerAltName", AltName);
          _ExtensionValueFactory.register(id_AuthorityKeyIdentifier, "AuthorityKeyIdentifier", AuthorityKeyIdentifier);
          _ExtensionValueFactory.register(id_BasicConstraints, "BasicConstraints", BasicConstraints);
          _ExtensionValueFactory.register(id_MicrosoftCaVersion, "MicrosoftCaVersion", CAVersion);
          _ExtensionValueFactory.register(id_CertificatePolicies, "CertificatePolicies", CertificatePolicies);
          _ExtensionValueFactory.register(id_MicrosoftAppPolicies, "CertificatePoliciesMicrosoft", CertificatePolicies);
          _ExtensionValueFactory.register(id_MicrosoftCertTemplateV2, "MicrosoftCertTemplateV2", CertificateTemplate);
          _ExtensionValueFactory.register(id_CRLDistributionPoints, "CRLDistributionPoints", CRLDistributionPoints);
          _ExtensionValueFactory.register(id_FreshestCRL, "FreshestCRL", CRLDistributionPoints);
          _ExtensionValueFactory.register(id_ExtKeyUsage, "ExtKeyUsage", ExtKeyUsage);
          _ExtensionValueFactory.register(id_CertificateIssuer, "CertificateIssuer", GeneralNames);
          _ExtensionValueFactory.register(id_AuthorityInfoAccess, "AuthorityInfoAccess", InfoAccess);
          _ExtensionValueFactory.register(id_SubjectInfoAccess, "SubjectInfoAccess", InfoAccess);
          _ExtensionValueFactory.register(id_IssuingDistributionPoint, "IssuingDistributionPoint", IssuingDistributionPoint);
          _ExtensionValueFactory.register(id_NameConstraints, "NameConstraints", NameConstraints);
          _ExtensionValueFactory.register(id_PolicyConstraints, "PolicyConstraints", PolicyConstraints);
          _ExtensionValueFactory.register(id_PolicyMappings, "PolicyMappings", PolicyMappings);
          _ExtensionValueFactory.register(id_PrivateKeyUsagePeriod, "PrivateKeyUsagePeriod", PrivateKeyUsagePeriod);
          _ExtensionValueFactory.register(id_QCStatements, "QCStatements", QCStatements);
          _ExtensionValueFactory.register(id_SignedCertificateTimestampList, "SignedCertificateTimestampList", SignedCertificateTimestampList);
          _ExtensionValueFactory.register(id_SubjectDirectoryAttributes, "SubjectDirectoryAttributes", SubjectDirectoryAttributes);
        }
        return this.types;
      }
      static fromBER(id, raw) {
        const asn1 = asn1js__namespace.fromBER(raw);
        if (asn1.offset === -1) {
          return null;
        }
        const item = this.find(id);
        if (item) {
          try {
            return new item.type({ schema: asn1.result });
          } catch (ex) {
            const res = new item.type();
            res.parsingError = `Incorrectly formatted value of extension ${item.name} (${id})`;
            return res;
          }
        }
        return asn1.result;
      }
      static find(id) {
        const types3 = this.getItems();
        return types3[id] || null;
      }
      static register(id, name, type) {
        this.getItems()[id] = { name, type };
      }
    };
    var EXTN_ID = "extnID";
    var CRITICAL = "critical";
    var EXTN_VALUE = "extnValue";
    var PARSED_VALUE$5 = "parsedValue";
    var CLEAR_PROPS$10 = [
      EXTN_ID,
      CRITICAL,
      EXTN_VALUE
    ];
    var Extension = class _Extension extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.extnID = pvutils__namespace.getParametersValue(parameters, EXTN_ID, _Extension.defaultValues(EXTN_ID));
        this.critical = pvutils__namespace.getParametersValue(parameters, CRITICAL, _Extension.defaultValues(CRITICAL));
        if (EXTN_VALUE in parameters) {
          this.extnValue = new asn1js__namespace.OctetString({ valueHex: parameters.extnValue });
        } else {
          this.extnValue = _Extension.defaultValues(EXTN_VALUE);
        }
        if (PARSED_VALUE$5 in parameters) {
          this.parsedValue = pvutils__namespace.getParametersValue(parameters, PARSED_VALUE$5, _Extension.defaultValues(PARSED_VALUE$5));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      get parsedValue() {
        if (this._parsedValue === void 0) {
          const parsedValue = ExtensionValueFactory.fromBER(this.extnID, this.extnValue.valueBlock.valueHexView);
          this._parsedValue = parsedValue;
        }
        return this._parsedValue || void 0;
      }
      set parsedValue(value) {
        this._parsedValue = value;
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case EXTN_ID:
            return EMPTY_STRING;
          case CRITICAL:
            return false;
          case EXTN_VALUE:
            return new asn1js__namespace.OctetString();
          case PARSED_VALUE$5:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.extnID || EMPTY_STRING }),
            new asn1js__namespace.Boolean({
              name: names.critical || EMPTY_STRING,
              optional: true
            }),
            new asn1js__namespace.OctetString({ name: names.extnValue || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$10);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _Extension.schema({
          names: {
            extnID: EXTN_ID,
            critical: CRITICAL,
            extnValue: EXTN_VALUE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.extnID = asn1.result.extnID.valueBlock.toString();
        if (CRITICAL in asn1.result) {
          this.critical = asn1.result.critical.valueBlock.value;
        }
        this.extnValue = asn1.result.extnValue;
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.ObjectIdentifier({ value: this.extnID }));
        if (this.critical !== _Extension.defaultValues(CRITICAL)) {
          outputArray.push(new asn1js__namespace.Boolean({ value: this.critical }));
        }
        outputArray.push(this.extnValue);
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const object = {
          extnID: this.extnID,
          extnValue: this.extnValue.toJSON()
        };
        if (this.critical !== _Extension.defaultValues(CRITICAL)) {
          object.critical = this.critical;
        }
        if (this.parsedValue && this.parsedValue.toJSON) {
          object.parsedValue = this.parsedValue.toJSON();
        }
        return object;
      }
    };
    Extension.CLASS_NAME = "Extension";
    var EXTENSIONS$5 = "extensions";
    var CLEAR_PROPS$$ = [
      EXTENSIONS$5
    ];
    var Extensions = class _Extensions extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.extensions = pvutils__namespace.getParametersValue(parameters, EXTENSIONS$5, _Extensions.defaultValues(EXTENSIONS$5));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case EXTENSIONS$5:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}, optional = false) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          optional,
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.extensions || EMPTY_STRING,
              value: Extension.schema(names.extension || {})
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$$);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _Extensions.schema({
          names: {
            extensions: EXTENSIONS$5
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.extensions = Array.from(asn1.result.extensions, (element) => new Extension({ schema: element }));
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.extensions, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          extensions: this.extensions.map((o) => o.toJSON())
        };
      }
    };
    Extensions.CLASS_NAME = "Extensions";
    var ISSUER$5 = "issuer";
    var SERIAL_NUMBER$6 = "serialNumber";
    var ISSUER_UID = "issuerUID";
    var CLEAR_PROPS$_ = [
      ISSUER$5,
      SERIAL_NUMBER$6,
      ISSUER_UID
    ];
    var IssuerSerial = class _IssuerSerial extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.issuer = pvutils__namespace.getParametersValue(parameters, ISSUER$5, _IssuerSerial.defaultValues(ISSUER$5));
        this.serialNumber = pvutils__namespace.getParametersValue(parameters, SERIAL_NUMBER$6, _IssuerSerial.defaultValues(SERIAL_NUMBER$6));
        if (ISSUER_UID in parameters) {
          this.issuerUID = pvutils__namespace.getParametersValue(parameters, ISSUER_UID, _IssuerSerial.defaultValues(ISSUER_UID));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ISSUER$5:
            return new GeneralNames();
          case SERIAL_NUMBER$6:
            return new asn1js__namespace.Integer();
          case ISSUER_UID:
            return new asn1js__namespace.BitString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            GeneralNames.schema(names.issuer || {}),
            new asn1js__namespace.Integer({ name: names.serialNumber || EMPTY_STRING }),
            new asn1js__namespace.BitString({
              optional: true,
              name: names.issuerUID || EMPTY_STRING
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$_);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _IssuerSerial.schema({
          names: {
            issuer: {
              names: {
                blockName: ISSUER$5
              }
            },
            serialNumber: SERIAL_NUMBER$6,
            issuerUID: ISSUER_UID
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.issuer = new GeneralNames({ schema: asn1.result.issuer });
        this.serialNumber = asn1.result.serialNumber;
        if (ISSUER_UID in asn1.result)
          this.issuerUID = asn1.result.issuerUID;
      }
      toSchema() {
        const result = new asn1js__namespace.Sequence({
          value: [
            this.issuer.toSchema(),
            this.serialNumber
          ]
        });
        if (this.issuerUID) {
          result.valueBlock.value.push(this.issuerUID);
        }
        return result;
      }
      toJSON() {
        const result = {
          issuer: this.issuer.toJSON(),
          serialNumber: this.serialNumber.toJSON()
        };
        if (this.issuerUID) {
          result.issuerUID = this.issuerUID.toJSON();
        }
        return result;
      }
    };
    IssuerSerial.CLASS_NAME = "IssuerSerial";
    var VERSION$h = "version";
    var BASE_CERTIFICATE_ID$2 = "baseCertificateID";
    var SUBJECT_NAME = "subjectName";
    var ISSUER$4 = "issuer";
    var SIGNATURE$6 = "signature";
    var SERIAL_NUMBER$5 = "serialNumber";
    var ATTR_CERT_VALIDITY_PERIOD$1 = "attrCertValidityPeriod";
    var ATTRIBUTES$3 = "attributes";
    var ISSUER_UNIQUE_ID$2 = "issuerUniqueID";
    var EXTENSIONS$4 = "extensions";
    var CLEAR_PROPS$Z = [
      VERSION$h,
      BASE_CERTIFICATE_ID$2,
      SUBJECT_NAME,
      ISSUER$4,
      SIGNATURE$6,
      SERIAL_NUMBER$5,
      ATTR_CERT_VALIDITY_PERIOD$1,
      ATTRIBUTES$3,
      ISSUER_UNIQUE_ID$2,
      EXTENSIONS$4
    ];
    var AttributeCertificateInfoV1 = class _AttributeCertificateInfoV1 extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$h, _AttributeCertificateInfoV1.defaultValues(VERSION$h));
        if (BASE_CERTIFICATE_ID$2 in parameters) {
          this.baseCertificateID = pvutils__namespace.getParametersValue(parameters, BASE_CERTIFICATE_ID$2, _AttributeCertificateInfoV1.defaultValues(BASE_CERTIFICATE_ID$2));
        }
        if (SUBJECT_NAME in parameters) {
          this.subjectName = pvutils__namespace.getParametersValue(parameters, SUBJECT_NAME, _AttributeCertificateInfoV1.defaultValues(SUBJECT_NAME));
        }
        this.issuer = pvutils__namespace.getParametersValue(parameters, ISSUER$4, _AttributeCertificateInfoV1.defaultValues(ISSUER$4));
        this.signature = pvutils__namespace.getParametersValue(parameters, SIGNATURE$6, _AttributeCertificateInfoV1.defaultValues(SIGNATURE$6));
        this.serialNumber = pvutils__namespace.getParametersValue(parameters, SERIAL_NUMBER$5, _AttributeCertificateInfoV1.defaultValues(SERIAL_NUMBER$5));
        this.attrCertValidityPeriod = pvutils__namespace.getParametersValue(parameters, ATTR_CERT_VALIDITY_PERIOD$1, _AttributeCertificateInfoV1.defaultValues(ATTR_CERT_VALIDITY_PERIOD$1));
        this.attributes = pvutils__namespace.getParametersValue(parameters, ATTRIBUTES$3, _AttributeCertificateInfoV1.defaultValues(ATTRIBUTES$3));
        if (ISSUER_UNIQUE_ID$2 in parameters)
          this.issuerUniqueID = pvutils__namespace.getParametersValue(parameters, ISSUER_UNIQUE_ID$2, _AttributeCertificateInfoV1.defaultValues(ISSUER_UNIQUE_ID$2));
        if (EXTENSIONS$4 in parameters) {
          this.extensions = pvutils__namespace.getParametersValue(parameters, EXTENSIONS$4, _AttributeCertificateInfoV1.defaultValues(EXTENSIONS$4));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$h:
            return 0;
          case BASE_CERTIFICATE_ID$2:
            return new IssuerSerial();
          case SUBJECT_NAME:
            return new GeneralNames();
          case ISSUER$4:
            return new GeneralNames();
          case SIGNATURE$6:
            return new AlgorithmIdentifier();
          case SERIAL_NUMBER$5:
            return new asn1js__namespace.Integer();
          case ATTR_CERT_VALIDITY_PERIOD$1:
            return new AttCertValidityPeriod();
          case ATTRIBUTES$3:
            return [];
          case ISSUER_UNIQUE_ID$2:
            return new asn1js__namespace.BitString();
          case EXTENSIONS$4:
            return new Extensions();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || EMPTY_STRING }),
            new asn1js__namespace.Choice({
              value: [
                new asn1js__namespace.Constructed({
                  name: names.baseCertificateID || EMPTY_STRING,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  },
                  value: IssuerSerial.schema().valueBlock.value
                }),
                new asn1js__namespace.Constructed({
                  name: names.subjectName || EMPTY_STRING,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                  },
                  value: GeneralNames.schema().valueBlock.value
                })
              ]
            }),
            GeneralNames.schema({
              names: {
                blockName: names.issuer || EMPTY_STRING
              }
            }),
            AlgorithmIdentifier.schema(names.signature || {}),
            new asn1js__namespace.Integer({ name: names.serialNumber || EMPTY_STRING }),
            AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}),
            new asn1js__namespace.Sequence({
              name: names.attributes || EMPTY_STRING,
              value: [
                new asn1js__namespace.Repeated({
                  value: Attribute.schema()
                })
              ]
            }),
            new asn1js__namespace.BitString({
              optional: true,
              name: names.issuerUniqueID || EMPTY_STRING
            }),
            Extensions.schema(names.extensions || {}, true)
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$Z);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _AttributeCertificateInfoV1.schema({
          names: {
            version: VERSION$h,
            baseCertificateID: BASE_CERTIFICATE_ID$2,
            subjectName: SUBJECT_NAME,
            issuer: ISSUER$4,
            signature: {
              names: {
                blockName: SIGNATURE$6
              }
            },
            serialNumber: SERIAL_NUMBER$5,
            attrCertValidityPeriod: {
              names: {
                blockName: ATTR_CERT_VALIDITY_PERIOD$1
              }
            },
            attributes: ATTRIBUTES$3,
            issuerUniqueID: ISSUER_UNIQUE_ID$2,
            extensions: {
              names: {
                blockName: EXTENSIONS$4
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        if (BASE_CERTIFICATE_ID$2 in asn1.result) {
          this.baseCertificateID = new IssuerSerial({
            schema: new asn1js__namespace.Sequence({
              value: asn1.result.baseCertificateID.valueBlock.value
            })
          });
        }
        if (SUBJECT_NAME in asn1.result) {
          this.subjectName = new GeneralNames({
            schema: new asn1js__namespace.Sequence({
              value: asn1.result.subjectName.valueBlock.value
            })
          });
        }
        this.issuer = asn1.result.issuer;
        this.signature = new AlgorithmIdentifier({ schema: asn1.result.signature });
        this.serialNumber = asn1.result.serialNumber;
        this.attrCertValidityPeriod = new AttCertValidityPeriod({ schema: asn1.result.attrCertValidityPeriod });
        this.attributes = Array.from(asn1.result.attributes.valueBlock.value, (element) => new Attribute({ schema: element }));
        if (ISSUER_UNIQUE_ID$2 in asn1.result) {
          this.issuerUniqueID = asn1.result.issuerUniqueID;
        }
        if (EXTENSIONS$4 in asn1.result) {
          this.extensions = new Extensions({ schema: asn1.result.extensions });
        }
      }
      toSchema() {
        const result = new asn1js__namespace.Sequence({
          value: [new asn1js__namespace.Integer({ value: this.version })]
        });
        if (this.baseCertificateID) {
          result.valueBlock.value.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.baseCertificateID.toSchema().valueBlock.value
          }));
        }
        if (this.subjectName) {
          result.valueBlock.value.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: this.subjectName.toSchema().valueBlock.value
          }));
        }
        result.valueBlock.value.push(this.issuer.toSchema());
        result.valueBlock.value.push(this.signature.toSchema());
        result.valueBlock.value.push(this.serialNumber);
        result.valueBlock.value.push(this.attrCertValidityPeriod.toSchema());
        result.valueBlock.value.push(new asn1js__namespace.Sequence({
          value: Array.from(this.attributes, (o) => o.toSchema())
        }));
        if (this.issuerUniqueID) {
          result.valueBlock.value.push(this.issuerUniqueID);
        }
        if (this.extensions) {
          result.valueBlock.value.push(this.extensions.toSchema());
        }
        return result;
      }
      toJSON() {
        const result = {
          version: this.version
        };
        if (this.baseCertificateID) {
          result.baseCertificateID = this.baseCertificateID.toJSON();
        }
        if (this.subjectName) {
          result.subjectName = this.subjectName.toJSON();
        }
        result.issuer = this.issuer.toJSON();
        result.signature = this.signature.toJSON();
        result.serialNumber = this.serialNumber.toJSON();
        result.attrCertValidityPeriod = this.attrCertValidityPeriod.toJSON();
        result.attributes = Array.from(this.attributes, (o) => o.toJSON());
        if (this.issuerUniqueID) {
          result.issuerUniqueID = this.issuerUniqueID.toJSON();
        }
        if (this.extensions) {
          result.extensions = this.extensions.toJSON();
        }
        return result;
      }
    };
    AttributeCertificateInfoV1.CLASS_NAME = "AttributeCertificateInfoV1";
    var ACINFO$1 = "acinfo";
    var SIGNATURE_ALGORITHM$7 = "signatureAlgorithm";
    var SIGNATURE_VALUE$4 = "signatureValue";
    var CLEAR_PROPS$Y = [
      ACINFO$1,
      SIGNATURE_VALUE$4,
      SIGNATURE_ALGORITHM$7
    ];
    var AttributeCertificateV1 = class _AttributeCertificateV1 extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.acinfo = pvutils__namespace.getParametersValue(parameters, ACINFO$1, _AttributeCertificateV1.defaultValues(ACINFO$1));
        this.signatureAlgorithm = pvutils__namespace.getParametersValue(parameters, SIGNATURE_ALGORITHM$7, _AttributeCertificateV1.defaultValues(SIGNATURE_ALGORITHM$7));
        this.signatureValue = pvutils__namespace.getParametersValue(parameters, SIGNATURE_VALUE$4, _AttributeCertificateV1.defaultValues(SIGNATURE_VALUE$4));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ACINFO$1:
            return new AttributeCertificateInfoV1();
          case SIGNATURE_ALGORITHM$7:
            return new AlgorithmIdentifier();
          case SIGNATURE_VALUE$4:
            return new asn1js__namespace.BitString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            AttributeCertificateInfoV1.schema(names.acinfo || {}),
            AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
            new asn1js__namespace.BitString({ name: names.signatureValue || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$Y);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _AttributeCertificateV1.schema({
          names: {
            acinfo: {
              names: {
                blockName: ACINFO$1
              }
            },
            signatureAlgorithm: {
              names: {
                blockName: SIGNATURE_ALGORITHM$7
              }
            },
            signatureValue: SIGNATURE_VALUE$4
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.acinfo = new AttributeCertificateInfoV1({ schema: asn1.result.acinfo });
        this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
        this.signatureValue = asn1.result.signatureValue;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.acinfo.toSchema(),
            this.signatureAlgorithm.toSchema(),
            this.signatureValue
          ]
        });
      }
      toJSON() {
        return {
          acinfo: this.acinfo.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signatureValue: this.signatureValue.toJSON()
        };
      }
    };
    AttributeCertificateV1.CLASS_NAME = "AttributeCertificateV1";
    var DIGESTED_OBJECT_TYPE = "digestedObjectType";
    var OTHER_OBJECT_TYPE_ID = "otherObjectTypeID";
    var DIGEST_ALGORITHM$2 = "digestAlgorithm";
    var OBJECT_DIGEST = "objectDigest";
    var CLEAR_PROPS$X = [
      DIGESTED_OBJECT_TYPE,
      OTHER_OBJECT_TYPE_ID,
      DIGEST_ALGORITHM$2,
      OBJECT_DIGEST
    ];
    var ObjectDigestInfo = class _ObjectDigestInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.digestedObjectType = pvutils__namespace.getParametersValue(parameters, DIGESTED_OBJECT_TYPE, _ObjectDigestInfo.defaultValues(DIGESTED_OBJECT_TYPE));
        if (OTHER_OBJECT_TYPE_ID in parameters) {
          this.otherObjectTypeID = pvutils__namespace.getParametersValue(parameters, OTHER_OBJECT_TYPE_ID, _ObjectDigestInfo.defaultValues(OTHER_OBJECT_TYPE_ID));
        }
        this.digestAlgorithm = pvutils__namespace.getParametersValue(parameters, DIGEST_ALGORITHM$2, _ObjectDigestInfo.defaultValues(DIGEST_ALGORITHM$2));
        this.objectDigest = pvutils__namespace.getParametersValue(parameters, OBJECT_DIGEST, _ObjectDigestInfo.defaultValues(OBJECT_DIGEST));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case DIGESTED_OBJECT_TYPE:
            return new asn1js__namespace.Enumerated();
          case OTHER_OBJECT_TYPE_ID:
            return new asn1js__namespace.ObjectIdentifier();
          case DIGEST_ALGORITHM$2:
            return new AlgorithmIdentifier();
          case OBJECT_DIGEST:
            return new asn1js__namespace.BitString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Enumerated({ name: names.digestedObjectType || EMPTY_STRING }),
            new asn1js__namespace.ObjectIdentifier({
              optional: true,
              name: names.otherObjectTypeID || EMPTY_STRING
            }),
            AlgorithmIdentifier.schema(names.digestAlgorithm || {}),
            new asn1js__namespace.BitString({ name: names.objectDigest || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$X);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _ObjectDigestInfo.schema({
          names: {
            digestedObjectType: DIGESTED_OBJECT_TYPE,
            otherObjectTypeID: OTHER_OBJECT_TYPE_ID,
            digestAlgorithm: {
              names: {
                blockName: DIGEST_ALGORITHM$2
              }
            },
            objectDigest: OBJECT_DIGEST
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.digestedObjectType = asn1.result.digestedObjectType;
        if (OTHER_OBJECT_TYPE_ID in asn1.result) {
          this.otherObjectTypeID = asn1.result.otherObjectTypeID;
        }
        this.digestAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.digestAlgorithm });
        this.objectDigest = asn1.result.objectDigest;
      }
      toSchema() {
        const result = new asn1js__namespace.Sequence({
          value: [this.digestedObjectType]
        });
        if (this.otherObjectTypeID) {
          result.valueBlock.value.push(this.otherObjectTypeID);
        }
        result.valueBlock.value.push(this.digestAlgorithm.toSchema());
        result.valueBlock.value.push(this.objectDigest);
        return result;
      }
      toJSON() {
        const result = {
          digestedObjectType: this.digestedObjectType.toJSON(),
          digestAlgorithm: this.digestAlgorithm.toJSON(),
          objectDigest: this.objectDigest.toJSON()
        };
        if (this.otherObjectTypeID) {
          result.otherObjectTypeID = this.otherObjectTypeID.toJSON();
        }
        return result;
      }
    };
    ObjectDigestInfo.CLASS_NAME = "ObjectDigestInfo";
    var ISSUER_NAME = "issuerName";
    var BASE_CERTIFICATE_ID$1 = "baseCertificateID";
    var OBJECT_DIGEST_INFO$1 = "objectDigestInfo";
    var CLEAR_PROPS$W = [
      ISSUER_NAME,
      BASE_CERTIFICATE_ID$1,
      OBJECT_DIGEST_INFO$1
    ];
    var V2Form = class _V2Form extends PkiObject {
      constructor(parameters = {}) {
        super();
        if (ISSUER_NAME in parameters) {
          this.issuerName = pvutils__namespace.getParametersValue(parameters, ISSUER_NAME, _V2Form.defaultValues(ISSUER_NAME));
        }
        if (BASE_CERTIFICATE_ID$1 in parameters) {
          this.baseCertificateID = pvutils__namespace.getParametersValue(parameters, BASE_CERTIFICATE_ID$1, _V2Form.defaultValues(BASE_CERTIFICATE_ID$1));
        }
        if (OBJECT_DIGEST_INFO$1 in parameters) {
          this.objectDigestInfo = pvutils__namespace.getParametersValue(parameters, OBJECT_DIGEST_INFO$1, _V2Form.defaultValues(OBJECT_DIGEST_INFO$1));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ISSUER_NAME:
            return new GeneralNames();
          case BASE_CERTIFICATE_ID$1:
            return new IssuerSerial();
          case OBJECT_DIGEST_INFO$1:
            return new ObjectDigestInfo();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            GeneralNames.schema({
              names: {
                blockName: names.issuerName
              }
            }, true),
            new asn1js__namespace.Constructed({
              optional: true,
              name: names.baseCertificateID || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: IssuerSerial.schema().valueBlock.value
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              name: names.objectDigestInfo || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: ObjectDigestInfo.schema().valueBlock.value
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$W);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _V2Form.schema({
          names: {
            issuerName: ISSUER_NAME,
            baseCertificateID: BASE_CERTIFICATE_ID$1,
            objectDigestInfo: OBJECT_DIGEST_INFO$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (ISSUER_NAME in asn1.result)
          this.issuerName = new GeneralNames({ schema: asn1.result.issuerName });
        if (BASE_CERTIFICATE_ID$1 in asn1.result) {
          this.baseCertificateID = new IssuerSerial({
            schema: new asn1js__namespace.Sequence({
              value: asn1.result.baseCertificateID.valueBlock.value
            })
          });
        }
        if (OBJECT_DIGEST_INFO$1 in asn1.result) {
          this.objectDigestInfo = new ObjectDigestInfo({
            schema: new asn1js__namespace.Sequence({
              value: asn1.result.objectDigestInfo.valueBlock.value
            })
          });
        }
      }
      toSchema() {
        const result = new asn1js__namespace.Sequence();
        if (this.issuerName)
          result.valueBlock.value.push(this.issuerName.toSchema());
        if (this.baseCertificateID) {
          result.valueBlock.value.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.baseCertificateID.toSchema().valueBlock.value
          }));
        }
        if (this.objectDigestInfo) {
          result.valueBlock.value.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: this.objectDigestInfo.toSchema().valueBlock.value
          }));
        }
        return result;
      }
      toJSON() {
        const result = {};
        if (this.issuerName) {
          result.issuerName = this.issuerName.toJSON();
        }
        if (this.baseCertificateID) {
          result.baseCertificateID = this.baseCertificateID.toJSON();
        }
        if (this.objectDigestInfo) {
          result.objectDigestInfo = this.objectDigestInfo.toJSON();
        }
        return result;
      }
    };
    V2Form.CLASS_NAME = "V2Form";
    var BASE_CERTIFICATE_ID = "baseCertificateID";
    var ENTITY_NAME = "entityName";
    var OBJECT_DIGEST_INFO = "objectDigestInfo";
    var CLEAR_PROPS$V = [
      BASE_CERTIFICATE_ID,
      ENTITY_NAME,
      OBJECT_DIGEST_INFO
    ];
    var Holder = class _Holder extends PkiObject {
      constructor(parameters = {}) {
        super();
        if (BASE_CERTIFICATE_ID in parameters) {
          this.baseCertificateID = pvutils__namespace.getParametersValue(parameters, BASE_CERTIFICATE_ID, _Holder.defaultValues(BASE_CERTIFICATE_ID));
        }
        if (ENTITY_NAME in parameters) {
          this.entityName = pvutils__namespace.getParametersValue(parameters, ENTITY_NAME, _Holder.defaultValues(ENTITY_NAME));
        }
        if (OBJECT_DIGEST_INFO in parameters) {
          this.objectDigestInfo = pvutils__namespace.getParametersValue(parameters, OBJECT_DIGEST_INFO, _Holder.defaultValues(OBJECT_DIGEST_INFO));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case BASE_CERTIFICATE_ID:
            return new IssuerSerial();
          case ENTITY_NAME:
            return new GeneralNames();
          case OBJECT_DIGEST_INFO:
            return new ObjectDigestInfo();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Constructed({
              optional: true,
              name: names.baseCertificateID || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: IssuerSerial.schema().valueBlock.value
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              name: names.entityName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: GeneralNames.schema().valueBlock.value
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              name: names.objectDigestInfo || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: ObjectDigestInfo.schema().valueBlock.value
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$V);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _Holder.schema({
          names: {
            baseCertificateID: BASE_CERTIFICATE_ID,
            entityName: ENTITY_NAME,
            objectDigestInfo: OBJECT_DIGEST_INFO
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (BASE_CERTIFICATE_ID in asn1.result) {
          this.baseCertificateID = new IssuerSerial({
            schema: new asn1js__namespace.Sequence({
              value: asn1.result.baseCertificateID.valueBlock.value
            })
          });
        }
        if (ENTITY_NAME in asn1.result) {
          this.entityName = new GeneralNames({
            schema: new asn1js__namespace.Sequence({
              value: asn1.result.entityName.valueBlock.value
            })
          });
        }
        if (OBJECT_DIGEST_INFO in asn1.result) {
          this.objectDigestInfo = new ObjectDigestInfo({
            schema: new asn1js__namespace.Sequence({
              value: asn1.result.objectDigestInfo.valueBlock.value
            })
          });
        }
      }
      toSchema() {
        const result = new asn1js__namespace.Sequence();
        if (this.baseCertificateID) {
          result.valueBlock.value.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.baseCertificateID.toSchema().valueBlock.value
          }));
        }
        if (this.entityName) {
          result.valueBlock.value.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: this.entityName.toSchema().valueBlock.value
          }));
        }
        if (this.objectDigestInfo) {
          result.valueBlock.value.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: this.objectDigestInfo.toSchema().valueBlock.value
          }));
        }
        return result;
      }
      toJSON() {
        const result = {};
        if (this.baseCertificateID) {
          result.baseCertificateID = this.baseCertificateID.toJSON();
        }
        if (this.entityName) {
          result.entityName = this.entityName.toJSON();
        }
        if (this.objectDigestInfo) {
          result.objectDigestInfo = this.objectDigestInfo.toJSON();
        }
        return result;
      }
    };
    Holder.CLASS_NAME = "Holder";
    var VERSION$g = "version";
    var HOLDER = "holder";
    var ISSUER$3 = "issuer";
    var SIGNATURE$5 = "signature";
    var SERIAL_NUMBER$4 = "serialNumber";
    var ATTR_CERT_VALIDITY_PERIOD = "attrCertValidityPeriod";
    var ATTRIBUTES$2 = "attributes";
    var ISSUER_UNIQUE_ID$1 = "issuerUniqueID";
    var EXTENSIONS$3 = "extensions";
    var CLEAR_PROPS$U = [
      VERSION$g,
      HOLDER,
      ISSUER$3,
      SIGNATURE$5,
      SERIAL_NUMBER$4,
      ATTR_CERT_VALIDITY_PERIOD,
      ATTRIBUTES$2,
      ISSUER_UNIQUE_ID$1,
      EXTENSIONS$3
    ];
    var AttributeCertificateInfoV2 = class _AttributeCertificateInfoV2 extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$g, _AttributeCertificateInfoV2.defaultValues(VERSION$g));
        this.holder = pvutils__namespace.getParametersValue(parameters, HOLDER, _AttributeCertificateInfoV2.defaultValues(HOLDER));
        this.issuer = pvutils__namespace.getParametersValue(parameters, ISSUER$3, _AttributeCertificateInfoV2.defaultValues(ISSUER$3));
        this.signature = pvutils__namespace.getParametersValue(parameters, SIGNATURE$5, _AttributeCertificateInfoV2.defaultValues(SIGNATURE$5));
        this.serialNumber = pvutils__namespace.getParametersValue(parameters, SERIAL_NUMBER$4, _AttributeCertificateInfoV2.defaultValues(SERIAL_NUMBER$4));
        this.attrCertValidityPeriod = pvutils__namespace.getParametersValue(parameters, ATTR_CERT_VALIDITY_PERIOD, _AttributeCertificateInfoV2.defaultValues(ATTR_CERT_VALIDITY_PERIOD));
        this.attributes = pvutils__namespace.getParametersValue(parameters, ATTRIBUTES$2, _AttributeCertificateInfoV2.defaultValues(ATTRIBUTES$2));
        if (ISSUER_UNIQUE_ID$1 in parameters) {
          this.issuerUniqueID = pvutils__namespace.getParametersValue(parameters, ISSUER_UNIQUE_ID$1, _AttributeCertificateInfoV2.defaultValues(ISSUER_UNIQUE_ID$1));
        }
        if (EXTENSIONS$3 in parameters) {
          this.extensions = pvutils__namespace.getParametersValue(parameters, EXTENSIONS$3, _AttributeCertificateInfoV2.defaultValues(EXTENSIONS$3));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$g:
            return 1;
          case HOLDER:
            return new Holder();
          case ISSUER$3:
            return {};
          case SIGNATURE$5:
            return new AlgorithmIdentifier();
          case SERIAL_NUMBER$4:
            return new asn1js__namespace.Integer();
          case ATTR_CERT_VALIDITY_PERIOD:
            return new AttCertValidityPeriod();
          case ATTRIBUTES$2:
            return [];
          case ISSUER_UNIQUE_ID$1:
            return new asn1js__namespace.BitString();
          case EXTENSIONS$3:
            return new Extensions();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || EMPTY_STRING }),
            Holder.schema(names.holder || {}),
            new asn1js__namespace.Choice({
              value: [
                GeneralNames.schema({
                  names: {
                    blockName: names.issuer || EMPTY_STRING
                  }
                }),
                new asn1js__namespace.Constructed({
                  name: names.issuer || EMPTY_STRING,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  },
                  value: V2Form.schema().valueBlock.value
                })
              ]
            }),
            AlgorithmIdentifier.schema(names.signature || {}),
            new asn1js__namespace.Integer({ name: names.serialNumber || EMPTY_STRING }),
            AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}),
            new asn1js__namespace.Sequence({
              name: names.attributes || EMPTY_STRING,
              value: [
                new asn1js__namespace.Repeated({
                  value: Attribute.schema()
                })
              ]
            }),
            new asn1js__namespace.BitString({
              optional: true,
              name: names.issuerUniqueID || EMPTY_STRING
            }),
            Extensions.schema(names.extensions || {}, true)
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$U);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _AttributeCertificateInfoV2.schema({
          names: {
            version: VERSION$g,
            holder: {
              names: {
                blockName: HOLDER
              }
            },
            issuer: ISSUER$3,
            signature: {
              names: {
                blockName: SIGNATURE$5
              }
            },
            serialNumber: SERIAL_NUMBER$4,
            attrCertValidityPeriod: {
              names: {
                blockName: ATTR_CERT_VALIDITY_PERIOD
              }
            },
            attributes: ATTRIBUTES$2,
            issuerUniqueID: ISSUER_UNIQUE_ID$1,
            extensions: {
              names: {
                blockName: EXTENSIONS$3
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.holder = new Holder({ schema: asn1.result.holder });
        switch (asn1.result.issuer.idBlock.tagClass) {
          case 3:
            this.issuer = new V2Form({
              schema: new asn1js__namespace.Sequence({
                value: asn1.result.issuer.valueBlock.value
              })
            });
            break;
          case 1:
          default:
            throw new Error("Incorrect value for 'issuer' in AttributeCertificateInfoV2");
        }
        this.signature = new AlgorithmIdentifier({ schema: asn1.result.signature });
        this.serialNumber = asn1.result.serialNumber;
        this.attrCertValidityPeriod = new AttCertValidityPeriod({ schema: asn1.result.attrCertValidityPeriod });
        this.attributes = Array.from(asn1.result.attributes.valueBlock.value, (element) => new Attribute({ schema: element }));
        if (ISSUER_UNIQUE_ID$1 in asn1.result) {
          this.issuerUniqueID = asn1.result.issuerUniqueID;
        }
        if (EXTENSIONS$3 in asn1.result) {
          this.extensions = new Extensions({ schema: asn1.result.extensions });
        }
      }
      toSchema() {
        const result = new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.Integer({ value: this.version }),
            this.holder.toSchema(),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: this.issuer.toSchema().valueBlock.value
            }),
            this.signature.toSchema(),
            this.serialNumber,
            this.attrCertValidityPeriod.toSchema(),
            new asn1js__namespace.Sequence({
              value: Array.from(this.attributes, (o) => o.toSchema())
            })
          ]
        });
        if (this.issuerUniqueID) {
          result.valueBlock.value.push(this.issuerUniqueID);
        }
        if (this.extensions) {
          result.valueBlock.value.push(this.extensions.toSchema());
        }
        return result;
      }
      toJSON() {
        const result = {
          version: this.version,
          holder: this.holder.toJSON(),
          issuer: this.issuer.toJSON(),
          signature: this.signature.toJSON(),
          serialNumber: this.serialNumber.toJSON(),
          attrCertValidityPeriod: this.attrCertValidityPeriod.toJSON(),
          attributes: Array.from(this.attributes, (o) => o.toJSON())
        };
        if (this.issuerUniqueID) {
          result.issuerUniqueID = this.issuerUniqueID.toJSON();
        }
        if (this.extensions) {
          result.extensions = this.extensions.toJSON();
        }
        return result;
      }
    };
    AttributeCertificateInfoV2.CLASS_NAME = "AttributeCertificateInfoV2";
    var ACINFO = "acinfo";
    var SIGNATURE_ALGORITHM$6 = "signatureAlgorithm";
    var SIGNATURE_VALUE$3 = "signatureValue";
    var CLEAR_PROPS$T = [
      ACINFO,
      SIGNATURE_ALGORITHM$6,
      SIGNATURE_VALUE$3
    ];
    var AttributeCertificateV2 = class _AttributeCertificateV2 extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.acinfo = pvutils__namespace.getParametersValue(parameters, ACINFO, _AttributeCertificateV2.defaultValues(ACINFO));
        this.signatureAlgorithm = pvutils__namespace.getParametersValue(parameters, SIGNATURE_ALGORITHM$6, _AttributeCertificateV2.defaultValues(SIGNATURE_ALGORITHM$6));
        this.signatureValue = pvutils__namespace.getParametersValue(parameters, SIGNATURE_VALUE$3, _AttributeCertificateV2.defaultValues(SIGNATURE_VALUE$3));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ACINFO:
            return new AttributeCertificateInfoV2();
          case SIGNATURE_ALGORITHM$6:
            return new AlgorithmIdentifier();
          case SIGNATURE_VALUE$3:
            return new asn1js__namespace.BitString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            AttributeCertificateInfoV2.schema(names.acinfo || {}),
            AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
            new asn1js__namespace.BitString({ name: names.signatureValue || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$T);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _AttributeCertificateV2.schema({
          names: {
            acinfo: {
              names: {
                blockName: ACINFO
              }
            },
            signatureAlgorithm: {
              names: {
                blockName: SIGNATURE_ALGORITHM$6
              }
            },
            signatureValue: SIGNATURE_VALUE$3
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.acinfo = new AttributeCertificateInfoV2({ schema: asn1.result.acinfo });
        this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
        this.signatureValue = asn1.result.signatureValue;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.acinfo.toSchema(),
            this.signatureAlgorithm.toSchema(),
            this.signatureValue
          ]
        });
      }
      toJSON() {
        return {
          acinfo: this.acinfo.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signatureValue: this.signatureValue.toJSON()
        };
      }
    };
    AttributeCertificateV2.CLASS_NAME = "AttributeCertificateV2";
    var CONTENT_TYPE = "contentType";
    var CONTENT = "content";
    var CLEAR_PROPS$S = [CONTENT_TYPE, CONTENT];
    var ContentInfo = class _ContentInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.contentType = pvutils__namespace.getParametersValue(parameters, CONTENT_TYPE, _ContentInfo.defaultValues(CONTENT_TYPE));
        this.content = pvutils__namespace.getParametersValue(parameters, CONTENT, _ContentInfo.defaultValues(CONTENT));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case CONTENT_TYPE:
            return EMPTY_STRING;
          case CONTENT:
            return new asn1js__namespace.Any();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CONTENT_TYPE:
            return typeof memberValue === "string" && memberValue === this.defaultValues(CONTENT_TYPE);
          case CONTENT:
            return memberValue instanceof asn1js__namespace.Any;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        if ("optional" in names === false) {
          names.optional = false;
        }
        return new asn1js__namespace.Sequence({
          name: names.blockName || "ContentInfo",
          optional: names.optional,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.contentType || CONTENT_TYPE }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.Any({ name: names.content || CONTENT })]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$S);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _ContentInfo.schema());
        AsnError.assertSchema(asn1, this.className);
        this.contentType = asn1.result.contentType.valueBlock.toString();
        this.content = asn1.result.content;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.contentType }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [this.content]
            })
          ]
        });
      }
      toJSON() {
        const object = {
          contentType: this.contentType
        };
        if (!(this.content instanceof asn1js__namespace.Any)) {
          object.content = this.content.toJSON();
        }
        return object;
      }
    };
    ContentInfo.CLASS_NAME = "ContentInfo";
    ContentInfo.DATA = id_ContentType_Data;
    ContentInfo.SIGNED_DATA = id_ContentType_SignedData;
    ContentInfo.ENVELOPED_DATA = id_ContentType_EnvelopedData;
    ContentInfo.ENCRYPTED_DATA = id_ContentType_EncryptedData;
    var TYPE$1 = "type";
    var VALUE$4 = "value";
    var UTC_TIME_NAME = "utcTimeName";
    var GENERAL_TIME_NAME = "generalTimeName";
    var CLEAR_PROPS$R = [UTC_TIME_NAME, GENERAL_TIME_NAME];
    exports.TimeType = void 0;
    (function(TimeType) {
      TimeType[TimeType["UTCTime"] = 0] = "UTCTime";
      TimeType[TimeType["GeneralizedTime"] = 1] = "GeneralizedTime";
      TimeType[TimeType["empty"] = 2] = "empty";
    })(exports.TimeType || (exports.TimeType = {}));
    var Time = class _Time extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.type = pvutils__namespace.getParametersValue(parameters, TYPE$1, _Time.defaultValues(TYPE$1));
        this.value = pvutils__namespace.getParametersValue(parameters, VALUE$4, _Time.defaultValues(VALUE$4));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TYPE$1:
            return 0;
          case VALUE$4:
            return new Date(0, 0, 0);
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}, optional = false) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Choice({
          optional,
          value: [
            new asn1js__namespace.UTCTime({ name: names.utcTimeName || EMPTY_STRING }),
            new asn1js__namespace.GeneralizedTime({ name: names.generalTimeName || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$R);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _Time.schema({
          names: {
            utcTimeName: UTC_TIME_NAME,
            generalTimeName: GENERAL_TIME_NAME
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (UTC_TIME_NAME in asn1.result) {
          this.type = 0;
          this.value = asn1.result.utcTimeName.toDate();
        }
        if (GENERAL_TIME_NAME in asn1.result) {
          this.type = 1;
          this.value = asn1.result.generalTimeName.toDate();
        }
      }
      toSchema() {
        if (this.type === 0) {
          return new asn1js__namespace.UTCTime({ valueDate: this.value });
        } else if (this.type === 1) {
          return new asn1js__namespace.GeneralizedTime({ valueDate: this.value });
        }
        return {};
      }
      toJSON() {
        return {
          type: this.type,
          value: this.value
        };
      }
    };
    Time.CLASS_NAME = "Time";
    var TBS$4 = "tbs";
    var VERSION$f = "version";
    var SERIAL_NUMBER$3 = "serialNumber";
    var SIGNATURE$4 = "signature";
    var ISSUER$2 = "issuer";
    var NOT_BEFORE = "notBefore";
    var NOT_AFTER = "notAfter";
    var SUBJECT$1 = "subject";
    var SUBJECT_PUBLIC_KEY_INFO = "subjectPublicKeyInfo";
    var ISSUER_UNIQUE_ID = "issuerUniqueID";
    var SUBJECT_UNIQUE_ID = "subjectUniqueID";
    var EXTENSIONS$2 = "extensions";
    var SIGNATURE_ALGORITHM$5 = "signatureAlgorithm";
    var SIGNATURE_VALUE$2 = "signatureValue";
    var TBS_CERTIFICATE = "tbsCertificate";
    var TBS_CERTIFICATE_VERSION = `${TBS_CERTIFICATE}.${VERSION$f}`;
    var TBS_CERTIFICATE_SERIAL_NUMBER = `${TBS_CERTIFICATE}.${SERIAL_NUMBER$3}`;
    var TBS_CERTIFICATE_SIGNATURE = `${TBS_CERTIFICATE}.${SIGNATURE$4}`;
    var TBS_CERTIFICATE_ISSUER = `${TBS_CERTIFICATE}.${ISSUER$2}`;
    var TBS_CERTIFICATE_NOT_BEFORE = `${TBS_CERTIFICATE}.${NOT_BEFORE}`;
    var TBS_CERTIFICATE_NOT_AFTER = `${TBS_CERTIFICATE}.${NOT_AFTER}`;
    var TBS_CERTIFICATE_SUBJECT = `${TBS_CERTIFICATE}.${SUBJECT$1}`;
    var TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY = `${TBS_CERTIFICATE}.${SUBJECT_PUBLIC_KEY_INFO}`;
    var TBS_CERTIFICATE_ISSUER_UNIQUE_ID = `${TBS_CERTIFICATE}.${ISSUER_UNIQUE_ID}`;
    var TBS_CERTIFICATE_SUBJECT_UNIQUE_ID = `${TBS_CERTIFICATE}.${SUBJECT_UNIQUE_ID}`;
    var TBS_CERTIFICATE_EXTENSIONS = `${TBS_CERTIFICATE}.${EXTENSIONS$2}`;
    var CLEAR_PROPS$Q = [
      TBS_CERTIFICATE,
      TBS_CERTIFICATE_VERSION,
      TBS_CERTIFICATE_SERIAL_NUMBER,
      TBS_CERTIFICATE_SIGNATURE,
      TBS_CERTIFICATE_ISSUER,
      TBS_CERTIFICATE_NOT_BEFORE,
      TBS_CERTIFICATE_NOT_AFTER,
      TBS_CERTIFICATE_SUBJECT,
      TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY,
      TBS_CERTIFICATE_ISSUER_UNIQUE_ID,
      TBS_CERTIFICATE_SUBJECT_UNIQUE_ID,
      TBS_CERTIFICATE_EXTENSIONS,
      SIGNATURE_ALGORITHM$5,
      SIGNATURE_VALUE$2
    ];
    function tbsCertificate(parameters = {}) {
      const names = pvutils__namespace.getParametersValue(parameters, "names", {});
      return new asn1js__namespace.Sequence({
        name: names.blockName || TBS_CERTIFICATE,
        value: [
          new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [
              new asn1js__namespace.Integer({ name: names.tbsCertificateVersion || TBS_CERTIFICATE_VERSION })
            ]
          }),
          new asn1js__namespace.Integer({ name: names.tbsCertificateSerialNumber || TBS_CERTIFICATE_SERIAL_NUMBER }),
          AlgorithmIdentifier.schema(names.signature || {
            names: {
              blockName: TBS_CERTIFICATE_SIGNATURE
            }
          }),
          RelativeDistinguishedNames.schema(names.issuer || {
            names: {
              blockName: TBS_CERTIFICATE_ISSUER
            }
          }),
          new asn1js__namespace.Sequence({
            name: names.tbsCertificateValidity || "tbsCertificate.validity",
            value: [
              Time.schema(names.notBefore || {
                names: {
                  utcTimeName: TBS_CERTIFICATE_NOT_BEFORE,
                  generalTimeName: TBS_CERTIFICATE_NOT_BEFORE
                }
              }),
              Time.schema(names.notAfter || {
                names: {
                  utcTimeName: TBS_CERTIFICATE_NOT_AFTER,
                  generalTimeName: TBS_CERTIFICATE_NOT_AFTER
                }
              })
            ]
          }),
          RelativeDistinguishedNames.schema(names.subject || {
            names: {
              blockName: TBS_CERTIFICATE_SUBJECT
            }
          }),
          PublicKeyInfo.schema(names.subjectPublicKeyInfo || {
            names: {
              blockName: TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY
            }
          }),
          new asn1js__namespace.Primitive({
            name: names.tbsCertificateIssuerUniqueID || TBS_CERTIFICATE_ISSUER_UNIQUE_ID,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            }
          }),
          new asn1js__namespace.Primitive({
            name: names.tbsCertificateSubjectUniqueID || TBS_CERTIFICATE_SUBJECT_UNIQUE_ID,
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            }
          }),
          new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            value: [Extensions.schema(names.extensions || {
              names: {
                blockName: TBS_CERTIFICATE_EXTENSIONS
              }
            })]
          })
        ]
      });
    }
    var Certificate = class _Certificate extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.tbsView = new Uint8Array(pvutils__namespace.getParametersValue(parameters, TBS$4, _Certificate.defaultValues(TBS$4)));
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$f, _Certificate.defaultValues(VERSION$f));
        this.serialNumber = pvutils__namespace.getParametersValue(parameters, SERIAL_NUMBER$3, _Certificate.defaultValues(SERIAL_NUMBER$3));
        this.signature = pvutils__namespace.getParametersValue(parameters, SIGNATURE$4, _Certificate.defaultValues(SIGNATURE$4));
        this.issuer = pvutils__namespace.getParametersValue(parameters, ISSUER$2, _Certificate.defaultValues(ISSUER$2));
        this.notBefore = pvutils__namespace.getParametersValue(parameters, NOT_BEFORE, _Certificate.defaultValues(NOT_BEFORE));
        this.notAfter = pvutils__namespace.getParametersValue(parameters, NOT_AFTER, _Certificate.defaultValues(NOT_AFTER));
        this.subject = pvutils__namespace.getParametersValue(parameters, SUBJECT$1, _Certificate.defaultValues(SUBJECT$1));
        this.subjectPublicKeyInfo = pvutils__namespace.getParametersValue(parameters, SUBJECT_PUBLIC_KEY_INFO, _Certificate.defaultValues(SUBJECT_PUBLIC_KEY_INFO));
        if (ISSUER_UNIQUE_ID in parameters) {
          this.issuerUniqueID = pvutils__namespace.getParametersValue(parameters, ISSUER_UNIQUE_ID, _Certificate.defaultValues(ISSUER_UNIQUE_ID));
        }
        if (SUBJECT_UNIQUE_ID in parameters) {
          this.subjectUniqueID = pvutils__namespace.getParametersValue(parameters, SUBJECT_UNIQUE_ID, _Certificate.defaultValues(SUBJECT_UNIQUE_ID));
        }
        if (EXTENSIONS$2 in parameters) {
          this.extensions = pvutils__namespace.getParametersValue(parameters, EXTENSIONS$2, _Certificate.defaultValues(EXTENSIONS$2));
        }
        this.signatureAlgorithm = pvutils__namespace.getParametersValue(parameters, SIGNATURE_ALGORITHM$5, _Certificate.defaultValues(SIGNATURE_ALGORITHM$5));
        this.signatureValue = pvutils__namespace.getParametersValue(parameters, SIGNATURE_VALUE$2, _Certificate.defaultValues(SIGNATURE_VALUE$2));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      get tbs() {
        return pvtsutils__namespace.BufferSourceConverter.toArrayBuffer(this.tbsView);
      }
      set tbs(value) {
        this.tbsView = new Uint8Array(value);
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TBS$4:
            return EMPTY_BUFFER;
          case VERSION$f:
            return 0;
          case SERIAL_NUMBER$3:
            return new asn1js__namespace.Integer();
          case SIGNATURE$4:
            return new AlgorithmIdentifier();
          case ISSUER$2:
            return new RelativeDistinguishedNames();
          case NOT_BEFORE:
            return new Time();
          case NOT_AFTER:
            return new Time();
          case SUBJECT$1:
            return new RelativeDistinguishedNames();
          case SUBJECT_PUBLIC_KEY_INFO:
            return new PublicKeyInfo();
          case ISSUER_UNIQUE_ID:
            return EMPTY_BUFFER;
          case SUBJECT_UNIQUE_ID:
            return EMPTY_BUFFER;
          case EXTENSIONS$2:
            return [];
          case SIGNATURE_ALGORITHM$5:
            return new AlgorithmIdentifier();
          case SIGNATURE_VALUE$2:
            return new asn1js__namespace.BitString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            tbsCertificate(names.tbsCertificate),
            AlgorithmIdentifier.schema(names.signatureAlgorithm || {
              names: {
                blockName: SIGNATURE_ALGORITHM$5
              }
            }),
            new asn1js__namespace.BitString({ name: names.signatureValue || SIGNATURE_VALUE$2 })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$Q);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _Certificate.schema({
          names: {
            tbsCertificate: {
              names: {
                extensions: {
                  names: {
                    extensions: TBS_CERTIFICATE_EXTENSIONS
                  }
                }
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.tbsView = asn1.result.tbsCertificate.valueBeforeDecodeView;
        if (TBS_CERTIFICATE_VERSION in asn1.result)
          this.version = asn1.result[TBS_CERTIFICATE_VERSION].valueBlock.valueDec;
        this.serialNumber = asn1.result[TBS_CERTIFICATE_SERIAL_NUMBER];
        this.signature = new AlgorithmIdentifier({ schema: asn1.result[TBS_CERTIFICATE_SIGNATURE] });
        this.issuer = new RelativeDistinguishedNames({ schema: asn1.result[TBS_CERTIFICATE_ISSUER] });
        this.notBefore = new Time({ schema: asn1.result[TBS_CERTIFICATE_NOT_BEFORE] });
        this.notAfter = new Time({ schema: asn1.result[TBS_CERTIFICATE_NOT_AFTER] });
        this.subject = new RelativeDistinguishedNames({ schema: asn1.result[TBS_CERTIFICATE_SUBJECT] });
        this.subjectPublicKeyInfo = new PublicKeyInfo({ schema: asn1.result[TBS_CERTIFICATE_SUBJECT_PUBLIC_KEY] });
        if (TBS_CERTIFICATE_ISSUER_UNIQUE_ID in asn1.result)
          this.issuerUniqueID = asn1.result[TBS_CERTIFICATE_ISSUER_UNIQUE_ID].valueBlock.valueHex;
        if (TBS_CERTIFICATE_SUBJECT_UNIQUE_ID in asn1.result)
          this.subjectUniqueID = asn1.result[TBS_CERTIFICATE_SUBJECT_UNIQUE_ID].valueBlock.valueHex;
        if (TBS_CERTIFICATE_EXTENSIONS in asn1.result)
          this.extensions = Array.from(asn1.result[TBS_CERTIFICATE_EXTENSIONS], (element) => new Extension({ schema: element }));
        this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
        this.signatureValue = asn1.result.signatureValue;
      }
      encodeTBS() {
        const outputArray = [];
        if (VERSION$f in this && this.version !== _Certificate.defaultValues(VERSION$f)) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [
              new asn1js__namespace.Integer({ value: this.version })
            ]
          }));
        }
        outputArray.push(this.serialNumber);
        outputArray.push(this.signature.toSchema());
        outputArray.push(this.issuer.toSchema());
        outputArray.push(new asn1js__namespace.Sequence({
          value: [
            this.notBefore.toSchema(),
            this.notAfter.toSchema()
          ]
        }));
        outputArray.push(this.subject.toSchema());
        outputArray.push(this.subjectPublicKeyInfo.toSchema());
        if (this.issuerUniqueID) {
          outputArray.push(new asn1js__namespace.Primitive({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            valueHex: this.issuerUniqueID
          }));
        }
        if (this.subjectUniqueID) {
          outputArray.push(new asn1js__namespace.Primitive({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            valueHex: this.subjectUniqueID
          }));
        }
        if (this.extensions) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 3
            },
            value: [new asn1js__namespace.Sequence({
              value: Array.from(this.extensions, (o) => o.toSchema())
            })]
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toSchema(encodeFlag = false) {
        let tbsSchema;
        if (encodeFlag === false) {
          if (!this.tbsView.byteLength) {
            return _Certificate.schema().value[0];
          }
          const asn1 = asn1js__namespace.fromBER(this.tbsView);
          AsnError.assert(asn1, "TBS Certificate");
          tbsSchema = asn1.result;
        } else {
          tbsSchema = this.encodeTBS();
        }
        return new asn1js__namespace.Sequence({
          value: [
            tbsSchema,
            this.signatureAlgorithm.toSchema(),
            this.signatureValue
          ]
        });
      }
      toJSON() {
        const res = {
          tbs: pvtsutils__namespace.Convert.ToHex(this.tbsView),
          version: this.version,
          serialNumber: this.serialNumber.toJSON(),
          signature: this.signature.toJSON(),
          issuer: this.issuer.toJSON(),
          notBefore: this.notBefore.toJSON(),
          notAfter: this.notAfter.toJSON(),
          subject: this.subject.toJSON(),
          subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signatureValue: this.signatureValue.toJSON()
        };
        if (VERSION$f in this && this.version !== _Certificate.defaultValues(VERSION$f)) {
          res.version = this.version;
        }
        if (this.issuerUniqueID) {
          res.issuerUniqueID = pvtsutils__namespace.Convert.ToHex(this.issuerUniqueID);
        }
        if (this.subjectUniqueID) {
          res.subjectUniqueID = pvtsutils__namespace.Convert.ToHex(this.subjectUniqueID);
        }
        if (this.extensions) {
          res.extensions = Array.from(this.extensions, (o) => o.toJSON());
        }
        return res;
      }
      async getPublicKey(parameters, crypto2 = getCrypto(true)) {
        return crypto2.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
      }
      async getKeyHash(hashAlgorithm = "SHA-1", crypto2 = getCrypto(true)) {
        return crypto2.digest({ name: hashAlgorithm }, this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);
      }
      async sign(privateKey, hashAlgorithm = "SHA-1", crypto2 = getCrypto(true)) {
        if (!privateKey) {
          throw new Error("Need to provide a private key for signing");
        }
        const signatureParameters = await crypto2.getSignatureParameters(privateKey, hashAlgorithm);
        const parameters = signatureParameters.parameters;
        this.signature = signatureParameters.signatureAlgorithm;
        this.signatureAlgorithm = signatureParameters.signatureAlgorithm;
        this.tbsView = new Uint8Array(this.encodeTBS().toBER());
        const signature = await crypto2.signWithPrivateKey(this.tbsView, privateKey, parameters);
        this.signatureValue = new asn1js__namespace.BitString({ valueHex: signature });
      }
      async verify(issuerCertificate, crypto2 = getCrypto(true)) {
        let subjectPublicKeyInfo;
        if (issuerCertificate) {
          subjectPublicKeyInfo = issuerCertificate.subjectPublicKeyInfo;
        } else if (this.issuer.isEqual(this.subject)) {
          subjectPublicKeyInfo = this.subjectPublicKeyInfo;
        }
        if (!(subjectPublicKeyInfo instanceof PublicKeyInfo)) {
          throw new Error("Please provide issuer certificate as a parameter");
        }
        return crypto2.verifyWithPublicKey(this.tbsView, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm);
      }
    };
    Certificate.CLASS_NAME = "Certificate";
    function checkCA(cert, signerCert = null) {
      if (signerCert && cert.issuer.isEqual(signerCert.issuer) && cert.serialNumber.isEqual(signerCert.serialNumber)) {
        return null;
      }
      let isCA = false;
      if (cert.extensions) {
        for (const extension of cert.extensions) {
          if (extension.extnID === id_BasicConstraints && extension.parsedValue instanceof BasicConstraints) {
            if (extension.parsedValue.cA) {
              isCA = true;
              break;
            }
          }
        }
      }
      if (isCA) {
        return cert;
      }
      return null;
    }
    var CERT_ID$1 = "certId";
    var CERT_VALUE = "certValue";
    var PARSED_VALUE$4 = "parsedValue";
    var CLEAR_PROPS$P = [
      CERT_ID$1,
      CERT_VALUE
    ];
    var CertBag = class _CertBag extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.certId = pvutils__namespace.getParametersValue(parameters, CERT_ID$1, _CertBag.defaultValues(CERT_ID$1));
        this.certValue = pvutils__namespace.getParametersValue(parameters, CERT_VALUE, _CertBag.defaultValues(CERT_VALUE));
        if (PARSED_VALUE$4 in parameters) {
          this.parsedValue = pvutils__namespace.getParametersValue(parameters, PARSED_VALUE$4, _CertBag.defaultValues(PARSED_VALUE$4));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case CERT_ID$1:
            return EMPTY_STRING;
          case CERT_VALUE:
            return new asn1js__namespace.Any();
          case PARSED_VALUE$4:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CERT_ID$1:
            return memberValue === EMPTY_STRING;
          case CERT_VALUE:
            return memberValue instanceof asn1js__namespace.Any;
          case PARSED_VALUE$4:
            return memberValue instanceof Object && Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.id || "id" }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.Any({ name: names.value || "value" })]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$P);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _CertBag.schema({
          names: {
            id: CERT_ID$1,
            value: CERT_VALUE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.certId = asn1.result.certId.valueBlock.toString();
        this.certValue = asn1.result.certValue;
        const certValueHex = this.certValue.valueBlock.valueHexView;
        switch (this.certId) {
          case id_CertBag_X509Certificate:
            {
              try {
                this.parsedValue = Certificate.fromBER(certValueHex);
              } catch (ex) {
                AttributeCertificateV2.fromBER(certValueHex);
              }
            }
            break;
          case id_CertBag_AttributeCertificate:
            {
              this.parsedValue = AttributeCertificateV2.fromBER(certValueHex);
            }
            break;
          case id_CertBag_SDSICertificate:
          default:
            throw new Error(`Incorrect CERT_ID value in CertBag: ${this.certId}`);
        }
      }
      toSchema() {
        if (PARSED_VALUE$4 in this) {
          if ("acinfo" in this.parsedValue) {
            this.certId = id_CertBag_AttributeCertificate;
          } else {
            this.certId = id_CertBag_X509Certificate;
          }
          this.certValue = new asn1js__namespace.OctetString({ valueHex: this.parsedValue.toSchema().toBER(false) });
        }
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.certId }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: ["toSchema" in this.certValue ? this.certValue.toSchema() : this.certValue]
            })
          ]
        });
      }
      toJSON() {
        return {
          certId: this.certId,
          certValue: this.certValue.toJSON()
        };
      }
    };
    CertBag.CLASS_NAME = "CertBag";
    var USER_CERTIFICATE = "userCertificate";
    var REVOCATION_DATE = "revocationDate";
    var CRL_ENTRY_EXTENSIONS = "crlEntryExtensions";
    var CLEAR_PROPS$O = [
      USER_CERTIFICATE,
      REVOCATION_DATE,
      CRL_ENTRY_EXTENSIONS
    ];
    var RevokedCertificate = class _RevokedCertificate extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.userCertificate = pvutils__namespace.getParametersValue(parameters, USER_CERTIFICATE, _RevokedCertificate.defaultValues(USER_CERTIFICATE));
        this.revocationDate = pvutils__namespace.getParametersValue(parameters, REVOCATION_DATE, _RevokedCertificate.defaultValues(REVOCATION_DATE));
        if (CRL_ENTRY_EXTENSIONS in parameters) {
          this.crlEntryExtensions = pvutils__namespace.getParametersValue(parameters, CRL_ENTRY_EXTENSIONS, _RevokedCertificate.defaultValues(CRL_ENTRY_EXTENSIONS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case USER_CERTIFICATE:
            return new asn1js__namespace.Integer();
          case REVOCATION_DATE:
            return new Time();
          case CRL_ENTRY_EXTENSIONS:
            return new Extensions();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.userCertificate || USER_CERTIFICATE }),
            Time.schema({
              names: {
                utcTimeName: names.revocationDate || REVOCATION_DATE,
                generalTimeName: names.revocationDate || REVOCATION_DATE
              }
            }),
            Extensions.schema({
              names: {
                blockName: names.crlEntryExtensions || CRL_ENTRY_EXTENSIONS
              }
            }, true)
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$O);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RevokedCertificate.schema());
        AsnError.assertSchema(asn1, this.className);
        this.userCertificate = asn1.result.userCertificate;
        this.revocationDate = new Time({ schema: asn1.result.revocationDate });
        if (CRL_ENTRY_EXTENSIONS in asn1.result) {
          this.crlEntryExtensions = new Extensions({ schema: asn1.result.crlEntryExtensions });
        }
      }
      toSchema() {
        const outputArray = [
          this.userCertificate,
          this.revocationDate.toSchema()
        ];
        if (this.crlEntryExtensions) {
          outputArray.push(this.crlEntryExtensions.toSchema());
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          userCertificate: this.userCertificate.toJSON(),
          revocationDate: this.revocationDate.toJSON()
        };
        if (this.crlEntryExtensions) {
          res.crlEntryExtensions = this.crlEntryExtensions.toJSON();
        }
        return res;
      }
    };
    RevokedCertificate.CLASS_NAME = "RevokedCertificate";
    var TBS$3 = "tbs";
    var VERSION$e = "version";
    var SIGNATURE$3 = "signature";
    var ISSUER$1 = "issuer";
    var THIS_UPDATE$1 = "thisUpdate";
    var NEXT_UPDATE$1 = "nextUpdate";
    var REVOKED_CERTIFICATES = "revokedCertificates";
    var CRL_EXTENSIONS = "crlExtensions";
    var SIGNATURE_ALGORITHM$4 = "signatureAlgorithm";
    var SIGNATURE_VALUE$1 = "signatureValue";
    var TBS_CERT_LIST = "tbsCertList";
    var TBS_CERT_LIST_VERSION = `${TBS_CERT_LIST}.version`;
    var TBS_CERT_LIST_SIGNATURE = `${TBS_CERT_LIST}.signature`;
    var TBS_CERT_LIST_ISSUER = `${TBS_CERT_LIST}.issuer`;
    var TBS_CERT_LIST_THIS_UPDATE = `${TBS_CERT_LIST}.thisUpdate`;
    var TBS_CERT_LIST_NEXT_UPDATE = `${TBS_CERT_LIST}.nextUpdate`;
    var TBS_CERT_LIST_REVOKED_CERTIFICATES = `${TBS_CERT_LIST}.revokedCertificates`;
    var TBS_CERT_LIST_EXTENSIONS = `${TBS_CERT_LIST}.extensions`;
    var CLEAR_PROPS$N = [
      TBS_CERT_LIST,
      TBS_CERT_LIST_VERSION,
      TBS_CERT_LIST_SIGNATURE,
      TBS_CERT_LIST_ISSUER,
      TBS_CERT_LIST_THIS_UPDATE,
      TBS_CERT_LIST_NEXT_UPDATE,
      TBS_CERT_LIST_REVOKED_CERTIFICATES,
      TBS_CERT_LIST_EXTENSIONS,
      SIGNATURE_ALGORITHM$4,
      SIGNATURE_VALUE$1
    ];
    function tbsCertList(parameters = {}) {
      const names = pvutils__namespace.getParametersValue(parameters, "names", {});
      return new asn1js__namespace.Sequence({
        name: names.blockName || TBS_CERT_LIST,
        value: [
          new asn1js__namespace.Integer({
            optional: true,
            name: names.tbsCertListVersion || TBS_CERT_LIST_VERSION,
            value: 2
          }),
          AlgorithmIdentifier.schema(names.signature || {
            names: {
              blockName: TBS_CERT_LIST_SIGNATURE
            }
          }),
          RelativeDistinguishedNames.schema(names.issuer || {
            names: {
              blockName: TBS_CERT_LIST_ISSUER
            }
          }),
          Time.schema(names.tbsCertListThisUpdate || {
            names: {
              utcTimeName: TBS_CERT_LIST_THIS_UPDATE,
              generalTimeName: TBS_CERT_LIST_THIS_UPDATE
            }
          }),
          Time.schema(names.tbsCertListNextUpdate || {
            names: {
              utcTimeName: TBS_CERT_LIST_NEXT_UPDATE,
              generalTimeName: TBS_CERT_LIST_NEXT_UPDATE
            }
          }, true),
          new asn1js__namespace.Sequence({
            optional: true,
            value: [
              new asn1js__namespace.Repeated({
                name: names.tbsCertListRevokedCertificates || TBS_CERT_LIST_REVOKED_CERTIFICATES,
                value: new asn1js__namespace.Sequence({
                  value: [
                    new asn1js__namespace.Integer(),
                    Time.schema(),
                    Extensions.schema({}, true)
                  ]
                })
              })
            ]
          }),
          new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [Extensions.schema(names.crlExtensions || {
              names: {
                blockName: TBS_CERT_LIST_EXTENSIONS
              }
            })]
          })
        ]
      });
    }
    var WELL_KNOWN_EXTENSIONS = [
      id_AuthorityKeyIdentifier,
      id_IssuerAltName,
      id_CRLNumber,
      id_BaseCRLNumber,
      id_IssuingDistributionPoint,
      id_FreshestCRL,
      id_AuthorityInfoAccess,
      id_CRLReason,
      id_InvalidityDate,
      id_CertificateIssuer
    ];
    var CertificateRevocationList = class _CertificateRevocationList extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.tbsView = new Uint8Array(pvutils__namespace.getParametersValue(parameters, TBS$3, _CertificateRevocationList.defaultValues(TBS$3)));
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$e, _CertificateRevocationList.defaultValues(VERSION$e));
        this.signature = pvutils__namespace.getParametersValue(parameters, SIGNATURE$3, _CertificateRevocationList.defaultValues(SIGNATURE$3));
        this.issuer = pvutils__namespace.getParametersValue(parameters, ISSUER$1, _CertificateRevocationList.defaultValues(ISSUER$1));
        this.thisUpdate = pvutils__namespace.getParametersValue(parameters, THIS_UPDATE$1, _CertificateRevocationList.defaultValues(THIS_UPDATE$1));
        if (NEXT_UPDATE$1 in parameters) {
          this.nextUpdate = pvutils__namespace.getParametersValue(parameters, NEXT_UPDATE$1, _CertificateRevocationList.defaultValues(NEXT_UPDATE$1));
        }
        if (REVOKED_CERTIFICATES in parameters) {
          this.revokedCertificates = pvutils__namespace.getParametersValue(parameters, REVOKED_CERTIFICATES, _CertificateRevocationList.defaultValues(REVOKED_CERTIFICATES));
        }
        if (CRL_EXTENSIONS in parameters) {
          this.crlExtensions = pvutils__namespace.getParametersValue(parameters, CRL_EXTENSIONS, _CertificateRevocationList.defaultValues(CRL_EXTENSIONS));
        }
        this.signatureAlgorithm = pvutils__namespace.getParametersValue(parameters, SIGNATURE_ALGORITHM$4, _CertificateRevocationList.defaultValues(SIGNATURE_ALGORITHM$4));
        this.signatureValue = pvutils__namespace.getParametersValue(parameters, SIGNATURE_VALUE$1, _CertificateRevocationList.defaultValues(SIGNATURE_VALUE$1));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      get tbs() {
        return pvtsutils__namespace.BufferSourceConverter.toArrayBuffer(this.tbsView);
      }
      set tbs(value) {
        this.tbsView = new Uint8Array(value);
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TBS$3:
            return EMPTY_BUFFER;
          case VERSION$e:
            return 0;
          case SIGNATURE$3:
            return new AlgorithmIdentifier();
          case ISSUER$1:
            return new RelativeDistinguishedNames();
          case THIS_UPDATE$1:
            return new Time();
          case NEXT_UPDATE$1:
            return new Time();
          case REVOKED_CERTIFICATES:
            return [];
          case CRL_EXTENSIONS:
            return new Extensions();
          case SIGNATURE_ALGORITHM$4:
            return new AlgorithmIdentifier();
          case SIGNATURE_VALUE$1:
            return new asn1js__namespace.BitString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || "CertificateList",
          value: [
            tbsCertList(parameters),
            AlgorithmIdentifier.schema(names.signatureAlgorithm || {
              names: {
                blockName: SIGNATURE_ALGORITHM$4
              }
            }),
            new asn1js__namespace.BitString({ name: names.signatureValue || SIGNATURE_VALUE$1 })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$N);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _CertificateRevocationList.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsView = asn1.result.tbsCertList.valueBeforeDecodeView;
        if (TBS_CERT_LIST_VERSION in asn1.result) {
          this.version = asn1.result[TBS_CERT_LIST_VERSION].valueBlock.valueDec;
        }
        this.signature = new AlgorithmIdentifier({ schema: asn1.result[TBS_CERT_LIST_SIGNATURE] });
        this.issuer = new RelativeDistinguishedNames({ schema: asn1.result[TBS_CERT_LIST_ISSUER] });
        this.thisUpdate = new Time({ schema: asn1.result[TBS_CERT_LIST_THIS_UPDATE] });
        if (TBS_CERT_LIST_NEXT_UPDATE in asn1.result) {
          this.nextUpdate = new Time({ schema: asn1.result[TBS_CERT_LIST_NEXT_UPDATE] });
        }
        if (TBS_CERT_LIST_REVOKED_CERTIFICATES in asn1.result) {
          this.revokedCertificates = Array.from(asn1.result[TBS_CERT_LIST_REVOKED_CERTIFICATES], (element) => new RevokedCertificate({ schema: element }));
        }
        if (TBS_CERT_LIST_EXTENSIONS in asn1.result) {
          this.crlExtensions = new Extensions({ schema: asn1.result[TBS_CERT_LIST_EXTENSIONS] });
        }
        this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
        this.signatureValue = asn1.result.signatureValue;
      }
      encodeTBS() {
        const outputArray = [];
        if (this.version !== _CertificateRevocationList.defaultValues(VERSION$e)) {
          outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
        }
        outputArray.push(this.signature.toSchema());
        outputArray.push(this.issuer.toSchema());
        outputArray.push(this.thisUpdate.toSchema());
        if (this.nextUpdate) {
          outputArray.push(this.nextUpdate.toSchema());
        }
        if (this.revokedCertificates) {
          outputArray.push(new asn1js__namespace.Sequence({
            value: Array.from(this.revokedCertificates, (o) => o.toSchema())
          }));
        }
        if (this.crlExtensions) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [
              this.crlExtensions.toSchema()
            ]
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toSchema(encodeFlag = false) {
        let tbsSchema;
        if (!encodeFlag) {
          if (!this.tbsView.byteLength) {
            return _CertificateRevocationList.schema();
          }
          const asn1 = asn1js__namespace.fromBER(this.tbsView);
          AsnError.assert(asn1, "TBS Certificate Revocation List");
          tbsSchema = asn1.result;
        } else {
          tbsSchema = this.encodeTBS();
        }
        return new asn1js__namespace.Sequence({
          value: [
            tbsSchema,
            this.signatureAlgorithm.toSchema(),
            this.signatureValue
          ]
        });
      }
      toJSON() {
        const res = {
          tbs: pvtsutils__namespace.Convert.ToHex(this.tbsView),
          version: this.version,
          signature: this.signature.toJSON(),
          issuer: this.issuer.toJSON(),
          thisUpdate: this.thisUpdate.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signatureValue: this.signatureValue.toJSON()
        };
        if (this.version !== _CertificateRevocationList.defaultValues(VERSION$e))
          res.version = this.version;
        if (this.nextUpdate) {
          res.nextUpdate = this.nextUpdate.toJSON();
        }
        if (this.revokedCertificates) {
          res.revokedCertificates = Array.from(this.revokedCertificates, (o) => o.toJSON());
        }
        if (this.crlExtensions) {
          res.crlExtensions = this.crlExtensions.toJSON();
        }
        return res;
      }
      isCertificateRevoked(certificate) {
        if (!this.issuer.isEqual(certificate.issuer)) {
          return false;
        }
        if (!this.revokedCertificates) {
          return false;
        }
        for (const revokedCertificate of this.revokedCertificates) {
          if (revokedCertificate.userCertificate.isEqual(certificate.serialNumber)) {
            return true;
          }
        }
        return false;
      }
      async sign(privateKey, hashAlgorithm = "SHA-1", crypto2 = getCrypto(true)) {
        if (!privateKey) {
          throw new Error("Need to provide a private key for signing");
        }
        const signatureParameters = await crypto2.getSignatureParameters(privateKey, hashAlgorithm);
        const { parameters } = signatureParameters;
        this.signature = signatureParameters.signatureAlgorithm;
        this.signatureAlgorithm = signatureParameters.signatureAlgorithm;
        this.tbsView = new Uint8Array(this.encodeTBS().toBER());
        const signature = await crypto2.signWithPrivateKey(this.tbsView, privateKey, parameters);
        this.signatureValue = new asn1js__namespace.BitString({ valueHex: signature });
      }
      async verify(parameters = {}, crypto2 = getCrypto(true)) {
        let subjectPublicKeyInfo;
        if (parameters.issuerCertificate) {
          subjectPublicKeyInfo = parameters.issuerCertificate.subjectPublicKeyInfo;
          if (!this.issuer.isEqual(parameters.issuerCertificate.subject)) {
            return false;
          }
        }
        if (parameters.publicKeyInfo) {
          subjectPublicKeyInfo = parameters.publicKeyInfo;
        }
        if (!subjectPublicKeyInfo) {
          throw new Error("Issuer's certificate must be provided as an input parameter");
        }
        if (this.crlExtensions) {
          for (const extension of this.crlExtensions.extensions) {
            if (extension.critical) {
              if (!WELL_KNOWN_EXTENSIONS.includes(extension.extnID))
                return false;
            }
          }
        }
        return crypto2.verifyWithPublicKey(this.tbsView, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm);
      }
    };
    CertificateRevocationList.CLASS_NAME = "CertificateRevocationList";
    var CRL_ID = "crlId";
    var CRL_VALUE = "crlValue";
    var PARSED_VALUE$3 = "parsedValue";
    var CLEAR_PROPS$M = [
      CRL_ID,
      CRL_VALUE
    ];
    var CRLBag = class _CRLBag extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.crlId = pvutils__namespace.getParametersValue(parameters, CRL_ID, _CRLBag.defaultValues(CRL_ID));
        this.crlValue = pvutils__namespace.getParametersValue(parameters, CRL_VALUE, _CRLBag.defaultValues(CRL_VALUE));
        if (PARSED_VALUE$3 in parameters) {
          this.parsedValue = pvutils__namespace.getParametersValue(parameters, PARSED_VALUE$3, _CRLBag.defaultValues(PARSED_VALUE$3));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case CRL_ID:
            return EMPTY_STRING;
          case CRL_VALUE:
            return new asn1js__namespace.Any();
          case PARSED_VALUE$3:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CRL_ID:
            return memberValue === EMPTY_STRING;
          case CRL_VALUE:
            return memberValue instanceof asn1js__namespace.Any;
          case PARSED_VALUE$3:
            return memberValue instanceof Object && Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.id || "id" }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.Any({ name: names.value || "value" })]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$M);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _CRLBag.schema({
          names: {
            id: CRL_ID,
            value: CRL_VALUE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.crlId = asn1.result.crlId.valueBlock.toString();
        this.crlValue = asn1.result.crlValue;
        switch (this.crlId) {
          case id_CRLBag_X509CRL:
            {
              this.parsedValue = CertificateRevocationList.fromBER(this.certValue.valueBlock.valueHex);
            }
            break;
          default:
            throw new Error(`Incorrect CRL_ID value in CRLBag: ${this.crlId}`);
        }
      }
      toSchema() {
        if (this.parsedValue) {
          this.crlId = id_CRLBag_X509CRL;
          this.crlValue = new asn1js__namespace.OctetString({ valueHex: this.parsedValue.toSchema().toBER(false) });
        }
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.crlId }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [this.crlValue.toSchema()]
            })
          ]
        });
      }
      toJSON() {
        return {
          crlId: this.crlId,
          crlValue: this.crlValue.toJSON()
        };
      }
    };
    CRLBag.CLASS_NAME = "CRLBag";
    var VERSION$d = "version";
    var ENCRYPTED_CONTENT_INFO$1 = "encryptedContentInfo";
    var UNPROTECTED_ATTRS$1 = "unprotectedAttrs";
    var CLEAR_PROPS$L = [
      VERSION$d,
      ENCRYPTED_CONTENT_INFO$1,
      UNPROTECTED_ATTRS$1
    ];
    var EncryptedData = class _EncryptedData extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$d, _EncryptedData.defaultValues(VERSION$d));
        this.encryptedContentInfo = pvutils__namespace.getParametersValue(parameters, ENCRYPTED_CONTENT_INFO$1, _EncryptedData.defaultValues(ENCRYPTED_CONTENT_INFO$1));
        if (UNPROTECTED_ATTRS$1 in parameters) {
          this.unprotectedAttrs = pvutils__namespace.getParametersValue(parameters, UNPROTECTED_ATTRS$1, _EncryptedData.defaultValues(UNPROTECTED_ATTRS$1));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$d:
            return 0;
          case ENCRYPTED_CONTENT_INFO$1:
            return new EncryptedContentInfo();
          case UNPROTECTED_ATTRS$1:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$d:
            return memberValue === 0;
          case ENCRYPTED_CONTENT_INFO$1:
            return EncryptedContentInfo.compareWithDefault("contentType", memberValue.contentType) && EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm) && EncryptedContentInfo.compareWithDefault("encryptedContent", memberValue.encryptedContent);
          case UNPROTECTED_ATTRS$1:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || EMPTY_STRING }),
            EncryptedContentInfo.schema(names.encryptedContentInfo || {}),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [
                new asn1js__namespace.Repeated({
                  name: names.unprotectedAttrs || EMPTY_STRING,
                  value: Attribute.schema()
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$L);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _EncryptedData.schema({
          names: {
            version: VERSION$d,
            encryptedContentInfo: {
              names: {
                blockName: ENCRYPTED_CONTENT_INFO$1
              }
            },
            unprotectedAttrs: UNPROTECTED_ATTRS$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.encryptedContentInfo = new EncryptedContentInfo({ schema: asn1.result.encryptedContentInfo });
        if (UNPROTECTED_ATTRS$1 in asn1.result)
          this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, (element) => new Attribute({ schema: element }));
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
        outputArray.push(this.encryptedContentInfo.toSchema());
        if (this.unprotectedAttrs) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.unprotectedAttrs, (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          version: this.version,
          encryptedContentInfo: this.encryptedContentInfo.toJSON()
        };
        if (this.unprotectedAttrs)
          res.unprotectedAttrs = Array.from(this.unprotectedAttrs, (o) => o.toJSON());
        return res;
      }
      async encrypt(parameters, crypto2 = getCrypto(true)) {
        ArgumentError.assert(parameters, "parameters", "object");
        const encryptParams = {
          ...parameters,
          contentType: "1.2.840.113549.1.7.1"
        };
        this.encryptedContentInfo = await crypto2.encryptEncryptedContentInfo(encryptParams);
      }
      async decrypt(parameters, crypto2 = getCrypto(true)) {
        ArgumentError.assert(parameters, "parameters", "object");
        const decryptParams = {
          ...parameters,
          encryptedContentInfo: this.encryptedContentInfo
        };
        return crypto2.decryptEncryptedContentInfo(decryptParams);
      }
    };
    EncryptedData.CLASS_NAME = "EncryptedData";
    var ENCRYPTION_ALGORITHM = "encryptionAlgorithm";
    var ENCRYPTED_DATA = "encryptedData";
    var PARSED_VALUE$2 = "parsedValue";
    var CLEAR_PROPS$K = [
      ENCRYPTION_ALGORITHM,
      ENCRYPTED_DATA
    ];
    var PKCS8ShroudedKeyBag = class _PKCS8ShroudedKeyBag extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.encryptionAlgorithm = pvutils__namespace.getParametersValue(parameters, ENCRYPTION_ALGORITHM, _PKCS8ShroudedKeyBag.defaultValues(ENCRYPTION_ALGORITHM));
        this.encryptedData = pvutils__namespace.getParametersValue(parameters, ENCRYPTED_DATA, _PKCS8ShroudedKeyBag.defaultValues(ENCRYPTED_DATA));
        if (PARSED_VALUE$2 in parameters) {
          this.parsedValue = pvutils__namespace.getParametersValue(parameters, PARSED_VALUE$2, _PKCS8ShroudedKeyBag.defaultValues(PARSED_VALUE$2));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ENCRYPTION_ALGORITHM:
            return new AlgorithmIdentifier();
          case ENCRYPTED_DATA:
            return new asn1js__namespace.OctetString();
          case PARSED_VALUE$2:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ENCRYPTION_ALGORITHM:
            return AlgorithmIdentifier.compareWithDefault("algorithmId", memberValue.algorithmId) && "algorithmParams" in memberValue === false;
          case ENCRYPTED_DATA:
            return memberValue.isEqual(_PKCS8ShroudedKeyBag.defaultValues(memberName));
          case PARSED_VALUE$2:
            return memberValue instanceof Object && Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            AlgorithmIdentifier.schema(names.encryptionAlgorithm || {
              names: {
                blockName: ENCRYPTION_ALGORITHM
              }
            }),
            new asn1js__namespace.Choice({
              value: [
                new asn1js__namespace.OctetString({ name: names.encryptedData || ENCRYPTED_DATA }),
                new asn1js__namespace.OctetString({
                  idBlock: {
                    isConstructed: true
                  },
                  name: names.encryptedData || ENCRYPTED_DATA
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$K);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PKCS8ShroudedKeyBag.schema({
          names: {
            encryptionAlgorithm: {
              names: {
                blockName: ENCRYPTION_ALGORITHM
              }
            },
            encryptedData: ENCRYPTED_DATA
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.encryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.encryptionAlgorithm });
        this.encryptedData = asn1.result.encryptedData;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.encryptionAlgorithm.toSchema(),
            this.encryptedData
          ]
        });
      }
      toJSON() {
        return {
          encryptionAlgorithm: this.encryptionAlgorithm.toJSON(),
          encryptedData: this.encryptedData.toJSON()
        };
      }
      async parseInternalValues(parameters, crypto2 = getCrypto(true)) {
        const cmsEncrypted = new EncryptedData({
          encryptedContentInfo: new EncryptedContentInfo({
            contentEncryptionAlgorithm: this.encryptionAlgorithm,
            encryptedContent: this.encryptedData
          })
        });
        const decryptedData = await cmsEncrypted.decrypt(parameters, crypto2);
        this.parsedValue = PrivateKeyInfo.fromBER(decryptedData);
      }
      async makeInternalValues(parameters, crypto2 = getCrypto(true)) {
        if (!this.parsedValue) {
          throw new Error('Please initialize "parsedValue" first');
        }
        const cmsEncrypted = new EncryptedData();
        const encryptParams = {
          ...parameters,
          contentToEncrypt: this.parsedValue.toSchema().toBER(false)
        };
        await cmsEncrypted.encrypt(encryptParams, crypto2);
        if (!cmsEncrypted.encryptedContentInfo.encryptedContent) {
          throw new Error("The filed `encryptedContent` in EncryptedContentInfo is empty");
        }
        this.encryptionAlgorithm = cmsEncrypted.encryptedContentInfo.contentEncryptionAlgorithm;
        this.encryptedData = cmsEncrypted.encryptedContentInfo.encryptedContent;
      }
    };
    PKCS8ShroudedKeyBag.CLASS_NAME = "PKCS8ShroudedKeyBag";
    var SECRET_TYPE_ID = "secretTypeId";
    var SECRET_VALUE = "secretValue";
    var CLEAR_PROPS$J = [
      SECRET_TYPE_ID,
      SECRET_VALUE
    ];
    var SecretBag = class _SecretBag extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.secretTypeId = pvutils__namespace.getParametersValue(parameters, SECRET_TYPE_ID, _SecretBag.defaultValues(SECRET_TYPE_ID));
        this.secretValue = pvutils__namespace.getParametersValue(parameters, SECRET_VALUE, _SecretBag.defaultValues(SECRET_VALUE));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case SECRET_TYPE_ID:
            return EMPTY_STRING;
          case SECRET_VALUE:
            return new asn1js__namespace.Any();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SECRET_TYPE_ID:
            return memberValue === EMPTY_STRING;
          case SECRET_VALUE:
            return memberValue instanceof asn1js__namespace.Any;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.id || "id" }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.Any({ name: names.value || "value" })]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$J);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _SecretBag.schema({
          names: {
            id: SECRET_TYPE_ID,
            value: SECRET_VALUE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.secretTypeId = asn1.result.secretTypeId.valueBlock.toString();
        this.secretValue = asn1.result.secretValue;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.secretTypeId }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [this.secretValue.toSchema()]
            })
          ]
        });
      }
      toJSON() {
        return {
          secretTypeId: this.secretTypeId,
          secretValue: this.secretValue.toJSON()
        };
      }
    };
    SecretBag.CLASS_NAME = "SecretBag";
    var SafeBagValueFactory = class _SafeBagValueFactory {
      static getItems() {
        if (!this.items) {
          this.items = {};
          _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.1", PrivateKeyInfo);
          _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.2", PKCS8ShroudedKeyBag);
          _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.3", CertBag);
          _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.4", CRLBag);
          _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.5", SecretBag);
          _SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.6", SafeContents);
        }
        return this.items;
      }
      static register(id, type) {
        this.getItems()[id] = type;
      }
      static find(id) {
        return this.getItems()[id] || null;
      }
    };
    var BAG_ID = "bagId";
    var BAG_VALUE = "bagValue";
    var BAG_ATTRIBUTES = "bagAttributes";
    var CLEAR_PROPS$I = [
      BAG_ID,
      BAG_VALUE,
      BAG_ATTRIBUTES
    ];
    var SafeBag = class _SafeBag extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.bagId = pvutils__namespace.getParametersValue(parameters, BAG_ID, _SafeBag.defaultValues(BAG_ID));
        this.bagValue = pvutils__namespace.getParametersValue(parameters, BAG_VALUE, _SafeBag.defaultValues(BAG_VALUE));
        if (BAG_ATTRIBUTES in parameters) {
          this.bagAttributes = pvutils__namespace.getParametersValue(parameters, BAG_ATTRIBUTES, _SafeBag.defaultValues(BAG_ATTRIBUTES));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case BAG_ID:
            return EMPTY_STRING;
          case BAG_VALUE:
            return new asn1js__namespace.Any();
          case BAG_ATTRIBUTES:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case BAG_ID:
            return memberValue === EMPTY_STRING;
          case BAG_VALUE:
            return memberValue instanceof asn1js__namespace.Any;
          case BAG_ATTRIBUTES:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.bagId || BAG_ID }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.Any({ name: names.bagValue || BAG_VALUE })]
            }),
            new asn1js__namespace.Set({
              optional: true,
              value: [
                new asn1js__namespace.Repeated({
                  name: names.bagAttributes || BAG_ATTRIBUTES,
                  value: Attribute.schema()
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$I);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _SafeBag.schema({
          names: {
            bagId: BAG_ID,
            bagValue: BAG_VALUE,
            bagAttributes: BAG_ATTRIBUTES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.bagId = asn1.result.bagId.valueBlock.toString();
        const bagType = SafeBagValueFactory.find(this.bagId);
        if (!bagType) {
          throw new Error(`Invalid BAG_ID for SafeBag: ${this.bagId}`);
        }
        this.bagValue = new bagType({ schema: asn1.result.bagValue });
        if (BAG_ATTRIBUTES in asn1.result) {
          this.bagAttributes = Array.from(asn1.result.bagAttributes, (element) => new Attribute({ schema: element }));
        }
      }
      toSchema() {
        const outputArray = [
          new asn1js__namespace.ObjectIdentifier({ value: this.bagId }),
          new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.bagValue.toSchema()]
          })
        ];
        if (this.bagAttributes) {
          outputArray.push(new asn1js__namespace.Set({
            value: Array.from(this.bagAttributes, (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const output = {
          bagId: this.bagId,
          bagValue: this.bagValue.toJSON()
        };
        if (this.bagAttributes) {
          output.bagAttributes = Array.from(this.bagAttributes, (o) => o.toJSON());
        }
        return output;
      }
    };
    SafeBag.CLASS_NAME = "SafeBag";
    var SAFE_BUGS = "safeBags";
    var SafeContents = class _SafeContents extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.safeBags = pvutils__namespace.getParametersValue(parameters, SAFE_BUGS, _SafeContents.defaultValues(SAFE_BUGS));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case SAFE_BUGS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SAFE_BUGS:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.safeBags || EMPTY_STRING,
              value: SafeBag.schema()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, [
          SAFE_BUGS
        ]);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _SafeContents.schema({
          names: {
            safeBags: SAFE_BUGS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.safeBags = Array.from(asn1.result.safeBags, (element) => new SafeBag({ schema: element }));
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.safeBags, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          safeBags: Array.from(this.safeBags, (o) => o.toJSON())
        };
      }
    };
    SafeContents.CLASS_NAME = "SafeContents";
    var OTHER_CERT_FORMAT = "otherCertFormat";
    var OTHER_CERT = "otherCert";
    var CLEAR_PROPS$H = [
      OTHER_CERT_FORMAT,
      OTHER_CERT
    ];
    var OtherCertificateFormat = class _OtherCertificateFormat extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.otherCertFormat = pvutils__namespace.getParametersValue(parameters, OTHER_CERT_FORMAT, _OtherCertificateFormat.defaultValues(OTHER_CERT_FORMAT));
        this.otherCert = pvutils__namespace.getParametersValue(parameters, OTHER_CERT, _OtherCertificateFormat.defaultValues(OTHER_CERT));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case OTHER_CERT_FORMAT:
            return EMPTY_STRING;
          case OTHER_CERT:
            return new asn1js__namespace.Any();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.otherCertFormat || OTHER_CERT_FORMAT }),
            new asn1js__namespace.Any({ name: names.otherCert || OTHER_CERT })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$H);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _OtherCertificateFormat.schema());
        AsnError.assertSchema(asn1, this.className);
        this.otherCertFormat = asn1.result.otherCertFormat.valueBlock.toString();
        this.otherCert = asn1.result.otherCert;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.otherCertFormat }),
            this.otherCert
          ]
        });
      }
      toJSON() {
        const res = {
          otherCertFormat: this.otherCertFormat
        };
        if (!(this.otherCert instanceof asn1js__namespace.Any)) {
          res.otherCert = this.otherCert.toJSON();
        }
        return res;
      }
    };
    var CERTIFICATES$1 = "certificates";
    var CLEAR_PROPS$G = [
      CERTIFICATES$1
    ];
    var CertificateSet = class _CertificateSet extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.certificates = pvutils__namespace.getParametersValue(parameters, CERTIFICATES$1, _CertificateSet.defaultValues(CERTIFICATES$1));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case CERTIFICATES$1:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Set({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.certificates || CERTIFICATES$1,
              value: new asn1js__namespace.Choice({
                value: [
                  Certificate.schema(),
                  new asn1js__namespace.Constructed({
                    idBlock: {
                      tagClass: 3,
                      tagNumber: 0
                    },
                    value: [
                      new asn1js__namespace.Any()
                    ]
                  }),
                  new asn1js__namespace.Constructed({
                    idBlock: {
                      tagClass: 3,
                      tagNumber: 1
                    },
                    value: [
                      new asn1js__namespace.Sequence()
                    ]
                  }),
                  new asn1js__namespace.Constructed({
                    idBlock: {
                      tagClass: 3,
                      tagNumber: 2
                    },
                    value: AttributeCertificateV2.schema().valueBlock.value
                  }),
                  new asn1js__namespace.Constructed({
                    idBlock: {
                      tagClass: 3,
                      tagNumber: 3
                    },
                    value: OtherCertificateFormat.schema().valueBlock.value
                  })
                ]
              })
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$G);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _CertificateSet.schema());
        AsnError.assertSchema(asn1, this.className);
        this.certificates = Array.from(asn1.result.certificates || [], (element) => {
          const initialTagNumber = element.idBlock.tagNumber;
          if (element.idBlock.tagClass === 1)
            return new Certificate({ schema: element });
          const elementSequence = new asn1js__namespace.Sequence({
            value: element.valueBlock.value
          });
          switch (initialTagNumber) {
            case 1:
              if (elementSequence.valueBlock.value[0].valueBlock.value[0].valueBlock.valueDec === 1) {
                return new AttributeCertificateV2({ schema: elementSequence });
              } else {
                return new AttributeCertificateV1({ schema: elementSequence });
              }
            case 2:
              return new AttributeCertificateV2({ schema: elementSequence });
            case 3:
              return new OtherCertificateFormat({ schema: elementSequence });
          }
          return element;
        });
      }
      toSchema() {
        return new asn1js__namespace.Set({
          value: Array.from(this.certificates, (element) => {
            switch (true) {
              case element instanceof Certificate:
                return element.toSchema();
              case element instanceof AttributeCertificateV1:
                return new asn1js__namespace.Constructed({
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                  },
                  value: element.toSchema().valueBlock.value
                });
              case element instanceof AttributeCertificateV2:
                return new asn1js__namespace.Constructed({
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                  },
                  value: element.toSchema().valueBlock.value
                });
              case element instanceof OtherCertificateFormat:
                return new asn1js__namespace.Constructed({
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 3
                  },
                  value: element.toSchema().valueBlock.value
                });
            }
            return element.toSchema();
          })
        });
      }
      toJSON() {
        return {
          certificates: Array.from(this.certificates, (o) => o.toJSON())
        };
      }
    };
    CertificateSet.CLASS_NAME = "CertificateSet";
    var OTHER_REV_INFO_FORMAT = "otherRevInfoFormat";
    var OTHER_REV_INFO = "otherRevInfo";
    var CLEAR_PROPS$F = [
      OTHER_REV_INFO_FORMAT,
      OTHER_REV_INFO
    ];
    var OtherRevocationInfoFormat = class _OtherRevocationInfoFormat extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.otherRevInfoFormat = pvutils__namespace.getParametersValue(parameters, OTHER_REV_INFO_FORMAT, _OtherRevocationInfoFormat.defaultValues(OTHER_REV_INFO_FORMAT));
        this.otherRevInfo = pvutils__namespace.getParametersValue(parameters, OTHER_REV_INFO, _OtherRevocationInfoFormat.defaultValues(OTHER_REV_INFO));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case OTHER_REV_INFO_FORMAT:
            return EMPTY_STRING;
          case OTHER_REV_INFO:
            return new asn1js__namespace.Any();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.otherRevInfoFormat || OTHER_REV_INFO_FORMAT }),
            new asn1js__namespace.Any({ name: names.otherRevInfo || OTHER_REV_INFO })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$F);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _OtherRevocationInfoFormat.schema());
        AsnError.assertSchema(asn1, this.className);
        this.otherRevInfoFormat = asn1.result.otherRevInfoFormat.valueBlock.toString();
        this.otherRevInfo = asn1.result.otherRevInfo;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.otherRevInfoFormat }),
            this.otherRevInfo
          ]
        });
      }
      toJSON() {
        const res = {
          otherRevInfoFormat: this.otherRevInfoFormat
        };
        if (!(this.otherRevInfo instanceof asn1js__namespace.Any)) {
          res.otherRevInfo = this.otherRevInfo.toJSON();
        }
        return res;
      }
    };
    OtherRevocationInfoFormat.CLASS_NAME = "OtherRevocationInfoFormat";
    var CRLS$3 = "crls";
    var OTHER_REVOCATION_INFOS = "otherRevocationInfos";
    var CLEAR_PROPS$E = [
      CRLS$3
    ];
    var RevocationInfoChoices = class _RevocationInfoChoices extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.crls = pvutils__namespace.getParametersValue(parameters, CRLS$3, _RevocationInfoChoices.defaultValues(CRLS$3));
        this.otherRevocationInfos = pvutils__namespace.getParametersValue(parameters, OTHER_REVOCATION_INFOS, _RevocationInfoChoices.defaultValues(OTHER_REVOCATION_INFOS));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case CRLS$3:
            return [];
          case OTHER_REVOCATION_INFOS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Set({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.crls || EMPTY_STRING,
              value: new asn1js__namespace.Choice({
                value: [
                  CertificateRevocationList.schema(),
                  new asn1js__namespace.Constructed({
                    idBlock: {
                      tagClass: 3,
                      tagNumber: 1
                    },
                    value: [
                      new asn1js__namespace.ObjectIdentifier(),
                      new asn1js__namespace.Any()
                    ]
                  })
                ]
              })
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$E);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RevocationInfoChoices.schema({
          names: {
            crls: CRLS$3
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (asn1.result.crls) {
          for (const element of asn1.result.crls) {
            if (element.idBlock.tagClass === 1)
              this.crls.push(new CertificateRevocationList({ schema: element }));
            else
              this.otherRevocationInfos.push(new OtherRevocationInfoFormat({ schema: element }));
          }
        }
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(...Array.from(this.crls, (o) => o.toSchema()));
        outputArray.push(...Array.from(this.otherRevocationInfos, (element) => {
          const schema = element.toSchema();
          schema.idBlock.tagClass = 3;
          schema.idBlock.tagNumber = 1;
          return schema;
        }));
        return new asn1js__namespace.Set({
          value: outputArray
        });
      }
      toJSON() {
        return {
          crls: Array.from(this.crls, (o) => o.toJSON()),
          otherRevocationInfos: Array.from(this.otherRevocationInfos, (o) => o.toJSON())
        };
      }
    };
    RevocationInfoChoices.CLASS_NAME = "RevocationInfoChoices";
    var CERTS$3 = "certs";
    var CRLS$2 = "crls";
    var CLEAR_PROPS$D = [
      CERTS$3,
      CRLS$2
    ];
    var OriginatorInfo = class _OriginatorInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.crls = pvutils__namespace.getParametersValue(parameters, CRLS$2, _OriginatorInfo.defaultValues(CRLS$2));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case CERTS$3:
            return new CertificateSet();
          case CRLS$2:
            return new RevocationInfoChoices();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CERTS$3:
            return memberValue.certificates.length === 0;
          case CRLS$2:
            return memberValue.crls.length === 0 && memberValue.otherRevocationInfos.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Constructed({
              name: names.certs || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: CertificateSet.schema().valueBlock.value
            }),
            new asn1js__namespace.Constructed({
              name: names.crls || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: RevocationInfoChoices.schema().valueBlock.value
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$D);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _OriginatorInfo.schema({
          names: {
            certs: CERTS$3,
            crls: CRLS$2
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (CERTS$3 in asn1.result) {
          this.certs = new CertificateSet({
            schema: new asn1js__namespace.Set({
              value: asn1.result.certs.valueBlock.value
            })
          });
        }
        if (CRLS$2 in asn1.result) {
          this.crls = new RevocationInfoChoices({
            schema: new asn1js__namespace.Set({
              value: asn1.result.crls.valueBlock.value
            })
          });
        }
      }
      toSchema() {
        const sequenceValue = [];
        if (this.certs) {
          sequenceValue.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.certs.toSchema().valueBlock.value
          }));
        }
        if (this.crls) {
          sequenceValue.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: this.crls.toSchema().valueBlock.value
          }));
        }
        return new asn1js__namespace.Sequence({
          value: sequenceValue
        });
      }
      toJSON() {
        const res = {};
        if (this.certs) {
          res.certs = this.certs.toJSON();
        }
        if (this.crls) {
          res.crls = this.crls.toJSON();
        }
        return res;
      }
    };
    OriginatorInfo.CLASS_NAME = "OriginatorInfo";
    var ISSUER = "issuer";
    var SERIAL_NUMBER$2 = "serialNumber";
    var CLEAR_PROPS$C = [
      ISSUER,
      SERIAL_NUMBER$2
    ];
    var IssuerAndSerialNumber = class _IssuerAndSerialNumber extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.issuer = pvutils__namespace.getParametersValue(parameters, ISSUER, _IssuerAndSerialNumber.defaultValues(ISSUER));
        this.serialNumber = pvutils__namespace.getParametersValue(parameters, SERIAL_NUMBER$2, _IssuerAndSerialNumber.defaultValues(SERIAL_NUMBER$2));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ISSUER:
            return new RelativeDistinguishedNames();
          case SERIAL_NUMBER$2:
            return new asn1js__namespace.Integer();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            RelativeDistinguishedNames.schema(names.issuer || {}),
            new asn1js__namespace.Integer({ name: names.serialNumber || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$C);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _IssuerAndSerialNumber.schema({
          names: {
            issuer: {
              names: {
                blockName: ISSUER
              }
            },
            serialNumber: SERIAL_NUMBER$2
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.issuer = new RelativeDistinguishedNames({ schema: asn1.result.issuer });
        this.serialNumber = asn1.result.serialNumber;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.issuer.toSchema(),
            this.serialNumber
          ]
        });
      }
      toJSON() {
        return {
          issuer: this.issuer.toJSON(),
          serialNumber: this.serialNumber.toJSON()
        };
      }
    };
    IssuerAndSerialNumber.CLASS_NAME = "IssuerAndSerialNumber";
    var VARIANT$3 = "variant";
    var VALUE$3 = "value";
    var CLEAR_PROPS$B = [
      "blockName"
    ];
    var RecipientIdentifier = class _RecipientIdentifier extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.variant = pvutils__namespace.getParametersValue(parameters, VARIANT$3, _RecipientIdentifier.defaultValues(VARIANT$3));
        if (VALUE$3 in parameters) {
          this.value = pvutils__namespace.getParametersValue(parameters, VALUE$3, _RecipientIdentifier.defaultValues(VALUE$3));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VARIANT$3:
            return -1;
          case VALUE$3:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VARIANT$3:
            return memberValue === -1;
          case VALUE$3:
            return Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Choice({
          value: [
            IssuerAndSerialNumber.schema({
              names: {
                blockName: names.blockName || EMPTY_STRING
              }
            }),
            new asn1js__namespace.Primitive({
              name: names.blockName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              }
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$B);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RecipientIdentifier.schema({
          names: {
            blockName: "blockName"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (asn1.result.blockName.idBlock.tagClass === 1) {
          this.variant = 1;
          this.value = new IssuerAndSerialNumber({ schema: asn1.result.blockName });
        } else {
          this.variant = 2;
          this.value = new asn1js__namespace.OctetString({ valueHex: asn1.result.blockName.valueBlock.valueHex });
        }
      }
      toSchema() {
        switch (this.variant) {
          case 1:
            if (!(this.value instanceof IssuerAndSerialNumber)) {
              throw new Error("Incorrect type of RecipientIdentifier.value. It should be IssuerAndSerialNumber.");
            }
            return this.value.toSchema();
          case 2:
            if (!(this.value instanceof asn1js__namespace.OctetString)) {
              throw new Error("Incorrect type of RecipientIdentifier.value. It should be ASN.1 OctetString.");
            }
            return new asn1js__namespace.Primitive({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              valueHex: this.value.valueBlock.valueHexView
            });
          default:
            return new asn1js__namespace.Any();
        }
      }
      toJSON() {
        const res = {
          variant: this.variant
        };
        if ((this.variant === 1 || this.variant === 2) && this.value) {
          res.value = this.value.toJSON();
        }
        return res;
      }
    };
    RecipientIdentifier.CLASS_NAME = "RecipientIdentifier";
    var VERSION$c = "version";
    var RID$1 = "rid";
    var KEY_ENCRYPTION_ALGORITHM$3 = "keyEncryptionAlgorithm";
    var ENCRYPTED_KEY$3 = "encryptedKey";
    var RECIPIENT_CERTIFICATE$1 = "recipientCertificate";
    var CLEAR_PROPS$A = [
      VERSION$c,
      RID$1,
      KEY_ENCRYPTION_ALGORITHM$3,
      ENCRYPTED_KEY$3
    ];
    var KeyTransRecipientInfo = class _KeyTransRecipientInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$c, _KeyTransRecipientInfo.defaultValues(VERSION$c));
        this.rid = pvutils__namespace.getParametersValue(parameters, RID$1, _KeyTransRecipientInfo.defaultValues(RID$1));
        this.keyEncryptionAlgorithm = pvutils__namespace.getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$3, _KeyTransRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$3));
        this.encryptedKey = pvutils__namespace.getParametersValue(parameters, ENCRYPTED_KEY$3, _KeyTransRecipientInfo.defaultValues(ENCRYPTED_KEY$3));
        this.recipientCertificate = pvutils__namespace.getParametersValue(parameters, RECIPIENT_CERTIFICATE$1, _KeyTransRecipientInfo.defaultValues(RECIPIENT_CERTIFICATE$1));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$c:
            return -1;
          case RID$1:
            return {};
          case KEY_ENCRYPTION_ALGORITHM$3:
            return new AlgorithmIdentifier();
          case ENCRYPTED_KEY$3:
            return new asn1js__namespace.OctetString();
          case RECIPIENT_CERTIFICATE$1:
            return new Certificate();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$c:
            return memberValue === _KeyTransRecipientInfo.defaultValues(VERSION$c);
          case RID$1:
            return Object.keys(memberValue).length === 0;
          case KEY_ENCRYPTION_ALGORITHM$3:
          case ENCRYPTED_KEY$3:
            return memberValue.isEqual(_KeyTransRecipientInfo.defaultValues(memberName));
          case RECIPIENT_CERTIFICATE$1:
            return false;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || EMPTY_STRING }),
            RecipientIdentifier.schema(names.rid || {}),
            AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
            new asn1js__namespace.OctetString({ name: names.encryptedKey || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$A);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _KeyTransRecipientInfo.schema({
          names: {
            version: VERSION$c,
            rid: {
              names: {
                blockName: RID$1
              }
            },
            keyEncryptionAlgorithm: {
              names: {
                blockName: KEY_ENCRYPTION_ALGORITHM$3
              }
            },
            encryptedKey: ENCRYPTED_KEY$3
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        if (asn1.result.rid.idBlock.tagClass === 3) {
          this.rid = new asn1js__namespace.OctetString({ valueHex: asn1.result.rid.valueBlock.valueHex });
        } else {
          this.rid = new IssuerAndSerialNumber({ schema: asn1.result.rid });
        }
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
        this.encryptedKey = asn1.result.encryptedKey;
      }
      toSchema() {
        const outputArray = [];
        if (this.rid instanceof IssuerAndSerialNumber) {
          this.version = 0;
          outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
          outputArray.push(this.rid.toSchema());
        } else {
          this.version = 2;
          outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
          outputArray.push(new asn1js__namespace.Primitive({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            valueHex: this.rid.valueBlock.valueHexView
          }));
        }
        outputArray.push(this.keyEncryptionAlgorithm.toSchema());
        outputArray.push(this.encryptedKey);
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        return {
          version: this.version,
          rid: this.rid.toJSON(),
          keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
          encryptedKey: this.encryptedKey.toJSON()
        };
      }
    };
    KeyTransRecipientInfo.CLASS_NAME = "KeyTransRecipientInfo";
    var ALGORITHM = "algorithm";
    var PUBLIC_KEY = "publicKey";
    var CLEAR_PROPS$z = [
      ALGORITHM,
      PUBLIC_KEY
    ];
    var OriginatorPublicKey = class _OriginatorPublicKey extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.algorithm = pvutils__namespace.getParametersValue(parameters, ALGORITHM, _OriginatorPublicKey.defaultValues(ALGORITHM));
        this.publicKey = pvutils__namespace.getParametersValue(parameters, PUBLIC_KEY, _OriginatorPublicKey.defaultValues(PUBLIC_KEY));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ALGORITHM:
            return new AlgorithmIdentifier();
          case PUBLIC_KEY:
            return new asn1js__namespace.BitString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ALGORITHM:
          case PUBLIC_KEY:
            return memberValue.isEqual(_OriginatorPublicKey.defaultValues(memberName));
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            AlgorithmIdentifier.schema(names.algorithm || {}),
            new asn1js__namespace.BitString({ name: names.publicKey || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$z);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _OriginatorPublicKey.schema({
          names: {
            algorithm: {
              names: {
                blockName: ALGORITHM
              }
            },
            publicKey: PUBLIC_KEY
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.algorithm = new AlgorithmIdentifier({ schema: asn1.result.algorithm });
        this.publicKey = asn1.result.publicKey;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.algorithm.toSchema(),
            this.publicKey
          ]
        });
      }
      toJSON() {
        return {
          algorithm: this.algorithm.toJSON(),
          publicKey: this.publicKey.toJSON()
        };
      }
    };
    OriginatorPublicKey.CLASS_NAME = "OriginatorPublicKey";
    var VARIANT$2 = "variant";
    var VALUE$2 = "value";
    var CLEAR_PROPS$y = [
      "blockName"
    ];
    var OriginatorIdentifierOrKey = class _OriginatorIdentifierOrKey extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.variant = pvutils__namespace.getParametersValue(parameters, VARIANT$2, _OriginatorIdentifierOrKey.defaultValues(VARIANT$2));
        if (VALUE$2 in parameters) {
          this.value = pvutils__namespace.getParametersValue(parameters, VALUE$2, _OriginatorIdentifierOrKey.defaultValues(VALUE$2));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VARIANT$2:
            return -1;
          case VALUE$2:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VARIANT$2:
            return memberValue === -1;
          case VALUE$2:
            return Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Choice({
          value: [
            IssuerAndSerialNumber.schema({
              names: {
                blockName: names.blockName || EMPTY_STRING
              }
            }),
            new asn1js__namespace.Primitive({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              name: names.blockName || EMPTY_STRING
            }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              name: names.blockName || EMPTY_STRING,
              value: OriginatorPublicKey.schema().valueBlock.value
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$y);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _OriginatorIdentifierOrKey.schema({
          names: {
            blockName: "blockName"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (asn1.result.blockName.idBlock.tagClass === 1) {
          this.variant = 1;
          this.value = new IssuerAndSerialNumber({ schema: asn1.result.blockName });
        } else {
          if (asn1.result.blockName.idBlock.tagNumber === 0) {
            asn1.result.blockName.idBlock.tagClass = 1;
            asn1.result.blockName.idBlock.tagNumber = 4;
            this.variant = 2;
            this.value = asn1.result.blockName;
          } else {
            this.variant = 3;
            this.value = new OriginatorPublicKey({
              schema: new asn1js__namespace.Sequence({
                value: asn1.result.blockName.valueBlock.value
              })
            });
          }
        }
      }
      toSchema() {
        switch (this.variant) {
          case 1:
            return this.value.toSchema();
          case 2:
            this.value.idBlock.tagClass = 3;
            this.value.idBlock.tagNumber = 0;
            return this.value;
          case 3: {
            const _schema = this.value.toSchema();
            _schema.idBlock.tagClass = 3;
            _schema.idBlock.tagNumber = 1;
            return _schema;
          }
          default:
            return new asn1js__namespace.Any();
        }
      }
      toJSON() {
        const res = {
          variant: this.variant
        };
        if (this.variant === 1 || this.variant === 2 || this.variant === 3) {
          res.value = this.value.toJSON();
        }
        return res;
      }
    };
    OriginatorIdentifierOrKey.CLASS_NAME = "OriginatorIdentifierOrKey";
    var KEY_ATTR_ID = "keyAttrId";
    var KEY_ATTR = "keyAttr";
    var CLEAR_PROPS$x = [
      KEY_ATTR_ID,
      KEY_ATTR
    ];
    var OtherKeyAttribute = class _OtherKeyAttribute extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.keyAttrId = pvutils__namespace.getParametersValue(parameters, KEY_ATTR_ID, _OtherKeyAttribute.defaultValues(KEY_ATTR_ID));
        if (KEY_ATTR in parameters) {
          this.keyAttr = pvutils__namespace.getParametersValue(parameters, KEY_ATTR, _OtherKeyAttribute.defaultValues(KEY_ATTR));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case KEY_ATTR_ID:
            return EMPTY_STRING;
          case KEY_ATTR:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case KEY_ATTR_ID:
            return typeof memberValue === "string" && memberValue === EMPTY_STRING;
          case KEY_ATTR:
            return Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          optional: names.optional || true,
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.keyAttrId || EMPTY_STRING }),
            new asn1js__namespace.Any({
              optional: true,
              name: names.keyAttr || EMPTY_STRING
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$x);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _OtherKeyAttribute.schema({
          names: {
            keyAttrId: KEY_ATTR_ID,
            keyAttr: KEY_ATTR
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.keyAttrId = asn1.result.keyAttrId.valueBlock.toString();
        if (KEY_ATTR in asn1.result) {
          this.keyAttr = asn1.result.keyAttr;
        }
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.ObjectIdentifier({ value: this.keyAttrId }));
        if (KEY_ATTR in this) {
          outputArray.push(this.keyAttr);
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          keyAttrId: this.keyAttrId
        };
        if (KEY_ATTR in this) {
          res.keyAttr = this.keyAttr.toJSON();
        }
        return res;
      }
    };
    OtherKeyAttribute.CLASS_NAME = "OtherKeyAttribute";
    var SUBJECT_KEY_IDENTIFIER = "subjectKeyIdentifier";
    var DATE$1 = "date";
    var OTHER$1 = "other";
    var CLEAR_PROPS$w = [
      SUBJECT_KEY_IDENTIFIER,
      DATE$1,
      OTHER$1
    ];
    var RecipientKeyIdentifier = class _RecipientKeyIdentifier extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.subjectKeyIdentifier = pvutils__namespace.getParametersValue(parameters, SUBJECT_KEY_IDENTIFIER, _RecipientKeyIdentifier.defaultValues(SUBJECT_KEY_IDENTIFIER));
        if (DATE$1 in parameters) {
          this.date = pvutils__namespace.getParametersValue(parameters, DATE$1, _RecipientKeyIdentifier.defaultValues(DATE$1));
        }
        if (OTHER$1 in parameters) {
          this.other = pvutils__namespace.getParametersValue(parameters, OTHER$1, _RecipientKeyIdentifier.defaultValues(OTHER$1));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case SUBJECT_KEY_IDENTIFIER:
            return new asn1js__namespace.OctetString();
          case DATE$1:
            return new asn1js__namespace.GeneralizedTime();
          case OTHER$1:
            return new OtherKeyAttribute();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SUBJECT_KEY_IDENTIFIER:
            return memberValue.isEqual(_RecipientKeyIdentifier.defaultValues(SUBJECT_KEY_IDENTIFIER));
          case DATE$1:
            return memberValue.year === 0 && memberValue.month === 0 && memberValue.day === 0 && memberValue.hour === 0 && memberValue.minute === 0 && memberValue.second === 0 && memberValue.millisecond === 0;
          case OTHER$1:
            return memberValue.keyAttrId === EMPTY_STRING && "keyAttr" in memberValue === false;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.OctetString({ name: names.subjectKeyIdentifier || EMPTY_STRING }),
            new asn1js__namespace.GeneralizedTime({
              optional: true,
              name: names.date || EMPTY_STRING
            }),
            OtherKeyAttribute.schema(names.other || {})
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$w);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RecipientKeyIdentifier.schema({
          names: {
            subjectKeyIdentifier: SUBJECT_KEY_IDENTIFIER,
            date: DATE$1,
            other: {
              names: {
                blockName: OTHER$1
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.subjectKeyIdentifier = asn1.result.subjectKeyIdentifier;
        if (DATE$1 in asn1.result)
          this.date = asn1.result.date;
        if (OTHER$1 in asn1.result)
          this.other = new OtherKeyAttribute({ schema: asn1.result.other });
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(this.subjectKeyIdentifier);
        if (this.date) {
          outputArray.push(this.date);
        }
        if (this.other) {
          outputArray.push(this.other.toSchema());
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          subjectKeyIdentifier: this.subjectKeyIdentifier.toJSON()
        };
        if (this.date) {
          res.date = this.date.toJSON();
        }
        if (this.other) {
          res.other = this.other.toJSON();
        }
        return res;
      }
    };
    RecipientKeyIdentifier.CLASS_NAME = "RecipientKeyIdentifier";
    var VARIANT$1 = "variant";
    var VALUE$1 = "value";
    var CLEAR_PROPS$v = [
      "blockName"
    ];
    var KeyAgreeRecipientIdentifier = class _KeyAgreeRecipientIdentifier extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.variant = pvutils__namespace.getParametersValue(parameters, VARIANT$1, _KeyAgreeRecipientIdentifier.defaultValues(VARIANT$1));
        this.value = pvutils__namespace.getParametersValue(parameters, VALUE$1, _KeyAgreeRecipientIdentifier.defaultValues(VALUE$1));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VARIANT$1:
            return -1;
          case VALUE$1:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VARIANT$1:
            return memberValue === -1;
          case VALUE$1:
            return Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Choice({
          value: [
            IssuerAndSerialNumber.schema(names.issuerAndSerialNumber || {
              names: {
                blockName: names.blockName || EMPTY_STRING
              }
            }),
            new asn1js__namespace.Constructed({
              name: names.blockName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: RecipientKeyIdentifier.schema(names.rKeyId || {
                names: {
                  blockName: names.blockName || EMPTY_STRING
                }
              }).valueBlock.value
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$v);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _KeyAgreeRecipientIdentifier.schema({
          names: {
            blockName: "blockName"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (asn1.result.blockName.idBlock.tagClass === 1) {
          this.variant = 1;
          this.value = new IssuerAndSerialNumber({ schema: asn1.result.blockName });
        } else {
          this.variant = 2;
          this.value = new RecipientKeyIdentifier({
            schema: new asn1js__namespace.Sequence({
              value: asn1.result.blockName.valueBlock.value
            })
          });
        }
      }
      toSchema() {
        switch (this.variant) {
          case 1:
            return this.value.toSchema();
          case 2:
            return new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: this.value.toSchema().valueBlock.value
            });
          default:
            return new asn1js__namespace.Any();
        }
      }
      toJSON() {
        const res = {
          variant: this.variant
        };
        if (this.variant === 1 || this.variant === 2) {
          res.value = this.value.toJSON();
        }
        return res;
      }
    };
    KeyAgreeRecipientIdentifier.CLASS_NAME = "KeyAgreeRecipientIdentifier";
    var RID = "rid";
    var ENCRYPTED_KEY$2 = "encryptedKey";
    var CLEAR_PROPS$u = [
      RID,
      ENCRYPTED_KEY$2
    ];
    var RecipientEncryptedKey = class _RecipientEncryptedKey extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.rid = pvutils__namespace.getParametersValue(parameters, RID, _RecipientEncryptedKey.defaultValues(RID));
        this.encryptedKey = pvutils__namespace.getParametersValue(parameters, ENCRYPTED_KEY$2, _RecipientEncryptedKey.defaultValues(ENCRYPTED_KEY$2));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case RID:
            return new KeyAgreeRecipientIdentifier();
          case ENCRYPTED_KEY$2:
            return new asn1js__namespace.OctetString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case RID:
            return memberValue.variant === -1 && "value" in memberValue === false;
          case ENCRYPTED_KEY$2:
            return memberValue.isEqual(_RecipientEncryptedKey.defaultValues(ENCRYPTED_KEY$2));
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            KeyAgreeRecipientIdentifier.schema(names.rid || {}),
            new asn1js__namespace.OctetString({ name: names.encryptedKey || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$u);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RecipientEncryptedKey.schema({
          names: {
            rid: {
              names: {
                blockName: RID
              }
            },
            encryptedKey: ENCRYPTED_KEY$2
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.rid = new KeyAgreeRecipientIdentifier({ schema: asn1.result.rid });
        this.encryptedKey = asn1.result.encryptedKey;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.rid.toSchema(),
            this.encryptedKey
          ]
        });
      }
      toJSON() {
        return {
          rid: this.rid.toJSON(),
          encryptedKey: this.encryptedKey.toJSON()
        };
      }
    };
    RecipientEncryptedKey.CLASS_NAME = "RecipientEncryptedKey";
    var ENCRYPTED_KEYS = "encryptedKeys";
    var RECIPIENT_ENCRYPTED_KEYS = "RecipientEncryptedKeys";
    var CLEAR_PROPS$t = [
      RECIPIENT_ENCRYPTED_KEYS
    ];
    var RecipientEncryptedKeys = class _RecipientEncryptedKeys extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.encryptedKeys = pvutils__namespace.getParametersValue(parameters, ENCRYPTED_KEYS, _RecipientEncryptedKeys.defaultValues(ENCRYPTED_KEYS));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ENCRYPTED_KEYS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ENCRYPTED_KEYS:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.RecipientEncryptedKeys || EMPTY_STRING,
              value: RecipientEncryptedKey.schema()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$t);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RecipientEncryptedKeys.schema({
          names: {
            RecipientEncryptedKeys: RECIPIENT_ENCRYPTED_KEYS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.encryptedKeys = Array.from(asn1.result.RecipientEncryptedKeys, (element) => new RecipientEncryptedKey({ schema: element }));
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.encryptedKeys, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          encryptedKeys: Array.from(this.encryptedKeys, (o) => o.toJSON())
        };
      }
    };
    RecipientEncryptedKeys.CLASS_NAME = "RecipientEncryptedKeys";
    var VERSION$b = "version";
    var ORIGINATOR = "originator";
    var UKM = "ukm";
    var KEY_ENCRYPTION_ALGORITHM$2 = "keyEncryptionAlgorithm";
    var RECIPIENT_ENCRYPTED_KEY = "recipientEncryptedKeys";
    var RECIPIENT_CERTIFICATE = "recipientCertificate";
    var RECIPIENT_PUBLIC_KEY = "recipientPublicKey";
    var CLEAR_PROPS$s = [
      VERSION$b,
      ORIGINATOR,
      UKM,
      KEY_ENCRYPTION_ALGORITHM$2,
      RECIPIENT_ENCRYPTED_KEY
    ];
    var KeyAgreeRecipientInfo = class _KeyAgreeRecipientInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$b, _KeyAgreeRecipientInfo.defaultValues(VERSION$b));
        this.originator = pvutils__namespace.getParametersValue(parameters, ORIGINATOR, _KeyAgreeRecipientInfo.defaultValues(ORIGINATOR));
        if (UKM in parameters) {
          this.ukm = pvutils__namespace.getParametersValue(parameters, UKM, _KeyAgreeRecipientInfo.defaultValues(UKM));
        }
        this.keyEncryptionAlgorithm = pvutils__namespace.getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$2, _KeyAgreeRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$2));
        this.recipientEncryptedKeys = pvutils__namespace.getParametersValue(parameters, RECIPIENT_ENCRYPTED_KEY, _KeyAgreeRecipientInfo.defaultValues(RECIPIENT_ENCRYPTED_KEY));
        this.recipientCertificate = pvutils__namespace.getParametersValue(parameters, RECIPIENT_CERTIFICATE, _KeyAgreeRecipientInfo.defaultValues(RECIPIENT_CERTIFICATE));
        this.recipientPublicKey = pvutils__namespace.getParametersValue(parameters, RECIPIENT_PUBLIC_KEY, _KeyAgreeRecipientInfo.defaultValues(RECIPIENT_PUBLIC_KEY));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$b:
            return 0;
          case ORIGINATOR:
            return new OriginatorIdentifierOrKey();
          case UKM:
            return new asn1js__namespace.OctetString();
          case KEY_ENCRYPTION_ALGORITHM$2:
            return new AlgorithmIdentifier();
          case RECIPIENT_ENCRYPTED_KEY:
            return new RecipientEncryptedKeys();
          case RECIPIENT_CERTIFICATE:
            return new Certificate();
          case RECIPIENT_PUBLIC_KEY:
            return null;
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$b:
            return memberValue === 0;
          case ORIGINATOR:
            return memberValue.variant === -1 && "value" in memberValue === false;
          case UKM:
            return memberValue.isEqual(_KeyAgreeRecipientInfo.defaultValues(UKM));
          case KEY_ENCRYPTION_ALGORITHM$2:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case RECIPIENT_ENCRYPTED_KEY:
            return memberValue.encryptedKeys.length === 0;
          case RECIPIENT_CERTIFICATE:
            return false;
          case RECIPIENT_PUBLIC_KEY:
            return false;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || EMPTY_STRING }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                OriginatorIdentifierOrKey.schema(names.originator || {})
              ]
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [new asn1js__namespace.OctetString({ name: names.ukm || EMPTY_STRING })]
            }),
            AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
            RecipientEncryptedKeys.schema(names.recipientEncryptedKeys || {})
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$s);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _KeyAgreeRecipientInfo.schema({
          names: {
            version: VERSION$b,
            originator: {
              names: {
                blockName: ORIGINATOR
              }
            },
            ukm: UKM,
            keyEncryptionAlgorithm: {
              names: {
                blockName: KEY_ENCRYPTION_ALGORITHM$2
              }
            },
            recipientEncryptedKeys: {
              names: {
                blockName: RECIPIENT_ENCRYPTED_KEY
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.originator = new OriginatorIdentifierOrKey({ schema: asn1.result.originator });
        if (UKM in asn1.result)
          this.ukm = asn1.result.ukm;
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
        this.recipientEncryptedKeys = new RecipientEncryptedKeys({ schema: asn1.result.recipientEncryptedKeys });
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
        outputArray.push(new asn1js__namespace.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 0
          },
          value: [this.originator.toSchema()]
        }));
        if (this.ukm) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [this.ukm]
          }));
        }
        outputArray.push(this.keyEncryptionAlgorithm.toSchema());
        outputArray.push(this.recipientEncryptedKeys.toSchema());
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          version: this.version,
          originator: this.originator.toJSON(),
          keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
          recipientEncryptedKeys: this.recipientEncryptedKeys.toJSON()
        };
        if (this.ukm) {
          res.ukm = this.ukm.toJSON();
        }
        return res;
      }
    };
    KeyAgreeRecipientInfo.CLASS_NAME = "KeyAgreeRecipientInfo";
    var KEY_IDENTIFIER = "keyIdentifier";
    var DATE = "date";
    var OTHER = "other";
    var CLEAR_PROPS$r = [
      KEY_IDENTIFIER,
      DATE,
      OTHER
    ];
    var KEKIdentifier = class _KEKIdentifier extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.keyIdentifier = pvutils__namespace.getParametersValue(parameters, KEY_IDENTIFIER, _KEKIdentifier.defaultValues(KEY_IDENTIFIER));
        if (DATE in parameters) {
          this.date = pvutils__namespace.getParametersValue(parameters, DATE, _KEKIdentifier.defaultValues(DATE));
        }
        if (OTHER in parameters) {
          this.other = pvutils__namespace.getParametersValue(parameters, OTHER, _KEKIdentifier.defaultValues(OTHER));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case KEY_IDENTIFIER:
            return new asn1js__namespace.OctetString();
          case DATE:
            return new asn1js__namespace.GeneralizedTime();
          case OTHER:
            return new OtherKeyAttribute();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case KEY_IDENTIFIER:
            return memberValue.isEqual(_KEKIdentifier.defaultValues(KEY_IDENTIFIER));
          case DATE:
            return memberValue.year === 0 && memberValue.month === 0 && memberValue.day === 0 && memberValue.hour === 0 && memberValue.minute === 0 && memberValue.second === 0 && memberValue.millisecond === 0;
          case OTHER:
            return memberValue.compareWithDefault("keyAttrId", memberValue.keyAttrId) && "keyAttr" in memberValue === false;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.OctetString({ name: names.keyIdentifier || EMPTY_STRING }),
            new asn1js__namespace.GeneralizedTime({
              optional: true,
              name: names.date || EMPTY_STRING
            }),
            OtherKeyAttribute.schema(names.other || {})
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$r);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _KEKIdentifier.schema({
          names: {
            keyIdentifier: KEY_IDENTIFIER,
            date: DATE,
            other: {
              names: {
                blockName: OTHER
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.keyIdentifier = asn1.result.keyIdentifier;
        if (DATE in asn1.result)
          this.date = asn1.result.date;
        if (OTHER in asn1.result)
          this.other = new OtherKeyAttribute({ schema: asn1.result.other });
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(this.keyIdentifier);
        if (this.date) {
          outputArray.push(this.date);
        }
        if (this.other) {
          outputArray.push(this.other.toSchema());
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          keyIdentifier: this.keyIdentifier.toJSON()
        };
        if (this.date) {
          res.date = this.date;
        }
        if (this.other) {
          res.other = this.other.toJSON();
        }
        return res;
      }
    };
    KEKIdentifier.CLASS_NAME = "KEKIdentifier";
    var VERSION$a = "version";
    var KEK_ID = "kekid";
    var KEY_ENCRYPTION_ALGORITHM$1 = "keyEncryptionAlgorithm";
    var ENCRYPTED_KEY$1 = "encryptedKey";
    var PER_DEFINED_KEK = "preDefinedKEK";
    var CLEAR_PROPS$q = [
      VERSION$a,
      KEK_ID,
      KEY_ENCRYPTION_ALGORITHM$1,
      ENCRYPTED_KEY$1
    ];
    var KEKRecipientInfo = class _KEKRecipientInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$a, _KEKRecipientInfo.defaultValues(VERSION$a));
        this.kekid = pvutils__namespace.getParametersValue(parameters, KEK_ID, _KEKRecipientInfo.defaultValues(KEK_ID));
        this.keyEncryptionAlgorithm = pvutils__namespace.getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM$1, _KEKRecipientInfo.defaultValues(KEY_ENCRYPTION_ALGORITHM$1));
        this.encryptedKey = pvutils__namespace.getParametersValue(parameters, ENCRYPTED_KEY$1, _KEKRecipientInfo.defaultValues(ENCRYPTED_KEY$1));
        this.preDefinedKEK = pvutils__namespace.getParametersValue(parameters, PER_DEFINED_KEK, _KEKRecipientInfo.defaultValues(PER_DEFINED_KEK));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$a:
            return 0;
          case KEK_ID:
            return new KEKIdentifier();
          case KEY_ENCRYPTION_ALGORITHM$1:
            return new AlgorithmIdentifier();
          case ENCRYPTED_KEY$1:
            return new asn1js__namespace.OctetString();
          case PER_DEFINED_KEK:
            return EMPTY_BUFFER;
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case "KEKRecipientInfo":
            return memberValue === _KEKRecipientInfo.defaultValues(VERSION$a);
          case KEK_ID:
            return memberValue.compareWithDefault("keyIdentifier", memberValue.keyIdentifier) && "date" in memberValue === false && "other" in memberValue === false;
          case KEY_ENCRYPTION_ALGORITHM$1:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case ENCRYPTED_KEY$1:
            return memberValue.isEqual(_KEKRecipientInfo.defaultValues(ENCRYPTED_KEY$1));
          case PER_DEFINED_KEK:
            return memberValue.byteLength === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || EMPTY_STRING }),
            KEKIdentifier.schema(names.kekid || {}),
            AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
            new asn1js__namespace.OctetString({ name: names.encryptedKey || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$q);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _KEKRecipientInfo.schema({
          names: {
            version: VERSION$a,
            kekid: {
              names: {
                blockName: KEK_ID
              }
            },
            keyEncryptionAlgorithm: {
              names: {
                blockName: KEY_ENCRYPTION_ALGORITHM$1
              }
            },
            encryptedKey: ENCRYPTED_KEY$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.kekid = new KEKIdentifier({ schema: asn1.result.kekid });
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
        this.encryptedKey = asn1.result.encryptedKey;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.Integer({ value: this.version }),
            this.kekid.toSchema(),
            this.keyEncryptionAlgorithm.toSchema(),
            this.encryptedKey
          ]
        });
      }
      toJSON() {
        return {
          version: this.version,
          kekid: this.kekid.toJSON(),
          keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
          encryptedKey: this.encryptedKey.toJSON()
        };
      }
    };
    KEKRecipientInfo.CLASS_NAME = "KEKRecipientInfo";
    var VERSION$9 = "version";
    var KEY_DERIVATION_ALGORITHM = "keyDerivationAlgorithm";
    var KEY_ENCRYPTION_ALGORITHM = "keyEncryptionAlgorithm";
    var ENCRYPTED_KEY = "encryptedKey";
    var PASSWORD = "password";
    var CLEAR_PROPS$p = [
      VERSION$9,
      KEY_DERIVATION_ALGORITHM,
      KEY_ENCRYPTION_ALGORITHM,
      ENCRYPTED_KEY
    ];
    var PasswordRecipientinfo = class _PasswordRecipientinfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$9, _PasswordRecipientinfo.defaultValues(VERSION$9));
        if (KEY_DERIVATION_ALGORITHM in parameters) {
          this.keyDerivationAlgorithm = pvutils__namespace.getParametersValue(parameters, KEY_DERIVATION_ALGORITHM, _PasswordRecipientinfo.defaultValues(KEY_DERIVATION_ALGORITHM));
        }
        this.keyEncryptionAlgorithm = pvutils__namespace.getParametersValue(parameters, KEY_ENCRYPTION_ALGORITHM, _PasswordRecipientinfo.defaultValues(KEY_ENCRYPTION_ALGORITHM));
        this.encryptedKey = pvutils__namespace.getParametersValue(parameters, ENCRYPTED_KEY, _PasswordRecipientinfo.defaultValues(ENCRYPTED_KEY));
        this.password = pvutils__namespace.getParametersValue(parameters, PASSWORD, _PasswordRecipientinfo.defaultValues(PASSWORD));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$9:
            return -1;
          case KEY_DERIVATION_ALGORITHM:
            return new AlgorithmIdentifier();
          case KEY_ENCRYPTION_ALGORITHM:
            return new AlgorithmIdentifier();
          case ENCRYPTED_KEY:
            return new asn1js__namespace.OctetString();
          case PASSWORD:
            return EMPTY_BUFFER;
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$9:
            return memberValue === -1;
          case KEY_DERIVATION_ALGORITHM:
          case KEY_ENCRYPTION_ALGORITHM:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case ENCRYPTED_KEY:
            return memberValue.isEqual(_PasswordRecipientinfo.defaultValues(ENCRYPTED_KEY));
          case PASSWORD:
            return memberValue.byteLength === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || EMPTY_STRING }),
            new asn1js__namespace.Constructed({
              name: names.keyDerivationAlgorithm || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: AlgorithmIdentifier.schema().valueBlock.value
            }),
            AlgorithmIdentifier.schema(names.keyEncryptionAlgorithm || {}),
            new asn1js__namespace.OctetString({ name: names.encryptedKey || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$p);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PasswordRecipientinfo.schema({
          names: {
            version: VERSION$9,
            keyDerivationAlgorithm: KEY_DERIVATION_ALGORITHM,
            keyEncryptionAlgorithm: {
              names: {
                blockName: KEY_ENCRYPTION_ALGORITHM
              }
            },
            encryptedKey: ENCRYPTED_KEY
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        if (KEY_DERIVATION_ALGORITHM in asn1.result) {
          this.keyDerivationAlgorithm = new AlgorithmIdentifier({
            schema: new asn1js__namespace.Sequence({
              value: asn1.result.keyDerivationAlgorithm.valueBlock.value
            })
          });
        }
        this.keyEncryptionAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.keyEncryptionAlgorithm });
        this.encryptedKey = asn1.result.encryptedKey;
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
        if (this.keyDerivationAlgorithm) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.keyDerivationAlgorithm.toSchema().valueBlock.value
          }));
        }
        outputArray.push(this.keyEncryptionAlgorithm.toSchema());
        outputArray.push(this.encryptedKey);
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          version: this.version,
          keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
          encryptedKey: this.encryptedKey.toJSON()
        };
        if (this.keyDerivationAlgorithm) {
          res.keyDerivationAlgorithm = this.keyDerivationAlgorithm.toJSON();
        }
        return res;
      }
    };
    PasswordRecipientinfo.CLASS_NAME = "PasswordRecipientInfo";
    var ORI_TYPE = "oriType";
    var ORI_VALUE = "oriValue";
    var CLEAR_PROPS$o = [
      ORI_TYPE,
      ORI_VALUE
    ];
    var OtherRecipientInfo = class _OtherRecipientInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.oriType = pvutils__namespace.getParametersValue(parameters, ORI_TYPE, _OtherRecipientInfo.defaultValues(ORI_TYPE));
        this.oriValue = pvutils__namespace.getParametersValue(parameters, ORI_VALUE, _OtherRecipientInfo.defaultValues(ORI_VALUE));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case ORI_TYPE:
            return EMPTY_STRING;
          case ORI_VALUE:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case ORI_TYPE:
            return memberValue === EMPTY_STRING;
          case ORI_VALUE:
            return Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.oriType || EMPTY_STRING }),
            new asn1js__namespace.Any({ name: names.oriValue || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$o);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _OtherRecipientInfo.schema({
          names: {
            oriType: ORI_TYPE,
            oriValue: ORI_VALUE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.oriType = asn1.result.oriType.valueBlock.toString();
        this.oriValue = asn1.result.oriValue;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.oriType }),
            this.oriValue
          ]
        });
      }
      toJSON() {
        const res = {
          oriType: this.oriType
        };
        if (!_OtherRecipientInfo.compareWithDefault(ORI_VALUE, this.oriValue)) {
          res.oriValue = this.oriValue.toJSON();
        }
        return res;
      }
    };
    OtherRecipientInfo.CLASS_NAME = "OtherRecipientInfo";
    var VARIANT = "variant";
    var VALUE = "value";
    var CLEAR_PROPS$n = [
      "blockName"
    ];
    var RecipientInfo = class _RecipientInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.variant = pvutils__namespace.getParametersValue(parameters, VARIANT, _RecipientInfo.defaultValues(VARIANT));
        if (VALUE in parameters) {
          this.value = pvutils__namespace.getParametersValue(parameters, VALUE, _RecipientInfo.defaultValues(VALUE));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VARIANT:
            return -1;
          case VALUE:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VARIANT:
            return memberValue === _RecipientInfo.defaultValues(memberName);
          case VALUE:
            return Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Choice({
          value: [
            KeyTransRecipientInfo.schema({
              names: {
                blockName: names.blockName || EMPTY_STRING
              }
            }),
            new asn1js__namespace.Constructed({
              name: names.blockName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: KeyAgreeRecipientInfo.schema().valueBlock.value
            }),
            new asn1js__namespace.Constructed({
              name: names.blockName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: KEKRecipientInfo.schema().valueBlock.value
            }),
            new asn1js__namespace.Constructed({
              name: names.blockName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 3
              },
              value: PasswordRecipientinfo.schema().valueBlock.value
            }),
            new asn1js__namespace.Constructed({
              name: names.blockName || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 4
              },
              value: OtherRecipientInfo.schema().valueBlock.value
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$n);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RecipientInfo.schema({
          names: {
            blockName: "blockName"
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (asn1.result.blockName.idBlock.tagClass === 1) {
          this.variant = 1;
          this.value = new KeyTransRecipientInfo({ schema: asn1.result.blockName });
        } else {
          const blockSequence = new asn1js__namespace.Sequence({
            value: asn1.result.blockName.valueBlock.value
          });
          switch (asn1.result.blockName.idBlock.tagNumber) {
            case 1:
              this.variant = 2;
              this.value = new KeyAgreeRecipientInfo({ schema: blockSequence });
              break;
            case 2:
              this.variant = 3;
              this.value = new KEKRecipientInfo({ schema: blockSequence });
              break;
            case 3:
              this.variant = 4;
              this.value = new PasswordRecipientinfo({ schema: blockSequence });
              break;
            case 4:
              this.variant = 5;
              this.value = new OtherRecipientInfo({ schema: blockSequence });
              break;
            default:
              throw new Error("Incorrect structure of RecipientInfo block");
          }
        }
      }
      toSchema() {
        ParameterError.assertEmpty(this.value, "value", "RecipientInfo");
        const _schema = this.value.toSchema();
        switch (this.variant) {
          case 1:
            return _schema;
          case 2:
          case 3:
          case 4:
            _schema.idBlock.tagClass = 3;
            _schema.idBlock.tagNumber = this.variant - 1;
            return _schema;
          default:
            return new asn1js__namespace.Any();
        }
      }
      toJSON() {
        const res = {
          variant: this.variant
        };
        if (this.value && this.variant >= 1 && this.variant <= 4) {
          res.value = this.value.toJSON();
        }
        return res;
      }
    };
    RecipientInfo.CLASS_NAME = "RecipientInfo";
    var HASH_ALGORITHM$2 = "hashAlgorithm";
    var MASK_GEN_ALGORITHM = "maskGenAlgorithm";
    var P_SOURCE_ALGORITHM = "pSourceAlgorithm";
    var CLEAR_PROPS$m = [
      HASH_ALGORITHM$2,
      MASK_GEN_ALGORITHM,
      P_SOURCE_ALGORITHM
    ];
    var RSAESOAEPParams = class _RSAESOAEPParams extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.hashAlgorithm = pvutils__namespace.getParametersValue(parameters, HASH_ALGORITHM$2, _RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2));
        this.maskGenAlgorithm = pvutils__namespace.getParametersValue(parameters, MASK_GEN_ALGORITHM, _RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM));
        this.pSourceAlgorithm = pvutils__namespace.getParametersValue(parameters, P_SOURCE_ALGORITHM, _RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case HASH_ALGORITHM$2:
            return new AlgorithmIdentifier({
              algorithmId: "1.3.14.3.2.26",
              algorithmParams: new asn1js__namespace.Null()
            });
          case MASK_GEN_ALGORITHM:
            return new AlgorithmIdentifier({
              algorithmId: "1.2.840.113549.1.1.8",
              algorithmParams: new AlgorithmIdentifier({
                algorithmId: "1.3.14.3.2.26",
                algorithmParams: new asn1js__namespace.Null()
              }).toSchema()
            });
          case P_SOURCE_ALGORITHM:
            return new AlgorithmIdentifier({
              algorithmId: "1.2.840.113549.1.1.9",
              algorithmParams: new asn1js__namespace.OctetString({ valueHex: new Uint8Array([218, 57, 163, 238, 94, 107, 75, 13, 50, 85, 191, 239, 149, 96, 24, 144, 175, 216, 7, 9]).buffer })
            });
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              optional: true,
              value: [AlgorithmIdentifier.schema(names.hashAlgorithm || {})]
            }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              optional: true,
              value: [AlgorithmIdentifier.schema(names.maskGenAlgorithm || {})]
            }),
            new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              optional: true,
              value: [AlgorithmIdentifier.schema(names.pSourceAlgorithm || {})]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$m);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _RSAESOAEPParams.schema({
          names: {
            hashAlgorithm: {
              names: {
                blockName: HASH_ALGORITHM$2
              }
            },
            maskGenAlgorithm: {
              names: {
                blockName: MASK_GEN_ALGORITHM
              }
            },
            pSourceAlgorithm: {
              names: {
                blockName: P_SOURCE_ALGORITHM
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        if (HASH_ALGORITHM$2 in asn1.result)
          this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
        if (MASK_GEN_ALGORITHM in asn1.result)
          this.maskGenAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.maskGenAlgorithm });
        if (P_SOURCE_ALGORITHM in asn1.result)
          this.pSourceAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.pSourceAlgorithm });
      }
      toSchema() {
        const outputArray = [];
        if (!this.hashAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2))) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.hashAlgorithm.toSchema()]
          }));
        }
        if (!this.maskGenAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM))) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: [this.maskGenAlgorithm.toSchema()]
          }));
        }
        if (!this.pSourceAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM))) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 2
            },
            value: [this.pSourceAlgorithm.toSchema()]
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {};
        if (!this.hashAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(HASH_ALGORITHM$2))) {
          res.hashAlgorithm = this.hashAlgorithm.toJSON();
        }
        if (!this.maskGenAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(MASK_GEN_ALGORITHM))) {
          res.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();
        }
        if (!this.pSourceAlgorithm.isEqual(_RSAESOAEPParams.defaultValues(P_SOURCE_ALGORITHM))) {
          res.pSourceAlgorithm = this.pSourceAlgorithm.toJSON();
        }
        return res;
      }
    };
    RSAESOAEPParams.CLASS_NAME = "RSAESOAEPParams";
    var KEY_INFO = "keyInfo";
    var ENTITY_U_INFO = "entityUInfo";
    var SUPP_PUB_INFO = "suppPubInfo";
    var CLEAR_PROPS$l = [
      KEY_INFO,
      ENTITY_U_INFO,
      SUPP_PUB_INFO
    ];
    var ECCCMSSharedInfo = class _ECCCMSSharedInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.keyInfo = pvutils__namespace.getParametersValue(parameters, KEY_INFO, _ECCCMSSharedInfo.defaultValues(KEY_INFO));
        if (ENTITY_U_INFO in parameters) {
          this.entityUInfo = pvutils__namespace.getParametersValue(parameters, ENTITY_U_INFO, _ECCCMSSharedInfo.defaultValues(ENTITY_U_INFO));
        }
        this.suppPubInfo = pvutils__namespace.getParametersValue(parameters, SUPP_PUB_INFO, _ECCCMSSharedInfo.defaultValues(SUPP_PUB_INFO));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case KEY_INFO:
            return new AlgorithmIdentifier();
          case ENTITY_U_INFO:
            return new asn1js__namespace.OctetString();
          case SUPP_PUB_INFO:
            return new asn1js__namespace.OctetString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case KEY_INFO:
          case ENTITY_U_INFO:
          case SUPP_PUB_INFO:
            return memberValue.isEqual(_ECCCMSSharedInfo.defaultValues(memberName));
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            AlgorithmIdentifier.schema(names.keyInfo || {}),
            new asn1js__namespace.Constructed({
              name: names.entityUInfo || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              optional: true,
              value: [new asn1js__namespace.OctetString()]
            }),
            new asn1js__namespace.Constructed({
              name: names.suppPubInfo || EMPTY_STRING,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: [new asn1js__namespace.OctetString()]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$l);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _ECCCMSSharedInfo.schema({
          names: {
            keyInfo: {
              names: {
                blockName: KEY_INFO
              }
            },
            entityUInfo: ENTITY_U_INFO,
            suppPubInfo: SUPP_PUB_INFO
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.keyInfo = new AlgorithmIdentifier({ schema: asn1.result.keyInfo });
        if (ENTITY_U_INFO in asn1.result)
          this.entityUInfo = asn1.result.entityUInfo.valueBlock.value[0];
        this.suppPubInfo = asn1.result.suppPubInfo.valueBlock.value[0];
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(this.keyInfo.toSchema());
        if (this.entityUInfo) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.entityUInfo]
          }));
        }
        outputArray.push(new asn1js__namespace.Constructed({
          idBlock: {
            tagClass: 3,
            tagNumber: 2
          },
          value: [this.suppPubInfo]
        }));
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          keyInfo: this.keyInfo.toJSON(),
          suppPubInfo: this.suppPubInfo.toJSON()
        };
        if (this.entityUInfo) {
          res.entityUInfo = this.entityUInfo.toJSON();
        }
        return res;
      }
    };
    ECCCMSSharedInfo.CLASS_NAME = "ECCCMSSharedInfo";
    var VERSION$8 = "version";
    var ORIGINATOR_INFO = "originatorInfo";
    var RECIPIENT_INFOS = "recipientInfos";
    var ENCRYPTED_CONTENT_INFO = "encryptedContentInfo";
    var UNPROTECTED_ATTRS = "unprotectedAttrs";
    var CLEAR_PROPS$k = [
      VERSION$8,
      ORIGINATOR_INFO,
      RECIPIENT_INFOS,
      ENCRYPTED_CONTENT_INFO,
      UNPROTECTED_ATTRS
    ];
    var defaultEncryptionParams = {
      kdfAlgorithm: "SHA-512",
      kekEncryptionLength: 256
    };
    var curveLengthByName = {
      "P-256": 256,
      "P-384": 384,
      "P-521": 528
    };
    var EnvelopedData = class _EnvelopedData extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$8, _EnvelopedData.defaultValues(VERSION$8));
        if (ORIGINATOR_INFO in parameters) {
          this.originatorInfo = pvutils__namespace.getParametersValue(parameters, ORIGINATOR_INFO, _EnvelopedData.defaultValues(ORIGINATOR_INFO));
        }
        this.recipientInfos = pvutils__namespace.getParametersValue(parameters, RECIPIENT_INFOS, _EnvelopedData.defaultValues(RECIPIENT_INFOS));
        this.encryptedContentInfo = pvutils__namespace.getParametersValue(parameters, ENCRYPTED_CONTENT_INFO, _EnvelopedData.defaultValues(ENCRYPTED_CONTENT_INFO));
        if (UNPROTECTED_ATTRS in parameters) {
          this.unprotectedAttrs = pvutils__namespace.getParametersValue(parameters, UNPROTECTED_ATTRS, _EnvelopedData.defaultValues(UNPROTECTED_ATTRS));
        }
        this.policy = {
          disableSplit: !!parameters.disableSplit
        };
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$8:
            return 0;
          case ORIGINATOR_INFO:
            return new OriginatorInfo();
          case RECIPIENT_INFOS:
            return [];
          case ENCRYPTED_CONTENT_INFO:
            return new EncryptedContentInfo();
          case UNPROTECTED_ATTRS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$8:
            return memberValue === _EnvelopedData.defaultValues(memberName);
          case ORIGINATOR_INFO:
            return memberValue.certs.certificates.length === 0 && memberValue.crls.crls.length === 0;
          case RECIPIENT_INFOS:
          case UNPROTECTED_ATTRS:
            return memberValue.length === 0;
          case ENCRYPTED_CONTENT_INFO:
            return EncryptedContentInfo.compareWithDefault("contentType", memberValue.contentType) && (EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm) && EncryptedContentInfo.compareWithDefault("encryptedContent", memberValue.encryptedContent));
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || EMPTY_STRING }),
            new asn1js__namespace.Constructed({
              name: names.originatorInfo || EMPTY_STRING,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: OriginatorInfo.schema().valueBlock.value
            }),
            new asn1js__namespace.Set({
              value: [
                new asn1js__namespace.Repeated({
                  name: names.recipientInfos || EMPTY_STRING,
                  value: RecipientInfo.schema()
                })
              ]
            }),
            EncryptedContentInfo.schema(names.encryptedContentInfo || {}),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [
                new asn1js__namespace.Repeated({
                  name: names.unprotectedAttrs || EMPTY_STRING,
                  value: Attribute.schema()
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$k);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _EnvelopedData.schema({
          names: {
            version: VERSION$8,
            originatorInfo: ORIGINATOR_INFO,
            recipientInfos: RECIPIENT_INFOS,
            encryptedContentInfo: {
              names: {
                blockName: ENCRYPTED_CONTENT_INFO
              }
            },
            unprotectedAttrs: UNPROTECTED_ATTRS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        if (ORIGINATOR_INFO in asn1.result) {
          this.originatorInfo = new OriginatorInfo({
            schema: new asn1js__namespace.Sequence({
              value: asn1.result.originatorInfo.valueBlock.value
            })
          });
        }
        this.recipientInfos = Array.from(asn1.result.recipientInfos, (o) => new RecipientInfo({ schema: o }));
        this.encryptedContentInfo = new EncryptedContentInfo({ schema: asn1.result.encryptedContentInfo });
        if (UNPROTECTED_ATTRS in asn1.result)
          this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, (o) => new Attribute({ schema: o }));
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
        if (this.originatorInfo) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: this.originatorInfo.toSchema().valueBlock.value
          }));
        }
        outputArray.push(new asn1js__namespace.Set({
          value: Array.from(this.recipientInfos, (o) => o.toSchema())
        }));
        outputArray.push(this.encryptedContentInfo.toSchema());
        if (this.unprotectedAttrs) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.unprotectedAttrs, (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          version: this.version,
          recipientInfos: Array.from(this.recipientInfos, (o) => o.toJSON()),
          encryptedContentInfo: this.encryptedContentInfo.toJSON()
        };
        if (this.originatorInfo)
          res.originatorInfo = this.originatorInfo.toJSON();
        if (this.unprotectedAttrs)
          res.unprotectedAttrs = Array.from(this.unprotectedAttrs, (o) => o.toJSON());
        return res;
      }
      addRecipientByCertificate(certificate, parameters, variant, crypto2 = getCrypto(true)) {
        const encryptionParameters = Object.assign({ useOAEP: true, oaepHashAlgorithm: "SHA-512" }, defaultEncryptionParams, parameters || {});
        if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549") !== -1)
          variant = 1;
        else {
          if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045") !== -1)
            variant = 2;
          else
            throw new Error(`Unknown type of certificate's public key: ${certificate.subjectPublicKeyInfo.algorithm.algorithmId}`);
        }
        switch (variant) {
          case 1:
            {
              let algorithmId;
              let algorithmParams;
              if (encryptionParameters.useOAEP === true) {
                algorithmId = crypto2.getOIDByAlgorithm({
                  name: "RSA-OAEP"
                }, true, "keyEncryptionAlgorithm");
                const hashOID = crypto2.getOIDByAlgorithm({
                  name: encryptionParameters.oaepHashAlgorithm
                }, true, "RSAES-OAEP-params");
                const hashAlgorithm = new AlgorithmIdentifier({
                  algorithmId: hashOID,
                  algorithmParams: new asn1js__namespace.Null()
                });
                const rsaOAEPParams = new RSAESOAEPParams({
                  hashAlgorithm,
                  maskGenAlgorithm: new AlgorithmIdentifier({
                    algorithmId: "1.2.840.113549.1.1.8",
                    algorithmParams: hashAlgorithm.toSchema()
                  })
                });
                algorithmParams = rsaOAEPParams.toSchema();
              } else {
                algorithmId = crypto2.getOIDByAlgorithm({
                  name: "RSAES-PKCS1-v1_5"
                });
                if (algorithmId === EMPTY_STRING)
                  throw new Error("Can not find OID for RSAES-PKCS1-v1_5");
                algorithmParams = new asn1js__namespace.Null();
              }
              const keyInfo = new KeyTransRecipientInfo({
                version: 0,
                rid: new IssuerAndSerialNumber({
                  issuer: certificate.issuer,
                  serialNumber: certificate.serialNumber
                }),
                keyEncryptionAlgorithm: new AlgorithmIdentifier({
                  algorithmId,
                  algorithmParams
                }),
                recipientCertificate: certificate
              });
              this.recipientInfos.push(new RecipientInfo({
                variant: 1,
                value: keyInfo
              }));
            }
            break;
          case 2:
            {
              const recipientIdentifier = new KeyAgreeRecipientIdentifier({
                variant: 1,
                value: new IssuerAndSerialNumber({
                  issuer: certificate.issuer,
                  serialNumber: certificate.serialNumber
                })
              });
              this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, { recipientCertificate: certificate }, crypto2);
            }
            break;
          default:
            throw new Error(`Unknown "variant" value: ${variant}`);
        }
        return true;
      }
      addRecipientByPreDefinedData(preDefinedData, parameters = {}, variant, crypto2 = getCrypto(true)) {
        ArgumentError.assert(preDefinedData, "preDefinedData", "ArrayBuffer");
        if (!preDefinedData.byteLength) {
          throw new Error("Pre-defined data could have zero length");
        }
        if (!parameters.keyIdentifier) {
          const keyIdentifierBuffer = new ArrayBuffer(16);
          const keyIdentifierView = new Uint8Array(keyIdentifierBuffer);
          crypto2.getRandomValues(keyIdentifierView);
          parameters.keyIdentifier = keyIdentifierBuffer;
        }
        if (!parameters.hmacHashAlgorithm)
          parameters.hmacHashAlgorithm = "SHA-512";
        if (parameters.iterationCount === void 0) {
          parameters.iterationCount = 2048;
        }
        if (!parameters.keyEncryptionAlgorithm) {
          parameters.keyEncryptionAlgorithm = {
            name: "AES-KW",
            length: 256
          };
        }
        if (!parameters.keyEncryptionAlgorithmParams)
          parameters.keyEncryptionAlgorithmParams = new asn1js__namespace.Null();
        switch (variant) {
          case 1:
            {
              const kekOID = crypto2.getOIDByAlgorithm(parameters.keyEncryptionAlgorithm, true, "keyEncryptionAlgorithm");
              const keyInfo = new KEKRecipientInfo({
                version: 4,
                kekid: new KEKIdentifier({
                  keyIdentifier: new asn1js__namespace.OctetString({ valueHex: parameters.keyIdentifier })
                }),
                keyEncryptionAlgorithm: new AlgorithmIdentifier({
                  algorithmId: kekOID,
                  algorithmParams: parameters.keyEncryptionAlgorithmParams
                }),
                preDefinedKEK: preDefinedData
              });
              this.recipientInfos.push(new RecipientInfo({
                variant: 3,
                value: keyInfo
              }));
            }
            break;
          case 2:
            {
              const pbkdf2OID = crypto2.getOIDByAlgorithm({ name: "PBKDF2" }, true, "keyDerivationAlgorithm");
              const saltBuffer = new ArrayBuffer(64);
              const saltView = new Uint8Array(saltBuffer);
              crypto2.getRandomValues(saltView);
              const hmacOID = crypto2.getOIDByAlgorithm({
                name: "HMAC",
                hash: {
                  name: parameters.hmacHashAlgorithm
                }
              }, true, "hmacHashAlgorithm");
              const pbkdf2Params = new PBKDF2Params({
                salt: new asn1js__namespace.OctetString({ valueHex: saltBuffer }),
                iterationCount: parameters.iterationCount,
                prf: new AlgorithmIdentifier({
                  algorithmId: hmacOID,
                  algorithmParams: new asn1js__namespace.Null()
                })
              });
              const kekOID = crypto2.getOIDByAlgorithm(parameters.keyEncryptionAlgorithm, true, "keyEncryptionAlgorithm");
              const keyInfo = new PasswordRecipientinfo({
                version: 0,
                keyDerivationAlgorithm: new AlgorithmIdentifier({
                  algorithmId: pbkdf2OID,
                  algorithmParams: pbkdf2Params.toSchema()
                }),
                keyEncryptionAlgorithm: new AlgorithmIdentifier({
                  algorithmId: kekOID,
                  algorithmParams: parameters.keyEncryptionAlgorithmParams
                }),
                password: preDefinedData
              });
              this.recipientInfos.push(new RecipientInfo({
                variant: 4,
                value: keyInfo
              }));
            }
            break;
          default:
            throw new Error(`Unknown value for "variant": ${variant}`);
        }
      }
      addRecipientByKeyIdentifier(key, keyId, parameters, crypto2 = getCrypto(true)) {
        const encryptionParameters = Object.assign({}, defaultEncryptionParams, parameters || {});
        const recipientIdentifier = new KeyAgreeRecipientIdentifier({
          variant: 2,
          value: new RecipientKeyIdentifier({
            subjectKeyIdentifier: new asn1js__namespace.OctetString({ valueHex: keyId })
          })
        });
        this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, { recipientPublicKey: key }, crypto2);
      }
      _addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, extraRecipientInfoParams, crypto2 = getCrypto(true)) {
        const encryptedKey = new RecipientEncryptedKey({
          rid: recipientIdentifier
        });
        const aesKWoid = crypto2.getOIDByAlgorithm({
          name: "AES-KW",
          length: encryptionParameters.kekEncryptionLength
        }, true, "keyEncryptionAlgorithm");
        const aesKW = new AlgorithmIdentifier({
          algorithmId: aesKWoid
        });
        const ecdhOID = crypto2.getOIDByAlgorithm({
          name: "ECDH",
          kdf: encryptionParameters.kdfAlgorithm
        }, true, "KeyAgreeRecipientInfo");
        const ukmBuffer = new ArrayBuffer(64);
        const ukmView = new Uint8Array(ukmBuffer);
        crypto2.getRandomValues(ukmView);
        const recipientInfoParams = {
          version: 3,
          ukm: new asn1js__namespace.OctetString({ valueHex: ukmBuffer }),
          keyEncryptionAlgorithm: new AlgorithmIdentifier({
            algorithmId: ecdhOID,
            algorithmParams: aesKW.toSchema()
          }),
          recipientEncryptedKeys: new RecipientEncryptedKeys({
            encryptedKeys: [encryptedKey]
          })
        };
        const keyInfo = new KeyAgreeRecipientInfo(Object.assign(recipientInfoParams, extraRecipientInfoParams));
        this.recipientInfos.push(new RecipientInfo({
          variant: 2,
          value: keyInfo
        }));
      }
      async encrypt(contentEncryptionAlgorithm, contentToEncrypt, crypto2 = getCrypto(true)) {
        const ivBuffer = new ArrayBuffer(16);
        const ivView = new Uint8Array(ivBuffer);
        crypto2.getRandomValues(ivView);
        const contentView = new Uint8Array(contentToEncrypt);
        const contentEncryptionOID = crypto2.getOIDByAlgorithm(contentEncryptionAlgorithm, true, "contentEncryptionAlgorithm");
        const sessionKey = await crypto2.generateKey(contentEncryptionAlgorithm, true, ["encrypt"]);
        const encryptedContent = await crypto2.encrypt({
          name: contentEncryptionAlgorithm.name,
          iv: ivView
        }, sessionKey, contentView);
        const exportedSessionKey = await crypto2.exportKey("raw", sessionKey);
        this.version = 2;
        this.encryptedContentInfo = new EncryptedContentInfo({
          disableSplit: this.policy.disableSplit,
          contentType: "1.2.840.113549.1.7.1",
          contentEncryptionAlgorithm: new AlgorithmIdentifier({
            algorithmId: contentEncryptionOID,
            algorithmParams: new asn1js__namespace.OctetString({ valueHex: ivBuffer })
          }),
          encryptedContent: new asn1js__namespace.OctetString({ valueHex: encryptedContent })
        });
        const SubKeyAgreeRecipientInfo = async (index) => {
          const recipientInfo = this.recipientInfos[index].value;
          let recipientCurve;
          let recipientPublicKey;
          if (recipientInfo.recipientPublicKey) {
            recipientCurve = recipientInfo.recipientPublicKey.algorithm.namedCurve;
            recipientPublicKey = recipientInfo.recipientPublicKey;
          } else if (recipientInfo.recipientCertificate) {
            const curveObject = recipientInfo.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
            if (curveObject.constructor.blockName() !== asn1js__namespace.ObjectIdentifier.blockName())
              throw new Error(`Incorrect "recipientCertificate" for index ${index}`);
            const curveOID = curveObject.valueBlock.toString();
            switch (curveOID) {
              case "1.2.840.10045.3.1.7":
                recipientCurve = "P-256";
                break;
              case "1.3.132.0.34":
                recipientCurve = "P-384";
                break;
              case "1.3.132.0.35":
                recipientCurve = "P-521";
                break;
              default:
                throw new Error(`Incorrect curve OID for index ${index}`);
            }
            recipientPublicKey = await recipientInfo.recipientCertificate.getPublicKey({
              algorithm: {
                algorithm: {
                  name: "ECDH",
                  namedCurve: recipientCurve
                },
                usages: []
              }
            }, crypto2);
          } else {
            throw new Error("Unsupported RecipientInfo");
          }
          const recipientCurveLength = curveLengthByName[recipientCurve];
          const ecdhKeys = await crypto2.generateKey({ name: "ECDH", namedCurve: recipientCurve }, true, ["deriveBits"]);
          const exportedECDHPublicKey = await crypto2.exportKey("spki", ecdhKeys.publicKey);
          const derivedBits = await crypto2.deriveBits({
            name: "ECDH",
            public: recipientPublicKey
          }, ecdhKeys.privateKey, recipientCurveLength);
          const aesKWAlgorithm = new AlgorithmIdentifier({ schema: recipientInfo.keyEncryptionAlgorithm.algorithmParams });
          const kwAlgorithm = crypto2.getAlgorithmByOID(aesKWAlgorithm.algorithmId, true, "aesKWAlgorithm");
          let kwLength = kwAlgorithm.length;
          const kwLengthBuffer = new ArrayBuffer(4);
          const kwLengthView = new Uint8Array(kwLengthBuffer);
          for (let j = 3; j >= 0; j--) {
            kwLengthView[j] = kwLength;
            kwLength >>= 8;
          }
          const eccInfo = new ECCCMSSharedInfo({
            keyInfo: new AlgorithmIdentifier({
              algorithmId: aesKWAlgorithm.algorithmId
            }),
            entityUInfo: recipientInfo.ukm,
            suppPubInfo: new asn1js__namespace.OctetString({ valueHex: kwLengthBuffer })
          });
          const encodedInfo = eccInfo.toSchema().toBER(false);
          const ecdhAlgorithm = crypto2.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "ecdhAlgorithm");
          const derivedKeyRaw = await kdf(ecdhAlgorithm.kdf, derivedBits, kwAlgorithm.length, encodedInfo, crypto2);
          const awsKW = await crypto2.importKey("raw", derivedKeyRaw, { name: "AES-KW" }, true, ["wrapKey"]);
          const wrappedKey = await crypto2.wrapKey("raw", sessionKey, awsKW, { name: "AES-KW" });
          const originator = new OriginatorIdentifierOrKey();
          originator.variant = 3;
          originator.value = OriginatorPublicKey.fromBER(exportedECDHPublicKey);
          recipientInfo.originator = originator;
          recipientInfo.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new asn1js__namespace.OctetString({ valueHex: wrappedKey });
          return { ecdhPrivateKey: ecdhKeys.privateKey };
        };
        const SubKeyTransRecipientInfo = async (index) => {
          const recipientInfo = this.recipientInfos[index].value;
          const algorithmParameters = crypto2.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
          if (algorithmParameters.name === "RSA-OAEP") {
            const schema = recipientInfo.keyEncryptionAlgorithm.algorithmParams;
            const rsaOAEPParams = new RSAESOAEPParams({ schema });
            algorithmParameters.hash = crypto2.getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
            if ("name" in algorithmParameters.hash === false)
              throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
          }
          try {
            const publicKey = await recipientInfo.recipientCertificate.getPublicKey({
              algorithm: {
                algorithm: algorithmParameters,
                usages: ["encrypt", "wrapKey"]
              }
            }, crypto2);
            const encryptedKey = await crypto2.encrypt(publicKey.algorithm, publicKey, exportedSessionKey);
            recipientInfo.encryptedKey = new asn1js__namespace.OctetString({ valueHex: encryptedKey });
          } catch {
          }
        };
        const SubKEKRecipientInfo = async (index) => {
          const recipientInfo = this.recipientInfos[index].value;
          const kekAlgorithm = crypto2.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
          const kekKey = await crypto2.importKey("raw", new Uint8Array(recipientInfo.preDefinedKEK), kekAlgorithm, true, ["wrapKey"]);
          const wrappedKey = await crypto2.wrapKey("raw", sessionKey, kekKey, kekAlgorithm);
          recipientInfo.encryptedKey = new asn1js__namespace.OctetString({ valueHex: wrappedKey });
        };
        const SubPasswordRecipientinfo = async (index) => {
          const recipientInfo = this.recipientInfos[index].value;
          let pbkdf2Params;
          if (!recipientInfo.keyDerivationAlgorithm)
            throw new Error('Please append encoded "keyDerivationAlgorithm"');
          if (!recipientInfo.keyDerivationAlgorithm.algorithmParams)
            throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');
          try {
            pbkdf2Params = new PBKDF2Params({ schema: recipientInfo.keyDerivationAlgorithm.algorithmParams });
          } catch (ex) {
            throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');
          }
          const passwordView = new Uint8Array(recipientInfo.password);
          const derivationKey = await crypto2.importKey("raw", passwordView, "PBKDF2", false, ["deriveKey"]);
          const kekAlgorithm = crypto2.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
          let hmacHashAlgorithm = "SHA-1";
          if (pbkdf2Params.prf) {
            const prfAlgorithm = crypto2.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true, "prfAlgorithm");
            hmacHashAlgorithm = prfAlgorithm.hash.name;
          }
          const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
          const iterations = pbkdf2Params.iterationCount;
          const derivedKey = await crypto2.deriveKey({
            name: "PBKDF2",
            hash: {
              name: hmacHashAlgorithm
            },
            salt: saltView,
            iterations
          }, derivationKey, kekAlgorithm, true, ["wrapKey"]);
          const wrappedKey = await crypto2.wrapKey("raw", sessionKey, derivedKey, kekAlgorithm);
          recipientInfo.encryptedKey = new asn1js__namespace.OctetString({ valueHex: wrappedKey });
        };
        const res = [];
        for (let i = 0; i < this.recipientInfos.length; i++) {
          switch (this.recipientInfos[i].variant) {
            case 1:
              res.push(await SubKeyTransRecipientInfo(i));
              break;
            case 2:
              res.push(await SubKeyAgreeRecipientInfo(i));
              break;
            case 3:
              res.push(await SubKEKRecipientInfo(i));
              break;
            case 4:
              res.push(await SubPasswordRecipientinfo(i));
              break;
            default:
              throw new Error(`Unknown recipient type in array with index ${i}`);
          }
        }
        return res;
      }
      async decrypt(recipientIndex, parameters, crypto2 = getCrypto(true)) {
        const decryptionParameters = parameters || {};
        if (recipientIndex + 1 > this.recipientInfos.length) {
          throw new Error(`Maximum value for "index" is: ${this.recipientInfos.length - 1}`);
        }
        const SubKeyAgreeRecipientInfo = async (index) => {
          const recipientInfo = this.recipientInfos[index].value;
          let curveOID;
          let recipientCurve;
          let recipientCurveLength;
          const originator = recipientInfo.originator;
          if (decryptionParameters.recipientCertificate) {
            const curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
            if (curveObject.constructor.blockName() !== asn1js__namespace.ObjectIdentifier.blockName()) {
              throw new Error(`Incorrect "recipientCertificate" for index ${index}`);
            }
            curveOID = curveObject.valueBlock.toString();
          } else if (originator.value.algorithm.algorithmParams) {
            const curveObject = originator.value.algorithm.algorithmParams;
            if (curveObject.constructor.blockName() !== asn1js__namespace.ObjectIdentifier.blockName()) {
              throw new Error(`Incorrect originator for index ${index}`);
            }
            curveOID = curveObject.valueBlock.toString();
          } else {
            throw new Error('Parameter "recipientCertificate" is mandatory for "KeyAgreeRecipientInfo" if algorithm params are missing from originator');
          }
          if (!decryptionParameters.recipientPrivateKey)
            throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyAgreeRecipientInfo"');
          switch (curveOID) {
            case "1.2.840.10045.3.1.7":
              recipientCurve = "P-256";
              recipientCurveLength = 256;
              break;
            case "1.3.132.0.34":
              recipientCurve = "P-384";
              recipientCurveLength = 384;
              break;
            case "1.3.132.0.35":
              recipientCurve = "P-521";
              recipientCurveLength = 528;
              break;
            default:
              throw new Error(`Incorrect curve OID for index ${index}`);
          }
          let ecdhPrivateKey;
          let keyCrypto = crypto2;
          if (pvtsutils.BufferSourceConverter.isBufferSource(decryptionParameters.recipientPrivateKey)) {
            ecdhPrivateKey = await crypto2.importKey("pkcs8", decryptionParameters.recipientPrivateKey, {
              name: "ECDH",
              namedCurve: recipientCurve
            }, true, ["deriveBits"]);
          } else {
            ecdhPrivateKey = decryptionParameters.recipientPrivateKey;
            if ("crypto" in decryptionParameters && decryptionParameters.crypto) {
              keyCrypto = decryptionParameters.crypto.subtle;
            }
          }
          if ("algorithmParams" in originator.value.algorithm === false)
            originator.value.algorithm.algorithmParams = new asn1js__namespace.ObjectIdentifier({ value: curveOID });
          const buffer = originator.value.toSchema().toBER(false);
          const ecdhPublicKey = await crypto2.importKey("spki", buffer, {
            name: "ECDH",
            namedCurve: recipientCurve
          }, true, []);
          const sharedSecret = await keyCrypto.deriveBits({
            name: "ECDH",
            public: ecdhPublicKey
          }, ecdhPrivateKey, recipientCurveLength);
          async function applyKDF(includeAlgorithmParams) {
            includeAlgorithmParams = includeAlgorithmParams || false;
            const aesKWAlgorithm = new AlgorithmIdentifier({ schema: recipientInfo.keyEncryptionAlgorithm.algorithmParams });
            const kwAlgorithm = crypto2.getAlgorithmByOID(aesKWAlgorithm.algorithmId, true, "kwAlgorithm");
            let kwLength = kwAlgorithm.length;
            const kwLengthBuffer = new ArrayBuffer(4);
            const kwLengthView = new Uint8Array(kwLengthBuffer);
            for (let j = 3; j >= 0; j--) {
              kwLengthView[j] = kwLength;
              kwLength >>= 8;
            }
            const keyInfoAlgorithm = {
              algorithmId: aesKWAlgorithm.algorithmId
            };
            if (includeAlgorithmParams) {
              keyInfoAlgorithm.algorithmParams = new asn1js__namespace.Null();
            }
            const eccInfo = new ECCCMSSharedInfo({
              keyInfo: new AlgorithmIdentifier(keyInfoAlgorithm),
              entityUInfo: recipientInfo.ukm,
              suppPubInfo: new asn1js__namespace.OctetString({ valueHex: kwLengthBuffer })
            });
            const encodedInfo = eccInfo.toSchema().toBER(false);
            const ecdhAlgorithm = crypto2.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "ecdhAlgorithm");
            if (!ecdhAlgorithm.name) {
              throw new Error(`Incorrect OID for key encryption algorithm: ${recipientInfo.keyEncryptionAlgorithm.algorithmId}`);
            }
            return kdf(ecdhAlgorithm.kdf, sharedSecret, kwAlgorithm.length, encodedInfo, crypto2);
          }
          const kdfResult = await applyKDF();
          const importAesKwKey = async (kdfResult2) => {
            return crypto2.importKey("raw", kdfResult2, { name: "AES-KW" }, true, ["unwrapKey"]);
          };
          const aesKwKey = await importAesKwKey(kdfResult);
          const unwrapSessionKey = async (aesKwKey2) => {
            const algorithmId2 = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
            const contentEncryptionAlgorithm2 = crypto2.getAlgorithmByOID(algorithmId2, true, "contentEncryptionAlgorithm");
            return crypto2.unwrapKey("raw", recipientInfo.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHexView, aesKwKey2, { name: "AES-KW" }, contentEncryptionAlgorithm2, true, ["decrypt"]);
          };
          try {
            return await unwrapSessionKey(aesKwKey);
          } catch {
            const kdfResult2 = await applyKDF(true);
            const aesKwKey2 = await importAesKwKey(kdfResult2);
            return unwrapSessionKey(aesKwKey2);
          }
        };
        const SubKeyTransRecipientInfo = async (index) => {
          const recipientInfo = this.recipientInfos[index].value;
          if (!decryptionParameters.recipientPrivateKey) {
            throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyTransRecipientInfo"');
          }
          const algorithmParameters = crypto2.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
          if (algorithmParameters.name === "RSA-OAEP") {
            const schema = recipientInfo.keyEncryptionAlgorithm.algorithmParams;
            const rsaOAEPParams = new RSAESOAEPParams({ schema });
            algorithmParameters.hash = crypto2.getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);
            if ("name" in algorithmParameters.hash === false)
              throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
          }
          let privateKey;
          let keyCrypto = crypto2;
          if (pvtsutils.BufferSourceConverter.isBufferSource(decryptionParameters.recipientPrivateKey)) {
            privateKey = await crypto2.importKey("pkcs8", decryptionParameters.recipientPrivateKey, algorithmParameters, true, ["decrypt"]);
          } else {
            privateKey = decryptionParameters.recipientPrivateKey;
            if ("crypto" in decryptionParameters && decryptionParameters.crypto) {
              keyCrypto = decryptionParameters.crypto.subtle;
            }
          }
          const sessionKey = await keyCrypto.decrypt(privateKey.algorithm, privateKey, recipientInfo.encryptedKey.valueBlock.valueHexView);
          const algorithmId2 = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
          const contentEncryptionAlgorithm2 = crypto2.getAlgorithmByOID(algorithmId2, true, "contentEncryptionAlgorithm");
          if ("name" in contentEncryptionAlgorithm2 === false)
            throw new Error(`Incorrect "contentEncryptionAlgorithm": ${algorithmId2}`);
          return crypto2.importKey("raw", sessionKey, contentEncryptionAlgorithm2, true, ["decrypt"]);
        };
        const SubKEKRecipientInfo = async (index) => {
          const recipientInfo = this.recipientInfos[index].value;
          if (!decryptionParameters.preDefinedData)
            throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');
          const kekAlgorithm = crypto2.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "kekAlgorithm");
          const importedKey = await crypto2.importKey("raw", decryptionParameters.preDefinedData, kekAlgorithm, true, ["unwrapKey"]);
          const algorithmId2 = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
          const contentEncryptionAlgorithm2 = crypto2.getAlgorithmByOID(algorithmId2, true, "contentEncryptionAlgorithm");
          if (!contentEncryptionAlgorithm2.name) {
            throw new Error(`Incorrect "contentEncryptionAlgorithm": ${algorithmId2}`);
          }
          return crypto2.unwrapKey("raw", recipientInfo.encryptedKey.valueBlock.valueHexView, importedKey, kekAlgorithm, contentEncryptionAlgorithm2, true, ["decrypt"]);
        };
        const SubPasswordRecipientinfo = async (index) => {
          const recipientInfo = this.recipientInfos[index].value;
          let pbkdf2Params;
          if (!decryptionParameters.preDefinedData) {
            throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');
          }
          if (!recipientInfo.keyDerivationAlgorithm) {
            throw new Error('Please append encoded "keyDerivationAlgorithm"');
          }
          if (!recipientInfo.keyDerivationAlgorithm.algorithmParams) {
            throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');
          }
          try {
            pbkdf2Params = new PBKDF2Params({ schema: recipientInfo.keyDerivationAlgorithm.algorithmParams });
          } catch (ex) {
            throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');
          }
          const pbkdf2Key = await crypto2.importKey("raw", decryptionParameters.preDefinedData, "PBKDF2", false, ["deriveKey"]);
          const kekAlgorithm = crypto2.getAlgorithmByOID(recipientInfo.keyEncryptionAlgorithm.algorithmId, true, "keyEncryptionAlgorithm");
          const hmacHashAlgorithm = pbkdf2Params.prf ? crypto2.getAlgorithmByOID(pbkdf2Params.prf.algorithmId, true, "prfAlgorithm").hash.name : "SHA-1";
          const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
          const iterations = pbkdf2Params.iterationCount;
          const kekKey = await crypto2.deriveKey({
            name: "PBKDF2",
            hash: {
              name: hmacHashAlgorithm
            },
            salt: saltView,
            iterations
          }, pbkdf2Key, kekAlgorithm, true, ["unwrapKey"]);
          const algorithmId2 = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
          const contentEncryptionAlgorithm2 = crypto2.getAlgorithmByOID(algorithmId2, true, "contentEncryptionAlgorithm");
          return crypto2.unwrapKey("raw", recipientInfo.encryptedKey.valueBlock.valueHexView, kekKey, kekAlgorithm, contentEncryptionAlgorithm2, true, ["decrypt"]);
        };
        let unwrappedKey;
        switch (this.recipientInfos[recipientIndex].variant) {
          case 1:
            unwrappedKey = await SubKeyTransRecipientInfo(recipientIndex);
            break;
          case 2:
            unwrappedKey = await SubKeyAgreeRecipientInfo(recipientIndex);
            break;
          case 3:
            unwrappedKey = await SubKEKRecipientInfo(recipientIndex);
            break;
          case 4:
            unwrappedKey = await SubPasswordRecipientinfo(recipientIndex);
            break;
          default:
            throw new Error(`Unknown recipient type in array with index ${recipientIndex}`);
        }
        const algorithmId = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId;
        const contentEncryptionAlgorithm = crypto2.getAlgorithmByOID(algorithmId, true, "contentEncryptionAlgorithm");
        const ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;
        const ivView = new Uint8Array(ivBuffer);
        if (!this.encryptedContentInfo.encryptedContent) {
          throw new Error("Required property `encryptedContent` is empty");
        }
        const dataBuffer = this.encryptedContentInfo.getEncryptedContent();
        return crypto2.decrypt({
          name: contentEncryptionAlgorithm.name,
          iv: ivView
        }, unwrappedKey, dataBuffer);
      }
    };
    EnvelopedData.CLASS_NAME = "EnvelopedData";
    var SAFE_CONTENTS = "safeContents";
    var PARSED_VALUE$1 = "parsedValue";
    var CONTENT_INFOS = "contentInfos";
    var AuthenticatedSafe = class _AuthenticatedSafe extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.safeContents = pvutils__namespace.getParametersValue(parameters, SAFE_CONTENTS, _AuthenticatedSafe.defaultValues(SAFE_CONTENTS));
        if (PARSED_VALUE$1 in parameters) {
          this.parsedValue = pvutils__namespace.getParametersValue(parameters, PARSED_VALUE$1, _AuthenticatedSafe.defaultValues(PARSED_VALUE$1));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case SAFE_CONTENTS:
            return [];
          case PARSED_VALUE$1:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SAFE_CONTENTS:
            return memberValue.length === 0;
          case PARSED_VALUE$1:
            return memberValue instanceof Object && Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Repeated({
              name: names.contentInfos || EMPTY_STRING,
              value: ContentInfo.schema()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, [
          CONTENT_INFOS
        ]);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _AuthenticatedSafe.schema({
          names: {
            contentInfos: CONTENT_INFOS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.safeContents = Array.from(asn1.result.contentInfos, (element) => new ContentInfo({ schema: element }));
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: Array.from(this.safeContents, (o) => o.toSchema())
        });
      }
      toJSON() {
        return {
          safeContents: Array.from(this.safeContents, (o) => o.toJSON())
        };
      }
      async parseInternalValues(parameters, crypto2 = getCrypto(true)) {
        ParameterError.assert(parameters, SAFE_CONTENTS);
        ArgumentError.assert(parameters.safeContents, SAFE_CONTENTS, "Array");
        if (parameters.safeContents.length !== this.safeContents.length) {
          throw new ArgumentError('Length of "parameters.safeContents" must be equal to "this.safeContents.length"');
        }
        this.parsedValue = {
          safeContents: []
        };
        for (const [index, content] of this.safeContents.entries()) {
          const safeContent = parameters.safeContents[index];
          const errorTarget = `parameters.safeContents[${index}]`;
          switch (content.contentType) {
            case id_ContentType_Data:
              {
                ArgumentError.assert(content.content, "this.safeContents[j].content", asn1js__namespace.OctetString);
                const authSafeContent = content.content.getValue();
                this.parsedValue.safeContents.push({
                  privacyMode: 0,
                  value: SafeContents.fromBER(authSafeContent)
                });
              }
              break;
            case id_ContentType_EnvelopedData:
              {
                const cmsEnveloped = new EnvelopedData({ schema: content.content });
                ParameterError.assert(errorTarget, safeContent, "recipientCertificate", "recipientKey");
                const envelopedData = safeContent;
                const recipientCertificate = envelopedData.recipientCertificate;
                const recipientKey = envelopedData.recipientKey;
                const decrypted = await cmsEnveloped.decrypt(0, {
                  recipientCertificate,
                  recipientPrivateKey: recipientKey
                }, crypto2);
                this.parsedValue.safeContents.push({
                  privacyMode: 2,
                  value: SafeContents.fromBER(decrypted)
                });
              }
              break;
            case id_ContentType_EncryptedData:
              {
                const cmsEncrypted = new EncryptedData({ schema: content.content });
                ParameterError.assert(errorTarget, safeContent, "password");
                const password = safeContent.password;
                const decrypted = await cmsEncrypted.decrypt({
                  password
                }, crypto2);
                this.parsedValue.safeContents.push({
                  privacyMode: 1,
                  value: SafeContents.fromBER(decrypted)
                });
              }
              break;
            default:
              throw new Error(`Unknown "contentType" for AuthenticatedSafe: " ${content.contentType}`);
          }
        }
      }
      async makeInternalValues(parameters, crypto2 = getCrypto(true)) {
        if (!this.parsedValue) {
          throw new Error('Please run "parseValues" first or add "parsedValue" manually');
        }
        ArgumentError.assert(this.parsedValue, "this.parsedValue", "object");
        ArgumentError.assert(this.parsedValue.safeContents, "this.parsedValue.safeContents", "Array");
        ArgumentError.assert(parameters, "parameters", "object");
        ParameterError.assert(parameters, "safeContents");
        ArgumentError.assert(parameters.safeContents, "parameters.safeContents", "Array");
        if (parameters.safeContents.length !== this.parsedValue.safeContents.length) {
          throw new ArgumentError('Length of "parameters.safeContents" must be equal to "this.parsedValue.safeContents"');
        }
        this.safeContents = [];
        for (const [index, content] of this.parsedValue.safeContents.entries()) {
          ParameterError.assert("content", content, "privacyMode", "value");
          ArgumentError.assert(content.value, "content.value", SafeContents);
          switch (content.privacyMode) {
            case 0:
              {
                const contentBuffer = content.value.toSchema().toBER(false);
                this.safeContents.push(new ContentInfo({
                  contentType: "1.2.840.113549.1.7.1",
                  content: new asn1js__namespace.OctetString({ valueHex: contentBuffer })
                }));
              }
              break;
            case 1:
              {
                const cmsEncrypted = new EncryptedData();
                const currentParameters = parameters.safeContents[index];
                currentParameters.contentToEncrypt = content.value.toSchema().toBER(false);
                await cmsEncrypted.encrypt(currentParameters, crypto2);
                this.safeContents.push(new ContentInfo({
                  contentType: "1.2.840.113549.1.7.6",
                  content: cmsEncrypted.toSchema()
                }));
              }
              break;
            case 2:
              {
                const cmsEnveloped = new EnvelopedData();
                const contentToEncrypt = content.value.toSchema().toBER(false);
                const safeContent = parameters.safeContents[index];
                ParameterError.assert(`parameters.safeContents[${index}]`, safeContent, "encryptingCertificate", "encryptionAlgorithm");
                switch (true) {
                  case safeContent.encryptionAlgorithm.name.toLowerCase() === "aes-cbc":
                  case safeContent.encryptionAlgorithm.name.toLowerCase() === "aes-gcm":
                    break;
                  default:
                    throw new Error(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${safeContent.encryptionAlgorithm}`);
                }
                switch (true) {
                  case safeContent.encryptionAlgorithm.length === 128:
                  case safeContent.encryptionAlgorithm.length === 192:
                  case safeContent.encryptionAlgorithm.length === 256:
                    break;
                  default:
                    throw new Error(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${safeContent.encryptionAlgorithm.length}`);
                }
                const encryptionAlgorithm = safeContent.encryptionAlgorithm;
                cmsEnveloped.addRecipientByCertificate(safeContent.encryptingCertificate, {}, void 0, crypto2);
                await cmsEnveloped.encrypt(encryptionAlgorithm, contentToEncrypt, crypto2);
                this.safeContents.push(new ContentInfo({
                  contentType: "1.2.840.113549.1.7.3",
                  content: cmsEnveloped.toSchema()
                }));
              }
              break;
            default:
              throw new Error(`Incorrect value for "content.privacyMode": ${content.privacyMode}`);
          }
        }
        return this;
      }
    };
    AuthenticatedSafe.CLASS_NAME = "AuthenticatedSafe";
    var HASH_ALGORITHM$1 = "hashAlgorithm";
    var ISSUER_NAME_HASH = "issuerNameHash";
    var ISSUER_KEY_HASH = "issuerKeyHash";
    var SERIAL_NUMBER$1 = "serialNumber";
    var CLEAR_PROPS$j = [
      HASH_ALGORITHM$1,
      ISSUER_NAME_HASH,
      ISSUER_KEY_HASH,
      SERIAL_NUMBER$1
    ];
    var CertID = class _CertID extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.hashAlgorithm = pvutils__namespace.getParametersValue(parameters, HASH_ALGORITHM$1, _CertID.defaultValues(HASH_ALGORITHM$1));
        this.issuerNameHash = pvutils__namespace.getParametersValue(parameters, ISSUER_NAME_HASH, _CertID.defaultValues(ISSUER_NAME_HASH));
        this.issuerKeyHash = pvutils__namespace.getParametersValue(parameters, ISSUER_KEY_HASH, _CertID.defaultValues(ISSUER_KEY_HASH));
        this.serialNumber = pvutils__namespace.getParametersValue(parameters, SERIAL_NUMBER$1, _CertID.defaultValues(SERIAL_NUMBER$1));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static async create(certificate, parameters, crypto2 = getCrypto(true)) {
        const certID = new _CertID();
        await certID.createForCertificate(certificate, parameters, crypto2);
        return certID;
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case HASH_ALGORITHM$1:
            return new AlgorithmIdentifier();
          case ISSUER_NAME_HASH:
          case ISSUER_KEY_HASH:
            return new asn1js__namespace.OctetString();
          case SERIAL_NUMBER$1:
            return new asn1js__namespace.Integer();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case HASH_ALGORITHM$1:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case ISSUER_NAME_HASH:
          case ISSUER_KEY_HASH:
          case SERIAL_NUMBER$1:
            return memberValue.isEqual(_CertID.defaultValues(SERIAL_NUMBER$1));
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            AlgorithmIdentifier.schema(names.hashAlgorithmObject || {
              names: {
                blockName: names.hashAlgorithm || EMPTY_STRING
              }
            }),
            new asn1js__namespace.OctetString({ name: names.issuerNameHash || EMPTY_STRING }),
            new asn1js__namespace.OctetString({ name: names.issuerKeyHash || EMPTY_STRING }),
            new asn1js__namespace.Integer({ name: names.serialNumber || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$j);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _CertID.schema({
          names: {
            hashAlgorithm: HASH_ALGORITHM$1,
            issuerNameHash: ISSUER_NAME_HASH,
            issuerKeyHash: ISSUER_KEY_HASH,
            serialNumber: SERIAL_NUMBER$1
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
        this.issuerNameHash = asn1.result.issuerNameHash;
        this.issuerKeyHash = asn1.result.issuerKeyHash;
        this.serialNumber = asn1.result.serialNumber;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.hashAlgorithm.toSchema(),
            this.issuerNameHash,
            this.issuerKeyHash,
            this.serialNumber
          ]
        });
      }
      toJSON() {
        return {
          hashAlgorithm: this.hashAlgorithm.toJSON(),
          issuerNameHash: this.issuerNameHash.toJSON(),
          issuerKeyHash: this.issuerKeyHash.toJSON(),
          serialNumber: this.serialNumber.toJSON()
        };
      }
      isEqual(certificateID) {
        if (this.hashAlgorithm.algorithmId !== certificateID.hashAlgorithm.algorithmId) {
          return false;
        }
        if (!pvtsutils__namespace.BufferSourceConverter.isEqual(this.issuerNameHash.valueBlock.valueHexView, certificateID.issuerNameHash.valueBlock.valueHexView)) {
          return false;
        }
        if (!pvtsutils__namespace.BufferSourceConverter.isEqual(this.issuerKeyHash.valueBlock.valueHexView, certificateID.issuerKeyHash.valueBlock.valueHexView)) {
          return false;
        }
        if (!this.serialNumber.isEqual(certificateID.serialNumber)) {
          return false;
        }
        return true;
      }
      async createForCertificate(certificate, parameters, crypto2 = getCrypto(true)) {
        ParameterError.assert(parameters, HASH_ALGORITHM$1, "issuerCertificate");
        const hashOID = crypto2.getOIDByAlgorithm({ name: parameters.hashAlgorithm }, true, "hashAlgorithm");
        this.hashAlgorithm = new AlgorithmIdentifier({
          algorithmId: hashOID,
          algorithmParams: new asn1js__namespace.Null()
        });
        const issuerCertificate = parameters.issuerCertificate;
        this.serialNumber = certificate.serialNumber;
        const hashIssuerName = await crypto2.digest({ name: parameters.hashAlgorithm }, issuerCertificate.subject.toSchema().toBER(false));
        this.issuerNameHash = new asn1js__namespace.OctetString({ valueHex: hashIssuerName });
        const issuerKeyBuffer = issuerCertificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView;
        const hashIssuerKey = await crypto2.digest({ name: parameters.hashAlgorithm }, issuerKeyBuffer);
        this.issuerKeyHash = new asn1js__namespace.OctetString({ valueHex: hashIssuerKey });
      }
    };
    CertID.CLASS_NAME = "CertID";
    var CERT_ID = "certID";
    var CERT_STATUS = "certStatus";
    var THIS_UPDATE = "thisUpdate";
    var NEXT_UPDATE = "nextUpdate";
    var SINGLE_EXTENSIONS = "singleExtensions";
    var CLEAR_PROPS$i = [
      CERT_ID,
      CERT_STATUS,
      THIS_UPDATE,
      NEXT_UPDATE,
      SINGLE_EXTENSIONS
    ];
    var SingleResponse = class _SingleResponse extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.certID = pvutils__namespace.getParametersValue(parameters, CERT_ID, _SingleResponse.defaultValues(CERT_ID));
        this.certStatus = pvutils__namespace.getParametersValue(parameters, CERT_STATUS, _SingleResponse.defaultValues(CERT_STATUS));
        this.thisUpdate = pvutils__namespace.getParametersValue(parameters, THIS_UPDATE, _SingleResponse.defaultValues(THIS_UPDATE));
        if (NEXT_UPDATE in parameters) {
          this.nextUpdate = pvutils__namespace.getParametersValue(parameters, NEXT_UPDATE, _SingleResponse.defaultValues(NEXT_UPDATE));
        }
        if (SINGLE_EXTENSIONS in parameters) {
          this.singleExtensions = pvutils__namespace.getParametersValue(parameters, SINGLE_EXTENSIONS, _SingleResponse.defaultValues(SINGLE_EXTENSIONS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case CERT_ID:
            return new CertID();
          case CERT_STATUS:
            return {};
          case THIS_UPDATE:
          case NEXT_UPDATE:
            return new Date(0, 0, 0);
          case SINGLE_EXTENSIONS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case CERT_ID:
            return CertID.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm) && CertID.compareWithDefault("issuerNameHash", memberValue.issuerNameHash) && CertID.compareWithDefault("issuerKeyHash", memberValue.issuerKeyHash) && CertID.compareWithDefault("serialNumber", memberValue.serialNumber);
          case CERT_STATUS:
            return Object.keys(memberValue).length === 0;
          case THIS_UPDATE:
          case NEXT_UPDATE:
            return memberValue === _SingleResponse.defaultValues(memberName);
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            CertID.schema(names.certID || {}),
            new asn1js__namespace.Choice({
              value: [
                new asn1js__namespace.Primitive({
                  name: names.certStatus || EMPTY_STRING,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 0
                  }
                }),
                new asn1js__namespace.Constructed({
                  name: names.certStatus || EMPTY_STRING,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                  },
                  value: [
                    new asn1js__namespace.GeneralizedTime(),
                    new asn1js__namespace.Constructed({
                      optional: true,
                      idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                      },
                      value: [new asn1js__namespace.Enumerated()]
                    })
                  ]
                }),
                new asn1js__namespace.Primitive({
                  name: names.certStatus || EMPTY_STRING,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                  },
                  lenBlock: { length: 1 }
                })
              ]
            }),
            new asn1js__namespace.GeneralizedTime({ name: names.thisUpdate || EMPTY_STRING }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.GeneralizedTime({ name: names.nextUpdate || EMPTY_STRING })]
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [Extensions.schema(names.singleExtensions || {})]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$i);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _SingleResponse.schema({
          names: {
            certID: {
              names: {
                blockName: CERT_ID
              }
            },
            certStatus: CERT_STATUS,
            thisUpdate: THIS_UPDATE,
            nextUpdate: NEXT_UPDATE,
            singleExtensions: {
              names: {
                blockName: SINGLE_EXTENSIONS
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.certID = new CertID({ schema: asn1.result.certID });
        this.certStatus = asn1.result.certStatus;
        this.thisUpdate = asn1.result.thisUpdate.toDate();
        if (NEXT_UPDATE in asn1.result)
          this.nextUpdate = asn1.result.nextUpdate.toDate();
        if (SINGLE_EXTENSIONS in asn1.result)
          this.singleExtensions = Array.from(asn1.result.singleExtensions.valueBlock.value, (element) => new Extension({ schema: element }));
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(this.certID.toSchema());
        outputArray.push(this.certStatus);
        outputArray.push(new asn1js__namespace.GeneralizedTime({ valueDate: this.thisUpdate }));
        if (this.nextUpdate) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [new asn1js__namespace.GeneralizedTime({ valueDate: this.nextUpdate })]
          }));
        }
        if (this.singleExtensions) {
          outputArray.push(new asn1js__namespace.Sequence({
            value: Array.from(this.singleExtensions, (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          certID: this.certID.toJSON(),
          certStatus: this.certStatus.toJSON(),
          thisUpdate: this.thisUpdate
        };
        if (this.nextUpdate) {
          res.nextUpdate = this.nextUpdate;
        }
        if (this.singleExtensions) {
          res.singleExtensions = Array.from(this.singleExtensions, (o) => o.toJSON());
        }
        return res;
      }
    };
    SingleResponse.CLASS_NAME = "SingleResponse";
    var TBS$2 = "tbs";
    var VERSION$7 = "version";
    var RESPONDER_ID = "responderID";
    var PRODUCED_AT = "producedAt";
    var RESPONSES = "responses";
    var RESPONSE_EXTENSIONS = "responseExtensions";
    var RESPONSE_DATA = "ResponseData";
    var RESPONSE_DATA_VERSION = `${RESPONSE_DATA}.${VERSION$7}`;
    var RESPONSE_DATA_RESPONDER_ID = `${RESPONSE_DATA}.${RESPONDER_ID}`;
    var RESPONSE_DATA_PRODUCED_AT = `${RESPONSE_DATA}.${PRODUCED_AT}`;
    var RESPONSE_DATA_RESPONSES = `${RESPONSE_DATA}.${RESPONSES}`;
    var RESPONSE_DATA_RESPONSE_EXTENSIONS = `${RESPONSE_DATA}.${RESPONSE_EXTENSIONS}`;
    var CLEAR_PROPS$h = [
      RESPONSE_DATA,
      RESPONSE_DATA_VERSION,
      RESPONSE_DATA_RESPONDER_ID,
      RESPONSE_DATA_PRODUCED_AT,
      RESPONSE_DATA_RESPONSES,
      RESPONSE_DATA_RESPONSE_EXTENSIONS
    ];
    var ResponseData = class _ResponseData extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.tbsView = new Uint8Array(pvutils__namespace.getParametersValue(parameters, TBS$2, _ResponseData.defaultValues(TBS$2)));
        if (VERSION$7 in parameters) {
          this.version = pvutils__namespace.getParametersValue(parameters, VERSION$7, _ResponseData.defaultValues(VERSION$7));
        }
        this.responderID = pvutils__namespace.getParametersValue(parameters, RESPONDER_ID, _ResponseData.defaultValues(RESPONDER_ID));
        this.producedAt = pvutils__namespace.getParametersValue(parameters, PRODUCED_AT, _ResponseData.defaultValues(PRODUCED_AT));
        this.responses = pvutils__namespace.getParametersValue(parameters, RESPONSES, _ResponseData.defaultValues(RESPONSES));
        if (RESPONSE_EXTENSIONS in parameters) {
          this.responseExtensions = pvutils__namespace.getParametersValue(parameters, RESPONSE_EXTENSIONS, _ResponseData.defaultValues(RESPONSE_EXTENSIONS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      get tbs() {
        return pvtsutils__namespace.BufferSourceConverter.toArrayBuffer(this.tbsView);
      }
      set tbs(value) {
        this.tbsView = new Uint8Array(value);
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$7:
            return 0;
          case TBS$2:
            return EMPTY_BUFFER;
          case RESPONDER_ID:
            return {};
          case PRODUCED_AT:
            return new Date(0, 0, 0);
          case RESPONSES:
          case RESPONSE_EXTENSIONS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TBS$2:
            return memberValue.byteLength === 0;
          case RESPONDER_ID:
            return Object.keys(memberValue).length === 0;
          case PRODUCED_AT:
            return memberValue === _ResponseData.defaultValues(memberName);
          case RESPONSES:
          case RESPONSE_EXTENSIONS:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || RESPONSE_DATA,
          value: [
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.Integer({ name: names.version || RESPONSE_DATA_VERSION })]
            }),
            new asn1js__namespace.Choice({
              value: [
                new asn1js__namespace.Constructed({
                  name: names.responderID || RESPONSE_DATA_RESPONDER_ID,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 1
                  },
                  value: [RelativeDistinguishedNames.schema(names.ResponseDataByName || {
                    names: {
                      blockName: "ResponseData.byName"
                    }
                  })]
                }),
                new asn1js__namespace.Constructed({
                  name: names.responderID || RESPONSE_DATA_RESPONDER_ID,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: 2
                  },
                  value: [new asn1js__namespace.OctetString({ name: names.ResponseDataByKey || "ResponseData.byKey" })]
                })
              ]
            }),
            new asn1js__namespace.GeneralizedTime({ name: names.producedAt || RESPONSE_DATA_PRODUCED_AT }),
            new asn1js__namespace.Sequence({
              value: [
                new asn1js__namespace.Repeated({
                  name: RESPONSE_DATA_RESPONSES,
                  value: SingleResponse.schema(names.response || {})
                })
              ]
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [Extensions.schema(names.extensions || {
                names: {
                  blockName: RESPONSE_DATA_RESPONSE_EXTENSIONS
                }
              })]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$h);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _ResponseData.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsView = asn1.result.ResponseData.valueBeforeDecodeView;
        if (RESPONSE_DATA_VERSION in asn1.result)
          this.version = asn1.result[RESPONSE_DATA_VERSION].valueBlock.valueDec;
        if (asn1.result[RESPONSE_DATA_RESPONDER_ID].idBlock.tagNumber === 1)
          this.responderID = new RelativeDistinguishedNames({ schema: asn1.result[RESPONSE_DATA_RESPONDER_ID].valueBlock.value[0] });
        else
          this.responderID = asn1.result[RESPONSE_DATA_RESPONDER_ID].valueBlock.value[0];
        this.producedAt = asn1.result[RESPONSE_DATA_PRODUCED_AT].toDate();
        this.responses = Array.from(asn1.result[RESPONSE_DATA_RESPONSES], (element) => new SingleResponse({ schema: element }));
        if (RESPONSE_DATA_RESPONSE_EXTENSIONS in asn1.result)
          this.responseExtensions = Array.from(asn1.result[RESPONSE_DATA_RESPONSE_EXTENSIONS].valueBlock.value, (element) => new Extension({ schema: element }));
      }
      toSchema(encodeFlag = false) {
        let tbsSchema;
        if (encodeFlag === false) {
          if (!this.tbsView.byteLength) {
            return _ResponseData.schema();
          }
          const asn1 = asn1js__namespace.fromBER(this.tbsView);
          AsnError.assert(asn1, "TBS Response Data");
          tbsSchema = asn1.result;
        } else {
          const outputArray = [];
          if (VERSION$7 in this) {
            outputArray.push(new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.Integer({ value: this.version })]
            }));
          }
          if (this.responderID instanceof RelativeDistinguishedNames) {
            outputArray.push(new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [this.responderID.toSchema()]
            }));
          } else {
            outputArray.push(new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: [this.responderID]
            }));
          }
          outputArray.push(new asn1js__namespace.GeneralizedTime({ valueDate: this.producedAt }));
          outputArray.push(new asn1js__namespace.Sequence({
            value: Array.from(this.responses, (o) => o.toSchema())
          }));
          if (this.responseExtensions) {
            outputArray.push(new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [new asn1js__namespace.Sequence({
                value: Array.from(this.responseExtensions, (o) => o.toSchema())
              })]
            }));
          }
          tbsSchema = new asn1js__namespace.Sequence({
            value: outputArray
          });
        }
        return tbsSchema;
      }
      toJSON() {
        const res = {};
        if (VERSION$7 in this) {
          res.version = this.version;
        }
        if (this.responderID) {
          res.responderID = this.responderID;
        }
        if (this.producedAt) {
          res.producedAt = this.producedAt;
        }
        if (this.responses) {
          res.responses = Array.from(this.responses, (o) => o.toJSON());
        }
        if (this.responseExtensions) {
          res.responseExtensions = Array.from(this.responseExtensions, (o) => o.toJSON());
        }
        return res;
      }
    };
    ResponseData.CLASS_NAME = "ResponseData";
    var TRUSTED_CERTS = "trustedCerts";
    var CERTS$2 = "certs";
    var CRLS$1 = "crls";
    var OCSPS$1 = "ocsps";
    var CHECK_DATE = "checkDate";
    var FIND_ORIGIN = "findOrigin";
    var FIND_ISSUER = "findIssuer";
    exports.ChainValidationCode = void 0;
    (function(ChainValidationCode) {
      ChainValidationCode[ChainValidationCode["unknown"] = -1] = "unknown";
      ChainValidationCode[ChainValidationCode["success"] = 0] = "success";
      ChainValidationCode[ChainValidationCode["noRevocation"] = 11] = "noRevocation";
      ChainValidationCode[ChainValidationCode["noPath"] = 60] = "noPath";
      ChainValidationCode[ChainValidationCode["noValidPath"] = 97] = "noValidPath";
    })(exports.ChainValidationCode || (exports.ChainValidationCode = {}));
    var ChainValidationError = class _ChainValidationError extends Error {
      constructor(code, message3) {
        super(message3);
        this.name = _ChainValidationError.NAME;
        this.code = code;
        this.message = message3;
      }
    };
    ChainValidationError.NAME = "ChainValidationError";
    function isTrusted(cert, trustedList) {
      for (let i = 0; i < trustedList.length; i++) {
        if (pvtsutils__namespace.BufferSourceConverter.isEqual(cert.tbsView, trustedList[i].tbsView)) {
          return true;
        }
      }
      return false;
    }
    var CertificateChainValidationEngine = class _CertificateChainValidationEngine {
      constructor(parameters = {}) {
        this.trustedCerts = pvutils__namespace.getParametersValue(parameters, TRUSTED_CERTS, this.defaultValues(TRUSTED_CERTS));
        this.certs = pvutils__namespace.getParametersValue(parameters, CERTS$2, this.defaultValues(CERTS$2));
        this.crls = pvutils__namespace.getParametersValue(parameters, CRLS$1, this.defaultValues(CRLS$1));
        this.ocsps = pvutils__namespace.getParametersValue(parameters, OCSPS$1, this.defaultValues(OCSPS$1));
        this.checkDate = pvutils__namespace.getParametersValue(parameters, CHECK_DATE, this.defaultValues(CHECK_DATE));
        this.findOrigin = pvutils__namespace.getParametersValue(parameters, FIND_ORIGIN, this.defaultValues(FIND_ORIGIN));
        this.findIssuer = pvutils__namespace.getParametersValue(parameters, FIND_ISSUER, this.defaultValues(FIND_ISSUER));
      }
      static defaultFindOrigin(certificate, validationEngine) {
        if (certificate.tbsView.byteLength === 0) {
          certificate.tbsView = new Uint8Array(certificate.encodeTBS().toBER());
        }
        for (const localCert of validationEngine.certs) {
          if (localCert.tbsView.byteLength === 0) {
            localCert.tbsView = new Uint8Array(localCert.encodeTBS().toBER());
          }
          if (pvtsutils__namespace.BufferSourceConverter.isEqual(certificate.tbsView, localCert.tbsView))
            return "Intermediate Certificates";
        }
        for (const trustedCert of validationEngine.trustedCerts) {
          if (trustedCert.tbsView.byteLength === 0)
            trustedCert.tbsView = new Uint8Array(trustedCert.encodeTBS().toBER());
          if (pvtsutils__namespace.BufferSourceConverter.isEqual(certificate.tbsView, trustedCert.tbsView))
            return "Trusted Certificates";
        }
        return "Unknown";
      }
      async defaultFindIssuer(certificate, validationEngine, crypto2 = getCrypto(true)) {
        const result = [];
        let keyIdentifier = null;
        let authorityCertIssuer = null;
        let authorityCertSerialNumber = null;
        if (certificate.subject.isEqual(certificate.issuer)) {
          try {
            const verificationResult = await certificate.verify(void 0, crypto2);
            if (verificationResult) {
              return [certificate];
            }
          } catch (ex) {
          }
        }
        if (certificate.extensions) {
          for (const extension of certificate.extensions) {
            if (extension.extnID === id_AuthorityKeyIdentifier && extension.parsedValue instanceof AuthorityKeyIdentifier) {
              if (extension.parsedValue.keyIdentifier) {
                keyIdentifier = extension.parsedValue.keyIdentifier;
              } else {
                if (extension.parsedValue.authorityCertIssuer) {
                  authorityCertIssuer = extension.parsedValue.authorityCertIssuer;
                }
                if (extension.parsedValue.authorityCertSerialNumber) {
                  authorityCertSerialNumber = extension.parsedValue.authorityCertSerialNumber;
                }
              }
              break;
            }
          }
        }
        function checkCertificate(possibleIssuer) {
          if (keyIdentifier !== null) {
            if (possibleIssuer.extensions) {
              let extensionFound = false;
              for (const extension of possibleIssuer.extensions) {
                if (extension.extnID === id_SubjectKeyIdentifier && extension.parsedValue) {
                  extensionFound = true;
                  if (pvtsutils__namespace.BufferSourceConverter.isEqual(extension.parsedValue.valueBlock.valueHex, keyIdentifier.valueBlock.valueHexView)) {
                    result.push(possibleIssuer);
                  }
                  break;
                }
              }
              if (extensionFound) {
                return;
              }
            }
          }
          let authorityCertSerialNumberEqual = false;
          if (authorityCertSerialNumber !== null)
            authorityCertSerialNumberEqual = possibleIssuer.serialNumber.isEqual(authorityCertSerialNumber);
          if (authorityCertIssuer !== null) {
            if (possibleIssuer.subject.isEqual(authorityCertIssuer)) {
              if (authorityCertSerialNumberEqual)
                result.push(possibleIssuer);
            }
          } else {
            if (certificate.issuer.isEqual(possibleIssuer.subject))
              result.push(possibleIssuer);
          }
        }
        for (const trustedCert of validationEngine.trustedCerts) {
          checkCertificate(trustedCert);
        }
        for (const intermediateCert of validationEngine.certs) {
          checkCertificate(intermediateCert);
        }
        for (let i = 0; i < result.length; i++) {
          try {
            const verificationResult = await certificate.verify(result[i], crypto2);
            if (verificationResult === false)
              result.splice(i, 1);
          } catch (ex) {
            result.splice(i, 1);
          }
        }
        return result;
      }
      defaultValues(memberName) {
        switch (memberName) {
          case TRUSTED_CERTS:
            return [];
          case CERTS$2:
            return [];
          case CRLS$1:
            return [];
          case OCSPS$1:
            return [];
          case CHECK_DATE:
            return /* @__PURE__ */ new Date();
          case FIND_ORIGIN:
            return _CertificateChainValidationEngine.defaultFindOrigin;
          case FIND_ISSUER:
            return this.defaultFindIssuer;
          default:
            throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${memberName}`);
        }
      }
      async sort(passedWhenNotRevValues = false, crypto2 = getCrypto(true)) {
        const localCerts = [];
        const buildPath = async (certificate, crypto3) => {
          const result2 = [];
          function checkUnique(array) {
            let unique = true;
            for (let i = 0; i < array.length; i++) {
              for (let j = 0; j < array.length; j++) {
                if (j === i)
                  continue;
                if (array[i] === array[j]) {
                  unique = false;
                  break;
                }
              }
              if (!unique)
                break;
            }
            return unique;
          }
          if (isTrusted(certificate, this.trustedCerts)) {
            return [[certificate]];
          }
          const findIssuerResult = await this.findIssuer(certificate, this, crypto3);
          if (findIssuerResult.length === 0) {
            throw new Error("No valid certificate paths found");
          }
          for (let i = 0; i < findIssuerResult.length; i++) {
            if (pvtsutils__namespace.BufferSourceConverter.isEqual(findIssuerResult[i].tbsView, certificate.tbsView)) {
              result2.push([findIssuerResult[i]]);
              continue;
            }
            const buildPathResult = await buildPath(findIssuerResult[i], crypto3);
            for (let j = 0; j < buildPathResult.length; j++) {
              const copy = buildPathResult[j].slice();
              copy.splice(0, 0, findIssuerResult[i]);
              if (checkUnique(copy))
                result2.push(copy);
              else
                result2.push(buildPathResult[j]);
            }
          }
          return result2;
        };
        const findCRL = async (certificate) => {
          const issuerCertificates = [];
          const crls = [];
          const crlsAndCertificates = [];
          issuerCertificates.push(...localCerts.filter((element) => certificate.issuer.isEqual(element.subject)));
          if (issuerCertificates.length === 0) {
            return {
              status: 1,
              statusMessage: "No certificate's issuers"
            };
          }
          crls.push(...this.crls.filter((o) => o.issuer.isEqual(certificate.issuer)));
          if (crls.length === 0) {
            return {
              status: 2,
              statusMessage: "No CRLs for specific certificate issuer"
            };
          }
          for (let i = 0; i < crls.length; i++) {
            const crl = crls[i];
            if (crl.nextUpdate && crl.nextUpdate.value < this.checkDate) {
              continue;
            }
            for (let j = 0; j < issuerCertificates.length; j++) {
              try {
                const result2 = await crls[i].verify({ issuerCertificate: issuerCertificates[j] }, crypto2);
                if (result2) {
                  crlsAndCertificates.push({
                    crl: crls[i],
                    certificate: issuerCertificates[j]
                  });
                  break;
                }
              } catch (ex) {
              }
            }
          }
          if (crlsAndCertificates.length) {
            return {
              status: 0,
              statusMessage: EMPTY_STRING,
              result: crlsAndCertificates
            };
          }
          return {
            status: 3,
            statusMessage: "No valid CRLs found"
          };
        };
        const findOCSP = async (certificate, issuerCertificate) => {
          const hashAlgorithm = crypto2.getAlgorithmByOID(certificate.signatureAlgorithm.algorithmId);
          if (!hashAlgorithm.name) {
            return 1;
          }
          if (!hashAlgorithm.hash) {
            return 1;
          }
          for (let i = 0; i < this.ocsps.length; i++) {
            const ocsp = this.ocsps[i];
            const result2 = await ocsp.getCertificateStatus(certificate, issuerCertificate, crypto2);
            if (result2.isForCertificate) {
              if (result2.status === 0)
                return 0;
              return 1;
            }
          }
          return 2;
        };
        async function checkForCA(certificate, needToCheckCRL = false) {
          let isCA = false;
          let mustBeCA = false;
          let keyUsagePresent = false;
          let cRLSign = false;
          if (certificate.extensions) {
            for (let j = 0; j < certificate.extensions.length; j++) {
              const extension = certificate.extensions[j];
              if (extension.critical && !extension.parsedValue) {
                return {
                  result: false,
                  resultCode: 6,
                  resultMessage: `Unable to parse critical certificate extension: ${extension.extnID}`
                };
              }
              if (extension.extnID === id_KeyUsage) {
                keyUsagePresent = true;
                const view = new Uint8Array(extension.parsedValue.valueBlock.valueHex);
                if ((view[0] & 4) === 4)
                  mustBeCA = true;
                if ((view[0] & 2) === 2)
                  cRLSign = true;
              }
              if (extension.extnID === id_BasicConstraints) {
                if ("cA" in extension.parsedValue) {
                  if (extension.parsedValue.cA === true)
                    isCA = true;
                }
              }
            }
            if (mustBeCA === true && isCA === false) {
              return {
                result: false,
                resultCode: 3,
                resultMessage: 'Unable to build certificate chain - using "keyCertSign" flag set without BasicConstraints'
              };
            }
            if (keyUsagePresent === true && isCA === true && mustBeCA === false) {
              return {
                result: false,
                resultCode: 4,
                resultMessage: 'Unable to build certificate chain - "keyCertSign" flag was not set'
              };
            }
            if (isCA === true && keyUsagePresent === true && (needToCheckCRL && cRLSign === false)) {
              return {
                result: false,
                resultCode: 5,
                resultMessage: 'Unable to build certificate chain - intermediate certificate must have "cRLSign" key usage flag'
              };
            }
          }
          if (isCA === false) {
            return {
              result: false,
              resultCode: 7,
              resultMessage: "Unable to build certificate chain - more than one possible end-user certificate"
            };
          }
          return {
            result: true,
            resultCode: 0,
            resultMessage: EMPTY_STRING
          };
        }
        const basicCheck = async (path, checkDate) => {
          for (let i = 0; i < path.length; i++) {
            if (path[i].notBefore.value > checkDate || path[i].notAfter.value < checkDate) {
              return {
                result: false,
                resultCode: 8,
                resultMessage: "The certificate is either not yet valid or expired"
              };
            }
          }
          if (path.length < 2) {
            return {
              result: false,
              resultCode: 9,
              resultMessage: "Too short certificate path"
            };
          }
          for (let i = path.length - 2; i >= 0; i--) {
            if (path[i].issuer.isEqual(path[i].subject) === false) {
              if (path[i].issuer.isEqual(path[i + 1].subject) === false) {
                return {
                  result: false,
                  resultCode: 10,
                  resultMessage: "Incorrect name chaining"
                };
              }
            }
          }
          if (this.crls.length !== 0 || this.ocsps.length !== 0) {
            for (let i = 0; i < path.length - 1; i++) {
              let ocspResult = 2;
              let crlResult = {
                status: 0,
                statusMessage: EMPTY_STRING
              };
              if (this.ocsps.length !== 0) {
                ocspResult = await findOCSP(path[i], path[i + 1]);
                switch (ocspResult) {
                  case 0:
                    continue;
                  case 1:
                    return {
                      result: false,
                      resultCode: 12,
                      resultMessage: "One of certificates was revoked via OCSP response"
                    };
                }
              }
              if (this.crls.length !== 0) {
                crlResult = await findCRL(path[i]);
                if (crlResult.status === 0 && crlResult.result) {
                  for (let j = 0; j < crlResult.result.length; j++) {
                    const isCertificateRevoked = crlResult.result[j].crl.isCertificateRevoked(path[i]);
                    if (isCertificateRevoked) {
                      return {
                        result: false,
                        resultCode: 12,
                        resultMessage: "One of certificates had been revoked"
                      };
                    }
                    const isCertificateCA = await checkForCA(crlResult.result[j].certificate, true);
                    if (isCertificateCA.result === false) {
                      return {
                        result: false,
                        resultCode: 13,
                        resultMessage: "CRL issuer certificate is not a CA certificate or does not have crlSign flag"
                      };
                    }
                  }
                } else {
                  if (passedWhenNotRevValues === false) {
                    throw new ChainValidationError(exports.ChainValidationCode.noRevocation, `No revocation values found for one of certificates: ${crlResult.statusMessage}`);
                  }
                }
              } else {
                if (ocspResult === 2) {
                  return {
                    result: false,
                    resultCode: 11,
                    resultMessage: "No revocation values found for one of certificates"
                  };
                }
              }
              if (ocspResult === 2 && crlResult.status === 2 && passedWhenNotRevValues) {
                const issuerCertificate = path[i + 1];
                let extensionFound = false;
                if (issuerCertificate.extensions) {
                  for (const extension of issuerCertificate.extensions) {
                    switch (extension.extnID) {
                      case id_CRLDistributionPoints:
                      case id_FreshestCRL:
                      case id_AuthorityInfoAccess:
                        extensionFound = true;
                        break;
                    }
                  }
                }
                if (extensionFound) {
                  throw new ChainValidationError(exports.ChainValidationCode.noRevocation, `No revocation values found for one of certificates: ${crlResult.statusMessage}`);
                }
              }
            }
          }
          for (const [i, cert] of path.entries()) {
            if (!i) {
              continue;
            }
            const result2 = await checkForCA(cert);
            if (!result2.result) {
              return {
                result: false,
                resultCode: 14,
                resultMessage: "One of intermediate certificates is not a CA certificate"
              };
            }
          }
          return {
            result: true
          };
        };
        localCerts.push(...this.trustedCerts);
        localCerts.push(...this.certs);
        for (let i = 0; i < localCerts.length; i++) {
          for (let j = 0; j < localCerts.length; j++) {
            if (i === j)
              continue;
            if (pvtsutils__namespace.BufferSourceConverter.isEqual(localCerts[i].tbsView, localCerts[j].tbsView)) {
              localCerts.splice(j, 1);
              i = 0;
              break;
            }
          }
        }
        const leafCert = localCerts[localCerts.length - 1];
        let result;
        const certificatePath = [leafCert];
        result = await buildPath(leafCert, crypto2);
        if (result.length === 0) {
          throw new ChainValidationError(exports.ChainValidationCode.noPath, "Unable to find certificate path");
        }
        for (let i = 0; i < result.length; i++) {
          let found = false;
          for (let j = 0; j < result[i].length; j++) {
            const certificate = result[i][j];
            for (let k = 0; k < this.trustedCerts.length; k++) {
              if (pvtsutils__namespace.BufferSourceConverter.isEqual(certificate.tbsView, this.trustedCerts[k].tbsView)) {
                found = true;
                break;
              }
            }
            if (found)
              break;
          }
          if (!found) {
            result.splice(i, 1);
            i = 0;
          }
        }
        if (result.length === 0) {
          throw new ChainValidationError(exports.ChainValidationCode.noValidPath, "No valid certificate paths found");
        }
        let shortestLength = result[0].length;
        let shortestIndex = 0;
        for (let i = 0; i < result.length; i++) {
          if (result[i].length < shortestLength) {
            shortestLength = result[i].length;
            shortestIndex = i;
          }
        }
        for (let i = 0; i < result[shortestIndex].length; i++)
          certificatePath.push(result[shortestIndex][i]);
        result = await basicCheck(certificatePath, this.checkDate);
        if (result.result === false)
          throw result;
        return certificatePath;
      }
      async verify(parameters = {}, crypto2 = getCrypto(true)) {
        function compareDNSName(name, constraint) {
          const namePrepared = stringPrep(name);
          const constraintPrepared = stringPrep(constraint);
          const nameSplitted = namePrepared.split(".");
          const constraintSplitted = constraintPrepared.split(".");
          const nameLen = nameSplitted.length;
          const constrLen = constraintSplitted.length;
          if (nameLen === 0 || constrLen === 0 || nameLen < constrLen) {
            return false;
          }
          for (let i = 0; i < nameLen; i++) {
            if (nameSplitted[i].length === 0) {
              return false;
            }
          }
          for (let i = 0; i < constrLen; i++) {
            if (constraintSplitted[i].length === 0) {
              if (i === 0) {
                if (constrLen === 1) {
                  return false;
                }
                continue;
              }
              return false;
            }
          }
          for (let i = 0; i < constrLen; i++) {
            if (constraintSplitted[constrLen - 1 - i].length === 0) {
              continue;
            }
            if (nameSplitted[nameLen - 1 - i].localeCompare(constraintSplitted[constrLen - 1 - i]) !== 0) {
              return false;
            }
          }
          return true;
        }
        function compareRFC822Name(name, constraint) {
          const namePrepared = stringPrep(name);
          const constraintPrepared = stringPrep(constraint);
          const nameSplitted = namePrepared.split("@");
          const constraintSplitted = constraintPrepared.split("@");
          if (nameSplitted.length === 0 || constraintSplitted.length === 0 || nameSplitted.length < constraintSplitted.length)
            return false;
          if (constraintSplitted.length === 1) {
            const result = compareDNSName(nameSplitted[1], constraintSplitted[0]);
            if (result) {
              const ns = nameSplitted[1].split(".");
              const cs = constraintSplitted[0].split(".");
              if (cs[0].length === 0)
                return true;
              return ns.length === cs.length;
            }
            return false;
          }
          return namePrepared.localeCompare(constraintPrepared) === 0;
        }
        function compareUniformResourceIdentifier(name, constraint) {
          let namePrepared = stringPrep(name);
          const constraintPrepared = stringPrep(constraint);
          const ns = namePrepared.split("/");
          const cs = constraintPrepared.split("/");
          if (cs.length > 1)
            return false;
          if (ns.length > 1) {
            for (let i = 0; i < ns.length; i++) {
              if (ns[i].length > 0 && ns[i].charAt(ns[i].length - 1) !== ":") {
                const nsPort = ns[i].split(":");
                namePrepared = nsPort[0];
                break;
              }
            }
          }
          const result = compareDNSName(namePrepared, constraintPrepared);
          if (result) {
            const nameSplitted = namePrepared.split(".");
            const constraintSplitted = constraintPrepared.split(".");
            if (constraintSplitted[0].length === 0)
              return true;
            return nameSplitted.length === constraintSplitted.length;
          }
          return false;
        }
        function compareIPAddress(name, constraint) {
          const nameView = name.valueBlock.valueHexView;
          const constraintView = constraint.valueBlock.valueHexView;
          if (nameView.length === 4 && constraintView.length === 8) {
            for (let i = 0; i < 4; i++) {
              if ((nameView[i] ^ constraintView[i]) & constraintView[i + 4])
                return false;
            }
            return true;
          }
          if (nameView.length === 16 && constraintView.length === 32) {
            for (let i = 0; i < 16; i++) {
              if ((nameView[i] ^ constraintView[i]) & constraintView[i + 16])
                return false;
            }
            return true;
          }
          return false;
        }
        function compareDirectoryName(name, constraint) {
          if (name.typesAndValues.length === 0 || constraint.typesAndValues.length === 0)
            return true;
          if (name.typesAndValues.length < constraint.typesAndValues.length)
            return false;
          let result = true;
          let nameStart = 0;
          for (let i = 0; i < constraint.typesAndValues.length; i++) {
            let localResult = false;
            for (let j = nameStart; j < name.typesAndValues.length; j++) {
              localResult = name.typesAndValues[j].isEqual(constraint.typesAndValues[i]);
              if (name.typesAndValues[j].type === constraint.typesAndValues[i].type)
                result = result && localResult;
              if (localResult === true) {
                if (nameStart === 0 || nameStart === j) {
                  nameStart = j + 1;
                  break;
                } else
                  return false;
              }
            }
            if (localResult === false)
              return false;
          }
          return nameStart === 0 ? false : result;
        }
        try {
          if (this.certs.length === 0)
            throw new Error("Empty certificate array");
          const passedWhenNotRevValues = parameters.passedWhenNotRevValues || false;
          const initialPolicySet = parameters.initialPolicySet || [id_AnyPolicy];
          const initialExplicitPolicy = parameters.initialExplicitPolicy || false;
          const initialPolicyMappingInhibit = parameters.initialPolicyMappingInhibit || false;
          const initialInhibitPolicy = parameters.initialInhibitPolicy || false;
          const initialPermittedSubtreesSet = parameters.initialPermittedSubtreesSet || [];
          const initialExcludedSubtreesSet = parameters.initialExcludedSubtreesSet || [];
          const initialRequiredNameForms = parameters.initialRequiredNameForms || [];
          let explicitPolicyIndicator = initialExplicitPolicy;
          let policyMappingInhibitIndicator = initialPolicyMappingInhibit;
          let inhibitAnyPolicyIndicator = initialInhibitPolicy;
          const pendingConstraints = [
            false,
            false,
            false
          ];
          let explicitPolicyPending = 0;
          let policyMappingInhibitPending = 0;
          let inhibitAnyPolicyPending = 0;
          let permittedSubtrees = initialPermittedSubtreesSet;
          let excludedSubtrees = initialExcludedSubtreesSet;
          const requiredNameForms = initialRequiredNameForms;
          let pathDepth = 1;
          this.certs = await this.sort(passedWhenNotRevValues, crypto2);
          const allPolicies = [];
          allPolicies.push(id_AnyPolicy);
          const policiesAndCerts = [];
          const anyPolicyArray = new Array(this.certs.length - 1);
          for (let ii = 0; ii < this.certs.length - 1; ii++)
            anyPolicyArray[ii] = true;
          policiesAndCerts.push(anyPolicyArray);
          const policyMappings = new Array(this.certs.length - 1);
          const certPolicies = new Array(this.certs.length - 1);
          let explicitPolicyStart = explicitPolicyIndicator ? this.certs.length - 1 : -1;
          for (let i = this.certs.length - 2; i >= 0; i--, pathDepth++) {
            const cert = this.certs[i];
            if (cert.extensions) {
              for (let j = 0; j < cert.extensions.length; j++) {
                const extension = cert.extensions[j];
                if (extension.extnID === id_CertificatePolicies) {
                  certPolicies[i] = extension.parsedValue;
                  for (let s = 0; s < allPolicies.length; s++) {
                    if (allPolicies[s] === id_AnyPolicy) {
                      delete policiesAndCerts[s][i];
                      break;
                    }
                  }
                  for (let k = 0; k < extension.parsedValue.certificatePolicies.length; k++) {
                    let policyIndex = -1;
                    const policyId = extension.parsedValue.certificatePolicies[k].policyIdentifier;
                    for (let s = 0; s < allPolicies.length; s++) {
                      if (policyId === allPolicies[s]) {
                        policyIndex = s;
                        break;
                      }
                    }
                    if (policyIndex === -1) {
                      allPolicies.push(policyId);
                      const certArray = new Array(this.certs.length - 1);
                      certArray[i] = true;
                      policiesAndCerts.push(certArray);
                    } else
                      policiesAndCerts[policyIndex][i] = true;
                  }
                }
                if (extension.extnID === id_PolicyMappings) {
                  if (policyMappingInhibitIndicator) {
                    return {
                      result: false,
                      resultCode: 98,
                      resultMessage: "Policy mapping prohibited"
                    };
                  }
                  policyMappings[i] = extension.parsedValue;
                }
                if (extension.extnID === id_PolicyConstraints) {
                  if (explicitPolicyIndicator === false) {
                    if (extension.parsedValue.requireExplicitPolicy === 0) {
                      explicitPolicyIndicator = true;
                      explicitPolicyStart = i;
                    } else {
                      if (pendingConstraints[0] === false) {
                        pendingConstraints[0] = true;
                        explicitPolicyPending = extension.parsedValue.requireExplicitPolicy;
                      } else
                        explicitPolicyPending = explicitPolicyPending > extension.parsedValue.requireExplicitPolicy ? extension.parsedValue.requireExplicitPolicy : explicitPolicyPending;
                    }
                    if (extension.parsedValue.inhibitPolicyMapping === 0)
                      policyMappingInhibitIndicator = true;
                    else {
                      if (pendingConstraints[1] === false) {
                        pendingConstraints[1] = true;
                        policyMappingInhibitPending = extension.parsedValue.inhibitPolicyMapping + 1;
                      } else
                        policyMappingInhibitPending = policyMappingInhibitPending > extension.parsedValue.inhibitPolicyMapping + 1 ? extension.parsedValue.inhibitPolicyMapping + 1 : policyMappingInhibitPending;
                    }
                  }
                }
                if (extension.extnID === id_InhibitAnyPolicy) {
                  if (inhibitAnyPolicyIndicator === false) {
                    if (extension.parsedValue.valueBlock.valueDec === 0)
                      inhibitAnyPolicyIndicator = true;
                    else {
                      if (pendingConstraints[2] === false) {
                        pendingConstraints[2] = true;
                        inhibitAnyPolicyPending = extension.parsedValue.valueBlock.valueDec;
                      } else
                        inhibitAnyPolicyPending = inhibitAnyPolicyPending > extension.parsedValue.valueBlock.valueDec ? extension.parsedValue.valueBlock.valueDec : inhibitAnyPolicyPending;
                    }
                  }
                }
              }
              if (inhibitAnyPolicyIndicator === true) {
                let policyIndex = -1;
                for (let searchAnyPolicy = 0; searchAnyPolicy < allPolicies.length; searchAnyPolicy++) {
                  if (allPolicies[searchAnyPolicy] === id_AnyPolicy) {
                    policyIndex = searchAnyPolicy;
                    break;
                  }
                }
                if (policyIndex !== -1)
                  delete policiesAndCerts[0][i];
              }
              if (explicitPolicyIndicator === false) {
                if (pendingConstraints[0] === true) {
                  explicitPolicyPending--;
                  if (explicitPolicyPending === 0) {
                    explicitPolicyIndicator = true;
                    explicitPolicyStart = i;
                    pendingConstraints[0] = false;
                  }
                }
              }
              if (policyMappingInhibitIndicator === false) {
                if (pendingConstraints[1] === true) {
                  policyMappingInhibitPending--;
                  if (policyMappingInhibitPending === 0) {
                    policyMappingInhibitIndicator = true;
                    pendingConstraints[1] = false;
                  }
                }
              }
              if (inhibitAnyPolicyIndicator === false) {
                if (pendingConstraints[2] === true) {
                  inhibitAnyPolicyPending--;
                  if (inhibitAnyPolicyPending === 0) {
                    inhibitAnyPolicyIndicator = true;
                    pendingConstraints[2] = false;
                  }
                }
              }
            }
          }
          for (let i = 0; i < this.certs.length - 1; i++) {
            if (i < this.certs.length - 2 && typeof policyMappings[i + 1] !== "undefined") {
              for (let k = 0; k < policyMappings[i + 1].mappings.length; k++) {
                if (policyMappings[i + 1].mappings[k].issuerDomainPolicy === id_AnyPolicy || policyMappings[i + 1].mappings[k].subjectDomainPolicy === id_AnyPolicy) {
                  return {
                    result: false,
                    resultCode: 99,
                    resultMessage: 'The "anyPolicy" should not be a part of policy mapping scheme'
                  };
                }
                let issuerDomainPolicyIndex = -1;
                let subjectDomainPolicyIndex = -1;
                for (let n = 0; n < allPolicies.length; n++) {
                  if (allPolicies[n] === policyMappings[i + 1].mappings[k].issuerDomainPolicy)
                    issuerDomainPolicyIndex = n;
                  if (allPolicies[n] === policyMappings[i + 1].mappings[k].subjectDomainPolicy)
                    subjectDomainPolicyIndex = n;
                }
                if (typeof policiesAndCerts[issuerDomainPolicyIndex][i] !== "undefined")
                  delete policiesAndCerts[issuerDomainPolicyIndex][i];
                for (let j = 0; j < certPolicies[i].certificatePolicies.length; j++) {
                  if (policyMappings[i + 1].mappings[k].subjectDomainPolicy === certPolicies[i].certificatePolicies[j].policyIdentifier) {
                    if (issuerDomainPolicyIndex !== -1 && subjectDomainPolicyIndex !== -1) {
                      for (let m = 0; m <= i; m++) {
                        if (typeof policiesAndCerts[subjectDomainPolicyIndex][m] !== "undefined") {
                          policiesAndCerts[issuerDomainPolicyIndex][m] = true;
                          delete policiesAndCerts[subjectDomainPolicyIndex][m];
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (let i = 0; i < allPolicies.length; i++) {
            if (allPolicies[i] === id_AnyPolicy) {
              for (let j = 0; j < explicitPolicyStart; j++)
                delete policiesAndCerts[i][j];
            }
          }
          const authConstrPolicies = [];
          for (let i = 0; i < policiesAndCerts.length; i++) {
            let found = true;
            for (let j = 0; j < this.certs.length - 1; j++) {
              let anyPolicyFound = false;
              if (j < explicitPolicyStart && allPolicies[i] === id_AnyPolicy && allPolicies.length > 1) {
                found = false;
                break;
              }
              if (typeof policiesAndCerts[i][j] === "undefined") {
                if (j >= explicitPolicyStart) {
                  for (let k = 0; k < allPolicies.length; k++) {
                    if (allPolicies[k] === id_AnyPolicy) {
                      if (policiesAndCerts[k][j] === true)
                        anyPolicyFound = true;
                      break;
                    }
                  }
                }
                if (!anyPolicyFound) {
                  found = false;
                  break;
                }
              }
            }
            if (found === true)
              authConstrPolicies.push(allPolicies[i]);
          }
          let userConstrPolicies = [];
          if (initialPolicySet.length === 1 && initialPolicySet[0] === id_AnyPolicy && explicitPolicyIndicator === false)
            userConstrPolicies = initialPolicySet;
          else {
            if (authConstrPolicies.length === 1 && authConstrPolicies[0] === id_AnyPolicy)
              userConstrPolicies = initialPolicySet;
            else {
              for (let i = 0; i < authConstrPolicies.length; i++) {
                for (let j = 0; j < initialPolicySet.length; j++) {
                  if (initialPolicySet[j] === authConstrPolicies[i] || initialPolicySet[j] === id_AnyPolicy) {
                    userConstrPolicies.push(authConstrPolicies[i]);
                    break;
                  }
                }
              }
            }
          }
          const policyResult = {
            result: userConstrPolicies.length > 0,
            resultCode: 0,
            resultMessage: userConstrPolicies.length > 0 ? EMPTY_STRING : 'Zero "userConstrPolicies" array, no intersections with "authConstrPolicies"',
            authConstrPolicies,
            userConstrPolicies,
            explicitPolicyIndicator,
            policyMappings,
            certificatePath: this.certs
          };
          if (userConstrPolicies.length === 0)
            return policyResult;
          if (policyResult.result === false)
            return policyResult;
          pathDepth = 1;
          for (let i = this.certs.length - 2; i >= 0; i--, pathDepth++) {
            const cert = this.certs[i];
            let subjectAltNames = [];
            let certPermittedSubtrees = [];
            let certExcludedSubtrees = [];
            if (cert.extensions) {
              for (let j = 0; j < cert.extensions.length; j++) {
                const extension = cert.extensions[j];
                if (extension.extnID === id_NameConstraints) {
                  if ("permittedSubtrees" in extension.parsedValue)
                    certPermittedSubtrees = certPermittedSubtrees.concat(extension.parsedValue.permittedSubtrees);
                  if ("excludedSubtrees" in extension.parsedValue)
                    certExcludedSubtrees = certExcludedSubtrees.concat(extension.parsedValue.excludedSubtrees);
                }
                if (extension.extnID === id_SubjectAltName)
                  subjectAltNames = subjectAltNames.concat(extension.parsedValue.altNames);
              }
            }
            let formFound = requiredNameForms.length <= 0;
            for (let j = 0; j < requiredNameForms.length; j++) {
              switch (requiredNameForms[j].base.type) {
                case 4:
                  {
                    if (requiredNameForms[j].base.value.typesAndValues.length !== cert.subject.typesAndValues.length)
                      continue;
                    formFound = true;
                    for (let k = 0; k < cert.subject.typesAndValues.length; k++) {
                      if (cert.subject.typesAndValues[k].type !== requiredNameForms[j].base.value.typesAndValues[k].type) {
                        formFound = false;
                        break;
                      }
                    }
                    if (formFound === true)
                      break;
                  }
                  break;
                default:
              }
            }
            if (formFound === false) {
              policyResult.result = false;
              policyResult.resultCode = 21;
              policyResult.resultMessage = "No necessary name form found";
              throw policyResult;
            }
            const constrGroups = [
              [],
              [],
              [],
              [],
              []
            ];
            for (let j = 0; j < permittedSubtrees.length; j++) {
              switch (permittedSubtrees[j].base.type) {
                case 1:
                  constrGroups[0].push(permittedSubtrees[j]);
                  break;
                case 2:
                  constrGroups[1].push(permittedSubtrees[j]);
                  break;
                case 4:
                  constrGroups[2].push(permittedSubtrees[j]);
                  break;
                case 6:
                  constrGroups[3].push(permittedSubtrees[j]);
                  break;
                case 7:
                  constrGroups[4].push(permittedSubtrees[j]);
                  break;
                default:
              }
            }
            for (let p = 0; p < 5; p++) {
              let groupPermitted = false;
              let valueExists = false;
              const group = constrGroups[p];
              for (let j = 0; j < group.length; j++) {
                switch (p) {
                  case 0:
                    if (subjectAltNames.length > 0) {
                      for (let k = 0; k < subjectAltNames.length; k++) {
                        if (subjectAltNames[k].type === 1) {
                          valueExists = true;
                          groupPermitted = groupPermitted || compareRFC822Name(subjectAltNames[k].value, group[j].base.value);
                        }
                      }
                    } else {
                      for (let k = 0; k < cert.subject.typesAndValues.length; k++) {
                        if (cert.subject.typesAndValues[k].type === "1.2.840.113549.1.9.1" || cert.subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3") {
                          valueExists = true;
                          groupPermitted = groupPermitted || compareRFC822Name(cert.subject.typesAndValues[k].value.valueBlock.value, group[j].base.value);
                        }
                      }
                    }
                    break;
                  case 1:
                    if (subjectAltNames.length > 0) {
                      for (let k = 0; k < subjectAltNames.length; k++) {
                        if (subjectAltNames[k].type === 2) {
                          valueExists = true;
                          groupPermitted = groupPermitted || compareDNSName(subjectAltNames[k].value, group[j].base.value);
                        }
                      }
                    }
                    break;
                  case 2:
                    valueExists = true;
                    groupPermitted = compareDirectoryName(cert.subject, group[j].base.value);
                    break;
                  case 3:
                    if (subjectAltNames.length > 0) {
                      for (let k = 0; k < subjectAltNames.length; k++) {
                        if (subjectAltNames[k].type === 6) {
                          valueExists = true;
                          groupPermitted = groupPermitted || compareUniformResourceIdentifier(subjectAltNames[k].value, group[j].base.value);
                        }
                      }
                    }
                    break;
                  case 4:
                    if (subjectAltNames.length > 0) {
                      for (let k = 0; k < subjectAltNames.length; k++) {
                        if (subjectAltNames[k].type === 7) {
                          valueExists = true;
                          groupPermitted = groupPermitted || compareIPAddress(subjectAltNames[k].value, group[j].base.value);
                        }
                      }
                    }
                    break;
                  default:
                }
                if (groupPermitted)
                  break;
              }
              if (groupPermitted === false && group.length > 0 && valueExists) {
                policyResult.result = false;
                policyResult.resultCode = 41;
                policyResult.resultMessage = 'Failed to meet "permitted sub-trees" name constraint';
                throw policyResult;
              }
            }
            let excluded = false;
            for (let j = 0; j < excludedSubtrees.length; j++) {
              switch (excludedSubtrees[j].base.type) {
                case 1:
                  if (subjectAltNames.length >= 0) {
                    for (let k = 0; k < subjectAltNames.length; k++) {
                      if (subjectAltNames[k].type === 1)
                        excluded = excluded || compareRFC822Name(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                    }
                  } else {
                    for (let k = 0; k < cert.subject.typesAndValues.length; k++) {
                      if (cert.subject.typesAndValues[k].type === "1.2.840.113549.1.9.1" || cert.subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3")
                        excluded = excluded || compareRFC822Name(cert.subject.typesAndValues[k].value.valueBlock.value, excludedSubtrees[j].base.value);
                    }
                  }
                  break;
                case 2:
                  if (subjectAltNames.length > 0) {
                    for (let k = 0; k < subjectAltNames.length; k++) {
                      if (subjectAltNames[k].type === 2)
                        excluded = excluded || compareDNSName(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                    }
                  }
                  break;
                case 4:
                  excluded = excluded || compareDirectoryName(cert.subject, excludedSubtrees[j].base.value);
                  break;
                case 6:
                  if (subjectAltNames.length > 0) {
                    for (let k = 0; k < subjectAltNames.length; k++) {
                      if (subjectAltNames[k].type === 6)
                        excluded = excluded || compareUniformResourceIdentifier(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                    }
                  }
                  break;
                case 7:
                  if (subjectAltNames.length > 0) {
                    for (let k = 0; k < subjectAltNames.length; k++) {
                      if (subjectAltNames[k].type === 7)
                        excluded = excluded || compareIPAddress(subjectAltNames[k].value, excludedSubtrees[j].base.value);
                    }
                  }
                  break;
                default:
              }
              if (excluded)
                break;
            }
            if (excluded === true) {
              policyResult.result = false;
              policyResult.resultCode = 42;
              policyResult.resultMessage = 'Failed to meet "excluded sub-trees" name constraint';
              throw policyResult;
            }
            permittedSubtrees = permittedSubtrees.concat(certPermittedSubtrees);
            excludedSubtrees = excludedSubtrees.concat(certExcludedSubtrees);
          }
          return policyResult;
        } catch (error) {
          if (error instanceof Error) {
            if (error instanceof ChainValidationError) {
              return {
                result: false,
                resultCode: error.code,
                resultMessage: error.message,
                error
              };
            }
            return {
              result: false,
              resultCode: exports.ChainValidationCode.unknown,
              resultMessage: error.message,
              error
            };
          }
          if (error && typeof error === "object" && "resultMessage" in error) {
            return error;
          }
          return {
            result: false,
            resultCode: -1,
            resultMessage: `${error}`
          };
        }
      }
    };
    var TBS_RESPONSE_DATA = "tbsResponseData";
    var SIGNATURE_ALGORITHM$3 = "signatureAlgorithm";
    var SIGNATURE$2 = "signature";
    var CERTS$1 = "certs";
    var BASIC_OCSP_RESPONSE = "BasicOCSPResponse";
    var BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA = `${BASIC_OCSP_RESPONSE}.${TBS_RESPONSE_DATA}`;
    var BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM = `${BASIC_OCSP_RESPONSE}.${SIGNATURE_ALGORITHM$3}`;
    var BASIC_OCSP_RESPONSE_SIGNATURE = `${BASIC_OCSP_RESPONSE}.${SIGNATURE$2}`;
    var BASIC_OCSP_RESPONSE_CERTS = `${BASIC_OCSP_RESPONSE}.${CERTS$1}`;
    var CLEAR_PROPS$g = [
      BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA,
      BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM,
      BASIC_OCSP_RESPONSE_SIGNATURE,
      BASIC_OCSP_RESPONSE_CERTS
    ];
    var BasicOCSPResponse = class _BasicOCSPResponse extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.tbsResponseData = pvutils__namespace.getParametersValue(parameters, TBS_RESPONSE_DATA, _BasicOCSPResponse.defaultValues(TBS_RESPONSE_DATA));
        this.signatureAlgorithm = pvutils__namespace.getParametersValue(parameters, SIGNATURE_ALGORITHM$3, _BasicOCSPResponse.defaultValues(SIGNATURE_ALGORITHM$3));
        this.signature = pvutils__namespace.getParametersValue(parameters, SIGNATURE$2, _BasicOCSPResponse.defaultValues(SIGNATURE$2));
        if (CERTS$1 in parameters) {
          this.certs = pvutils__namespace.getParametersValue(parameters, CERTS$1, _BasicOCSPResponse.defaultValues(CERTS$1));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TBS_RESPONSE_DATA:
            return new ResponseData();
          case SIGNATURE_ALGORITHM$3:
            return new AlgorithmIdentifier();
          case SIGNATURE$2:
            return new asn1js__namespace.BitString();
          case CERTS$1:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case "type": {
            let comparisonResult = ResponseData.compareWithDefault("tbs", memberValue.tbs) && ResponseData.compareWithDefault("responderID", memberValue.responderID) && ResponseData.compareWithDefault("producedAt", memberValue.producedAt) && ResponseData.compareWithDefault("responses", memberValue.responses);
            if ("responseExtensions" in memberValue)
              comparisonResult = comparisonResult && ResponseData.compareWithDefault("responseExtensions", memberValue.responseExtensions);
            return comparisonResult;
          }
          case SIGNATURE_ALGORITHM$3:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case SIGNATURE$2:
            return memberValue.isEqual(_BasicOCSPResponse.defaultValues(memberName));
          case CERTS$1:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || BASIC_OCSP_RESPONSE,
          value: [
            ResponseData.schema(names.tbsResponseData || {
              names: {
                blockName: BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA
              }
            }),
            AlgorithmIdentifier.schema(names.signatureAlgorithm || {
              names: {
                blockName: BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM
              }
            }),
            new asn1js__namespace.BitString({ name: names.signature || BASIC_OCSP_RESPONSE_SIGNATURE }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                new asn1js__namespace.Sequence({
                  value: [new asn1js__namespace.Repeated({
                    name: BASIC_OCSP_RESPONSE_CERTS,
                    value: Certificate.schema(names.certs || {})
                  })]
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$g);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _BasicOCSPResponse.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsResponseData = new ResponseData({ schema: asn1.result[BASIC_OCSP_RESPONSE_TBS_RESPONSE_DATA] });
        this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result[BASIC_OCSP_RESPONSE_SIGNATURE_ALGORITHM] });
        this.signature = asn1.result[BASIC_OCSP_RESPONSE_SIGNATURE];
        if (BASIC_OCSP_RESPONSE_CERTS in asn1.result) {
          this.certs = Array.from(asn1.result[BASIC_OCSP_RESPONSE_CERTS], (element) => new Certificate({ schema: element }));
        }
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(this.tbsResponseData.toSchema());
        outputArray.push(this.signatureAlgorithm.toSchema());
        outputArray.push(this.signature);
        if (this.certs) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [
              new asn1js__namespace.Sequence({
                value: Array.from(this.certs, (o) => o.toSchema())
              })
            ]
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          tbsResponseData: this.tbsResponseData.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signature: this.signature.toJSON()
        };
        if (this.certs) {
          res.certs = Array.from(this.certs, (o) => o.toJSON());
        }
        return res;
      }
      async getCertificateStatus(certificate, issuerCertificate, crypto2 = getCrypto(true)) {
        const result = {
          isForCertificate: false,
          status: 2
        };
        const hashesObject = {};
        const certIDs = [];
        for (const response of this.tbsResponseData.responses) {
          const hashAlgorithm = crypto2.getAlgorithmByOID(response.certID.hashAlgorithm.algorithmId, true, "CertID.hashAlgorithm");
          if (!hashesObject[hashAlgorithm.name]) {
            hashesObject[hashAlgorithm.name] = 1;
            const certID = new CertID();
            certIDs.push(certID);
            await certID.createForCertificate(certificate, {
              hashAlgorithm: hashAlgorithm.name,
              issuerCertificate
            }, crypto2);
          }
        }
        for (const response of this.tbsResponseData.responses) {
          for (const id of certIDs) {
            if (response.certID.isEqual(id)) {
              result.isForCertificate = true;
              try {
                switch (response.certStatus.idBlock.isConstructed) {
                  case true:
                    if (response.certStatus.idBlock.tagNumber === 1)
                      result.status = 1;
                    break;
                  case false:
                    switch (response.certStatus.idBlock.tagNumber) {
                      case 0:
                        result.status = 0;
                        break;
                      case 2:
                        result.status = 2;
                        break;
                      default:
                    }
                    break;
                  default:
                }
              } catch (ex) {
              }
              return result;
            }
          }
        }
        return result;
      }
      async sign(privateKey, hashAlgorithm = "SHA-1", crypto2 = getCrypto(true)) {
        if (!privateKey) {
          throw new Error("Need to provide a private key for signing");
        }
        const signatureParams = await crypto2.getSignatureParameters(privateKey, hashAlgorithm);
        const algorithm = signatureParams.parameters.algorithm;
        if (!("name" in algorithm)) {
          throw new Error("Empty algorithm");
        }
        this.signatureAlgorithm = signatureParams.signatureAlgorithm;
        this.tbsResponseData.tbsView = new Uint8Array(this.tbsResponseData.toSchema(true).toBER());
        const signature = await crypto2.signWithPrivateKey(this.tbsResponseData.tbsView, privateKey, { algorithm });
        this.signature = new asn1js__namespace.BitString({ valueHex: signature });
      }
      async verify(params = {}, crypto2 = getCrypto(true)) {
        let signerCert = null;
        let certIndex = -1;
        const trustedCerts = params.trustedCerts || [];
        if (!this.certs) {
          throw new Error("No certificates attached to the BasicOCSPResponse");
        }
        switch (true) {
          case this.tbsResponseData.responderID instanceof RelativeDistinguishedNames:
            for (const [index, certificate] of this.certs.entries()) {
              if (certificate.subject.isEqual(this.tbsResponseData.responderID)) {
                certIndex = index;
                break;
              }
            }
            break;
          case this.tbsResponseData.responderID instanceof asn1js__namespace.OctetString:
            for (const [index, cert] of this.certs.entries()) {
              const hash2 = await crypto2.digest({ name: "sha-1" }, cert.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);
              if (pvutils__namespace.isEqualBuffer(hash2, this.tbsResponseData.responderID.valueBlock.valueHex)) {
                certIndex = index;
                break;
              }
            }
            break;
          default:
            throw new Error("Wrong value for responderID");
        }
        if (certIndex === -1)
          throw new Error("Correct certificate was not found in OCSP response");
        signerCert = this.certs[certIndex];
        const additionalCerts = [signerCert];
        for (const cert of this.certs) {
          const caCert = await checkCA(cert, signerCert);
          if (caCert) {
            additionalCerts.push(caCert);
          }
        }
        const certChain = new CertificateChainValidationEngine({
          certs: additionalCerts,
          trustedCerts
        });
        const verificationResult = await certChain.verify({}, crypto2);
        if (!verificationResult.result) {
          throw new Error("Validation of signer's certificate failed");
        }
        return crypto2.verifyWithPublicKey(this.tbsResponseData.tbsView, this.signature, this.certs[certIndex].subjectPublicKeyInfo, this.signatureAlgorithm);
      }
    };
    BasicOCSPResponse.CLASS_NAME = "BasicOCSPResponse";
    var TBS$1 = "tbs";
    var VERSION$6 = "version";
    var SUBJECT = "subject";
    var SPKI = "subjectPublicKeyInfo";
    var ATTRIBUTES$1 = "attributes";
    var SIGNATURE_ALGORITHM$2 = "signatureAlgorithm";
    var SIGNATURE_VALUE = "signatureValue";
    var CSR_INFO = "CertificationRequestInfo";
    var CSR_INFO_VERSION = `${CSR_INFO}.version`;
    var CSR_INFO_SUBJECT = `${CSR_INFO}.subject`;
    var CSR_INFO_SPKI = `${CSR_INFO}.subjectPublicKeyInfo`;
    var CSR_INFO_ATTRS = `${CSR_INFO}.attributes`;
    var CLEAR_PROPS$f = [
      CSR_INFO,
      CSR_INFO_VERSION,
      CSR_INFO_SUBJECT,
      CSR_INFO_SPKI,
      CSR_INFO_ATTRS,
      SIGNATURE_ALGORITHM$2,
      SIGNATURE_VALUE
    ];
    function CertificationRequestInfo(parameters = {}) {
      const names = pvutils__namespace.getParametersValue(parameters, "names", {});
      return new asn1js__namespace.Sequence({
        name: names.CertificationRequestInfo || CSR_INFO,
        value: [
          new asn1js__namespace.Integer({ name: names.CertificationRequestInfoVersion || CSR_INFO_VERSION }),
          RelativeDistinguishedNames.schema(names.subject || {
            names: {
              blockName: CSR_INFO_SUBJECT
            }
          }),
          PublicKeyInfo.schema({
            names: {
              blockName: CSR_INFO_SPKI
            }
          }),
          new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [
              new asn1js__namespace.Repeated({
                optional: true,
                name: names.CertificationRequestInfoAttributes || CSR_INFO_ATTRS,
                value: Attribute.schema(names.attributes || {})
              })
            ]
          })
        ]
      });
    }
    var CertificationRequest = class _CertificationRequest extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.tbsView = new Uint8Array(pvutils__namespace.getParametersValue(parameters, TBS$1, _CertificationRequest.defaultValues(TBS$1)));
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$6, _CertificationRequest.defaultValues(VERSION$6));
        this.subject = pvutils__namespace.getParametersValue(parameters, SUBJECT, _CertificationRequest.defaultValues(SUBJECT));
        this.subjectPublicKeyInfo = pvutils__namespace.getParametersValue(parameters, SPKI, _CertificationRequest.defaultValues(SPKI));
        if (ATTRIBUTES$1 in parameters) {
          this.attributes = pvutils__namespace.getParametersValue(parameters, ATTRIBUTES$1, _CertificationRequest.defaultValues(ATTRIBUTES$1));
        }
        this.signatureAlgorithm = pvutils__namespace.getParametersValue(parameters, SIGNATURE_ALGORITHM$2, _CertificationRequest.defaultValues(SIGNATURE_ALGORITHM$2));
        this.signatureValue = pvutils__namespace.getParametersValue(parameters, SIGNATURE_VALUE, _CertificationRequest.defaultValues(SIGNATURE_VALUE));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      get tbs() {
        return pvtsutils__namespace.BufferSourceConverter.toArrayBuffer(this.tbsView);
      }
      set tbs(value) {
        this.tbsView = new Uint8Array(value);
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TBS$1:
            return EMPTY_BUFFER;
          case VERSION$6:
            return 0;
          case SUBJECT:
            return new RelativeDistinguishedNames();
          case SPKI:
            return new PublicKeyInfo();
          case ATTRIBUTES$1:
            return [];
          case SIGNATURE_ALGORITHM$2:
            return new AlgorithmIdentifier();
          case SIGNATURE_VALUE:
            return new asn1js__namespace.BitString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          value: [
            CertificationRequestInfo(names.certificationRequestInfo || {}),
            new asn1js__namespace.Sequence({
              name: names.signatureAlgorithm || SIGNATURE_ALGORITHM$2,
              value: [
                new asn1js__namespace.ObjectIdentifier(),
                new asn1js__namespace.Any({ optional: true })
              ]
            }),
            new asn1js__namespace.BitString({ name: names.signatureValue || SIGNATURE_VALUE })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$f);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _CertificationRequest.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsView = asn1.result.CertificationRequestInfo.valueBeforeDecodeView;
        this.version = asn1.result[CSR_INFO_VERSION].valueBlock.valueDec;
        this.subject = new RelativeDistinguishedNames({ schema: asn1.result[CSR_INFO_SUBJECT] });
        this.subjectPublicKeyInfo = new PublicKeyInfo({ schema: asn1.result[CSR_INFO_SPKI] });
        if (CSR_INFO_ATTRS in asn1.result) {
          this.attributes = Array.from(asn1.result[CSR_INFO_ATTRS], (element) => new Attribute({ schema: element }));
        }
        this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
        this.signatureValue = asn1.result.signatureValue;
      }
      encodeTBS() {
        const outputArray = [
          new asn1js__namespace.Integer({ value: this.version }),
          this.subject.toSchema(),
          this.subjectPublicKeyInfo.toSchema()
        ];
        if (ATTRIBUTES$1 in this) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: Array.from(this.attributes || [], (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toSchema(encodeFlag = false) {
        let tbsSchema;
        if (encodeFlag === false) {
          if (this.tbsView.byteLength === 0) {
            return _CertificationRequest.schema();
          }
          const asn1 = asn1js__namespace.fromBER(this.tbsView);
          AsnError.assert(asn1, "PKCS#10 Certificate Request");
          tbsSchema = asn1.result;
        } else {
          tbsSchema = this.encodeTBS();
        }
        return new asn1js__namespace.Sequence({
          value: [
            tbsSchema,
            this.signatureAlgorithm.toSchema(),
            this.signatureValue
          ]
        });
      }
      toJSON() {
        const object = {
          tbs: pvtsutils__namespace.Convert.ToHex(this.tbsView),
          version: this.version,
          subject: this.subject.toJSON(),
          subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signatureValue: this.signatureValue.toJSON()
        };
        if (ATTRIBUTES$1 in this) {
          object.attributes = Array.from(this.attributes || [], (o) => o.toJSON());
        }
        return object;
      }
      async sign(privateKey, hashAlgorithm = "SHA-1", crypto2 = getCrypto(true)) {
        if (!privateKey) {
          throw new Error("Need to provide a private key for signing");
        }
        const signatureParams = await crypto2.getSignatureParameters(privateKey, hashAlgorithm);
        const parameters = signatureParams.parameters;
        this.signatureAlgorithm = signatureParams.signatureAlgorithm;
        this.tbsView = new Uint8Array(this.encodeTBS().toBER());
        const signature = await crypto2.signWithPrivateKey(this.tbsView, privateKey, parameters);
        this.signatureValue = new asn1js__namespace.BitString({ valueHex: signature });
      }
      async verify(crypto2 = getCrypto(true)) {
        return crypto2.verifyWithPublicKey(this.tbsView, this.signatureValue, this.subjectPublicKeyInfo, this.signatureAlgorithm);
      }
      async getPublicKey(parameters, crypto2 = getCrypto(true)) {
        return crypto2.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
      }
    };
    CertificationRequest.CLASS_NAME = "CertificationRequest";
    var DIGEST_ALGORITHM$1 = "digestAlgorithm";
    var DIGEST = "digest";
    var CLEAR_PROPS$e = [
      DIGEST_ALGORITHM$1,
      DIGEST
    ];
    var DigestInfo = class _DigestInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.digestAlgorithm = pvutils__namespace.getParametersValue(parameters, DIGEST_ALGORITHM$1, _DigestInfo.defaultValues(DIGEST_ALGORITHM$1));
        this.digest = pvutils__namespace.getParametersValue(parameters, DIGEST, _DigestInfo.defaultValues(DIGEST));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case DIGEST_ALGORITHM$1:
            return new AlgorithmIdentifier();
          case DIGEST:
            return new asn1js__namespace.OctetString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case DIGEST_ALGORITHM$1:
            return AlgorithmIdentifier.compareWithDefault("algorithmId", memberValue.algorithmId) && "algorithmParams" in memberValue === false;
          case DIGEST:
            return memberValue.isEqual(_DigestInfo.defaultValues(memberName));
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            AlgorithmIdentifier.schema(names.digestAlgorithm || {
              names: {
                blockName: DIGEST_ALGORITHM$1
              }
            }),
            new asn1js__namespace.OctetString({ name: names.digest || DIGEST })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$e);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _DigestInfo.schema({
          names: {
            digestAlgorithm: {
              names: {
                blockName: DIGEST_ALGORITHM$1
              }
            },
            digest: DIGEST
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.digestAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.digestAlgorithm });
        this.digest = asn1.result.digest;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.digestAlgorithm.toSchema(),
            this.digest
          ]
        });
      }
      toJSON() {
        return {
          digestAlgorithm: this.digestAlgorithm.toJSON(),
          digest: this.digest.toJSON()
        };
      }
    };
    DigestInfo.CLASS_NAME = "DigestInfo";
    var E_CONTENT_TYPE = "eContentType";
    var E_CONTENT = "eContent";
    var CLEAR_PROPS$d = [
      E_CONTENT_TYPE,
      E_CONTENT
    ];
    var EncapsulatedContentInfo = class _EncapsulatedContentInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.eContentType = pvutils__namespace.getParametersValue(parameters, E_CONTENT_TYPE, _EncapsulatedContentInfo.defaultValues(E_CONTENT_TYPE));
        if (E_CONTENT in parameters) {
          this.eContent = pvutils__namespace.getParametersValue(parameters, E_CONTENT, _EncapsulatedContentInfo.defaultValues(E_CONTENT));
          if (this.eContent.idBlock.tagClass === 1 && this.eContent.idBlock.tagNumber === 4) {
            if (this.eContent.idBlock.isConstructed === false) {
              const constrString = new asn1js__namespace.OctetString({
                idBlock: { isConstructed: true },
                isConstructed: true
              });
              let offset = 0;
              const viewHex = this.eContent.valueBlock.valueHexView.slice().buffer;
              let length = viewHex.byteLength;
              while (length > 0) {
                const pieceView = new Uint8Array(viewHex, offset, offset + 65536 > viewHex.byteLength ? viewHex.byteLength - offset : 65536);
                const _array = new ArrayBuffer(pieceView.length);
                const _view = new Uint8Array(_array);
                for (let i = 0; i < _view.length; i++) {
                  _view[i] = pieceView[i];
                }
                constrString.valueBlock.value.push(new asn1js__namespace.OctetString({ valueHex: _array }));
                length -= pieceView.length;
                offset += pieceView.length;
              }
              this.eContent = constrString;
            }
          }
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case E_CONTENT_TYPE:
            return EMPTY_STRING;
          case E_CONTENT:
            return new asn1js__namespace.OctetString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case E_CONTENT_TYPE:
            return memberValue === EMPTY_STRING;
          case E_CONTENT: {
            if (memberValue.idBlock.tagClass === 1 && memberValue.idBlock.tagNumber === 4)
              return memberValue.isEqual(_EncapsulatedContentInfo.defaultValues(E_CONTENT));
            return false;
          }
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.eContentType || EMPTY_STRING }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                new asn1js__namespace.Any({ name: names.eContent || EMPTY_STRING })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$d);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _EncapsulatedContentInfo.schema({
          names: {
            eContentType: E_CONTENT_TYPE,
            eContent: E_CONTENT
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.eContentType = asn1.result.eContentType.valueBlock.toString();
        if (E_CONTENT in asn1.result)
          this.eContent = asn1.result.eContent;
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.ObjectIdentifier({ value: this.eContentType }));
        if (this.eContent) {
          if (_EncapsulatedContentInfo.compareWithDefault(E_CONTENT, this.eContent) === false) {
            outputArray.push(new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [this.eContent]
            }));
          }
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          eContentType: this.eContentType
        };
        if (this.eContent && _EncapsulatedContentInfo.compareWithDefault(E_CONTENT, this.eContent) === false) {
          res.eContent = this.eContent.toJSON();
        }
        return res;
      }
    };
    EncapsulatedContentInfo.CLASS_NAME = "EncapsulatedContentInfo";
    var KeyBag = class extends PrivateKeyInfo {
      constructor(parameters = {}) {
        super(parameters);
      }
    };
    var MAC = "mac";
    var MAC_SALT = "macSalt";
    var ITERATIONS = "iterations";
    var CLEAR_PROPS$c = [
      MAC,
      MAC_SALT,
      ITERATIONS
    ];
    var MacData = class _MacData extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.mac = pvutils__namespace.getParametersValue(parameters, MAC, _MacData.defaultValues(MAC));
        this.macSalt = pvutils__namespace.getParametersValue(parameters, MAC_SALT, _MacData.defaultValues(MAC_SALT));
        if (ITERATIONS in parameters) {
          this.iterations = pvutils__namespace.getParametersValue(parameters, ITERATIONS, _MacData.defaultValues(ITERATIONS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case MAC:
            return new DigestInfo();
          case MAC_SALT:
            return new asn1js__namespace.OctetString();
          case ITERATIONS:
            return 1;
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case MAC:
            return DigestInfo.compareWithDefault("digestAlgorithm", memberValue.digestAlgorithm) && DigestInfo.compareWithDefault("digest", memberValue.digest);
          case MAC_SALT:
            return memberValue.isEqual(_MacData.defaultValues(memberName));
          case ITERATIONS:
            return memberValue === _MacData.defaultValues(memberName);
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          optional: names.optional || true,
          value: [
            DigestInfo.schema(names.mac || {
              names: {
                blockName: MAC
              }
            }),
            new asn1js__namespace.OctetString({ name: names.macSalt || MAC_SALT }),
            new asn1js__namespace.Integer({
              optional: true,
              name: names.iterations || ITERATIONS
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$c);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _MacData.schema({
          names: {
            mac: {
              names: {
                blockName: MAC
              }
            },
            macSalt: MAC_SALT,
            iterations: ITERATIONS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.mac = new DigestInfo({ schema: asn1.result.mac });
        this.macSalt = asn1.result.macSalt;
        if (ITERATIONS in asn1.result)
          this.iterations = asn1.result.iterations.valueBlock.valueDec;
      }
      toSchema() {
        const outputArray = [
          this.mac.toSchema(),
          this.macSalt
        ];
        if (this.iterations !== void 0) {
          outputArray.push(new asn1js__namespace.Integer({ value: this.iterations }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          mac: this.mac.toJSON(),
          macSalt: this.macSalt.toJSON()
        };
        if (this.iterations !== void 0) {
          res.iterations = this.iterations;
        }
        return res;
      }
    };
    MacData.CLASS_NAME = "MacData";
    var HASH_ALGORITHM = "hashAlgorithm";
    var HASHED_MESSAGE = "hashedMessage";
    var CLEAR_PROPS$b = [
      HASH_ALGORITHM,
      HASHED_MESSAGE
    ];
    var MessageImprint = class _MessageImprint extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.hashAlgorithm = pvutils__namespace.getParametersValue(parameters, HASH_ALGORITHM, _MessageImprint.defaultValues(HASH_ALGORITHM));
        this.hashedMessage = pvutils__namespace.getParametersValue(parameters, HASHED_MESSAGE, _MessageImprint.defaultValues(HASHED_MESSAGE));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static async create(hashAlgorithm, message3, crypto2 = getCrypto(true)) {
        const hashAlgorithmOID = crypto2.getOIDByAlgorithm({ name: hashAlgorithm }, true, "hashAlgorithm");
        const hashedMessage = await crypto2.digest(hashAlgorithm, message3);
        const res = new _MessageImprint({
          hashAlgorithm: new AlgorithmIdentifier({
            algorithmId: hashAlgorithmOID,
            algorithmParams: new asn1js__namespace.Null()
          }),
          hashedMessage: new asn1js__namespace.OctetString({ valueHex: hashedMessage })
        });
        return res;
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case HASH_ALGORITHM:
            return new AlgorithmIdentifier();
          case HASHED_MESSAGE:
            return new asn1js__namespace.OctetString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case HASH_ALGORITHM:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case HASHED_MESSAGE:
            return memberValue.isEqual(_MessageImprint.defaultValues(memberName)) === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            AlgorithmIdentifier.schema(names.hashAlgorithm || {}),
            new asn1js__namespace.OctetString({ name: names.hashedMessage || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$b);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _MessageImprint.schema({
          names: {
            hashAlgorithm: {
              names: {
                blockName: HASH_ALGORITHM
              }
            },
            hashedMessage: HASHED_MESSAGE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.hashAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.hashAlgorithm });
        this.hashedMessage = asn1.result.hashedMessage;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            this.hashAlgorithm.toSchema(),
            this.hashedMessage
          ]
        });
      }
      toJSON() {
        return {
          hashAlgorithm: this.hashAlgorithm.toJSON(),
          hashedMessage: this.hashedMessage.toJSON()
        };
      }
    };
    MessageImprint.CLASS_NAME = "MessageImprint";
    var REQ_CERT = "reqCert";
    var SINGLE_REQUEST_EXTENSIONS = "singleRequestExtensions";
    var CLEAR_PROPS$a = [
      REQ_CERT,
      SINGLE_REQUEST_EXTENSIONS
    ];
    var Request = class _Request extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.reqCert = pvutils__namespace.getParametersValue(parameters, REQ_CERT, _Request.defaultValues(REQ_CERT));
        if (SINGLE_REQUEST_EXTENSIONS in parameters) {
          this.singleRequestExtensions = pvutils__namespace.getParametersValue(parameters, SINGLE_REQUEST_EXTENSIONS, _Request.defaultValues(SINGLE_REQUEST_EXTENSIONS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case REQ_CERT:
            return new CertID();
          case SINGLE_REQUEST_EXTENSIONS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case REQ_CERT:
            return memberValue.isEqual(_Request.defaultValues(memberName));
          case SINGLE_REQUEST_EXTENSIONS:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            CertID.schema(names.reqCert || {}),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [Extension.schema(names.extensions || {
                names: {
                  blockName: names.singleRequestExtensions || EMPTY_STRING
                }
              })]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$a);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _Request.schema({
          names: {
            reqCert: {
              names: {
                blockName: REQ_CERT
              }
            },
            extensions: {
              names: {
                blockName: SINGLE_REQUEST_EXTENSIONS
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.reqCert = new CertID({ schema: asn1.result.reqCert });
        if (SINGLE_REQUEST_EXTENSIONS in asn1.result) {
          this.singleRequestExtensions = Array.from(asn1.result.singleRequestExtensions.valueBlock.value, (element) => new Extension({ schema: element }));
        }
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(this.reqCert.toSchema());
        if (this.singleRequestExtensions) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [
              new asn1js__namespace.Sequence({
                value: Array.from(this.singleRequestExtensions, (o) => o.toSchema())
              })
            ]
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          reqCert: this.reqCert.toJSON()
        };
        if (this.singleRequestExtensions) {
          res.singleRequestExtensions = Array.from(this.singleRequestExtensions, (o) => o.toJSON());
        }
        return res;
      }
    };
    Request.CLASS_NAME = "Request";
    var TBS = "tbs";
    var VERSION$5 = "version";
    var REQUESTOR_NAME = "requestorName";
    var REQUEST_LIST = "requestList";
    var REQUEST_EXTENSIONS = "requestExtensions";
    var TBS_REQUEST$1 = "TBSRequest";
    var TBS_REQUEST_VERSION = `${TBS_REQUEST$1}.${VERSION$5}`;
    var TBS_REQUEST_REQUESTOR_NAME = `${TBS_REQUEST$1}.${REQUESTOR_NAME}`;
    var TBS_REQUEST_REQUESTS = `${TBS_REQUEST$1}.requests`;
    var TBS_REQUEST_REQUEST_EXTENSIONS = `${TBS_REQUEST$1}.${REQUEST_EXTENSIONS}`;
    var CLEAR_PROPS$9 = [
      TBS_REQUEST$1,
      TBS_REQUEST_VERSION,
      TBS_REQUEST_REQUESTOR_NAME,
      TBS_REQUEST_REQUESTS,
      TBS_REQUEST_REQUEST_EXTENSIONS
    ];
    var TBSRequest = class _TBSRequest extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.tbsView = new Uint8Array(pvutils__namespace.getParametersValue(parameters, TBS, _TBSRequest.defaultValues(TBS)));
        if (VERSION$5 in parameters) {
          this.version = pvutils__namespace.getParametersValue(parameters, VERSION$5, _TBSRequest.defaultValues(VERSION$5));
        }
        if (REQUESTOR_NAME in parameters) {
          this.requestorName = pvutils__namespace.getParametersValue(parameters, REQUESTOR_NAME, _TBSRequest.defaultValues(REQUESTOR_NAME));
        }
        this.requestList = pvutils__namespace.getParametersValue(parameters, REQUEST_LIST, _TBSRequest.defaultValues(REQUEST_LIST));
        if (REQUEST_EXTENSIONS in parameters) {
          this.requestExtensions = pvutils__namespace.getParametersValue(parameters, REQUEST_EXTENSIONS, _TBSRequest.defaultValues(REQUEST_EXTENSIONS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      get tbs() {
        return pvtsutils__namespace.BufferSourceConverter.toArrayBuffer(this.tbsView);
      }
      set tbs(value) {
        this.tbsView = new Uint8Array(value);
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TBS:
            return EMPTY_BUFFER;
          case VERSION$5:
            return 0;
          case REQUESTOR_NAME:
            return new GeneralName();
          case REQUEST_LIST:
          case REQUEST_EXTENSIONS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TBS:
            return memberValue.byteLength === 0;
          case VERSION$5:
            return memberValue === _TBSRequest.defaultValues(memberName);
          case REQUESTOR_NAME:
            return memberValue.type === GeneralName.defaultValues("type") && Object.keys(memberValue.value).length === 0;
          case REQUEST_LIST:
          case REQUEST_EXTENSIONS:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || TBS_REQUEST$1,
          value: [
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.Integer({ name: names.TBSRequestVersion || TBS_REQUEST_VERSION })]
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [GeneralName.schema(names.requestorName || {
                names: {
                  blockName: TBS_REQUEST_REQUESTOR_NAME
                }
              })]
            }),
            new asn1js__namespace.Sequence({
              name: names.requestList || "TBSRequest.requestList",
              value: [
                new asn1js__namespace.Repeated({
                  name: names.requests || TBS_REQUEST_REQUESTS,
                  value: Request.schema(names.requestNames || {})
                })
              ]
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: [Extensions.schema(names.extensions || {
                names: {
                  blockName: names.requestExtensions || TBS_REQUEST_REQUEST_EXTENSIONS
                }
              })]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$9);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _TBSRequest.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsView = asn1.result.TBSRequest.valueBeforeDecodeView;
        if (TBS_REQUEST_VERSION in asn1.result)
          this.version = asn1.result[TBS_REQUEST_VERSION].valueBlock.valueDec;
        if (TBS_REQUEST_REQUESTOR_NAME in asn1.result)
          this.requestorName = new GeneralName({ schema: asn1.result[TBS_REQUEST_REQUESTOR_NAME] });
        this.requestList = Array.from(asn1.result[TBS_REQUEST_REQUESTS], (element) => new Request({ schema: element }));
        if (TBS_REQUEST_REQUEST_EXTENSIONS in asn1.result)
          this.requestExtensions = Array.from(asn1.result[TBS_REQUEST_REQUEST_EXTENSIONS].valueBlock.value, (element) => new Extension({ schema: element }));
      }
      toSchema(encodeFlag = false) {
        let tbsSchema;
        if (encodeFlag === false) {
          if (this.tbsView.byteLength === 0)
            return _TBSRequest.schema();
          const asn1 = asn1js__namespace.fromBER(this.tbsView);
          AsnError.assert(asn1, "TBS Request");
          if (!(asn1.result instanceof asn1js__namespace.Sequence)) {
            throw new Error("ASN.1 result should be SEQUENCE");
          }
          tbsSchema = asn1.result;
        } else {
          const outputArray = [];
          if (this.version !== void 0) {
            outputArray.push(new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.Integer({ value: this.version })]
            }));
          }
          if (this.requestorName) {
            outputArray.push(new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [this.requestorName.toSchema()]
            }));
          }
          outputArray.push(new asn1js__namespace.Sequence({
            value: Array.from(this.requestList, (o) => o.toSchema())
          }));
          if (this.requestExtensions) {
            outputArray.push(new asn1js__namespace.Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: 2
              },
              value: [
                new asn1js__namespace.Sequence({
                  value: Array.from(this.requestExtensions, (o) => o.toSchema())
                })
              ]
            }));
          }
          tbsSchema = new asn1js__namespace.Sequence({
            value: outputArray
          });
        }
        return tbsSchema;
      }
      toJSON() {
        const res = {};
        if (this.version != void 0)
          res.version = this.version;
        if (this.requestorName) {
          res.requestorName = this.requestorName.toJSON();
        }
        res.requestList = Array.from(this.requestList, (o) => o.toJSON());
        if (this.requestExtensions) {
          res.requestExtensions = Array.from(this.requestExtensions, (o) => o.toJSON());
        }
        return res;
      }
    };
    TBSRequest.CLASS_NAME = "TBSRequest";
    var SIGNATURE_ALGORITHM$1 = "signatureAlgorithm";
    var SIGNATURE$1 = "signature";
    var CERTS = "certs";
    var Signature2 = class _Signature extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.signatureAlgorithm = pvutils__namespace.getParametersValue(parameters, SIGNATURE_ALGORITHM$1, _Signature.defaultValues(SIGNATURE_ALGORITHM$1));
        this.signature = pvutils__namespace.getParametersValue(parameters, SIGNATURE$1, _Signature.defaultValues(SIGNATURE$1));
        if (CERTS in parameters) {
          this.certs = pvutils__namespace.getParametersValue(parameters, CERTS, _Signature.defaultValues(CERTS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case SIGNATURE_ALGORITHM$1:
            return new AlgorithmIdentifier();
          case SIGNATURE$1:
            return new asn1js__namespace.BitString();
          case CERTS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case SIGNATURE_ALGORITHM$1:
            return memberValue.algorithmId === EMPTY_STRING && "algorithmParams" in memberValue === false;
          case SIGNATURE$1:
            return memberValue.isEqual(_Signature.defaultValues(memberName));
          case CERTS:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            AlgorithmIdentifier.schema(names.signatureAlgorithm || {}),
            new asn1js__namespace.BitString({ name: names.signature || EMPTY_STRING }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                new asn1js__namespace.Sequence({
                  value: [new asn1js__namespace.Repeated({
                    name: names.certs || EMPTY_STRING,
                    value: Certificate.schema({})
                  })]
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, [
          SIGNATURE_ALGORITHM$1,
          SIGNATURE$1,
          CERTS
        ]);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _Signature.schema({
          names: {
            signatureAlgorithm: {
              names: {
                blockName: SIGNATURE_ALGORITHM$1
              }
            },
            signature: SIGNATURE$1,
            certs: CERTS
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result.signatureAlgorithm });
        this.signature = asn1.result.signature;
        if (CERTS in asn1.result)
          this.certs = Array.from(asn1.result.certs, (element) => new Certificate({ schema: element }));
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(this.signatureAlgorithm.toSchema());
        outputArray.push(this.signature);
        if (this.certs) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [
              new asn1js__namespace.Sequence({
                value: Array.from(this.certs, (o) => o.toSchema())
              })
            ]
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signature: this.signature.toJSON()
        };
        if (this.certs) {
          res.certs = Array.from(this.certs, (o) => o.toJSON());
        }
        return res;
      }
    };
    Signature2.CLASS_NAME = "Signature";
    var TBS_REQUEST = "tbsRequest";
    var OPTIONAL_SIGNATURE = "optionalSignature";
    var CLEAR_PROPS$8 = [
      TBS_REQUEST,
      OPTIONAL_SIGNATURE
    ];
    var OCSPRequest = class _OCSPRequest extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.tbsRequest = pvutils__namespace.getParametersValue(parameters, TBS_REQUEST, _OCSPRequest.defaultValues(TBS_REQUEST));
        if (OPTIONAL_SIGNATURE in parameters) {
          this.optionalSignature = pvutils__namespace.getParametersValue(parameters, OPTIONAL_SIGNATURE, _OCSPRequest.defaultValues(OPTIONAL_SIGNATURE));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TBS_REQUEST:
            return new TBSRequest();
          case OPTIONAL_SIGNATURE:
            return new Signature2();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TBS_REQUEST:
            return TBSRequest.compareWithDefault("tbs", memberValue.tbs) && TBSRequest.compareWithDefault("version", memberValue.version) && TBSRequest.compareWithDefault("requestorName", memberValue.requestorName) && TBSRequest.compareWithDefault("requestList", memberValue.requestList) && TBSRequest.compareWithDefault("requestExtensions", memberValue.requestExtensions);
          case OPTIONAL_SIGNATURE:
            return Signature2.compareWithDefault("signatureAlgorithm", memberValue.signatureAlgorithm) && Signature2.compareWithDefault("signature", memberValue.signature) && Signature2.compareWithDefault("certs", memberValue.certs);
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || "OCSPRequest",
          value: [
            TBSRequest.schema(names.tbsRequest || {
              names: {
                blockName: TBS_REQUEST
              }
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                Signature2.schema(names.optionalSignature || {
                  names: {
                    blockName: OPTIONAL_SIGNATURE
                  }
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$8);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _OCSPRequest.schema());
        AsnError.assertSchema(asn1, this.className);
        this.tbsRequest = new TBSRequest({ schema: asn1.result.tbsRequest });
        if (OPTIONAL_SIGNATURE in asn1.result)
          this.optionalSignature = new Signature2({ schema: asn1.result.optionalSignature });
      }
      toSchema(encodeFlag = false) {
        const outputArray = [];
        outputArray.push(this.tbsRequest.toSchema(encodeFlag));
        if (this.optionalSignature)
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [
              this.optionalSignature.toSchema()
            ]
          }));
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          tbsRequest: this.tbsRequest.toJSON()
        };
        if (this.optionalSignature) {
          res.optionalSignature = this.optionalSignature.toJSON();
        }
        return res;
      }
      async createForCertificate(certificate, parameters, crypto2 = getCrypto(true)) {
        const certID = new CertID();
        await certID.createForCertificate(certificate, parameters, crypto2);
        this.tbsRequest.requestList.push(new Request({
          reqCert: certID
        }));
      }
      async sign(privateKey, hashAlgorithm = "SHA-1", crypto2 = getCrypto(true)) {
        ParameterError.assertEmpty(privateKey, "privateKey", "OCSPRequest.sign method");
        if (!this.optionalSignature) {
          throw new Error('Need to create "optionalSignature" field before signing');
        }
        const signatureParams = await crypto2.getSignatureParameters(privateKey, hashAlgorithm);
        const parameters = signatureParams.parameters;
        this.optionalSignature.signatureAlgorithm = signatureParams.signatureAlgorithm;
        const tbs = this.tbsRequest.toSchema(true).toBER(false);
        const signature = await crypto2.signWithPrivateKey(tbs, privateKey, parameters);
        this.optionalSignature.signature = new asn1js__namespace.BitString({ valueHex: signature });
      }
      verify() {
      }
    };
    OCSPRequest.CLASS_NAME = "OCSPRequest";
    var RESPONSE_TYPE = "responseType";
    var RESPONSE = "response";
    var CLEAR_PROPS$7 = [
      RESPONSE_TYPE,
      RESPONSE
    ];
    var ResponseBytes = class _ResponseBytes extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.responseType = pvutils__namespace.getParametersValue(parameters, RESPONSE_TYPE, _ResponseBytes.defaultValues(RESPONSE_TYPE));
        this.response = pvutils__namespace.getParametersValue(parameters, RESPONSE, _ResponseBytes.defaultValues(RESPONSE));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case RESPONSE_TYPE:
            return EMPTY_STRING;
          case RESPONSE:
            return new asn1js__namespace.OctetString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case RESPONSE_TYPE:
            return memberValue === EMPTY_STRING;
          case RESPONSE:
            return memberValue.isEqual(_ResponseBytes.defaultValues(memberName));
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.ObjectIdentifier({ name: names.responseType || EMPTY_STRING }),
            new asn1js__namespace.OctetString({ name: names.response || EMPTY_STRING })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$7);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _ResponseBytes.schema({
          names: {
            responseType: RESPONSE_TYPE,
            response: RESPONSE
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.responseType = asn1.result.responseType.valueBlock.toString();
        this.response = asn1.result.response;
      }
      toSchema() {
        return new asn1js__namespace.Sequence({
          value: [
            new asn1js__namespace.ObjectIdentifier({ value: this.responseType }),
            this.response
          ]
        });
      }
      toJSON() {
        return {
          responseType: this.responseType,
          response: this.response.toJSON()
        };
      }
    };
    ResponseBytes.CLASS_NAME = "ResponseBytes";
    var RESPONSE_STATUS = "responseStatus";
    var RESPONSE_BYTES = "responseBytes";
    var OCSPResponse = class _OCSPResponse extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.responseStatus = pvutils__namespace.getParametersValue(parameters, RESPONSE_STATUS, _OCSPResponse.defaultValues(RESPONSE_STATUS));
        if (RESPONSE_BYTES in parameters) {
          this.responseBytes = pvutils__namespace.getParametersValue(parameters, RESPONSE_BYTES, _OCSPResponse.defaultValues(RESPONSE_BYTES));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case RESPONSE_STATUS:
            return new asn1js__namespace.Enumerated();
          case RESPONSE_BYTES:
            return new ResponseBytes();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case RESPONSE_STATUS:
            return memberValue.isEqual(_OCSPResponse.defaultValues(memberName));
          case RESPONSE_BYTES:
            return ResponseBytes.compareWithDefault("responseType", memberValue.responseType) && ResponseBytes.compareWithDefault("response", memberValue.response);
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || "OCSPResponse",
          value: [
            new asn1js__namespace.Enumerated({ name: names.responseStatus || RESPONSE_STATUS }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [
                ResponseBytes.schema(names.responseBytes || {
                  names: {
                    blockName: RESPONSE_BYTES
                  }
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, [
          RESPONSE_STATUS,
          RESPONSE_BYTES
        ]);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _OCSPResponse.schema());
        AsnError.assertSchema(asn1, this.className);
        this.responseStatus = asn1.result.responseStatus;
        if (RESPONSE_BYTES in asn1.result)
          this.responseBytes = new ResponseBytes({ schema: asn1.result.responseBytes });
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(this.responseStatus);
        if (this.responseBytes) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.responseBytes.toSchema()]
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          responseStatus: this.responseStatus.toJSON()
        };
        if (this.responseBytes) {
          res.responseBytes = this.responseBytes.toJSON();
        }
        return res;
      }
      async getCertificateStatus(certificate, issuerCertificate, crypto2 = getCrypto(true)) {
        let basicResponse;
        const result = {
          isForCertificate: false,
          status: 2
        };
        if (!this.responseBytes)
          return result;
        if (this.responseBytes.responseType !== id_PKIX_OCSP_Basic)
          return result;
        try {
          const asn1Basic = asn1js__namespace.fromBER(this.responseBytes.response.valueBlock.valueHexView);
          AsnError.assert(asn1Basic, "Basic OCSP response");
          basicResponse = new BasicOCSPResponse({ schema: asn1Basic.result });
        } catch (ex) {
          return result;
        }
        return basicResponse.getCertificateStatus(certificate, issuerCertificate, crypto2);
      }
      async sign(privateKey, hashAlgorithm, crypto2 = getCrypto(true)) {
        var _a2;
        if (this.responseBytes && this.responseBytes.responseType === id_PKIX_OCSP_Basic) {
          const basicResponse = BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView);
          return basicResponse.sign(privateKey, hashAlgorithm, crypto2);
        }
        throw new Error(`Unknown ResponseBytes type: ${((_a2 = this.responseBytes) === null || _a2 === void 0 ? void 0 : _a2.responseType) || "Unknown"}`);
      }
      async verify(issuerCertificate = null, crypto2 = getCrypto(true)) {
        var _a2;
        if (RESPONSE_BYTES in this === false)
          throw new Error("Empty ResponseBytes field");
        if (this.responseBytes && this.responseBytes.responseType === id_PKIX_OCSP_Basic) {
          const basicResponse = BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView);
          if (issuerCertificate !== null) {
            if (!basicResponse.certs) {
              basicResponse.certs = [];
            }
            basicResponse.certs.push(issuerCertificate);
          }
          return basicResponse.verify({}, crypto2);
        }
        throw new Error(`Unknown ResponseBytes type: ${((_a2 = this.responseBytes) === null || _a2 === void 0 ? void 0 : _a2.responseType) || "Unknown"}`);
      }
    };
    OCSPResponse.CLASS_NAME = "OCSPResponse";
    var TYPE = "type";
    var ATTRIBUTES = "attributes";
    var ENCODED_VALUE = "encodedValue";
    var CLEAR_PROPS$6 = [
      ATTRIBUTES
    ];
    var SignedAndUnsignedAttributes = class _SignedAndUnsignedAttributes extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.type = pvutils__namespace.getParametersValue(parameters, TYPE, _SignedAndUnsignedAttributes.defaultValues(TYPE));
        this.attributes = pvutils__namespace.getParametersValue(parameters, ATTRIBUTES, _SignedAndUnsignedAttributes.defaultValues(ATTRIBUTES));
        this.encodedValue = pvutils__namespace.getParametersValue(parameters, ENCODED_VALUE, _SignedAndUnsignedAttributes.defaultValues(ENCODED_VALUE));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case TYPE:
            return -1;
          case ATTRIBUTES:
            return [];
          case ENCODED_VALUE:
            return EMPTY_BUFFER;
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case TYPE:
            return memberValue === _SignedAndUnsignedAttributes.defaultValues(TYPE);
          case ATTRIBUTES:
            return memberValue.length === 0;
          case ENCODED_VALUE:
            return memberValue.byteLength === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Constructed({
          name: names.blockName || EMPTY_STRING,
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: names.tagNumber || 0
          },
          value: [
            new asn1js__namespace.Repeated({
              name: names.attributes || EMPTY_STRING,
              value: Attribute.schema()
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$6);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _SignedAndUnsignedAttributes.schema({
          names: {
            tagNumber: this.type,
            attributes: ATTRIBUTES
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.type = asn1.result.idBlock.tagNumber;
        this.encodedValue = pvtsutils__namespace.BufferSourceConverter.toArrayBuffer(asn1.result.valueBeforeDecodeView);
        const encodedView = new Uint8Array(this.encodedValue);
        encodedView[0] = 49;
        if (ATTRIBUTES in asn1.result === false) {
          if (this.type === 0)
            throw new Error("Wrong structure of SignedUnsignedAttributes");
          else
            return;
        }
        this.attributes = Array.from(asn1.result.attributes, (element) => new Attribute({ schema: element }));
      }
      toSchema() {
        if (_SignedAndUnsignedAttributes.compareWithDefault(TYPE, this.type) || _SignedAndUnsignedAttributes.compareWithDefault(ATTRIBUTES, this.attributes))
          throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');
        return new asn1js__namespace.Constructed({
          optional: true,
          idBlock: {
            tagClass: 3,
            tagNumber: this.type
          },
          value: Array.from(this.attributes, (o) => o.toSchema())
        });
      }
      toJSON() {
        if (_SignedAndUnsignedAttributes.compareWithDefault(TYPE, this.type) || _SignedAndUnsignedAttributes.compareWithDefault(ATTRIBUTES, this.attributes))
          throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');
        return {
          type: this.type,
          attributes: Array.from(this.attributes, (o) => o.toJSON())
        };
      }
    };
    SignedAndUnsignedAttributes.CLASS_NAME = "SignedAndUnsignedAttributes";
    var VERSION$4 = "version";
    var SID = "sid";
    var DIGEST_ALGORITHM = "digestAlgorithm";
    var SIGNED_ATTRS = "signedAttrs";
    var SIGNATURE_ALGORITHM = "signatureAlgorithm";
    var SIGNATURE = "signature";
    var UNSIGNED_ATTRS = "unsignedAttrs";
    var SIGNER_INFO = "SignerInfo";
    var SIGNER_INFO_VERSION = `${SIGNER_INFO}.${VERSION$4}`;
    var SIGNER_INFO_SID = `${SIGNER_INFO}.${SID}`;
    var SIGNER_INFO_DIGEST_ALGORITHM = `${SIGNER_INFO}.${DIGEST_ALGORITHM}`;
    var SIGNER_INFO_SIGNED_ATTRS = `${SIGNER_INFO}.${SIGNED_ATTRS}`;
    var SIGNER_INFO_SIGNATURE_ALGORITHM = `${SIGNER_INFO}.${SIGNATURE_ALGORITHM}`;
    var SIGNER_INFO_SIGNATURE = `${SIGNER_INFO}.${SIGNATURE}`;
    var SIGNER_INFO_UNSIGNED_ATTRS = `${SIGNER_INFO}.${UNSIGNED_ATTRS}`;
    var CLEAR_PROPS$5 = [
      SIGNER_INFO_VERSION,
      SIGNER_INFO_SID,
      SIGNER_INFO_DIGEST_ALGORITHM,
      SIGNER_INFO_SIGNED_ATTRS,
      SIGNER_INFO_SIGNATURE_ALGORITHM,
      SIGNER_INFO_SIGNATURE,
      SIGNER_INFO_UNSIGNED_ATTRS
    ];
    var SignerInfo = class _SignerInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$4, _SignerInfo.defaultValues(VERSION$4));
        this.sid = pvutils__namespace.getParametersValue(parameters, SID, _SignerInfo.defaultValues(SID));
        this.digestAlgorithm = pvutils__namespace.getParametersValue(parameters, DIGEST_ALGORITHM, _SignerInfo.defaultValues(DIGEST_ALGORITHM));
        if (SIGNED_ATTRS in parameters) {
          this.signedAttrs = pvutils__namespace.getParametersValue(parameters, SIGNED_ATTRS, _SignerInfo.defaultValues(SIGNED_ATTRS));
        }
        this.signatureAlgorithm = pvutils__namespace.getParametersValue(parameters, SIGNATURE_ALGORITHM, _SignerInfo.defaultValues(SIGNATURE_ALGORITHM));
        this.signature = pvutils__namespace.getParametersValue(parameters, SIGNATURE, _SignerInfo.defaultValues(SIGNATURE));
        if (UNSIGNED_ATTRS in parameters) {
          this.unsignedAttrs = pvutils__namespace.getParametersValue(parameters, UNSIGNED_ATTRS, _SignerInfo.defaultValues(UNSIGNED_ATTRS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$4:
            return 0;
          case SID:
            return new asn1js__namespace.Any();
          case DIGEST_ALGORITHM:
            return new AlgorithmIdentifier();
          case SIGNED_ATTRS:
            return new SignedAndUnsignedAttributes({ type: 0 });
          case SIGNATURE_ALGORITHM:
            return new AlgorithmIdentifier();
          case SIGNATURE:
            return new asn1js__namespace.OctetString();
          case UNSIGNED_ATTRS:
            return new SignedAndUnsignedAttributes({ type: 1 });
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$4:
            return _SignerInfo.defaultValues(VERSION$4) === memberValue;
          case SID:
            return memberValue instanceof asn1js__namespace.Any;
          case DIGEST_ALGORITHM:
            if (memberValue instanceof AlgorithmIdentifier === false)
              return false;
            return memberValue.isEqual(_SignerInfo.defaultValues(DIGEST_ALGORITHM));
          case SIGNED_ATTRS:
            return SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type) && SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes) && SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue);
          case SIGNATURE_ALGORITHM:
            if (memberValue instanceof AlgorithmIdentifier === false)
              return false;
            return memberValue.isEqual(_SignerInfo.defaultValues(SIGNATURE_ALGORITHM));
          case SIGNATURE:
          case UNSIGNED_ATTRS:
            return SignedAndUnsignedAttributes.compareWithDefault("type", memberValue.type) && SignedAndUnsignedAttributes.compareWithDefault("attributes", memberValue.attributes) && SignedAndUnsignedAttributes.compareWithDefault("encodedValue", memberValue.encodedValue);
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: SIGNER_INFO,
          value: [
            new asn1js__namespace.Integer({ name: names.version || SIGNER_INFO_VERSION }),
            new asn1js__namespace.Choice({
              value: [
                IssuerAndSerialNumber.schema(names.sidSchema || {
                  names: {
                    blockName: SIGNER_INFO_SID
                  }
                }),
                new asn1js__namespace.Choice({
                  value: [
                    new asn1js__namespace.Constructed({
                      optional: true,
                      name: names.sid || SIGNER_INFO_SID,
                      idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                      },
                      value: [new asn1js__namespace.OctetString()]
                    }),
                    new asn1js__namespace.Primitive({
                      optional: true,
                      name: names.sid || SIGNER_INFO_SID,
                      idBlock: {
                        tagClass: 3,
                        tagNumber: 0
                      }
                    })
                  ]
                })
              ]
            }),
            AlgorithmIdentifier.schema(names.digestAlgorithm || {
              names: {
                blockName: SIGNER_INFO_DIGEST_ALGORITHM
              }
            }),
            SignedAndUnsignedAttributes.schema(names.signedAttrs || {
              names: {
                blockName: SIGNER_INFO_SIGNED_ATTRS,
                tagNumber: 0
              }
            }),
            AlgorithmIdentifier.schema(names.signatureAlgorithm || {
              names: {
                blockName: SIGNER_INFO_SIGNATURE_ALGORITHM
              }
            }),
            new asn1js__namespace.OctetString({ name: names.signature || SIGNER_INFO_SIGNATURE }),
            SignedAndUnsignedAttributes.schema(names.unsignedAttrs || {
              names: {
                blockName: SIGNER_INFO_UNSIGNED_ATTRS,
                tagNumber: 1
              }
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$5);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _SignerInfo.schema());
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result[SIGNER_INFO_VERSION].valueBlock.valueDec;
        const currentSid = asn1.result[SIGNER_INFO_SID];
        if (currentSid.idBlock.tagClass === 1)
          this.sid = new IssuerAndSerialNumber({ schema: currentSid });
        else
          this.sid = currentSid;
        this.digestAlgorithm = new AlgorithmIdentifier({ schema: asn1.result[SIGNER_INFO_DIGEST_ALGORITHM] });
        if (SIGNER_INFO_SIGNED_ATTRS in asn1.result)
          this.signedAttrs = new SignedAndUnsignedAttributes({ type: 0, schema: asn1.result[SIGNER_INFO_SIGNED_ATTRS] });
        this.signatureAlgorithm = new AlgorithmIdentifier({ schema: asn1.result[SIGNER_INFO_SIGNATURE_ALGORITHM] });
        this.signature = asn1.result[SIGNER_INFO_SIGNATURE];
        if (SIGNER_INFO_UNSIGNED_ATTRS in asn1.result)
          this.unsignedAttrs = new SignedAndUnsignedAttributes({ type: 1, schema: asn1.result[SIGNER_INFO_UNSIGNED_ATTRS] });
      }
      toSchema() {
        if (_SignerInfo.compareWithDefault(SID, this.sid))
          throw new Error('Incorrectly initialized "SignerInfo" class');
        const outputArray = [];
        outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
        if (this.sid instanceof IssuerAndSerialNumber)
          outputArray.push(this.sid.toSchema());
        else
          outputArray.push(this.sid);
        outputArray.push(this.digestAlgorithm.toSchema());
        if (this.signedAttrs) {
          if (_SignerInfo.compareWithDefault(SIGNED_ATTRS, this.signedAttrs) === false)
            outputArray.push(this.signedAttrs.toSchema());
        }
        outputArray.push(this.signatureAlgorithm.toSchema());
        outputArray.push(this.signature);
        if (this.unsignedAttrs) {
          if (_SignerInfo.compareWithDefault(UNSIGNED_ATTRS, this.unsignedAttrs) === false)
            outputArray.push(this.unsignedAttrs.toSchema());
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        if (_SignerInfo.compareWithDefault(SID, this.sid)) {
          throw new Error('Incorrectly initialized "SignerInfo" class');
        }
        const res = {
          version: this.version,
          digestAlgorithm: this.digestAlgorithm.toJSON(),
          signatureAlgorithm: this.signatureAlgorithm.toJSON(),
          signature: this.signature.toJSON()
        };
        if (!(this.sid instanceof asn1js__namespace.Any))
          res.sid = this.sid.toJSON();
        if (this.signedAttrs && _SignerInfo.compareWithDefault(SIGNED_ATTRS, this.signedAttrs) === false) {
          res.signedAttrs = this.signedAttrs.toJSON();
        }
        if (this.unsignedAttrs && _SignerInfo.compareWithDefault(UNSIGNED_ATTRS, this.unsignedAttrs) === false) {
          res.unsignedAttrs = this.unsignedAttrs.toJSON();
        }
        return res;
      }
    };
    SignerInfo.CLASS_NAME = "SignerInfo";
    var VERSION$3 = "version";
    var POLICY = "policy";
    var MESSAGE_IMPRINT$1 = "messageImprint";
    var SERIAL_NUMBER = "serialNumber";
    var GEN_TIME = "genTime";
    var ORDERING = "ordering";
    var NONCE$1 = "nonce";
    var ACCURACY = "accuracy";
    var TSA = "tsa";
    var EXTENSIONS$1 = "extensions";
    var TST_INFO = "TSTInfo";
    var TST_INFO_VERSION = `${TST_INFO}.${VERSION$3}`;
    var TST_INFO_POLICY = `${TST_INFO}.${POLICY}`;
    var TST_INFO_MESSAGE_IMPRINT = `${TST_INFO}.${MESSAGE_IMPRINT$1}`;
    var TST_INFO_SERIAL_NUMBER = `${TST_INFO}.${SERIAL_NUMBER}`;
    var TST_INFO_GEN_TIME = `${TST_INFO}.${GEN_TIME}`;
    var TST_INFO_ACCURACY = `${TST_INFO}.${ACCURACY}`;
    var TST_INFO_ORDERING = `${TST_INFO}.${ORDERING}`;
    var TST_INFO_NONCE = `${TST_INFO}.${NONCE$1}`;
    var TST_INFO_TSA = `${TST_INFO}.${TSA}`;
    var TST_INFO_EXTENSIONS = `${TST_INFO}.${EXTENSIONS$1}`;
    var CLEAR_PROPS$4 = [
      TST_INFO_VERSION,
      TST_INFO_POLICY,
      TST_INFO_MESSAGE_IMPRINT,
      TST_INFO_SERIAL_NUMBER,
      TST_INFO_GEN_TIME,
      TST_INFO_ACCURACY,
      TST_INFO_ORDERING,
      TST_INFO_NONCE,
      TST_INFO_TSA,
      TST_INFO_EXTENSIONS
    ];
    var TSTInfo = class _TSTInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$3, _TSTInfo.defaultValues(VERSION$3));
        this.policy = pvutils__namespace.getParametersValue(parameters, POLICY, _TSTInfo.defaultValues(POLICY));
        this.messageImprint = pvutils__namespace.getParametersValue(parameters, MESSAGE_IMPRINT$1, _TSTInfo.defaultValues(MESSAGE_IMPRINT$1));
        this.serialNumber = pvutils__namespace.getParametersValue(parameters, SERIAL_NUMBER, _TSTInfo.defaultValues(SERIAL_NUMBER));
        this.genTime = pvutils__namespace.getParametersValue(parameters, GEN_TIME, _TSTInfo.defaultValues(GEN_TIME));
        if (ACCURACY in parameters) {
          this.accuracy = pvutils__namespace.getParametersValue(parameters, ACCURACY, _TSTInfo.defaultValues(ACCURACY));
        }
        if (ORDERING in parameters) {
          this.ordering = pvutils__namespace.getParametersValue(parameters, ORDERING, _TSTInfo.defaultValues(ORDERING));
        }
        if (NONCE$1 in parameters) {
          this.nonce = pvutils__namespace.getParametersValue(parameters, NONCE$1, _TSTInfo.defaultValues(NONCE$1));
        }
        if (TSA in parameters) {
          this.tsa = pvutils__namespace.getParametersValue(parameters, TSA, _TSTInfo.defaultValues(TSA));
        }
        if (EXTENSIONS$1 in parameters) {
          this.extensions = pvutils__namespace.getParametersValue(parameters, EXTENSIONS$1, _TSTInfo.defaultValues(EXTENSIONS$1));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$3:
            return 0;
          case POLICY:
            return EMPTY_STRING;
          case MESSAGE_IMPRINT$1:
            return new MessageImprint();
          case SERIAL_NUMBER:
            return new asn1js__namespace.Integer();
          case GEN_TIME:
            return new Date(0, 0, 0);
          case ACCURACY:
            return new Accuracy();
          case ORDERING:
            return false;
          case NONCE$1:
            return new asn1js__namespace.Integer();
          case TSA:
            return new GeneralName();
          case EXTENSIONS$1:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$3:
          case POLICY:
          case GEN_TIME:
          case ORDERING:
            return memberValue === _TSTInfo.defaultValues(ORDERING);
          case MESSAGE_IMPRINT$1:
            return MessageImprint.compareWithDefault(HASH_ALGORITHM, memberValue.hashAlgorithm) && MessageImprint.compareWithDefault(HASHED_MESSAGE, memberValue.hashedMessage);
          case SERIAL_NUMBER:
          case NONCE$1:
            return memberValue.isEqual(_TSTInfo.defaultValues(NONCE$1));
          case ACCURACY:
            return Accuracy.compareWithDefault(SECONDS, memberValue.seconds) && Accuracy.compareWithDefault(MILLIS, memberValue.millis) && Accuracy.compareWithDefault(MICROS, memberValue.micros);
          case TSA:
            return GeneralName.compareWithDefault(TYPE$4, memberValue.type) && GeneralName.compareWithDefault(VALUE$5, memberValue.value);
          case EXTENSIONS$1:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || TST_INFO,
          value: [
            new asn1js__namespace.Integer({ name: names.version || TST_INFO_VERSION }),
            new asn1js__namespace.ObjectIdentifier({ name: names.policy || TST_INFO_POLICY }),
            MessageImprint.schema(names.messageImprint || {
              names: {
                blockName: TST_INFO_MESSAGE_IMPRINT
              }
            }),
            new asn1js__namespace.Integer({ name: names.serialNumber || TST_INFO_SERIAL_NUMBER }),
            new asn1js__namespace.GeneralizedTime({ name: names.genTime || TST_INFO_GEN_TIME }),
            Accuracy.schema(names.accuracy || {
              names: {
                blockName: TST_INFO_ACCURACY
              }
            }),
            new asn1js__namespace.Boolean({
              name: names.ordering || TST_INFO_ORDERING,
              optional: true
            }),
            new asn1js__namespace.Integer({
              name: names.nonce || TST_INFO_NONCE,
              optional: true
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [GeneralName.schema(names.tsa || {
                names: {
                  blockName: TST_INFO_TSA
                }
              })]
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: [
                new asn1js__namespace.Repeated({
                  name: names.extensions || TST_INFO_EXTENSIONS,
                  value: Extension.schema(names.extension || {})
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$4);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _TSTInfo.schema());
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result[TST_INFO_VERSION].valueBlock.valueDec;
        this.policy = asn1.result[TST_INFO_POLICY].valueBlock.toString();
        this.messageImprint = new MessageImprint({ schema: asn1.result[TST_INFO_MESSAGE_IMPRINT] });
        this.serialNumber = asn1.result[TST_INFO_SERIAL_NUMBER];
        this.genTime = asn1.result[TST_INFO_GEN_TIME].toDate();
        if (TST_INFO_ACCURACY in asn1.result)
          this.accuracy = new Accuracy({ schema: asn1.result[TST_INFO_ACCURACY] });
        if (TST_INFO_ORDERING in asn1.result)
          this.ordering = asn1.result[TST_INFO_ORDERING].valueBlock.value;
        if (TST_INFO_NONCE in asn1.result)
          this.nonce = asn1.result[TST_INFO_NONCE];
        if (TST_INFO_TSA in asn1.result)
          this.tsa = new GeneralName({ schema: asn1.result[TST_INFO_TSA] });
        if (TST_INFO_EXTENSIONS in asn1.result)
          this.extensions = Array.from(asn1.result[TST_INFO_EXTENSIONS], (element) => new Extension({ schema: element }));
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
        outputArray.push(new asn1js__namespace.ObjectIdentifier({ value: this.policy }));
        outputArray.push(this.messageImprint.toSchema());
        outputArray.push(this.serialNumber);
        outputArray.push(new asn1js__namespace.GeneralizedTime({ valueDate: this.genTime }));
        if (this.accuracy)
          outputArray.push(this.accuracy.toSchema());
        if (this.ordering !== void 0)
          outputArray.push(new asn1js__namespace.Boolean({ value: this.ordering }));
        if (this.nonce)
          outputArray.push(this.nonce);
        if (this.tsa) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: [this.tsa.toSchema()]
          }));
        }
        if (this.extensions) {
          outputArray.push(new asn1js__namespace.Constructed({
            optional: true,
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.extensions, (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          version: this.version,
          policy: this.policy,
          messageImprint: this.messageImprint.toJSON(),
          serialNumber: this.serialNumber.toJSON(),
          genTime: this.genTime
        };
        if (this.accuracy)
          res.accuracy = this.accuracy.toJSON();
        if (this.ordering !== void 0)
          res.ordering = this.ordering;
        if (this.nonce)
          res.nonce = this.nonce.toJSON();
        if (this.tsa)
          res.tsa = this.tsa.toJSON();
        if (this.extensions)
          res.extensions = Array.from(this.extensions, (o) => o.toJSON());
        return res;
      }
      async verify(params, crypto2 = getCrypto(true)) {
        if (!params.data) {
          throw new Error('"data" is a mandatory attribute for TST_INFO verification');
        }
        const data = params.data;
        if (params.notBefore) {
          if (this.genTime < params.notBefore)
            throw new Error("Generation time for TSTInfo object is less than notBefore value");
        }
        if (params.notAfter) {
          if (this.genTime > params.notAfter)
            throw new Error("Generation time for TSTInfo object is more than notAfter value");
        }
        const shaAlgorithm = crypto2.getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId, true, "MessageImprint.hashAlgorithm");
        const hash2 = await crypto2.digest(shaAlgorithm.name, new Uint8Array(data));
        return pvtsutils__namespace.BufferSourceConverter.isEqual(hash2, this.messageImprint.hashedMessage.valueBlock.valueHexView);
      }
    };
    TSTInfo.CLASS_NAME = "TSTInfo";
    var VERSION$2 = "version";
    var DIGEST_ALGORITHMS = "digestAlgorithms";
    var ENCAP_CONTENT_INFO = "encapContentInfo";
    var CERTIFICATES = "certificates";
    var CRLS = "crls";
    var SIGNER_INFOS = "signerInfos";
    var OCSPS = "ocsps";
    var SIGNED_DATA = "SignedData";
    var SIGNED_DATA_VERSION = `${SIGNED_DATA}.${VERSION$2}`;
    var SIGNED_DATA_DIGEST_ALGORITHMS = `${SIGNED_DATA}.${DIGEST_ALGORITHMS}`;
    var SIGNED_DATA_ENCAP_CONTENT_INFO = `${SIGNED_DATA}.${ENCAP_CONTENT_INFO}`;
    var SIGNED_DATA_CERTIFICATES = `${SIGNED_DATA}.${CERTIFICATES}`;
    var SIGNED_DATA_CRLS = `${SIGNED_DATA}.${CRLS}`;
    var SIGNED_DATA_SIGNER_INFOS = `${SIGNED_DATA}.${SIGNER_INFOS}`;
    var CLEAR_PROPS$3 = [
      SIGNED_DATA_VERSION,
      SIGNED_DATA_DIGEST_ALGORITHMS,
      SIGNED_DATA_ENCAP_CONTENT_INFO,
      SIGNED_DATA_CERTIFICATES,
      SIGNED_DATA_CRLS,
      SIGNED_DATA_SIGNER_INFOS
    ];
    var SignedDataVerifyError = class extends Error {
      constructor({ message: message3, code = 0, date = /* @__PURE__ */ new Date(), signatureVerified = null, signerCertificate = null, signerCertificateVerified = null, timestampSerial = null, certificatePath = [] }) {
        super(message3);
        this.name = "SignedDataVerifyError";
        this.date = date;
        this.code = code;
        this.timestampSerial = timestampSerial;
        this.signatureVerified = signatureVerified;
        this.signerCertificate = signerCertificate;
        this.signerCertificateVerified = signerCertificateVerified;
        this.certificatePath = certificatePath;
      }
    };
    var SignedData = class _SignedData extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$2, _SignedData.defaultValues(VERSION$2));
        this.digestAlgorithms = pvutils__namespace.getParametersValue(parameters, DIGEST_ALGORITHMS, _SignedData.defaultValues(DIGEST_ALGORITHMS));
        this.encapContentInfo = pvutils__namespace.getParametersValue(parameters, ENCAP_CONTENT_INFO, _SignedData.defaultValues(ENCAP_CONTENT_INFO));
        if (CERTIFICATES in parameters) {
          this.certificates = pvutils__namespace.getParametersValue(parameters, CERTIFICATES, _SignedData.defaultValues(CERTIFICATES));
        }
        if (CRLS in parameters) {
          this.crls = pvutils__namespace.getParametersValue(parameters, CRLS, _SignedData.defaultValues(CRLS));
        }
        if (OCSPS in parameters) {
          this.ocsps = pvutils__namespace.getParametersValue(parameters, OCSPS, _SignedData.defaultValues(OCSPS));
        }
        this.signerInfos = pvutils__namespace.getParametersValue(parameters, SIGNER_INFOS, _SignedData.defaultValues(SIGNER_INFOS));
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$2:
            return 0;
          case DIGEST_ALGORITHMS:
            return [];
          case ENCAP_CONTENT_INFO:
            return new EncapsulatedContentInfo();
          case CERTIFICATES:
            return [];
          case CRLS:
            return [];
          case OCSPS:
            return [];
          case SIGNER_INFOS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$2:
            return memberValue === _SignedData.defaultValues(VERSION$2);
          case ENCAP_CONTENT_INFO:
            return EncapsulatedContentInfo.compareWithDefault("eContentType", memberValue.eContentType) && EncapsulatedContentInfo.compareWithDefault("eContent", memberValue.eContent);
          case DIGEST_ALGORITHMS:
          case CERTIFICATES:
          case CRLS:
          case OCSPS:
          case SIGNER_INFOS:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        if (names.optional === void 0) {
          names.optional = false;
        }
        return new asn1js__namespace.Sequence({
          name: names.blockName || SIGNED_DATA,
          optional: names.optional,
          value: [
            new asn1js__namespace.Integer({ name: names.version || SIGNED_DATA_VERSION }),
            new asn1js__namespace.Set({
              value: [
                new asn1js__namespace.Repeated({
                  name: names.digestAlgorithms || SIGNED_DATA_DIGEST_ALGORITHMS,
                  value: AlgorithmIdentifier.schema()
                })
              ]
            }),
            EncapsulatedContentInfo.schema(names.encapContentInfo || {
              names: {
                blockName: SIGNED_DATA_ENCAP_CONTENT_INFO
              }
            }),
            new asn1js__namespace.Constructed({
              name: names.certificates || SIGNED_DATA_CERTIFICATES,
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: CertificateSet.schema().valueBlock.value
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 1
              },
              value: RevocationInfoChoices.schema(names.crls || {
                names: {
                  crls: SIGNED_DATA_CRLS
                }
              }).valueBlock.value
            }),
            new asn1js__namespace.Set({
              value: [
                new asn1js__namespace.Repeated({
                  name: names.signerInfos || SIGNED_DATA_SIGNER_INFOS,
                  value: SignerInfo.schema()
                })
              ]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$3);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _SignedData.schema());
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result[SIGNED_DATA_VERSION].valueBlock.valueDec;
        if (SIGNED_DATA_DIGEST_ALGORITHMS in asn1.result)
          this.digestAlgorithms = Array.from(asn1.result[SIGNED_DATA_DIGEST_ALGORITHMS], (algorithm) => new AlgorithmIdentifier({ schema: algorithm }));
        this.encapContentInfo = new EncapsulatedContentInfo({ schema: asn1.result[SIGNED_DATA_ENCAP_CONTENT_INFO] });
        if (SIGNED_DATA_CERTIFICATES in asn1.result) {
          const certificateSet = new CertificateSet({
            schema: new asn1js__namespace.Set({
              value: asn1.result[SIGNED_DATA_CERTIFICATES].valueBlock.value
            })
          });
          this.certificates = certificateSet.certificates.slice(0);
        }
        if (SIGNED_DATA_CRLS in asn1.result) {
          this.crls = Array.from(asn1.result[SIGNED_DATA_CRLS], (crl) => {
            if (crl.idBlock.tagClass === 1)
              return new CertificateRevocationList({ schema: crl });
            crl.idBlock.tagClass = 1;
            crl.idBlock.tagNumber = 16;
            return new OtherRevocationInfoFormat({ schema: crl });
          });
        }
        if (SIGNED_DATA_SIGNER_INFOS in asn1.result)
          this.signerInfos = Array.from(asn1.result[SIGNED_DATA_SIGNER_INFOS], (signerInfoSchema) => new SignerInfo({ schema: signerInfoSchema }));
      }
      toSchema(encodeFlag = false) {
        const outputArray = [];
        if (this.certificates && this.certificates.length && this.certificates.some((o) => o instanceof OtherCertificateFormat) || this.crls && this.crls.length && this.crls.some((o) => o instanceof OtherRevocationInfoFormat)) {
          this.version = 5;
        } else if (this.certificates && this.certificates.length && this.certificates.some((o) => o instanceof AttributeCertificateV2)) {
          this.version = 4;
        } else if (this.certificates && this.certificates.length && this.certificates.some((o) => o instanceof AttributeCertificateV1) || this.signerInfos.some((o) => o.version === 3) || this.encapContentInfo.eContentType !== _SignedData.ID_DATA) {
          this.version = 3;
        } else {
          this.version = 1;
        }
        outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
        outputArray.push(new asn1js__namespace.Set({
          value: Array.from(this.digestAlgorithms, (algorithm) => algorithm.toSchema())
        }));
        outputArray.push(this.encapContentInfo.toSchema());
        if (this.certificates) {
          const certificateSet = new CertificateSet({ certificates: this.certificates });
          const certificateSetSchema = certificateSet.toSchema();
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: certificateSetSchema.valueBlock.value
          }));
        }
        if (this.crls) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 1
            },
            value: Array.from(this.crls, (crl) => {
              if (crl instanceof OtherRevocationInfoFormat) {
                const crlSchema = crl.toSchema();
                crlSchema.idBlock.tagClass = 3;
                crlSchema.idBlock.tagNumber = 1;
                return crlSchema;
              }
              return crl.toSchema(encodeFlag);
            })
          }));
        }
        outputArray.push(new asn1js__namespace.Set({
          value: Array.from(this.signerInfos, (signerInfo) => signerInfo.toSchema())
        }));
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          version: this.version,
          digestAlgorithms: Array.from(this.digestAlgorithms, (algorithm) => algorithm.toJSON()),
          encapContentInfo: this.encapContentInfo.toJSON(),
          signerInfos: Array.from(this.signerInfos, (signerInfo) => signerInfo.toJSON())
        };
        if (this.certificates) {
          res.certificates = Array.from(this.certificates, (certificate) => certificate.toJSON());
        }
        if (this.crls) {
          res.crls = Array.from(this.crls, (crl) => crl.toJSON());
        }
        return res;
      }
      async verify({ signer = -1, data = EMPTY_BUFFER, trustedCerts = [], checkDate = /* @__PURE__ */ new Date(), checkChain = false, passedWhenNotRevValues = false, extendedMode = false, findOrigin = null, findIssuer = null } = {}, crypto2 = getCrypto(true)) {
        let signerCert = null;
        let timestampSerial = null;
        try {
          let messageDigestValue = EMPTY_BUFFER;
          let shaAlgorithm = EMPTY_STRING;
          let certificatePath = [];
          const signerInfo = this.signerInfos[signer];
          if (!signerInfo) {
            throw new SignedDataVerifyError({
              date: checkDate,
              code: 1,
              message: "Unable to get signer by supplied index"
            });
          }
          if (!this.certificates) {
            throw new SignedDataVerifyError({
              date: checkDate,
              code: 2,
              message: "No certificates attached to this signed data"
            });
          }
          if (signerInfo.sid instanceof IssuerAndSerialNumber) {
            for (const certificate of this.certificates) {
              if (!(certificate instanceof Certificate))
                continue;
              if (certificate.issuer.isEqual(signerInfo.sid.issuer) && certificate.serialNumber.isEqual(signerInfo.sid.serialNumber)) {
                signerCert = certificate;
                break;
              }
            }
          } else {
            const sid = signerInfo.sid;
            const keyId = sid.idBlock.isConstructed ? sid.valueBlock.value[0].valueBlock.valueHex : sid.valueBlock.valueHex;
            for (const certificate of this.certificates) {
              if (!(certificate instanceof Certificate)) {
                continue;
              }
              const digest2 = await crypto2.digest({ name: "sha-1" }, certificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);
              if (pvutils__namespace.isEqualBuffer(digest2, keyId)) {
                signerCert = certificate;
                break;
              }
            }
          }
          if (!signerCert) {
            throw new SignedDataVerifyError({
              date: checkDate,
              code: 3,
              message: "Unable to find signer certificate"
            });
          }
          if (this.encapContentInfo.eContentType === id_eContentType_TSTInfo) {
            if (!this.encapContentInfo.eContent) {
              throw new SignedDataVerifyError({
                date: checkDate,
                code: 15,
                message: "Error during verification: TSTInfo eContent is empty",
                signatureVerified: null,
                signerCertificate: signerCert,
                timestampSerial,
                signerCertificateVerified: true
              });
            }
            let tstInfo;
            try {
              tstInfo = TSTInfo.fromBER(this.encapContentInfo.eContent.valueBlock.valueHexView);
            } catch (ex) {
              throw new SignedDataVerifyError({
                date: checkDate,
                code: 15,
                message: "Error during verification: TSTInfo wrong ASN.1 schema ",
                signatureVerified: null,
                signerCertificate: signerCert,
                timestampSerial,
                signerCertificateVerified: true
              });
            }
            checkDate = tstInfo.genTime;
            timestampSerial = tstInfo.serialNumber.valueBlock.valueHexView.slice();
            if (data.byteLength === 0) {
              throw new SignedDataVerifyError({
                date: checkDate,
                code: 4,
                message: "Missed detached data input array"
              });
            }
            if (!await tstInfo.verify({ data }, crypto2)) {
              throw new SignedDataVerifyError({
                date: checkDate,
                code: 15,
                message: "Error during verification: TSTInfo verification is failed",
                signatureVerified: false,
                signerCertificate: signerCert,
                timestampSerial,
                signerCertificateVerified: true
              });
            }
          }
          if (checkChain) {
            const certs = this.certificates.filter((certificate) => certificate instanceof Certificate && !!checkCA(certificate, signerCert));
            const chainParams = {
              checkDate,
              certs,
              trustedCerts
            };
            if (findIssuer) {
              chainParams.findIssuer = findIssuer;
            }
            if (findOrigin) {
              chainParams.findOrigin = findOrigin;
            }
            const chainEngine = new CertificateChainValidationEngine(chainParams);
            chainEngine.certs.push(signerCert);
            if (this.crls) {
              for (const crl of this.crls) {
                if ("thisUpdate" in crl)
                  chainEngine.crls.push(crl);
                else {
                  if (crl.otherRevInfoFormat === id_PKIX_OCSP_Basic)
                    chainEngine.ocsps.push(new BasicOCSPResponse({ schema: crl.otherRevInfo }));
                }
              }
            }
            if (this.ocsps) {
              chainEngine.ocsps.push(...this.ocsps);
            }
            const verificationResult = await chainEngine.verify({ passedWhenNotRevValues }, crypto2).catch((e) => {
              throw new SignedDataVerifyError({
                date: checkDate,
                code: 5,
                message: `Validation of signer's certificate failed with error: ${e instanceof Object ? e.resultMessage : e}`,
                signerCertificate: signerCert,
                signerCertificateVerified: false
              });
            });
            if (verificationResult.certificatePath) {
              certificatePath = verificationResult.certificatePath;
            }
            if (!verificationResult.result)
              throw new SignedDataVerifyError({
                date: checkDate,
                code: 5,
                message: `Validation of signer's certificate failed: ${verificationResult.resultMessage}`,
                signerCertificate: signerCert,
                signerCertificateVerified: false
              });
          }
          const signerInfoHashAlgorithm = crypto2.getAlgorithmByOID(signerInfo.digestAlgorithm.algorithmId);
          if (!("name" in signerInfoHashAlgorithm)) {
            throw new SignedDataVerifyError({
              date: checkDate,
              code: 7,
              message: `Unsupported signature algorithm: ${signerInfo.digestAlgorithm.algorithmId}`,
              signerCertificate: signerCert,
              signerCertificateVerified: true
            });
          }
          shaAlgorithm = signerInfoHashAlgorithm.name;
          const eContent = this.encapContentInfo.eContent;
          if (eContent) {
            if (eContent.idBlock.tagClass === 1 && eContent.idBlock.tagNumber === 4) {
              data = eContent.getValue();
            } else
              data = eContent.valueBlock.valueBeforeDecodeView;
          } else {
            if (data.byteLength === 0) {
              throw new SignedDataVerifyError({
                date: checkDate,
                code: 8,
                message: "Missed detached data input array",
                signerCertificate: signerCert,
                signerCertificateVerified: true
              });
            }
          }
          if (signerInfo.signedAttrs) {
            let foundContentType = false;
            let foundMessageDigest = false;
            for (const attribute of signerInfo.signedAttrs.attributes) {
              if (attribute.type === "1.2.840.113549.1.9.3")
                foundContentType = true;
              if (attribute.type === "1.2.840.113549.1.9.4") {
                foundMessageDigest = true;
                messageDigestValue = attribute.values[0].valueBlock.valueHex;
              }
              if (foundContentType && foundMessageDigest)
                break;
            }
            if (foundContentType === false) {
              throw new SignedDataVerifyError({
                date: checkDate,
                code: 9,
                message: 'Attribute "content-type" is a mandatory attribute for "signed attributes"',
                signerCertificate: signerCert,
                signerCertificateVerified: true
              });
            }
            if (foundMessageDigest === false) {
              throw new SignedDataVerifyError({
                date: checkDate,
                code: 10,
                message: 'Attribute "message-digest" is a mandatory attribute for "signed attributes"',
                signatureVerified: null,
                signerCertificate: signerCert,
                signerCertificateVerified: true
              });
            }
          }
          if (signerInfo.signedAttrs) {
            const messageDigest = await crypto2.digest(shaAlgorithm, new Uint8Array(data));
            if (!pvutils__namespace.isEqualBuffer(messageDigest, messageDigestValue)) {
              throw new SignedDataVerifyError({
                date: checkDate,
                code: 15,
                message: "Error during verification: Message digest doesn't match",
                signatureVerified: null,
                signerCertificate: signerCert,
                timestampSerial,
                signerCertificateVerified: true
              });
            }
            data = signerInfo.signedAttrs.encodedValue;
          }
          const verifyResult = await crypto2.verifyWithPublicKey(data, signerInfo.signature, signerCert.subjectPublicKeyInfo, signerCert.signatureAlgorithm, shaAlgorithm);
          if (extendedMode) {
            return {
              date: checkDate,
              code: 14,
              message: EMPTY_STRING,
              signatureVerified: verifyResult,
              signerCertificate: signerCert,
              timestampSerial,
              signerCertificateVerified: true,
              certificatePath
            };
          } else {
            return verifyResult;
          }
        } catch (e) {
          if (e instanceof SignedDataVerifyError) {
            throw e;
          }
          throw new SignedDataVerifyError({
            date: checkDate,
            code: 15,
            message: `Error during verification: ${e instanceof Error ? e.message : e}`,
            signatureVerified: null,
            signerCertificate: signerCert,
            timestampSerial,
            signerCertificateVerified: true
          });
        }
      }
      async sign(privateKey, signerIndex, hashAlgorithm = "SHA-1", data = EMPTY_BUFFER, crypto2 = getCrypto(true)) {
        if (!privateKey)
          throw new Error("Need to provide a private key for signing");
        const hashAlgorithmOID = crypto2.getOIDByAlgorithm({ name: hashAlgorithm }, true, "hashAlgorithm");
        if (this.digestAlgorithms.filter((algorithm) => algorithm.algorithmId === hashAlgorithmOID).length === 0) {
          this.digestAlgorithms.push(new AlgorithmIdentifier({
            algorithmId: hashAlgorithmOID,
            algorithmParams: new asn1js__namespace.Null()
          }));
        }
        const signerInfo = this.signerInfos[signerIndex];
        if (!signerInfo) {
          throw new RangeError("SignerInfo index is out of range");
        }
        signerInfo.digestAlgorithm = new AlgorithmIdentifier({
          algorithmId: hashAlgorithmOID,
          algorithmParams: new asn1js__namespace.Null()
        });
        const signatureParams = await crypto2.getSignatureParameters(privateKey, hashAlgorithm);
        const parameters = signatureParams.parameters;
        signerInfo.signatureAlgorithm = signatureParams.signatureAlgorithm;
        if (signerInfo.signedAttrs) {
          if (signerInfo.signedAttrs.encodedValue.byteLength !== 0)
            data = signerInfo.signedAttrs.encodedValue;
          else {
            data = signerInfo.signedAttrs.toSchema().toBER();
            const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(data);
            view[0] = 49;
          }
        } else {
          const eContent = this.encapContentInfo.eContent;
          if (eContent) {
            if (eContent.idBlock.tagClass === 1 && eContent.idBlock.tagNumber === 4) {
              data = eContent.getValue();
            } else
              data = eContent.valueBlock.valueBeforeDecodeView;
          } else {
            if (data.byteLength === 0)
              throw new Error("Missed detached data input array");
          }
        }
        const signature = await crypto2.signWithPrivateKey(data, privateKey, parameters);
        signerInfo.signature = new asn1js__namespace.OctetString({ valueHex: signature });
      }
    };
    SignedData.CLASS_NAME = "SignedData";
    SignedData.ID_DATA = id_ContentType_Data;
    var VERSION$1 = "version";
    var AUTH_SAFE = "authSafe";
    var MAC_DATA = "macData";
    var PARSED_VALUE = "parsedValue";
    var CLERA_PROPS = [
      VERSION$1,
      AUTH_SAFE,
      MAC_DATA
    ];
    var PFX = class _PFX extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION$1, _PFX.defaultValues(VERSION$1));
        this.authSafe = pvutils__namespace.getParametersValue(parameters, AUTH_SAFE, _PFX.defaultValues(AUTH_SAFE));
        if (MAC_DATA in parameters) {
          this.macData = pvutils__namespace.getParametersValue(parameters, MAC_DATA, _PFX.defaultValues(MAC_DATA));
        }
        if (PARSED_VALUE in parameters) {
          this.parsedValue = pvutils__namespace.getParametersValue(parameters, PARSED_VALUE, _PFX.defaultValues(PARSED_VALUE));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION$1:
            return 3;
          case AUTH_SAFE:
            return new ContentInfo();
          case MAC_DATA:
            return new MacData();
          case PARSED_VALUE:
            return {};
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION$1:
            return memberValue === _PFX.defaultValues(memberName);
          case AUTH_SAFE:
            return ContentInfo.compareWithDefault("contentType", memberValue.contentType) && ContentInfo.compareWithDefault("content", memberValue.content);
          case MAC_DATA:
            return MacData.compareWithDefault("mac", memberValue.mac) && MacData.compareWithDefault("macSalt", memberValue.macSalt) && MacData.compareWithDefault("iterations", memberValue.iterations);
          case PARSED_VALUE:
            return memberValue instanceof Object && Object.keys(memberValue).length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.version || VERSION$1 }),
            ContentInfo.schema(names.authSafe || {
              names: {
                blockName: AUTH_SAFE
              }
            }),
            MacData.schema(names.macData || {
              names: {
                blockName: MAC_DATA,
                optional: true
              }
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLERA_PROPS);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PFX.schema({
          names: {
            version: VERSION$1,
            authSafe: {
              names: {
                blockName: AUTH_SAFE
              }
            },
            macData: {
              names: {
                blockName: MAC_DATA
              }
            }
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result.version.valueBlock.valueDec;
        this.authSafe = new ContentInfo({ schema: asn1.result.authSafe });
        if (MAC_DATA in asn1.result)
          this.macData = new MacData({ schema: asn1.result.macData });
      }
      toSchema() {
        const outputArray = [
          new asn1js__namespace.Integer({ value: this.version }),
          this.authSafe.toSchema()
        ];
        if (this.macData) {
          outputArray.push(this.macData.toSchema());
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const output = {
          version: this.version,
          authSafe: this.authSafe.toJSON()
        };
        if (this.macData) {
          output.macData = this.macData.toJSON();
        }
        return output;
      }
      async makeInternalValues(parameters = {}, crypto2 = getCrypto(true)) {
        ArgumentError.assert(parameters, "parameters", "object");
        if (!this.parsedValue) {
          throw new Error('Please call "parseValues" function first in order to make "parsedValue" data');
        }
        ParameterError.assertEmpty(this.parsedValue.integrityMode, "integrityMode", "parsedValue");
        ParameterError.assertEmpty(this.parsedValue.authenticatedSafe, "authenticatedSafe", "parsedValue");
        switch (this.parsedValue.integrityMode) {
          case 0:
            {
              if (!("iterations" in parameters))
                throw new ParameterError("iterations");
              ParameterError.assertEmpty(parameters.pbkdf2HashAlgorithm, "pbkdf2HashAlgorithm");
              ParameterError.assertEmpty(parameters.hmacHashAlgorithm, "hmacHashAlgorithm");
              ParameterError.assertEmpty(parameters.password, "password");
              const saltBuffer = new ArrayBuffer(64);
              const saltView = new Uint8Array(saltBuffer);
              crypto2.getRandomValues(saltView);
              const data = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
              this.authSafe = new ContentInfo({
                contentType: ContentInfo.DATA,
                content: new asn1js__namespace.OctetString({ valueHex: data })
              });
              const result = await crypto2.stampDataWithPassword({
                password: parameters.password,
                hashAlgorithm: parameters.hmacHashAlgorithm,
                salt: saltBuffer,
                iterationCount: parameters.iterations,
                contentToStamp: data
              });
              this.macData = new MacData({
                mac: new DigestInfo({
                  digestAlgorithm: new AlgorithmIdentifier({
                    algorithmId: crypto2.getOIDByAlgorithm({ name: parameters.hmacHashAlgorithm }, true, "hmacHashAlgorithm")
                  }),
                  digest: new asn1js__namespace.OctetString({ valueHex: result })
                }),
                macSalt: new asn1js__namespace.OctetString({ valueHex: saltBuffer }),
                iterations: parameters.iterations
              });
            }
            break;
          case 1:
            {
              if (!("signingCertificate" in parameters)) {
                throw new ParameterError("signingCertificate");
              }
              ParameterError.assertEmpty(parameters.privateKey, "privateKey");
              ParameterError.assertEmpty(parameters.hashAlgorithm, "hashAlgorithm");
              const toBeSigned = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
              const cmsSigned = new SignedData({
                version: 1,
                encapContentInfo: new EncapsulatedContentInfo({
                  eContentType: "1.2.840.113549.1.7.1",
                  eContent: new asn1js__namespace.OctetString({ valueHex: toBeSigned })
                }),
                certificates: [parameters.signingCertificate]
              });
              const result = await crypto2.digest({ name: parameters.hashAlgorithm }, new Uint8Array(toBeSigned));
              const signedAttr = [];
              signedAttr.push(new Attribute({
                type: "1.2.840.113549.1.9.3",
                values: [
                  new asn1js__namespace.ObjectIdentifier({ value: "1.2.840.113549.1.7.1" })
                ]
              }));
              signedAttr.push(new Attribute({
                type: "1.2.840.113549.1.9.5",
                values: [
                  new asn1js__namespace.UTCTime({ valueDate: /* @__PURE__ */ new Date() })
                ]
              }));
              signedAttr.push(new Attribute({
                type: "1.2.840.113549.1.9.4",
                values: [
                  new asn1js__namespace.OctetString({ valueHex: result })
                ]
              }));
              cmsSigned.signerInfos.push(new SignerInfo({
                version: 1,
                sid: new IssuerAndSerialNumber({
                  issuer: parameters.signingCertificate.issuer,
                  serialNumber: parameters.signingCertificate.serialNumber
                }),
                signedAttrs: new SignedAndUnsignedAttributes({
                  type: 0,
                  attributes: signedAttr
                })
              }));
              await cmsSigned.sign(parameters.privateKey, 0, parameters.hashAlgorithm, void 0, crypto2);
              this.authSafe = new ContentInfo({
                contentType: "1.2.840.113549.1.7.2",
                content: cmsSigned.toSchema(true)
              });
            }
            break;
          default:
            throw new Error(`Parameter "integrityMode" has unknown value: ${this.parsedValue.integrityMode}`);
        }
      }
      async parseInternalValues(parameters, crypto2 = getCrypto(true)) {
        ArgumentError.assert(parameters, "parameters", "object");
        if (parameters.checkIntegrity === void 0) {
          parameters.checkIntegrity = true;
        }
        this.parsedValue = {};
        switch (this.authSafe.contentType) {
          case ContentInfo.DATA:
            {
              ParameterError.assertEmpty(parameters.password, "password");
              this.parsedValue.integrityMode = 0;
              ArgumentError.assert(this.authSafe.content, "authSafe.content", asn1js__namespace.OctetString);
              const authSafeContent = this.authSafe.content.getValue();
              this.parsedValue.authenticatedSafe = AuthenticatedSafe.fromBER(authSafeContent);
              if (parameters.checkIntegrity) {
                if (!this.macData) {
                  throw new Error('Absent "macData" value, can not check PKCS#12 data integrity');
                }
                const hashAlgorithm = crypto2.getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId, true, "digestAlgorithm");
                const result = await crypto2.verifyDataStampedWithPassword({
                  password: parameters.password,
                  hashAlgorithm: hashAlgorithm.name,
                  salt: pvtsutils.BufferSourceConverter.toArrayBuffer(this.macData.macSalt.valueBlock.valueHexView),
                  iterationCount: this.macData.iterations || 1,
                  contentToVerify: authSafeContent,
                  signatureToVerify: pvtsutils.BufferSourceConverter.toArrayBuffer(this.macData.mac.digest.valueBlock.valueHexView)
                });
                if (!result) {
                  throw new Error("Integrity for the PKCS#12 data is broken!");
                }
              }
            }
            break;
          case ContentInfo.SIGNED_DATA:
            {
              this.parsedValue.integrityMode = 1;
              const cmsSigned = new SignedData({ schema: this.authSafe.content });
              const eContent = cmsSigned.encapContentInfo.eContent;
              ParameterError.assert(eContent, "eContent", "cmsSigned.encapContentInfo");
              ArgumentError.assert(eContent, "eContent", asn1js__namespace.OctetString);
              const data = eContent.getValue();
              this.parsedValue.authenticatedSafe = AuthenticatedSafe.fromBER(data);
              const ok = await cmsSigned.verify({ signer: 0, checkChain: false }, crypto2);
              if (!ok) {
                throw new Error("Integrity for the PKCS#12 data is broken!");
              }
            }
            break;
          default:
            throw new Error(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`);
        }
      }
    };
    PFX.CLASS_NAME = "PFX";
    var STATUS$1 = "status";
    var STATUS_STRINGS = "statusStrings";
    var FAIL_INFO = "failInfo";
    var CLEAR_PROPS$2 = [
      STATUS$1,
      STATUS_STRINGS,
      FAIL_INFO
    ];
    exports.PKIStatus = void 0;
    (function(PKIStatus) {
      PKIStatus[PKIStatus["granted"] = 0] = "granted";
      PKIStatus[PKIStatus["grantedWithMods"] = 1] = "grantedWithMods";
      PKIStatus[PKIStatus["rejection"] = 2] = "rejection";
      PKIStatus[PKIStatus["waiting"] = 3] = "waiting";
      PKIStatus[PKIStatus["revocationWarning"] = 4] = "revocationWarning";
      PKIStatus[PKIStatus["revocationNotification"] = 5] = "revocationNotification";
    })(exports.PKIStatus || (exports.PKIStatus = {}));
    var PKIStatusInfo = class _PKIStatusInfo extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.status = pvutils__namespace.getParametersValue(parameters, STATUS$1, _PKIStatusInfo.defaultValues(STATUS$1));
        if (STATUS_STRINGS in parameters) {
          this.statusStrings = pvutils__namespace.getParametersValue(parameters, STATUS_STRINGS, _PKIStatusInfo.defaultValues(STATUS_STRINGS));
        }
        if (FAIL_INFO in parameters) {
          this.failInfo = pvutils__namespace.getParametersValue(parameters, FAIL_INFO, _PKIStatusInfo.defaultValues(FAIL_INFO));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case STATUS$1:
            return 2;
          case STATUS_STRINGS:
            return [];
          case FAIL_INFO:
            return new asn1js__namespace.BitString();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case STATUS$1:
            return memberValue === _PKIStatusInfo.defaultValues(memberName);
          case STATUS_STRINGS:
            return memberValue.length === 0;
          case FAIL_INFO:
            return memberValue.isEqual(_PKIStatusInfo.defaultValues(memberName));
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || EMPTY_STRING,
          value: [
            new asn1js__namespace.Integer({ name: names.status || EMPTY_STRING }),
            new asn1js__namespace.Sequence({
              optional: true,
              value: [
                new asn1js__namespace.Repeated({
                  name: names.statusStrings || EMPTY_STRING,
                  value: new asn1js__namespace.Utf8String()
                })
              ]
            }),
            new asn1js__namespace.BitString({
              name: names.failInfo || EMPTY_STRING,
              optional: true
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$2);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _PKIStatusInfo.schema({
          names: {
            status: STATUS$1,
            statusStrings: STATUS_STRINGS,
            failInfo: FAIL_INFO
          }
        }));
        AsnError.assertSchema(asn1, this.className);
        const _status = asn1.result.status;
        if (_status.valueBlock.isHexOnly === true || _status.valueBlock.valueDec < 0 || _status.valueBlock.valueDec > 5)
          throw new Error('PKIStatusInfo "status" has invalid value');
        this.status = _status.valueBlock.valueDec;
        if (STATUS_STRINGS in asn1.result)
          this.statusStrings = asn1.result.statusStrings;
        if (FAIL_INFO in asn1.result)
          this.failInfo = asn1.result.failInfo;
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.Integer({ value: this.status }));
        if (this.statusStrings) {
          outputArray.push(new asn1js__namespace.Sequence({
            optional: true,
            value: this.statusStrings
          }));
        }
        if (this.failInfo) {
          outputArray.push(this.failInfo);
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          status: this.status
        };
        if (this.statusStrings) {
          res.statusStrings = Array.from(this.statusStrings, (o) => o.toJSON());
        }
        if (this.failInfo) {
          res.failInfo = this.failInfo.toJSON();
        }
        return res;
      }
    };
    PKIStatusInfo.CLASS_NAME = "PKIStatusInfo";
    var VERSION = "version";
    var MESSAGE_IMPRINT = "messageImprint";
    var REQ_POLICY = "reqPolicy";
    var NONCE = "nonce";
    var CERT_REQ = "certReq";
    var EXTENSIONS = "extensions";
    var TIME_STAMP_REQ = "TimeStampReq";
    var TIME_STAMP_REQ_VERSION = `${TIME_STAMP_REQ}.${VERSION}`;
    var TIME_STAMP_REQ_MESSAGE_IMPRINT = `${TIME_STAMP_REQ}.${MESSAGE_IMPRINT}`;
    var TIME_STAMP_REQ_POLICY = `${TIME_STAMP_REQ}.${REQ_POLICY}`;
    var TIME_STAMP_REQ_NONCE = `${TIME_STAMP_REQ}.${NONCE}`;
    var TIME_STAMP_REQ_CERT_REQ = `${TIME_STAMP_REQ}.${CERT_REQ}`;
    var TIME_STAMP_REQ_EXTENSIONS = `${TIME_STAMP_REQ}.${EXTENSIONS}`;
    var CLEAR_PROPS$1 = [
      TIME_STAMP_REQ_VERSION,
      TIME_STAMP_REQ_MESSAGE_IMPRINT,
      TIME_STAMP_REQ_POLICY,
      TIME_STAMP_REQ_NONCE,
      TIME_STAMP_REQ_CERT_REQ,
      TIME_STAMP_REQ_EXTENSIONS
    ];
    var TimeStampReq = class _TimeStampReq extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.version = pvutils__namespace.getParametersValue(parameters, VERSION, _TimeStampReq.defaultValues(VERSION));
        this.messageImprint = pvutils__namespace.getParametersValue(parameters, MESSAGE_IMPRINT, _TimeStampReq.defaultValues(MESSAGE_IMPRINT));
        if (REQ_POLICY in parameters) {
          this.reqPolicy = pvutils__namespace.getParametersValue(parameters, REQ_POLICY, _TimeStampReq.defaultValues(REQ_POLICY));
        }
        if (NONCE in parameters) {
          this.nonce = pvutils__namespace.getParametersValue(parameters, NONCE, _TimeStampReq.defaultValues(NONCE));
        }
        if (CERT_REQ in parameters) {
          this.certReq = pvutils__namespace.getParametersValue(parameters, CERT_REQ, _TimeStampReq.defaultValues(CERT_REQ));
        }
        if (EXTENSIONS in parameters) {
          this.extensions = pvutils__namespace.getParametersValue(parameters, EXTENSIONS, _TimeStampReq.defaultValues(EXTENSIONS));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case VERSION:
            return 0;
          case MESSAGE_IMPRINT:
            return new MessageImprint();
          case REQ_POLICY:
            return EMPTY_STRING;
          case NONCE:
            return new asn1js__namespace.Integer();
          case CERT_REQ:
            return false;
          case EXTENSIONS:
            return [];
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case VERSION:
          case REQ_POLICY:
          case CERT_REQ:
            return memberValue === _TimeStampReq.defaultValues(memberName);
          case MESSAGE_IMPRINT:
            return MessageImprint.compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm) && MessageImprint.compareWithDefault("hashedMessage", memberValue.hashedMessage);
          case NONCE:
            return memberValue.isEqual(_TimeStampReq.defaultValues(memberName));
          case EXTENSIONS:
            return memberValue.length === 0;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || TIME_STAMP_REQ,
          value: [
            new asn1js__namespace.Integer({ name: names.version || TIME_STAMP_REQ_VERSION }),
            MessageImprint.schema(names.messageImprint || {
              names: {
                blockName: TIME_STAMP_REQ_MESSAGE_IMPRINT
              }
            }),
            new asn1js__namespace.ObjectIdentifier({
              name: names.reqPolicy || TIME_STAMP_REQ_POLICY,
              optional: true
            }),
            new asn1js__namespace.Integer({
              name: names.nonce || TIME_STAMP_REQ_NONCE,
              optional: true
            }),
            new asn1js__namespace.Boolean({
              name: names.certReq || TIME_STAMP_REQ_CERT_REQ,
              optional: true
            }),
            new asn1js__namespace.Constructed({
              optional: true,
              idBlock: {
                tagClass: 3,
                tagNumber: 0
              },
              value: [new asn1js__namespace.Repeated({
                name: names.extensions || TIME_STAMP_REQ_EXTENSIONS,
                value: Extension.schema()
              })]
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS$1);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _TimeStampReq.schema());
        AsnError.assertSchema(asn1, this.className);
        this.version = asn1.result[TIME_STAMP_REQ_VERSION].valueBlock.valueDec;
        this.messageImprint = new MessageImprint({ schema: asn1.result[TIME_STAMP_REQ_MESSAGE_IMPRINT] });
        if (TIME_STAMP_REQ_POLICY in asn1.result)
          this.reqPolicy = asn1.result[TIME_STAMP_REQ_POLICY].valueBlock.toString();
        if (TIME_STAMP_REQ_NONCE in asn1.result)
          this.nonce = asn1.result[TIME_STAMP_REQ_NONCE];
        if (TIME_STAMP_REQ_CERT_REQ in asn1.result)
          this.certReq = asn1.result[TIME_STAMP_REQ_CERT_REQ].valueBlock.value;
        if (TIME_STAMP_REQ_EXTENSIONS in asn1.result)
          this.extensions = Array.from(asn1.result[TIME_STAMP_REQ_EXTENSIONS], (element) => new Extension({ schema: element }));
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(new asn1js__namespace.Integer({ value: this.version }));
        outputArray.push(this.messageImprint.toSchema());
        if (this.reqPolicy)
          outputArray.push(new asn1js__namespace.ObjectIdentifier({ value: this.reqPolicy }));
        if (this.nonce)
          outputArray.push(this.nonce);
        if (CERT_REQ in this && _TimeStampReq.compareWithDefault(CERT_REQ, this.certReq) === false)
          outputArray.push(new asn1js__namespace.Boolean({ value: this.certReq }));
        if (this.extensions) {
          outputArray.push(new asn1js__namespace.Constructed({
            idBlock: {
              tagClass: 3,
              tagNumber: 0
            },
            value: Array.from(this.extensions, (o) => o.toSchema())
          }));
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          version: this.version,
          messageImprint: this.messageImprint.toJSON()
        };
        if (this.reqPolicy !== void 0)
          res.reqPolicy = this.reqPolicy;
        if (this.nonce !== void 0)
          res.nonce = this.nonce.toJSON();
        if (this.certReq !== void 0 && _TimeStampReq.compareWithDefault(CERT_REQ, this.certReq) === false)
          res.certReq = this.certReq;
        if (this.extensions) {
          res.extensions = Array.from(this.extensions, (o) => o.toJSON());
        }
        return res;
      }
    };
    TimeStampReq.CLASS_NAME = "TimeStampReq";
    var STATUS = "status";
    var TIME_STAMP_TOKEN = "timeStampToken";
    var TIME_STAMP_RESP = "TimeStampResp";
    var TIME_STAMP_RESP_STATUS = `${TIME_STAMP_RESP}.${STATUS}`;
    var TIME_STAMP_RESP_TOKEN = `${TIME_STAMP_RESP}.${TIME_STAMP_TOKEN}`;
    var CLEAR_PROPS = [
      TIME_STAMP_RESP_STATUS,
      TIME_STAMP_RESP_TOKEN
    ];
    var TimeStampResp = class _TimeStampResp extends PkiObject {
      constructor(parameters = {}) {
        super();
        this.status = pvutils__namespace.getParametersValue(parameters, STATUS, _TimeStampResp.defaultValues(STATUS));
        if (TIME_STAMP_TOKEN in parameters) {
          this.timeStampToken = pvutils__namespace.getParametersValue(parameters, TIME_STAMP_TOKEN, _TimeStampResp.defaultValues(TIME_STAMP_TOKEN));
        }
        if (parameters.schema) {
          this.fromSchema(parameters.schema);
        }
      }
      static defaultValues(memberName) {
        switch (memberName) {
          case STATUS:
            return new PKIStatusInfo();
          case TIME_STAMP_TOKEN:
            return new ContentInfo();
          default:
            return super.defaultValues(memberName);
        }
      }
      static compareWithDefault(memberName, memberValue) {
        switch (memberName) {
          case STATUS:
            return PKIStatusInfo.compareWithDefault(STATUS, memberValue.status) && "statusStrings" in memberValue === false && "failInfo" in memberValue === false;
          case TIME_STAMP_TOKEN:
            return memberValue.contentType === EMPTY_STRING && memberValue.content instanceof asn1js__namespace.Any;
          default:
            return super.defaultValues(memberName);
        }
      }
      static schema(parameters = {}) {
        const names = pvutils__namespace.getParametersValue(parameters, "names", {});
        return new asn1js__namespace.Sequence({
          name: names.blockName || TIME_STAMP_RESP,
          value: [
            PKIStatusInfo.schema(names.status || {
              names: {
                blockName: TIME_STAMP_RESP_STATUS
              }
            }),
            ContentInfo.schema(names.timeStampToken || {
              names: {
                blockName: TIME_STAMP_RESP_TOKEN,
                optional: true
              }
            })
          ]
        });
      }
      fromSchema(schema) {
        pvutils__namespace.clearProps(schema, CLEAR_PROPS);
        const asn1 = asn1js__namespace.compareSchema(schema, schema, _TimeStampResp.schema());
        AsnError.assertSchema(asn1, this.className);
        this.status = new PKIStatusInfo({ schema: asn1.result[TIME_STAMP_RESP_STATUS] });
        if (TIME_STAMP_RESP_TOKEN in asn1.result)
          this.timeStampToken = new ContentInfo({ schema: asn1.result[TIME_STAMP_RESP_TOKEN] });
      }
      toSchema() {
        const outputArray = [];
        outputArray.push(this.status.toSchema());
        if (this.timeStampToken) {
          outputArray.push(this.timeStampToken.toSchema());
        }
        return new asn1js__namespace.Sequence({
          value: outputArray
        });
      }
      toJSON() {
        const res = {
          status: this.status.toJSON()
        };
        if (this.timeStampToken) {
          res.timeStampToken = this.timeStampToken.toJSON();
        }
        return res;
      }
      async sign(privateKey, hashAlgorithm, crypto2 = getCrypto(true)) {
        this.assertContentType();
        const signed = new SignedData({ schema: this.timeStampToken.content });
        return signed.sign(privateKey, 0, hashAlgorithm, void 0, crypto2);
      }
      async verify(verificationParameters = { signer: 0, trustedCerts: [], data: EMPTY_BUFFER }, crypto2 = getCrypto(true)) {
        this.assertContentType();
        const signed = new SignedData({ schema: this.timeStampToken.content });
        return signed.verify(verificationParameters, crypto2);
      }
      assertContentType() {
        if (!this.timeStampToken) {
          throw new Error("timeStampToken is absent in TSP response");
        }
        if (this.timeStampToken.contentType !== id_ContentType_SignedData) {
          throw new Error(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`);
        }
      }
    };
    TimeStampResp.CLASS_NAME = "TimeStampResp";
    function initCryptoEngine() {
      if (typeof self !== "undefined") {
        if ("crypto" in self) {
          let engineName = "webcrypto";
          if ("webkitSubtle" in self.crypto) {
            engineName = "safari";
          }
          setEngine2(engineName, new CryptoEngine2({ name: engineName, crypto }));
        }
      } else if (typeof crypto !== "undefined" && "webcrypto" in crypto) {
        const name = "NodeJS ^15";
        const nodeCrypto = crypto.webcrypto;
        setEngine2(name, new CryptoEngine2({ name, crypto: nodeCrypto }));
      }
    }
    initCryptoEngine();
    exports.AbstractCryptoEngine = AbstractCryptoEngine;
    exports.AccessDescription = AccessDescription;
    exports.Accuracy = Accuracy;
    exports.AlgorithmIdentifier = AlgorithmIdentifier;
    exports.AltName = AltName;
    exports.ArgumentError = ArgumentError;
    exports.AsnError = AsnError;
    exports.AttCertValidityPeriod = AttCertValidityPeriod;
    exports.Attribute = Attribute;
    exports.AttributeCertificateInfoV1 = AttributeCertificateInfoV1;
    exports.AttributeCertificateInfoV2 = AttributeCertificateInfoV2;
    exports.AttributeCertificateV1 = AttributeCertificateV1;
    exports.AttributeCertificateV2 = AttributeCertificateV2;
    exports.AttributeTypeAndValue = AttributeTypeAndValue;
    exports.AuthenticatedSafe = AuthenticatedSafe;
    exports.AuthorityKeyIdentifier = AuthorityKeyIdentifier;
    exports.BasicConstraints = BasicConstraints;
    exports.BasicOCSPResponse = BasicOCSPResponse;
    exports.CAVersion = CAVersion;
    exports.CRLBag = CRLBag;
    exports.CRLDistributionPoints = CRLDistributionPoints;
    exports.CertBag = CertBag;
    exports.CertID = CertID;
    exports.Certificate = Certificate;
    exports.CertificateChainValidationEngine = CertificateChainValidationEngine;
    exports.CertificatePolicies = CertificatePolicies;
    exports.CertificateRevocationList = CertificateRevocationList;
    exports.CertificateSet = CertificateSet;
    exports.CertificateTemplate = CertificateTemplate;
    exports.CertificationRequest = CertificationRequest;
    exports.ChainValidationError = ChainValidationError;
    exports.ContentInfo = ContentInfo;
    exports.CryptoEngine = CryptoEngine2;
    exports.DigestInfo = DigestInfo;
    exports.DistributionPoint = DistributionPoint;
    exports.ECCCMSSharedInfo = ECCCMSSharedInfo;
    exports.ECNamedCurves = ECNamedCurves;
    exports.ECPrivateKey = ECPrivateKey;
    exports.ECPublicKey = ECPublicKey;
    exports.EncapsulatedContentInfo = EncapsulatedContentInfo;
    exports.EncryptedContentInfo = EncryptedContentInfo;
    exports.EncryptedData = EncryptedData;
    exports.EnvelopedData = EnvelopedData;
    exports.ExtKeyUsage = ExtKeyUsage;
    exports.Extension = Extension;
    exports.ExtensionValueFactory = ExtensionValueFactory;
    exports.Extensions = Extensions;
    exports.GeneralName = GeneralName;
    exports.GeneralNames = GeneralNames;
    exports.GeneralSubtree = GeneralSubtree;
    exports.HASHED_MESSAGE = HASHED_MESSAGE;
    exports.HASH_ALGORITHM = HASH_ALGORITHM;
    exports.Holder = Holder;
    exports.InfoAccess = InfoAccess;
    exports.IssuerAndSerialNumber = IssuerAndSerialNumber;
    exports.IssuerSerial = IssuerSerial;
    exports.IssuingDistributionPoint = IssuingDistributionPoint;
    exports.KEKIdentifier = KEKIdentifier;
    exports.KEKRecipientInfo = KEKRecipientInfo;
    exports.KeyAgreeRecipientIdentifier = KeyAgreeRecipientIdentifier;
    exports.KeyAgreeRecipientInfo = KeyAgreeRecipientInfo;
    exports.KeyBag = KeyBag;
    exports.KeyTransRecipientInfo = KeyTransRecipientInfo;
    exports.MICROS = MICROS;
    exports.MILLIS = MILLIS;
    exports.MacData = MacData;
    exports.MessageImprint = MessageImprint;
    exports.NameConstraints = NameConstraints;
    exports.OCSPRequest = OCSPRequest;
    exports.OCSPResponse = OCSPResponse;
    exports.ObjectDigestInfo = ObjectDigestInfo;
    exports.OriginatorIdentifierOrKey = OriginatorIdentifierOrKey;
    exports.OriginatorInfo = OriginatorInfo;
    exports.OriginatorPublicKey = OriginatorPublicKey;
    exports.OtherCertificateFormat = OtherCertificateFormat;
    exports.OtherKeyAttribute = OtherKeyAttribute;
    exports.OtherPrimeInfo = OtherPrimeInfo;
    exports.OtherRecipientInfo = OtherRecipientInfo;
    exports.OtherRevocationInfoFormat = OtherRevocationInfoFormat;
    exports.PBES2Params = PBES2Params;
    exports.PBKDF2Params = PBKDF2Params;
    exports.PFX = PFX;
    exports.PKCS8ShroudedKeyBag = PKCS8ShroudedKeyBag;
    exports.PKIStatusInfo = PKIStatusInfo;
    exports.POLICY_IDENTIFIER = POLICY_IDENTIFIER;
    exports.POLICY_QUALIFIERS = POLICY_QUALIFIERS;
    exports.ParameterError = ParameterError;
    exports.PasswordRecipientinfo = PasswordRecipientinfo;
    exports.PkiObject = PkiObject;
    exports.PolicyConstraints = PolicyConstraints;
    exports.PolicyInformation = PolicyInformation;
    exports.PolicyMapping = PolicyMapping;
    exports.PolicyMappings = PolicyMappings;
    exports.PolicyQualifierInfo = PolicyQualifierInfo;
    exports.PrivateKeyInfo = PrivateKeyInfo;
    exports.PrivateKeyUsagePeriod = PrivateKeyUsagePeriod;
    exports.PublicKeyInfo = PublicKeyInfo;
    exports.QCStatement = QCStatement;
    exports.QCStatements = QCStatements;
    exports.RDN = RDN;
    exports.RSAESOAEPParams = RSAESOAEPParams;
    exports.RSAPrivateKey = RSAPrivateKey;
    exports.RSAPublicKey = RSAPublicKey;
    exports.RSASSAPSSParams = RSASSAPSSParams;
    exports.RecipientEncryptedKey = RecipientEncryptedKey;
    exports.RecipientEncryptedKeys = RecipientEncryptedKeys;
    exports.RecipientIdentifier = RecipientIdentifier;
    exports.RecipientInfo = RecipientInfo;
    exports.RecipientKeyIdentifier = RecipientKeyIdentifier;
    exports.RelativeDistinguishedNames = RelativeDistinguishedNames;
    exports.Request = Request;
    exports.ResponseBytes = ResponseBytes;
    exports.ResponseData = ResponseData;
    exports.RevocationInfoChoices = RevocationInfoChoices;
    exports.RevokedCertificate = RevokedCertificate;
    exports.SECONDS = SECONDS;
    exports.SafeBag = SafeBag;
    exports.SafeBagValueFactory = SafeBagValueFactory;
    exports.SafeContents = SafeContents;
    exports.SecretBag = SecretBag;
    exports.Signature = Signature2;
    exports.SignedAndUnsignedAttributes = SignedAndUnsignedAttributes;
    exports.SignedCertificateTimestamp = SignedCertificateTimestamp;
    exports.SignedCertificateTimestampList = SignedCertificateTimestampList;
    exports.SignedData = SignedData;
    exports.SignedDataVerifyError = SignedDataVerifyError;
    exports.SignerInfo = SignerInfo;
    exports.SingleResponse = SingleResponse;
    exports.SubjectDirectoryAttributes = SubjectDirectoryAttributes;
    exports.TBSRequest = TBSRequest;
    exports.TSTInfo = TSTInfo;
    exports.TYPE = TYPE$4;
    exports.TYPE_AND_VALUES = TYPE_AND_VALUES;
    exports.Time = Time;
    exports.TimeStampReq = TimeStampReq;
    exports.TimeStampResp = TimeStampResp;
    exports.V2Form = V2Form;
    exports.VALUE = VALUE$5;
    exports.VALUE_BEFORE_DECODE = VALUE_BEFORE_DECODE;
    exports.checkCA = checkCA;
    exports.createCMSECDSASignature = createCMSECDSASignature;
    exports.createECDSASignatureFromCMS = createECDSASignatureFromCMS;
    exports.getAlgorithmByOID = getAlgorithmByOID;
    exports.getAlgorithmParameters = getAlgorithmParameters;
    exports.getCrypto = getCrypto;
    exports.getEngine = getEngine;
    exports.getHashAlgorithm = getHashAlgorithm;
    exports.getOIDByAlgorithm = getOIDByAlgorithm;
    exports.getRandomValues = getRandomValues2;
    exports.id_AnyPolicy = id_AnyPolicy;
    exports.id_AuthorityInfoAccess = id_AuthorityInfoAccess;
    exports.id_AuthorityKeyIdentifier = id_AuthorityKeyIdentifier;
    exports.id_BaseCRLNumber = id_BaseCRLNumber;
    exports.id_BasicConstraints = id_BasicConstraints;
    exports.id_CRLBag_X509CRL = id_CRLBag_X509CRL;
    exports.id_CRLDistributionPoints = id_CRLDistributionPoints;
    exports.id_CRLNumber = id_CRLNumber;
    exports.id_CRLReason = id_CRLReason;
    exports.id_CertBag_AttributeCertificate = id_CertBag_AttributeCertificate;
    exports.id_CertBag_SDSICertificate = id_CertBag_SDSICertificate;
    exports.id_CertBag_X509Certificate = id_CertBag_X509Certificate;
    exports.id_CertificateIssuer = id_CertificateIssuer;
    exports.id_CertificatePolicies = id_CertificatePolicies;
    exports.id_ContentType_Data = id_ContentType_Data;
    exports.id_ContentType_EncryptedData = id_ContentType_EncryptedData;
    exports.id_ContentType_EnvelopedData = id_ContentType_EnvelopedData;
    exports.id_ContentType_SignedData = id_ContentType_SignedData;
    exports.id_ExtKeyUsage = id_ExtKeyUsage;
    exports.id_FreshestCRL = id_FreshestCRL;
    exports.id_InhibitAnyPolicy = id_InhibitAnyPolicy;
    exports.id_InvalidityDate = id_InvalidityDate;
    exports.id_IssuerAltName = id_IssuerAltName;
    exports.id_IssuingDistributionPoint = id_IssuingDistributionPoint;
    exports.id_KeyUsage = id_KeyUsage;
    exports.id_MicrosoftAppPolicies = id_MicrosoftAppPolicies;
    exports.id_MicrosoftCaVersion = id_MicrosoftCaVersion;
    exports.id_MicrosoftCertTemplateV1 = id_MicrosoftCertTemplateV1;
    exports.id_MicrosoftCertTemplateV2 = id_MicrosoftCertTemplateV2;
    exports.id_MicrosoftPrevCaCertHash = id_MicrosoftPrevCaCertHash;
    exports.id_NameConstraints = id_NameConstraints;
    exports.id_PKIX_OCSP_Basic = id_PKIX_OCSP_Basic;
    exports.id_PolicyConstraints = id_PolicyConstraints;
    exports.id_PolicyMappings = id_PolicyMappings;
    exports.id_PrivateKeyUsagePeriod = id_PrivateKeyUsagePeriod;
    exports.id_QCStatements = id_QCStatements;
    exports.id_SignedCertificateTimestampList = id_SignedCertificateTimestampList;
    exports.id_SubjectAltName = id_SubjectAltName;
    exports.id_SubjectDirectoryAttributes = id_SubjectDirectoryAttributes;
    exports.id_SubjectInfoAccess = id_SubjectInfoAccess;
    exports.id_SubjectKeyIdentifier = id_SubjectKeyIdentifier;
    exports.id_ad = id_ad;
    exports.id_ad_caIssuers = id_ad_caIssuers;
    exports.id_ad_ocsp = id_ad_ocsp;
    exports.id_eContentType_TSTInfo = id_eContentType_TSTInfo;
    exports.id_pkix = id_pkix;
    exports.id_sha1 = id_sha1;
    exports.id_sha256 = id_sha256;
    exports.id_sha384 = id_sha384;
    exports.id_sha512 = id_sha512;
    exports.kdf = kdf;
    exports.setEngine = setEngine2;
    exports.stringPrep = stringPrep;
    exports.verifySCTsForCertificate = verifySCTsForCertificate;
  }
});

// node_modules/cose/dist/browser/runtime/browser/pkijs.js
var pkijs, pkijs_1;
var init_pkijs = __esm({
  "node_modules/cose/dist/browser/runtime/browser/pkijs.js"() {
    pkijs = __toESM(require_build3(), 1);
    pkijs_1 = __toESM(require_build3(), 1);
    pkijs.setEngine("webcrypto", new pkijs.CryptoEngine({
      name: "webcrypto",
      crypto,
      subtle: crypto.subtle
    }));
  }
});

// node_modules/cose/dist/browser/lib/buffer_utils.js
function areEqual(buf1, buf2) {
  if (buf1 === buf2) {
    return true;
  }
  if (buf1.byteLength !== buf2.byteLength) {
    return false;
  }
  for (let i = 0; i < buf1.byteLength; i++) {
    if (buf1[i] !== buf2[i]) {
      return false;
    }
  }
  return true;
}
var encoder2, decoder3, fromUTF8;
var init_buffer_utils2 = __esm({
  "node_modules/cose/dist/browser/lib/buffer_utils.js"() {
    encoder2 = new TextEncoder();
    decoder3 = new TextDecoder();
    fromUTF8 = (input) => encoder2.encode(input);
  }
});

// node_modules/cose/dist/browser/runtime/browser/base64.js
var encodeBase642, encodeBase64URL, decodeBase642;
var init_base64 = __esm({
  "node_modules/cose/dist/browser/runtime/browser/base64.js"() {
    init_buffer_utils2();
    encodeBase642 = (input) => {
      let unencoded = input;
      if (typeof unencoded === "string") {
        unencoded = encoder2.encode(unencoded);
      }
      const CHUNK_SIZE = 32768;
      const arr = [];
      for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
      }
      return btoa(arr.join(""));
    };
    encodeBase64URL = (input) => {
      return encodeBase642(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    };
    decodeBase642 = (encoded) => {
      const binary = atob(encoded);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    };
  }
});

// node_modules/cose/dist/browser/util/errors.js
var COSEError, COSENotSupported, X509NoMatchingCertificate, X509InvalidCertificateChain;
var init_errors2 = __esm({
  "node_modules/cose/dist/browser/util/errors.js"() {
    COSEError = class extends Error {
      static get code() {
        return "ERR_COSE_GENERIC";
      }
      constructor(message3) {
        var _a;
        super(message3);
        this.code = "ERR_COSE_GENERIC";
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
      }
    };
    COSENotSupported = class extends COSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_COSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_COSE_NOT_SUPPORTED";
      }
    };
    X509NoMatchingCertificate = class extends COSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_X509_NO_MATCHING_CERTIFICATE";
        this.message = "no applicable certificate found in the COSE headers";
      }
      static get code() {
        return "ERR_X509_NO_MATCHING_CERTIFICATE";
      }
    };
    X509InvalidCertificateChain = class extends COSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_X509_INVALID_CERTIFICATE_CHAIN";
      }
      static get code() {
        return "ERR_X509_INVALID_CERTIFICATE_CHAIN";
      }
    };
  }
});

// node_modules/cose/dist/browser/util/cert.js
var pemToCert, certToPEM;
var init_cert = __esm({
  "node_modules/cose/dist/browser/util/cert.js"() {
    init_base64();
    pemToCert = (cert) => {
      const pem = /-----BEGIN (\w*)-----([^-]*)-----END (\w*)-----/g.exec(cert.toString());
      if (pem && pem.length > 0) {
        return pem[2].replace(/[\n|\r\n]/g, "");
      }
      return "";
    };
    certToPEM = (cert) => {
      return `-----BEGIN CERTIFICATE-----
${encodeBase642(cert).trim()}
-----END CERTIFICATE-----`;
    };
  }
});

// node_modules/cose/dist/browser/cbor.js
var encoder3, addExtension3;
var init_cbor = __esm({
  "node_modules/cose/dist/browser/cbor.js"() {
    init_cbor_x();
    encoder3 = new Encoder({
      tagUint8Array: false,
      useRecords: false,
      mapsAsObjects: false,
      useTag259ForMaps: false
    });
    addExtension3 = addExtension2;
  }
});

// node_modules/cose/dist/browser/headers.js
var algs, macAlgs, macAlgsToValue, algsToValue, headers, encodeProtectedHeaders, mapUnprotectedHeaders;
var init_headers = __esm({
  "node_modules/cose/dist/browser/headers.js"() {
    init_buffer_utils2();
    init_cbor();
    algs = /* @__PURE__ */ new Map([
      [-8, { name: "EdDSA" }],
      [-7, { name: "ES256", hash: "SHA-256" }],
      [-35, { name: "ES384", hash: "SHA-384" }],
      [-36, { name: "ES512", hash: "SHA-512" }],
      [-37, { name: "PS256", hash: "SHA-256" }],
      [-38, { name: "PS384", hash: "SHA-384" }],
      [-39, { name: "PS512", hash: "SHA-512" }],
      [-257, { name: "RS256", hash: "SHA-256" }],
      [-258, { name: "RS384", hash: "SHA-384" }],
      [-259, { name: "RS512", hash: "SHA-512" }]
    ]);
    macAlgs = /* @__PURE__ */ new Map([
      [5, { name: "HS256", hash: "SHA-256", length: 256 }]
    ]);
    macAlgsToValue = /* @__PURE__ */ new Map([
      ["HS256", 5]
    ]);
    algsToValue = /* @__PURE__ */ new Map([
      ["EdDSA", -8],
      ["ES256", -7],
      ["ES384", -35],
      ["ES512", -36],
      ["PS256", -37],
      ["PS384", -38],
      ["PS512", -39],
      ["RS256", -257],
      ["RS384", -258],
      ["RS512", -259]
    ]);
    headers = {
      partyUNonce: -22,
      static_key_id: -3,
      static_key: -2,
      ephemeral_key: -1,
      alg: 1,
      crit: 2,
      ctyp: 3,
      kid: 4,
      IV: 5,
      Partial_IV: 6,
      counter_signature: 7,
      x5bag: 32,
      x5chain: 33,
      x5t: 34,
      x5u: 35
    };
    encodeProtectedHeaders = (protectedHeader) => {
      if (typeof protectedHeader === "undefined") {
        return new Uint8Array();
      }
      return encoder3.encode(new Map(Object.entries(protectedHeader || {}).map(([k, v]) => {
        if (k === "alg") {
          v = algsToValue.get(v);
        } else if (typeof v === "string") {
          v = fromUTF8(v);
        }
        return [headers[k], v];
      })));
    };
    mapUnprotectedHeaders = (unprotectedHeader) => {
      return new Map(Object.entries(unprotectedHeader || {}).map(([k, v]) => {
        if (typeof v === "string") {
          v = fromUTF8(v);
        }
        return [headers[k], v];
      }));
    };
  }
});

// node_modules/cose/dist/browser/cose/WithHeaders.js
var __classPrivateFieldSet3, __classPrivateFieldGet3, _WithHeaders_decodedProtectedHeaders, WithHeaders;
var init_WithHeaders = __esm({
  "node_modules/cose/dist/browser/cose/WithHeaders.js"() {
    init_cbor();
    __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet3 = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    WithHeaders = class {
      constructor(protectedHeaders, unprotectedHeaders) {
        this.unprotectedHeaders = unprotectedHeaders;
        _WithHeaders_decodedProtectedHeaders.set(this, void 0);
        if (protectedHeaders instanceof Uint8Array) {
          this.encodedProtectedHeaders = protectedHeaders;
        } else {
          __classPrivateFieldSet3(this, _WithHeaders_decodedProtectedHeaders, protectedHeaders, "f");
          this.encodedProtectedHeaders = encoder3.encode(protectedHeaders);
        }
      }
      get protectedHeaders() {
        if (!__classPrivateFieldGet3(this, _WithHeaders_decodedProtectedHeaders, "f")) {
          if (!this.encodedProtectedHeaders || this.encodedProtectedHeaders.byteLength === 0) {
            __classPrivateFieldSet3(this, _WithHeaders_decodedProtectedHeaders, /* @__PURE__ */ new Map(), "f");
          } else {
            __classPrivateFieldSet3(this, _WithHeaders_decodedProtectedHeaders, encoder3.decode(this.encodedProtectedHeaders), "f");
          }
        }
        return __classPrivateFieldGet3(this, _WithHeaders_decodedProtectedHeaders, "f");
      }
    };
    _WithHeaders_decodedProtectedHeaders = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/cose/dist/browser/cose/SignatureBase.js
var SignatureBase;
var init_SignatureBase = __esm({
  "node_modules/cose/dist/browser/cose/SignatureBase.js"() {
    init_browser();
    init_pkijs();
    init_base64();
    init_errors2();
    init_cert();
    init_headers();
    init_WithHeaders();
    SignatureBase = class extends WithHeaders {
      constructor(protectedHeader, unprotectedHeader, signature) {
        super(protectedHeader, unprotectedHeader);
        this.signature = signature;
      }
      get alg() {
        return this.protectedHeaders.get(headers.alg) || this.unprotectedHeaders.get(headers.alg);
      }
      get algName() {
        var _a;
        return this.alg ? (_a = algs.get(this.alg)) === null || _a === void 0 ? void 0 : _a.name : void 0;
      }
      get kid() {
        return this.protectedHeaders.get(headers.kid) || this.unprotectedHeaders.get(headers.kid);
      }
      get x5bag() {
        const x5bag = this.protectedHeaders.get(headers.x5bag) || this.unprotectedHeaders.get(headers.x5bag);
        if (!x5bag) {
          return;
        }
        return Array.isArray(x5bag) ? x5bag : [x5bag];
      }
      get x5chain() {
        const x5chain = this.protectedHeaders.get(headers.x5chain) || this.unprotectedHeaders.get(headers.x5chain);
        if (!x5chain) {
          return;
        }
        return Array.isArray(x5chain) ? x5chain : [x5chain];
      }
      async verifyX509Chain(caRoots) {
        const { x5chain } = this;
        if (!x5chain || x5chain.length === 0) {
          throw new X509NoMatchingCertificate();
        }
        const chainEngine = new pkijs_1.CertificateChainValidationEngine({
          certs: x5chain.map((c) => pkijs_1.Certificate.fromBER(c)),
          trustedCerts: caRoots.map((c) => pkijs_1.Certificate.fromBER(decodeBase642(pemToCert(c))))
        });
        const chain = await chainEngine.verify();
        if (!chain.result) {
          throw new X509InvalidCertificateChain(chain.resultMessage);
        }
        const x509Cert = certToPEM(x5chain[0]);
        const publicKey = await importX509(x509Cert, this.algName);
        return { publicKey, raw: x5chain[0] };
      }
    };
  }
});

// node_modules/cose/dist/browser/runtime/browser/subtle_dsa.js
function subtleDsa2(alg, algorithm) {
  const hash2 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash2, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash2, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash2, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash2, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new COSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_dsa2 = __esm({
  "node_modules/cose/dist/browser/runtime/browser/subtle_dsa.js"() {
    init_errors2();
  }
});

// node_modules/cose/dist/browser/runtime/browser/webcrypto.js
var webcrypto_default2, isCryptoKey2;
var init_webcrypto2 = __esm({
  "node_modules/cose/dist/browser/runtime/browser/webcrypto.js"() {
    webcrypto_default2 = crypto;
    isCryptoKey2 = (key) => key instanceof CryptoKey;
  }
});

// node_modules/cose/dist/browser/runtime/browser/check_key_length.js
var check_key_length_default2;
var init_check_key_length2 = __esm({
  "node_modules/cose/dist/browser/runtime/browser/check_key_length.js"() {
    check_key_length_default2 = (alg, key) => {
      if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
      }
    };
  }
});

// node_modules/cose/dist/browser/lib/crypto_key.js
function unusable2(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm2(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength2(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
function getNamedCurve3(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage2(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey2(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm2(key.algorithm, "HMAC"))
        throw unusable2("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength2(key.algorithm.hash);
      if (actual !== expected)
        throw unusable2(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm2(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable2("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength2(key.algorithm.hash);
      if (actual !== expected)
        throw unusable2(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm2(key.algorithm, "RSA-PSS"))
        throw unusable2("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength2(key.algorithm.hash);
      if (actual !== expected)
        throw unusable2(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable2("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm2(key.algorithm, "ECDSA"))
        throw unusable2("ECDSA");
      const expected = getNamedCurve3(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable2(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage2(key, usages);
}
var init_crypto_key2 = __esm({
  "node_modules/cose/dist/browser/lib/crypto_key.js"() {
  }
});

// node_modules/cose/dist/browser/lib/invalid_key_input.js
function message2(msg, actual, ...types3) {
  if (types3.length > 2) {
    const last = types3.pop();
    msg += `one of type ${types3.join(", ")}, or ${last}.`;
  } else if (types3.length === 2) {
    msg += `one of type ${types3[0]} or ${types3[1]}.`;
  } else {
    msg += `of type ${types3[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default2;
var init_invalid_key_input2 = __esm({
  "node_modules/cose/dist/browser/lib/invalid_key_input.js"() {
    invalid_key_input_default2 = (actual, ...types3) => {
      return message2("Key must be ", actual, ...types3);
    };
  }
});

// node_modules/cose/dist/browser/runtime/browser/is_key_like.js
var types2;
var init_is_key_like2 = __esm({
  "node_modules/cose/dist/browser/runtime/browser/is_key_like.js"() {
    init_webcrypto2();
    types2 = ["CryptoKey"];
  }
});

// node_modules/cose/dist/browser/runtime/browser/get_sign_verify_key.js
function getCryptoKey4(alg, key, usage) {
  if (isCryptoKey2(key)) {
    checkSigCryptoKey2(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default2(key, ...types2));
    }
    return webcrypto_default2.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default2(key, ...types2, "Uint8Array"));
}
var init_get_sign_verify_key2 = __esm({
  "node_modules/cose/dist/browser/runtime/browser/get_sign_verify_key.js"() {
    init_webcrypto2();
    init_crypto_key2();
    init_invalid_key_input2();
    init_is_key_like2();
  }
});

// node_modules/cose/dist/browser/runtime/browser/verify.js
var verify2, verify_default2;
var init_verify6 = __esm({
  "node_modules/cose/dist/browser/runtime/browser/verify.js"() {
    init_subtle_dsa2();
    init_webcrypto2();
    init_check_key_length2();
    init_get_sign_verify_key2();
    verify2 = async (alg, key, signature, data) => {
      const cryptoKey = await getCryptoKey4(alg, key, "verify");
      check_key_length_default2(alg, cryptoKey);
      const algorithm = subtleDsa2(alg, cryptoKey.algorithm);
      try {
        return await webcrypto_default2.subtle.verify(algorithm, cryptoKey, signature, data);
      } catch (_a) {
        return false;
      }
    };
    verify_default2 = verify2;
  }
});

// node_modules/cose/dist/browser/runtime/browser/sign.js
var sign2, sign_default2;
var init_sign6 = __esm({
  "node_modules/cose/dist/browser/runtime/browser/sign.js"() {
    init_subtle_dsa2();
    init_webcrypto2();
    init_check_key_length2();
    init_get_sign_verify_key2();
    sign2 = async (alg, key, data) => {
      const cryptoKey = await getCryptoKey4(alg, key, "sign");
      check_key_length_default2(alg, cryptoKey);
      const signature = await webcrypto_default2.subtle.sign(subtleDsa2(alg, cryptoKey.algorithm), cryptoKey, data);
      return new Uint8Array(signature);
    };
    sign_default2 = sign2;
  }
});

// node_modules/cose/dist/browser/cose/Sign.js
var Sign, Signature;
var init_Sign = __esm({
  "node_modules/cose/dist/browser/cose/Sign.js"() {
    init_SignatureBase();
    init_WithHeaders();
    init_verify6();
    init_headers();
    init_sign6();
    init_cbor();
    Sign = class _Sign extends WithHeaders {
      constructor(protectedHeader, unprotectedHeader, payload, signatures) {
        super(protectedHeader, unprotectedHeader);
        this.payload = payload;
        this.signatures = signatures;
      }
      getContentForEncoding() {
        return [
          this.encodedProtectedHeaders,
          this.unprotectedHeaders,
          this.payload,
          this.signatures.map((signature) => [
            signature.protectedHeaders,
            signature.unprotectedHeaders,
            signature.signature
          ])
        ];
      }
      encode() {
        return encoder3.encode(this);
      }
      async verify(keys) {
        const results = await Promise.all(this.signatures.map(async (signature, index) => {
          const keyToUse = Array.isArray(keys) ? keys[index] : keys;
          return signature.verify(keyToUse, this.encodedProtectedHeaders, this.payload);
        }));
        return results.every(Boolean);
      }
      async verifyX509(roots) {
        const results = await Promise.all(this.signatures.map(async (signature) => {
          const { publicKey } = await signature.verifyX509Chain(roots);
          return signature.verify(publicKey, this.encodedProtectedHeaders, this.payload);
        }));
        return results.every(Boolean);
      }
      static async sign(bodyProtectedHeader, unprotectedHeader, payload, signers) {
        const encodedProtectedHeaders = encodeProtectedHeaders(bodyProtectedHeader);
        const unprotectedHeadersMap = mapUnprotectedHeaders(unprotectedHeader);
        const signatures = await Promise.all(signers.map(async ({ key, protectedHeader, unprotectedHeader: unprotectedHeader2 }) => {
          return Signature.sign(encodedProtectedHeaders, protectedHeader, unprotectedHeader2, payload, key);
        }));
        return new _Sign(encodedProtectedHeaders, unprotectedHeadersMap, payload, signatures);
      }
    };
    Signature = class _Signature extends SignatureBase {
      constructor(protectedHeader, unprotectedHeaders, signature) {
        super(protectedHeader, unprotectedHeaders, signature);
        this.unprotectedHeaders = unprotectedHeaders;
        this.signature = signature;
      }
      static Signature(bodyProtectedHeaders, protectedHeaders, applicationHeaders, payload) {
        return encoder3.encode([
          "Signature",
          bodyProtectedHeaders || new Uint8Array(),
          protectedHeaders || new Uint8Array(),
          applicationHeaders || new Uint8Array(),
          payload
        ]);
      }
      async verify(key, bodyProtectedHeaders, payload) {
        if (typeof key === "function") {
          key = await key(this);
        }
        if (!key) {
          throw new Error("key not found");
        }
        const toBeSigned = _Signature.Signature(bodyProtectedHeaders, this.encodedProtectedHeaders, new Uint8Array(), payload);
        if (!this.algName) {
          throw new Error("unknown algorithm: " + this.alg);
        }
        return verify_default2(this.algName, key, this.signature, toBeSigned);
      }
      static async sign(bodyProtectedHeaders, protectedHeader, unprotectedHeader, payload, key) {
        const { alg } = protectedHeader;
        const encodedProtectedHeaders = encodeProtectedHeaders(protectedHeader);
        const unprotectedHeadersMapped = mapUnprotectedHeaders(unprotectedHeader);
        const toBeSigned = _Signature.Signature(bodyProtectedHeaders, encodedProtectedHeaders, new Uint8Array(), payload);
        if (!alg) {
          throw new Error("The alg header must be set.");
        }
        const signature = await sign_default2(alg, key, toBeSigned);
        return new _Signature(encodedProtectedHeaders, unprotectedHeadersMapped, signature);
      }
    };
    addExtension3({
      Class: Sign,
      tag: 98,
      encode(instance, encode4) {
        return encode4(instance.getContentForEncoding());
      },
      decode: (data) => {
        const signatures = data[3].map((signature) => new Signature(signature[0], signature[1], signature[2]));
        return new Sign(data[0], data[1], data[2], signatures);
      }
    });
  }
});

// node_modules/cose/dist/browser/cose/Sign1.js
var Sign1;
var init_Sign1 = __esm({
  "node_modules/cose/dist/browser/cose/Sign1.js"() {
    init_verify6();
    init_headers();
    init_sign6();
    init_buffer_utils2();
    init_SignatureBase();
    init_cbor();
    Sign1 = class _Sign1 extends SignatureBase {
      constructor(protectedHeader, unprotectedHeader, payload, signature) {
        super(protectedHeader, unprotectedHeader, signature);
        this.payload = payload;
      }
      getContentForEncoding() {
        return [
          this.encodedProtectedHeaders,
          this.unprotectedHeaders,
          this.payload,
          this.signature
        ];
      }
      encode() {
        return encoder3.encode(this);
      }
      static Signature1(protectedHeader, applicationHeaders, payload) {
        return encoder3.encode([
          "Signature1",
          protectedHeader,
          applicationHeaders,
          payload
        ]);
      }
      async verify(key, externalAAD = new Uint8Array()) {
        if (typeof key === "function") {
          key = await key(this);
        }
        if (!key) {
          throw new Error("key not found");
        }
        const toBeSigned = _Sign1.Signature1(this.encodedProtectedHeaders || new Uint8Array(), externalAAD, this.payload);
        if (!this.algName) {
          throw new Error("unknown algorithm: " + this.alg);
        }
        return verify_default2(this.algName, key, this.signature, toBeSigned);
      }
      async verifyX509(roots) {
        const { publicKey } = await this.verifyX509Chain(roots);
        return this.verify(publicKey);
      }
      static async sign(protectedHeader, unprotectedHeader, payload, key) {
        const { alg } = protectedHeader;
        const encodedProtectedHeaders = encoder3.encode(new Map(Object.entries(protectedHeader).map(([k, v]) => {
          if (k === "alg") {
            v = algsToValue.get(v);
          } else if (typeof v === "string") {
            v = fromUTF8(v);
          }
          return [headers[k], v];
        })));
        const unprotectedHeadersMap = new Map(Object.entries(unprotectedHeader || {}).map(([k, v]) => {
          if (typeof v === "string") {
            v = fromUTF8(v);
          }
          return [headers[k], v];
        }));
        const toBeSigned = _Sign1.Signature1(encodedProtectedHeaders, new Uint8Array(), payload);
        if (!alg) {
          throw new Error("The alg header must be set.");
        }
        const signature = await sign_default2(alg, key, toBeSigned);
        return new _Sign1(encodedProtectedHeaders, unprotectedHeadersMap, payload, signature);
      }
    };
    addExtension3({
      Class: Sign1,
      tag: 18,
      encode(instance, encodeFn) {
        return encodeFn(instance.getContentForEncoding());
      },
      decode: (data) => {
        return new Sign1(data[0], data[1], data[2], data[3]);
      }
    });
  }
});

// node_modules/cose/dist/browser/cose/Mac0.js
var Mac0;
var init_Mac0 = __esm({
  "node_modules/cose/dist/browser/cose/Mac0.js"() {
    init_verify6();
    init_sign6();
    init_cbor();
    init_WithHeaders();
    init_headers();
    init_buffer_utils2();
    Mac0 = class _Mac0 extends WithHeaders {
      constructor(protectedHeader, unprotectedHeader, payload, tag) {
        super(protectedHeader, unprotectedHeader);
        this.payload = payload;
        this.tag = tag;
      }
      static createMAC0(protectedHeader, applicationHeaders, payload) {
        return encoder3.encode([
          "MAC0",
          protectedHeader,
          applicationHeaders,
          payload
        ]);
      }
      getContentForEncoding() {
        return [
          this.encodedProtectedHeaders,
          this.unprotectedHeaders,
          this.payload,
          this.tag
        ];
      }
      encode() {
        return encoder3.encode(this);
      }
      async verify(key, externalAAD = new Uint8Array()) {
        if (!key) {
          throw new Error("key not found");
        }
        const mac0Structure = _Mac0.createMAC0(this.encodedProtectedHeaders || new Uint8Array(), externalAAD, this.payload);
        if (!this.algName) {
          throw new Error("unknown algorithm: " + this.alg);
        }
        return verify_default2(this.algName, key, this.tag, mac0Structure);
      }
      get alg() {
        return this.protectedHeaders.get(headers.alg) || this.unprotectedHeaders.get(headers.alg);
      }
      get algName() {
        var _a;
        return this.alg ? (_a = macAlgs.get(this.alg)) === null || _a === void 0 ? void 0 : _a.name : void 0;
      }
      hasSupportedAlg() {
        return !!this.algName;
      }
      areEqual(mac0) {
        return areEqual(this.tag, mac0.tag);
      }
      static async create(protectedHeader, unprotectedHeader, payload, key) {
        const { alg } = protectedHeader;
        const encodedProtectedHeaders = encoder3.encode(new Map(Object.entries(protectedHeader).map(([k, v]) => {
          if (k === "alg") {
            v = macAlgsToValue.get(v);
          } else if (typeof v === "string") {
            v = fromUTF8(v);
          }
          return [headers[k], v];
        })));
        const unprotectedHeadersMap = new Map(Object.entries(unprotectedHeader || {}).map(([k, v]) => {
          if (typeof v === "string") {
            v = fromUTF8(v);
          }
          return [headers[k], v];
        }));
        const toBeSigned = _Mac0.createMAC0(encodedProtectedHeaders, new Uint8Array(), payload);
        if (!alg) {
          throw new Error("The alg header must be set.");
        }
        const tag = await sign_default2(alg, key, toBeSigned);
        return new _Mac0(encodedProtectedHeaders, unprotectedHeadersMap, payload, tag);
      }
    };
    addExtension3({
      Class: Mac0,
      tag: 17,
      encode(instance, encodeFn) {
        return encodeFn(instance.getContentForEncoding());
      },
      decode: (data) => {
        return new Mac0(data[0], data[1], data[2], data[3]);
      }
    });
  }
});

// node_modules/cose/dist/browser/verify.js
var coseVerify, coseVerifyMultiSignature, coseVerifyX509, coseVerifyMAC0;
var init_verify7 = __esm({
  "node_modules/cose/dist/browser/verify.js"() {
    init_cbor();
    init_Sign1();
    init_Sign();
    init_Mac0();
    coseVerify = async (cose, key, externalAAD = new Uint8Array()) => {
      let decoded = encoder3.decode(cose);
      if (Array.isArray(decoded) && decoded.length === 4) {
        const params = decoded;
        decoded = new Sign1(...params);
      }
      if (!(decoded instanceof Sign1)) {
        throw new Error("unknown COSE type");
      }
      const isValid = await decoded.verify(key, externalAAD);
      return { isValid, decoded };
    };
    coseVerifyMultiSignature = async (cose, keys) => {
      const decoded = encoder3.decode(cose);
      if (!(decoded instanceof Sign)) {
        throw new Error("unexpected COSE type");
      }
      const isValid = await decoded.verify(keys);
      return { isValid, decoded };
    };
    coseVerifyX509 = async (cose, roots) => {
      const decoded = encoder3.decode(cose);
      if (!(decoded instanceof Sign1 || decoded instanceof Sign)) {
        throw new Error("unknown COSE type");
      }
      const isValid = await decoded.verifyX509(roots);
      return { isValid, decoded };
    };
    coseVerifyMAC0 = async (cose, key, externalAAD = new Uint8Array()) => {
      let decoded = encoder3.decode(cose);
      if (Array.isArray(decoded) && decoded.length === 4) {
        const params = decoded;
        decoded = new Mac0(...params);
      }
      if (!(decoded instanceof Mac0)) {
        throw new Error("unexpected COSE type");
      }
      const isValid = await decoded.verify(key, externalAAD);
      return { isValid, decoded };
    };
  }
});

// node_modules/cose/dist/browser/key/kty.js
var KeyType, ValueToKeyType;
var init_kty = __esm({
  "node_modules/cose/dist/browser/key/kty.js"() {
    (function(KeyType2) {
      KeyType2[KeyType2["OKP"] = 1] = "OKP";
      KeyType2[KeyType2["EC2"] = 2] = "EC2";
      KeyType2[KeyType2["Symmetric"] = 4] = "Symmetric";
      KeyType2[KeyType2["Reserved"] = 0] = "Reserved";
    })(KeyType || (KeyType = {}));
    ValueToKeyType = /* @__PURE__ */ new Map([
      [1, "OKP"],
      [2, "EC"],
      [4, "Symmetric"],
      [0, "Reserved"]
    ]);
  }
});

// node_modules/cose/dist/browser/key/labels.js
var Label, ValueToLabel;
var init_labels = __esm({
  "node_modules/cose/dist/browser/key/labels.js"() {
    (function(Label2) {
      Label2[Label2["kty"] = 1] = "kty";
      Label2[Label2["kid"] = 2] = "kid";
      Label2[Label2["alg"] = 3] = "alg";
      Label2[Label2["key_opts"] = 4] = "key_opts";
      Label2[Label2["base_iv"] = 5] = "base_iv";
      Label2[Label2["crv"] = -1] = "crv";
      Label2[Label2["x"] = -2] = "x";
      Label2[Label2["y"] = -3] = "y";
      Label2[Label2["d"] = -4] = "d";
    })(Label || (Label = {}));
    ValueToLabel = /* @__PURE__ */ new Map([
      [1, "kty"],
      [2, "kid"],
      [3, "alg"],
      [4, "key_opts"],
      [5, "base_iv"],
      [-1, "crv"],
      [-2, "x"],
      [-3, "y"],
      [-4, "d"]
    ]);
  }
});

// node_modules/cose/dist/browser/key/algs.js
var table, valueToKeyTypeMap, Curves, ValuesToCurves;
var init_algs = __esm({
  "node_modules/cose/dist/browser/key/algs.js"() {
    table = [
      { name: "P-256", value: 1, keyType: "EC2", description: "NIST P-256 also known as secp256r1" },
      { name: "P-384", value: 2, keyType: "EC2", description: "NIST P-384 also known as secp384r1" },
      { name: "P-521", value: 3, keyType: "EC2", description: "NIST P-521 also known as secp521r1" },
      { name: "X25519", value: 4, keyType: "OKP", description: "X25519 for use w/ ECDH only" },
      { name: "X448", value: 5, keyType: "OKP", description: "X448 for use w/ ECDH only" },
      { name: "Ed25519", value: 6, keyType: "OKP", description: "Ed25519 for use w/ EdDSA only" },
      { name: "Ed448", value: 7, keyType: "OKP", description: "Ed448 for use w/ EdDSA only" }
    ];
    valueToKeyTypeMap = /* @__PURE__ */ new Map();
    for (const entry of table) {
      valueToKeyTypeMap.set(entry.value, entry);
    }
    (function(Curves2) {
      Curves2[Curves2["P_256"] = 1] = "P_256";
      Curves2[Curves2["P_384"] = 2] = "P_384";
      Curves2[Curves2["P_521"] = 3] = "P_521";
      Curves2[Curves2["X25519"] = 4] = "X25519";
      Curves2[Curves2["X448"] = 5] = "X448";
      Curves2[Curves2["Ed25519"] = 6] = "Ed25519";
      Curves2[Curves2["Ed448"] = 7] = "Ed448";
    })(Curves || (Curves = {}));
    ValuesToCurves = /* @__PURE__ */ new Map([
      [1, "P-256"],
      [2, "P-384"],
      [3, "P-521"],
      [4, "X25519"],
      [5, "X448"],
      [6, "Ed25519"],
      [7, "Ed448"]
    ]);
  }
});

// node_modules/cose/dist/browser/key/index.js
function decodedCOSEKeyToJWK(decoded) {
  const result = {};
  for (const [key, value] of decoded) {
    const jwkKey = ValueToLabel.get(key);
    const parser = parameterParsers.get(key);
    if (parser && jwkKey) {
      result[jwkKey] = parser(value);
    }
  }
  return result;
}
function COSEKeyToJWK(coseKey) {
  let decoded;
  if (coseKey instanceof Uint8Array) {
    decoded = encoder3.decode(coseKey);
  } else {
    decoded = coseKey;
  }
  const result = decodedCOSEKeyToJWK(decoded);
  return result;
}
async function importCOSEKey(coseKey) {
  const jwk = COSEKeyToJWK(coseKey);
  return importJWK(jwk);
}
async function importDecodedCOSEKey(decoded) {
  const jwk = decodedCOSEKeyToJWK(decoded);
  return importJWK(jwk);
}
var parameterParsers;
var init_key = __esm({
  "node_modules/cose/dist/browser/key/index.js"() {
    init_kty();
    init_labels();
    init_cbor();
    init_browser();
    init_algs();
    init_base64();
    parameterParsers = /* @__PURE__ */ new Map([
      [Label.kty, (value) => ValueToKeyType.get(value)],
      [Label.crv, (value) => ValuesToCurves.get(value)],
      [Label.kid, (v) => v],
      [Label.x, encodeBase64URL],
      [Label.y, encodeBase64URL],
      [Label.d, encodeBase64URL]
    ]);
  }
});

// node_modules/cose/dist/browser/index.js
var browser_exports2 = {};
__export(browser_exports2, {
  COSEKeyToJWK: () => COSEKeyToJWK,
  Mac0: () => Mac0,
  Sign: () => Sign,
  Sign1: () => Sign1,
  coseMultiSign: () => coseMultiSign,
  coseSign: () => coseSign,
  coseVerify: () => coseVerify,
  coseVerifyMAC0: () => coseVerifyMAC0,
  coseVerifyMultiSignature: () => coseVerifyMultiSignature,
  coseVerifyX509: () => coseVerifyX509,
  importCOSEKey: () => importCOSEKey,
  importDecodedCOSEKey: () => importDecodedCOSEKey
});
var coseSign, coseMultiSign;
var init_browser2 = __esm({
  "node_modules/cose/dist/browser/index.js"() {
    init_Sign();
    init_Sign1();
    init_verify7();
    init_Sign1();
    init_Sign();
    init_Mac0();
    init_key();
    coseSign = async (...args) => {
      return Sign1.sign(...args).then((s) => s.encode());
    };
    coseMultiSign = async (...args) => {
      return Sign.sign(...args).then((s) => s.encode());
    };
  }
});

// node_modules/uncrypto/dist/crypto.web.mjs
var crypto_web_exports = {};
__export(crypto_web_exports, {
  default: () => _crypto,
  getRandomValues: () => getRandomValues,
  randomUUID: () => randomUUID,
  subtle: () => subtle
});
var webCrypto, subtle, randomUUID, getRandomValues, _crypto;
var init_crypto_web = __esm({
  "node_modules/uncrypto/dist/crypto.web.mjs"() {
    webCrypto = globalThis.crypto;
    subtle = webCrypto.subtle;
    randomUUID = () => {
      return webCrypto.randomUUID();
    };
    getRandomValues = (array) => {
      return webCrypto.getRandomValues(array);
    };
    _crypto = {
      randomUUID,
      getRandomValues,
      subtle
    };
  }
});

// node_modules/mdl/lib/buffer_utils.js
var require_buffer_utils = __commonJS({
  "node_modules/mdl/lib/buffer_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUTF8 = exports.fromUTF8 = exports.areEqual = exports.concat = exports.decoder = exports.encoder = void 0;
    exports.encoder = new TextEncoder();
    exports.decoder = new TextDecoder();
    function concat2(...buffers) {
      const size = buffers.reduce((acc, { length }) => acc + length, 0);
      const buf = new Uint8Array(size);
      let i = 0;
      buffers.forEach((buffer) => {
        buf.set(buffer, i);
        i += buffer.length;
      });
      return buf;
    }
    exports.concat = concat2;
    function areEqual2(buf1, buf2) {
      if (buf1 === buf2) {
        return true;
      }
      if (buf1.byteLength !== buf2.byteLength) {
        return false;
      }
      for (let i = 0; i < buf1.byteLength; i++) {
        if (buf1[i] !== buf2[i]) {
          return false;
        }
      }
      return true;
    }
    exports.areEqual = areEqual2;
    var fromUTF82 = (input) => exports.encoder.encode(input);
    exports.fromUTF8 = fromUTF82;
    var toUTF8 = (input) => exports.decoder.decode(input);
    exports.toUTF8 = toUTF8;
  }
});

// node_modules/mdl/lib/cose/coseKey.js
var require_coseKey = __commonJS({
  "node_modules/mdl/lib/cose/coseKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_utils_1 = require_buffer_utils();
    var coseKeyMapToBuffer = (deviceKeyCoseKey) => {
      const kty = deviceKeyCoseKey.get(1);
      if (kty !== 2) {
        throw new Error(`Expected COSE Key type: EC2 (2), got: ${kty}`);
      }
      const crv = deviceKeyCoseKey.get(-1);
      if (crv !== 1) {
        throw new Error(`Expected COSE Key EC2 Curve: P-256 (1), got: ${crv}`);
      }
      const newLocal = Uint8Array.from([4]);
      return (0, buffer_utils_1.concat)(newLocal, deviceKeyCoseKey.get(-2), deviceKeyCoseKey.get(-3));
    };
    exports.default = coseKeyMapToBuffer;
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash2(hash3) {
      if (typeof hash3 !== "function" || typeof hash3.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash3.outputLen);
      number(hash3.blockLen);
    }
    exports.hash = hash2;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash: hash2, exists, output };
    exports.default = assert;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils2 = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto();
    var u8a = (a) => a instanceof Uint8Array;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils2();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash2);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash2.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash2, key, message3) => new HMAC(hash2, key).update(message3).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash2, key) => new HMAC(hash2, key);
  }
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils3 = __commonJS({
  "node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var u8a = (a) => a instanceof Uint8Array;
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    exports.numberToHexUnpadded = numberToHexUnpadded;
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    exports.hexToNumber = hexToNumber;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    exports.bytesToNumberBE = bytesToNumberBE;
    function bytesToNumberLE(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    exports.bytesToNumberLE = bytesToNumberLE;
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    exports.numberToBytesBE = numberToBytesBE;
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    exports.numberToBytesLE = numberToBytesLE;
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    exports.numberToVarBytesBE = numberToVarBytesBE;
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (u8a(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    exports.ensureBytes = ensureBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    function equalBytes(b1, b2) {
      if (b1.length !== b2.length)
        return false;
      for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
          return false;
      return true;
    }
    exports.equalBytes = equalBytes;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    exports.bitLen = bitLen;
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    exports.bitGet = bitGet;
    var bitSet = (n, pos, value) => {
      return n | (value ? _1n : _0n) << BigInt(pos);
    };
    exports.bitSet = bitSet;
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    exports.createHmacDrbg = createHmacDrbg;
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    exports.validateObject = validateObject;
  }
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
    var utils_js_1 = require_utils3();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    exports.mod = mod;
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    exports.pow = pow;
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    exports.pow2 = pow2;
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    exports.invert = invert;
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
          g = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g);
          r = m;
        }
        return x;
      };
    }
    exports.tonelliShanks = tonelliShanks;
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    exports.FpSqrt = FpSqrt;
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    exports.validateField = validateField;
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    exports.FpPow = FpPow;
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    exports.FpInvertBatch = FpInvertBatch;
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    exports.FpDiv = FpDiv;
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    exports.FpIsSquare = FpIsSquare;
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    exports.nLength = nLength;
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    exports.Field = Field;
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    exports.FpSqrtOdd = FpSqrtOdd;
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    exports.FpSqrtEven = FpSqrtEven;
    function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
      hash2 = (0, utils_js_1.ensureBytes)("privateHash", hash2);
      const hashLen = hash2.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash2) : (0, utils_js_1.bytesToNumberBE)(hash2);
      return mod(num, groupOrder - _1n) + _1n;
    }
    exports.hashToPrivateScalar = hashToPrivateScalar;
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength3 = fieldOrder.toString(2).length;
      return Math.ceil(bitLength3 / 8);
    }
    exports.getFieldBytesLength = getFieldBytesLength;
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    exports.getMinHashLength = getMinHashLength;
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
    exports.mapHashToField = mapHashToField;
  }
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateBasic = exports.wNAF = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils3();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    exports.wNAF = wNAF;
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    exports.validateBasic = validateBasic;
  }
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
    var mod = require_modular();
    var ut = require_utils3();
    var utils_js_1 = require_utils3();
    var curve_js_1 = require_curve();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
          throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (key instanceof Uint8Array)
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, n);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
          const I = Point.ZERO;
          if (n === _0n)
            return I;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    exports.weierstrassPoints = weierstrassPoints;
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER;
      }
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y = Fp.sqrt(y2);
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature2 {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature2(r, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature2(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash: hash2, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash2(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature2(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign3(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify3(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || sg instanceof Uint8Array) {
            try {
              _sig = Signature2.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature2.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s2 } = sg;
            _sig = new Signature2(r2, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r * is);
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign: sign3,
        verify: verify3,
        ProjectivePoint: Point,
        Signature: Signature2,
        utils
      };
    }
    exports.weierstrass = weierstrass;
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  }
});

// node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCurve = exports.getHash = void 0;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils2();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash2) {
      return {
        hash: hash2,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash2, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    exports.getHash = getHash;
    function createCurve(curveDef, defHash) {
      const create = (hash2) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash2) });
      return Object.freeze({ ...create(defHash), create });
    }
    exports.createCurve = createCurve;
  }
});

// node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils2();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView2 = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView2, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils2();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = /* @__PURE__ */ new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = /* @__PURE__ */ new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils3();
    function validateDST(dst) {
      if (dst instanceof Uint8Array)
        return dst;
      if (typeof dst === "string")
        return (0, utils_js_1.utf8ToBytes)(dst);
      throw new Error("DST must be Uint8Array or string");
    }
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function isBytes(item) {
      if (!(item instanceof Uint8Array))
        throw new Error("Uint8Array expected");
    }
    function isNum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    exports.expand_message_xmd = expand_message_xmd;
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    exports.expand_message_xof = expand_message_xof;
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash: hash2, expand, DST: _DST } = options;
      isBytes(msg);
      isNum(count);
      const DST = validateDST(_DST);
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    exports.hash_to_field = hash_to_field;
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    exports.isogenyMap = isogenyMap;
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
    exports.createHasher = createHasher;
  }
});

// node_modules/@noble/curves/p256.js
var require_p256 = __commonJS({
  "node_modules/@noble/curves/p256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.secp256r1 = exports.p256 = void 0;
    var _shortw_utils_js_1 = require_shortw_utils();
    var sha256_1 = require_sha256();
    var modular_js_1 = require_modular();
    var weierstrass_js_1 = require_weierstrass();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var Fp = (0, modular_js_1.Field)(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
    var CURVE_A = Fp.create(BigInt("-3"));
    var CURVE_B = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
    exports.p256 = (0, _shortw_utils_js_1.createCurve)({
      a: CURVE_A,
      b: CURVE_B,
      Fp,
      // Curve order, total count of valid points in the field
      n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
      // Base (generator) point (x, y)
      Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
      Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
      h: BigInt(1),
      lowS: false
    }, sha256_1.sha256);
    exports.secp256r1 = exports.p256;
    var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: CURVE_A,
      B: CURVE_B,
      Z: Fp.create(BigInt("-10"))
    }))();
    var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256r1.ProjectivePoint, (scalars) => mapSWU(scalars[0]), {
      DST: "P256_XMD:SHA-256_SSWU_RO_",
      encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports.hashToCurve = (() => htf.hashToCurve)();
    exports.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/mdl/lib/cbor/DataItem.js
var require_DataItem = __commonJS({
  "node_modules/mdl/lib/cbor/DataItem.js"(exports) {
    "use strict";
    var __classPrivateFieldSet4 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet4 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _DataItem_data;
    var _DataItem_buffer;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataItem = void 0;
    var cbor_x_1 = (init_cbor_x(), __toCommonJS(cbor_x_exports));
    var _1 = require_cbor();
    var DataItem3 = class _DataItem {
      constructor(params) {
        _DataItem_data.set(this, void 0);
        _DataItem_buffer.set(this, void 0);
        if (!("data" in params) && !("buffer" in params)) {
          throw new Error("DataItem must be initialized with either data or buffer");
        }
        if ("data" in params) {
          __classPrivateFieldSet4(this, _DataItem_data, params.data, "f");
          if (!("buffer" in params)) {
            __classPrivateFieldSet4(this, _DataItem_buffer, (0, _1.cborEncode)(__classPrivateFieldGet4(this, _DataItem_data, "f")), "f");
          }
        }
        if ("buffer" in params) {
          __classPrivateFieldSet4(this, _DataItem_buffer, params.buffer, "f");
        }
      }
      get data() {
        if (!__classPrivateFieldGet4(this, _DataItem_data, "f")) {
          __classPrivateFieldSet4(this, _DataItem_data, (0, _1.cborDecode)(__classPrivateFieldGet4(this, _DataItem_buffer, "f")), "f");
        }
        return __classPrivateFieldGet4(this, _DataItem_data, "f");
      }
      get buffer() {
        if (!__classPrivateFieldGet4(this, _DataItem_buffer, "f")) {
          __classPrivateFieldSet4(this, _DataItem_buffer, (0, _1.cborEncode)(__classPrivateFieldGet4(this, _DataItem_data, "f"), { useFloat32: 0 }), "f");
        }
        return __classPrivateFieldGet4(this, _DataItem_buffer, "f");
      }
      static fromData(data) {
        return new _DataItem({ data });
      }
    };
    exports.DataItem = DataItem3;
    _DataItem_data = /* @__PURE__ */ new WeakMap(), _DataItem_buffer = /* @__PURE__ */ new WeakMap();
    (0, cbor_x_1.addExtension)({
      Class: DataItem3,
      tag: 24,
      encode: (instance, encode4) => {
        return encode4(instance.buffer);
      },
      decode: (buffer) => {
        return new DataItem3({ buffer });
      }
    });
  }
});

// node_modules/mdl/lib/cbor/index.js
var require_cbor = __commonJS({
  "node_modules/mdl/lib/cbor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataItem = exports.cborEncode = exports.cborDecode = void 0;
    var cbor_x_1 = (init_cbor_x(), __toCommonJS(cbor_x_exports));
    var encoderDefaults2 = {
      tagUint8Array: false,
      useRecords: false,
      mapsAsObjects: false,
      // @ts-ignore
      useTag259ForMaps: false
    };
    (0, cbor_x_1.addExtension)({
      Class: Date,
      tag: 1004,
      encode: (instance, encode4) => {
        const str = instance.toISOString().split("T")[0];
        return encode4(str);
      },
      decode: (val) => {
        return new Date(val);
      }
    });
    var cborDecode3 = (input, options = encoderDefaults2) => {
      const params = { ...encoderDefaults2, ...options };
      const enc = new cbor_x_1.Encoder(params);
      return enc.decode(input);
    };
    exports.cborDecode = cborDecode3;
    var cborEncode2 = (obj, options = encoderDefaults2) => {
      const params = { ...encoderDefaults2, ...options };
      const enc = new cbor_x_1.Encoder(params);
      return enc.encode(obj);
    };
    exports.cborEncode = cborEncode2;
    var DataItem_1 = require_DataItem();
    Object.defineProperty(exports, "DataItem", { enumerable: true, get: function() {
      return DataItem_1.DataItem;
    } });
  }
});

// node_modules/mdl/lib/deviceResponse/utils.js
var require_utils4 = __commonJS({
  "node_modules/mdl/lib/deviceResponse/utils.js"(exports) {
    "use strict";
    var __createBinding3 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar3 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding3(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calculateDeviceAutenticationBytes = exports.calculateEphemeralMacKey = exports.hmacSHA256 = void 0;
    var pkijs2 = __importStar3(require_build3());
    var p256_1 = require_p256();
    var webcrypto = __importStar3((init_crypto_web(), __toCommonJS(crypto_web_exports)));
    var buffer_1 = require_buffer();
    var cbor_1 = require_cbor();
    var DataItem_1 = require_DataItem();
    var { subtle: subtle2 } = webcrypto;
    pkijs2.setEngine("webcrypto", new pkijs2.CryptoEngine({ name: "webcrypto", crypto: webcrypto, subtle: subtle2 }));
    var hmacSHA256 = async (key, data) => {
      const saltHMACKey = await subtle2.importKey("raw", key, { name: "HMAC", hash: "SHA-256" }, false, ["sign", "verify"]);
      const hmac = await subtle2.sign("HMAC", saltHMACKey, data);
      return hmac;
    };
    exports.hmacSHA256 = hmacSHA256;
    var calculateEphemeralMacKey = async (deviceKey, ephemeralPrivateKey, sessionTranscriptBytes) => {
      const sharedSecret = p256_1.p256.getSharedSecret(buffer_1.Buffer.from(ephemeralPrivateKey).toString("hex"), buffer_1.Buffer.from(deviceKey).toString("hex"), true).slice(1);
      const info = buffer_1.Buffer.from("454d61634b6579", "hex");
      const salt = await subtle2.digest("SHA-256", sessionTranscriptBytes);
      const prk = await (0, exports.hmacSHA256)(salt, sharedSecret);
      const result = buffer_1.Buffer.alloc(32);
      let ctr = 1;
      let pos = 0;
      let digest2 = buffer_1.Buffer.alloc(0);
      while (true) {
        const data = buffer_1.Buffer.concat([
          digest2,
          info,
          buffer_1.Buffer.from(String.fromCharCode(ctr))
        ]);
        digest2 = buffer_1.Buffer.from(await (0, exports.hmacSHA256)(prk, data));
        const digestLength = digest2.byteLength;
        if (pos + digestLength < 32) {
          result.set(digest2, pos);
          pos += digestLength;
          ctr += 1;
        } else {
          result.set(digest2.subarray(0, 32 - pos), pos);
          break;
        }
      }
      return result;
    };
    exports.calculateEphemeralMacKey = calculateEphemeralMacKey;
    var calculateDeviceAutenticationBytes = (sessionTranscriptBytes, docType, nameSpaces) => {
      const { data: decodedSessionTranscript } = (0, cbor_1.cborDecode)(sessionTranscriptBytes);
      const encode4 = DataItem_1.DataItem.fromData([
        "DeviceAuthentication",
        decodedSessionTranscript,
        docType,
        DataItem_1.DataItem.fromData(nameSpaces)
      ]);
      const result = (0, cbor_1.cborEncode)(encode4);
      return result;
    };
    exports.calculateDeviceAutenticationBytes = calculateDeviceAutenticationBytes;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/mdl/lib/deviceResponse/errors.js
var require_errors2 = __commonJS({
  "node_modules/mdl/lib/deviceResponse/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MDLParseError = exports.MDLError = void 0;
    var MDLError = class extends Error {
      constructor(message3) {
        super(message3);
        this.name = new.target.name;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports.MDLError = MDLError;
    var MDLParseError = class extends Error {
      constructor(message3) {
        super(message3);
        this.name = new.target.name;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports.MDLParseError = MDLParseError;
  }
});

// node_modules/mdl/lib/deviceResponse/checkCallback.js
var require_checkCallback = __commonJS({
  "node_modules/mdl/lib/deviceResponse/checkCallback.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onCatCheck = exports.buildCallback = exports.defaultCallback = void 0;
    var debug_1 = __importDefault3(require_browser());
    var errors_1 = require_errors2();
    var log = (0, debug_1.default)("mdl");
    exports.defaultCallback = (verification) => {
      log(`Verification: ${verification.check} => ${verification.status}`);
      if (verification.status !== "FAILED")
        return;
      throw new errors_1.MDLError(verification.reason ?? verification.check);
    };
    var buildCallback = (callback) => {
      if (typeof callback === "undefined") {
        return exports.defaultCallback;
      }
      return (item) => {
        callback(item, exports.defaultCallback);
      };
    };
    exports.buildCallback = buildCallback;
    var onCatCheck = (onCheck, category) => {
      return (item) => {
        onCheck({ ...item, category }, exports.defaultCallback);
      };
    };
    exports.onCatCheck = onCatCheck;
  }
});

// node_modules/mdl/lib/deviceResponse/IssuerAuth.js
var require_IssuerAuth = __commonJS({
  "node_modules/mdl/lib/deviceResponse/IssuerAuth.js"(exports) {
    "use strict";
    var __classPrivateFieldGet4 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet4 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _IssuerAuth_decodedPayload;
    var _IssuerAuth_certificate;
    Object.defineProperty(exports, "__esModule", { value: true });
    var cose_1 = (init_browser2(), __toCommonJS(browser_exports2));
    var x509_1 = require_x509_cjs();
    var cbor_1 = require_cbor();
    var DataItem_1 = require_DataItem();
    var IssuerAuth = class extends cose_1.Sign1 {
      constructor(protectedHeader, unprotectedHeader, payload, signature) {
        super(protectedHeader, unprotectedHeader, payload, signature);
        _IssuerAuth_decodedPayload.set(this, void 0);
        _IssuerAuth_certificate.set(this, void 0);
      }
      get decodedPayload() {
        if (__classPrivateFieldGet4(this, _IssuerAuth_decodedPayload, "f")) {
          return __classPrivateFieldGet4(this, _IssuerAuth_decodedPayload, "f");
        }
        let decoded = (0, cbor_1.cborDecode)(this.payload);
        decoded = decoded instanceof DataItem_1.DataItem ? decoded.data : decoded;
        decoded = Object.fromEntries(decoded);
        const mapValidityInfo = (validityInfo) => {
          if (!validityInfo) {
            return validityInfo;
          }
          return Object.fromEntries([...validityInfo.entries()].map(([key, value]) => {
            return [key, value instanceof Uint8Array ? (0, cbor_1.cborDecode)(value) : value];
          }));
        };
        const result = {
          ...decoded,
          validityInfo: mapValidityInfo(decoded.validityInfo),
          validityDigests: decoded.validityDigests ? Object.fromEntries(decoded.validityDigests) : decoded.validityDigests,
          deviceKeyInfo: decoded.deviceKeyInfo ? Object.fromEntries(decoded.deviceKeyInfo) : decoded.deviceKeyInfo
        };
        __classPrivateFieldSet4(this, _IssuerAuth_decodedPayload, result, "f");
        return result;
      }
      get certificate() {
        if (typeof __classPrivateFieldGet4(this, _IssuerAuth_certificate, "f") === "undefined" && this.x5chain?.length) {
          __classPrivateFieldSet4(this, _IssuerAuth_certificate, new x509_1.X509Certificate(this.x5chain[0]), "f");
        }
        return __classPrivateFieldGet4(this, _IssuerAuth_certificate, "f");
      }
      get countryName() {
        return this.certificate?.issuerName.getField("C")[0];
      }
      get stateOrProvince() {
        return this.certificate?.issuerName.getField("ST")[0];
      }
    };
    _IssuerAuth_decodedPayload = /* @__PURE__ */ new WeakMap(), _IssuerAuth_certificate = /* @__PURE__ */ new WeakMap();
    exports.default = IssuerAuth;
  }
});

// node_modules/mdl/lib/deviceResponse/IssuerSignedItem.js
var require_IssuerSignedItem = __commonJS({
  "node_modules/mdl/lib/deviceResponse/IssuerSignedItem.js"(exports) {
    "use strict";
    var __classPrivateFieldSet4 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet4 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _IssuerSignedItem_issuerAuth;
    var _IssuerSignedItem_nameSpace;
    var _IssuerSignedItem_isValid;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IssuerSignedItem = void 0;
    var uncrypto_1 = (init_crypto_web(), __toCommonJS(crypto_web_exports));
    var cbor_1 = require_cbor();
    var buffer_utils_1 = require_buffer_utils();
    var MDL_NAMESPACE = "org.iso.18013.5.1";
    var supportedDigestAlgorithms = ["SHA-256", "SHA-384", "SHA-512"];
    var IssuerSignedItem = class {
      constructor(issuerAuth, nameSpace, dataItem) {
        _IssuerSignedItem_issuerAuth.set(this, void 0);
        _IssuerSignedItem_nameSpace.set(this, void 0);
        _IssuerSignedItem_isValid.set(this, void 0);
        __classPrivateFieldSet4(this, _IssuerSignedItem_issuerAuth, issuerAuth, "f");
        __classPrivateFieldSet4(this, _IssuerSignedItem_nameSpace, nameSpace, "f");
        this.dataItem = dataItem;
      }
      get decodedData() {
        if (!this.dataItem.data.has("digestID")) {
          throw new Error("Invalid data item");
        }
        return this.dataItem.data;
      }
      get digestID() {
        return this.decodedData.get("digestID");
      }
      get random() {
        return this.decodedData.get("random");
      }
      get elementIdentifier() {
        return this.decodedData.get("elementIdentifier");
      }
      get elementValue() {
        return this.decodedData.get("elementValue");
      }
      async calculateDigest(alg) {
        const bytes = (0, cbor_1.cborEncode)(this.dataItem);
        const result = await uncrypto_1.subtle.digest(alg, bytes);
        return result;
      }
      async isValid() {
        if (typeof __classPrivateFieldGet4(this, _IssuerSignedItem_isValid, "f") !== "undefined") {
          return __classPrivateFieldGet4(this, _IssuerSignedItem_isValid, "f");
        }
        const { valueDigests, digestAlgorithm } = __classPrivateFieldGet4(this, _IssuerSignedItem_issuerAuth, "f").decodedPayload;
        if (!supportedDigestAlgorithms.includes(digestAlgorithm)) {
          __classPrivateFieldSet4(this, _IssuerSignedItem_isValid, false, "f");
          return false;
        }
        const digest2 = await this.calculateDigest(digestAlgorithm);
        const digests = valueDigests.get(__classPrivateFieldGet4(this, _IssuerSignedItem_nameSpace, "f"));
        if (typeof digests === "undefined") {
          return false;
        }
        const expectedDigest = digests.get(this.digestID);
        __classPrivateFieldSet4(this, _IssuerSignedItem_isValid, expectedDigest && (0, buffer_utils_1.areEqual)(new Uint8Array(digest2), expectedDigest), "f");
        return __classPrivateFieldGet4(this, _IssuerSignedItem_isValid, "f");
      }
      matchCertificate() {
        if (__classPrivateFieldGet4(this, _IssuerSignedItem_nameSpace, "f") !== MDL_NAMESPACE) {
          return void 0;
        }
        if (this.elementIdentifier === "issuing_country") {
          return __classPrivateFieldGet4(this, _IssuerSignedItem_issuerAuth, "f").countryName === this.elementValue;
        }
        if (this.elementIdentifier === "issuing_jurisdiction") {
          return __classPrivateFieldGet4(this, _IssuerSignedItem_issuerAuth, "f").stateOrProvince === this.elementValue;
        }
        return void 0;
      }
    };
    exports.IssuerSignedItem = IssuerSignedItem;
    _IssuerSignedItem_issuerAuth = /* @__PURE__ */ new WeakMap(), _IssuerSignedItem_nameSpace = /* @__PURE__ */ new WeakMap(), _IssuerSignedItem_isValid = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/mdl/lib/deviceResponse/parser.js
var require_parser2 = __commonJS({
  "node_modules/mdl/lib/deviceResponse/parser.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    var compare_versions_1 = require_umd();
    var cose_1 = (init_browser2(), __toCommonJS(browser_exports2));
    var cbor_1 = require_cbor();
    var IssuerAuth_1 = __importDefault3(require_IssuerAuth());
    var IssuerSignedItem_1 = require_IssuerSignedItem();
    var errors_1 = require_errors2();
    var parseIssuerAuthElement = (rawIssuerAuth, expectedDocType) => {
      const issuerAuth = new IssuerAuth_1.default(...rawIssuerAuth);
      const { decodedPayload } = issuerAuth;
      const { docType, version } = decodedPayload;
      if (docType !== expectedDocType) {
        throw new errors_1.MDLParseError(`The issuerAuth docType must be ${expectedDocType}`);
      }
      if (!version || (0, compare_versions_1.compareVersions)(version, "1.0") !== 0) {
        throw new errors_1.MDLParseError("The issuerAuth version must be '1.0'");
      }
      return issuerAuth;
    };
    var parseDeviceAuthElement = (rawDeviceAuth) => {
      const { deviceSignature, deviceMac } = Object.fromEntries(rawDeviceAuth);
      if (deviceSignature) {
        return { deviceSignature: new cose_1.Sign1(...deviceSignature) };
      }
      return { deviceMac: new cose_1.Mac0(...deviceMac) };
    };
    var namespaceToArray = (issuerAuth, nameSpace, entries) => {
      return entries.map((di) => new IssuerSignedItem_1.IssuerSignedItem(issuerAuth, nameSpace, di));
    };
    var unwrapNamespace = (issuerAuth, namespace) => {
      return Array.from(namespace.entries()).reduce((prev, [nameSpace, entries]) => {
        const mappedNamespace = namespaceToArray(issuerAuth, nameSpace, entries);
        return {
          ...prev,
          [nameSpace]: mappedNamespace
        };
      }, {});
    };
    var parse2 = async (encodedDeviceResponse) => {
      let deviceResponse;
      try {
        deviceResponse = (0, cbor_1.cborDecode)(encodedDeviceResponse);
      } catch (err) {
        throw new errors_1.MDLParseError(`Unable to decode device response: ${err.message}`);
      }
      const { version, documents, status } = Object.fromEntries(deviceResponse);
      const parsedDocuments = documents.map((doc) => {
        const issuerAuth = parseIssuerAuthElement(doc.get("issuerSigned").get("issuerAuth"), doc.get("docType"));
        return {
          raw: doc,
          docType: doc.get("docType"),
          issuerSigned: doc.has("issuerSigned") ? {
            ...doc.get("issuerSigned"),
            nameSpaces: unwrapNamespace(issuerAuth, doc.get("issuerSigned").get("nameSpaces")),
            issuerAuth
          } : void 0,
          // @ts-ignore
          deviceSigned: doc.has("deviceSigned") ? {
            ...doc.get("deviceSigned"),
            nameSpaces: doc.get("deviceSigned").get("nameSpaces").data,
            deviceAuth: parseDeviceAuthElement(doc.get("deviceSigned").get("deviceAuth"))
          } : void 0
        };
      });
      return {
        documents: parsedDocuments,
        version,
        status,
        raw: deviceResponse
      };
    };
    exports.parse = parse2;
  }
});

// node_modules/mdl/lib/deviceResponse/verify.js
var require_verify = __commonJS({
  "node_modules/mdl/lib/deviceResponse/verify.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceResponseVerifier = void 0;
    var compare_versions_1 = require_umd();
    var x509_1 = require_x509_cjs();
    var jose_1 = (init_browser(), __toCommonJS(browser_exports));
    var buffer_1 = require_buffer();
    var cose_1 = (init_browser2(), __toCommonJS(browser_exports2));
    var uncrypto_1 = __importDefault3((init_crypto_web(), __toCommonJS(crypto_web_exports)));
    var coseKey_1 = __importDefault3(require_coseKey());
    var utils_1 = require_utils4();
    var checkCallback_1 = require_checkCallback();
    var parser_1 = require_parser2();
    var MDL_NAMESPACE = "org.iso.18013.5.1";
    var DIGEST_ALGS = {
      "SHA-256": "sha256",
      "SHA-384": "sha384",
      "SHA-512": "sha512"
    };
    var DeviceResponseVerifier = class {
      /**
       *
       * @param issuersRootCertificates The IACA root certificates list of the supported issuers.
       */
      constructor(issuersRootCertificates) {
        this.issuersRootCertificates = issuersRootCertificates;
      }
      async verifyIssuerSignature(issuerAuth, disableCertificateChainValidation, onCheckG) {
        const onCheck = (0, checkCallback_1.onCatCheck)(onCheckG, "ISSUER_AUTH");
        const { certificate, countryName } = issuerAuth;
        const verificationKey = certificate ? await (0, jose_1.importX509)(certificate.toString(), issuerAuth.algName) : void 0;
        if (!disableCertificateChainValidation) {
          try {
            await issuerAuth.verifyX509Chain(this.issuersRootCertificates);
            onCheck({
              status: "PASSED",
              check: "Issuer certificate must be valid"
            });
          } catch (err) {
            onCheck({
              status: "FAILED",
              check: "Issuer certificate must be valid",
              reason: err.message
            });
          }
        }
        const verificationResult = verificationKey && await issuerAuth.verify(verificationKey);
        onCheck({
          status: verificationResult ? "PASSED" : "FAILED",
          check: "Issuer signature must be valid"
        });
        const { validityInfo } = issuerAuth.decodedPayload;
        const now = /* @__PURE__ */ new Date();
        onCheck({
          status: certificate && validityInfo && (validityInfo.signed < certificate.notBefore || validityInfo.signed > certificate.notAfter) ? "FAILED" : "PASSED",
          check: "The MSO signed date must be within the validity period of the certificate",
          reason: `The MSO signed date (${validityInfo.signed.toUTCString()}) must be within the validity period of the certificate (${certificate.notBefore.toUTCString()} to ${certificate.notAfter.toUTCString()})`
        });
        onCheck({
          status: validityInfo && (now < validityInfo.validFrom || now > validityInfo.validUntil) ? "FAILED" : "PASSED",
          check: "The MSO must be valid at the time of verification",
          reason: `The MSO must be valid at the time of verification (${now.toUTCString()})`
        });
        onCheck({
          status: countryName ? "PASSED" : "FAILED",
          check: "Country name (C) must be present in the issuer certificate's subject distinguished name"
        });
      }
      async verifyDeviceSignature(deviceAuth, options) {
        const onCheck = (0, checkCallback_1.onCatCheck)(options.onCheck, "DEVICE_AUTH");
        if (!deviceAuth.deviceMac && !deviceAuth.deviceSignature) {
          onCheck({
            status: "FAILED",
            check: "Device Auth must contain a deviceSignature or deviceMac element"
          });
          return;
        }
        if (!options.sessionTranscriptBytes) {
          onCheck({
            status: "FAILED",
            check: "Session Transcript Bytes missing from options, aborting device signature check"
          });
          return;
        }
        const deviceAuthenticationBytes = (0, utils_1.calculateDeviceAutenticationBytes)(options.sessionTranscriptBytes, options.docType, options.nameSpaces);
        if (!options.deviceKeyCoseKey) {
          onCheck({
            status: "FAILED",
            check: "Issuer signature must contain the device key.",
            reason: "Unable to verify deviceAuth signature: missing device key in issuerAuth"
          });
          return;
        }
        if (deviceAuth.deviceSignature) {
          try {
            const deviceKey = await (0, cose_1.importDecodedCOSEKey)(options.deviceKeyCoseKey);
            const ds = deviceAuth.deviceSignature;
            const verificationResult = await new cose_1.Sign1(ds.protectedHeaders, ds.unprotectedHeaders, deviceAuthenticationBytes, ds.signature).verify(deviceKey);
            onCheck({
              status: verificationResult ? "PASSED" : "FAILED",
              check: "Device signature must be valid"
            });
          } catch (err) {
            onCheck({
              status: "FAILED",
              check: "Device signature must be valid",
              reason: `Unable to verify deviceAuth signature (ECDSA/EdDSA): ${err.message}`
            });
          }
          return;
        }
        onCheck({
          status: deviceAuth.deviceMac ? "PASSED" : "FAILED",
          check: "Device MAC must be present when using MAC authentication"
        });
        if (!deviceAuth.deviceMac) {
          return;
        }
        onCheck({
          status: deviceAuth.deviceMac.hasSupportedAlg() ? "PASSED" : "FAILED",
          check: "Device MAC must use alg 5 (HMAC 256/256)"
        });
        if (!deviceAuth.deviceMac.hasSupportedAlg()) {
          return;
        }
        onCheck({
          status: options.ephemeralPrivateKey ? "PASSED" : "FAILED",
          check: "Ephemeral private key must be present when using MAC authentication"
        });
        if (!options.ephemeralPrivateKey) {
          return;
        }
        try {
          const deviceKey = (0, coseKey_1.default)(options.deviceKeyCoseKey);
          const ephemeralMacKey = await (0, utils_1.calculateEphemeralMacKey)(deviceKey, options.ephemeralPrivateKey, options.sessionTranscriptBytes);
          const isValid = await cose_1.Mac0.create({ alg: "HS256" }, {}, deviceAuthenticationBytes, ephemeralMacKey).then((mac) => deviceAuth.deviceMac && mac.areEqual(deviceAuth.deviceMac));
          onCheck({
            status: isValid ? "PASSED" : "FAILED",
            check: "Device MAC must be valid"
          });
        } catch (err) {
          onCheck({
            status: "FAILED",
            check: "Device MAC must be valid",
            reason: `Unable to verify deviceAuth MAC: ${err.message}`
          });
        }
      }
      async verifyData(mdoc, onCheckG) {
        const { issuerAuth } = mdoc.issuerSigned;
        const { valueDigests, digestAlgorithm } = issuerAuth.decodedPayload;
        const onCheck = (0, checkCallback_1.onCatCheck)(onCheckG, "DATA_INTEGRITY");
        onCheck({
          status: digestAlgorithm && DIGEST_ALGS[digestAlgorithm] ? "PASSED" : "FAILED",
          check: "Issuer Auth must include a supported digestAlgorithm element"
        });
        const nameSpaces = mdoc.issuerSigned.nameSpaces || {};
        const issuerNameSpaces = {};
        await Promise.all(Object.keys(nameSpaces).map(async (ns) => {
          onCheck({
            status: valueDigests.has(ns) ? "PASSED" : "FAILED",
            check: `Issuer Auth must include digests for namespace: ${ns}`
          });
          const verifications = await Promise.all(nameSpaces[ns].map(async (ev) => {
            const isValid = await ev.isValid();
            return { ev, ns, isValid };
          }));
          verifications.filter((v) => v.isValid).forEach((v) => {
            onCheck({
              status: "PASSED",
              check: `Issuer Auth must include a valid digest for ${ns}/${v.ev.elementIdentifier} element`
            });
          });
          verifications.filter((v) => !v.isValid).forEach((v) => {
            onCheck({
              status: "FAILED",
              check: `Issuer Auth must include a valid digest for ${ns}/${v.ev.elementIdentifier} element`
            });
          });
          if (ns === MDL_NAMESPACE) {
            const issuer = issuerAuth.certificate.issuerName;
            if (!issuer) {
              onCheck({
                status: "FAILED",
                check: "The 'issuing_country' if present must match the 'countryName' in the subject field within the DS certificate",
                reason: "The 'issuing_country' and 'issuing_jurisdiction' cannot be verified because the DS certificate was not provided"
              });
            } else {
              const isCountryInvalid = verifications.filter((v) => v.ns === ns && v.ev.elementIdentifier === "issuing_country").some((v) => !v.isValid || !v.ev.matchCertificate());
              onCheck({
                status: isCountryInvalid ? "FAILED" : "PASSED",
                check: "The 'issuing_country' if present must match the 'countryName' in the subject field within the DS certificate",
                reason: isCountryInvalid ? `The 'issuing_country' (${issuerNameSpaces[ns].issuing_country}) must match the 'countryName' (${issuerAuth.countryName}) in the subject field within the issuer certificate` : void 0
              });
              const isJurisdictionInvalid = verifications.filter((v) => v.ns === ns && v.ev.elementIdentifier === "issuing_jurisdiction").some((v) => !v.isValid || !v.ev.matchCertificate());
              onCheck({
                status: isJurisdictionInvalid ? "FAILED" : "PASSED",
                check: "The 'issuing_jurisdiction' if present must match the 'stateOrProvinceName' in the subject field within the DS certificate",
                reason: isJurisdictionInvalid ? `The 'issuing_jurisdiction' (${issuerNameSpaces[ns].issuing_jurisdiction}) must match the 'stateOrProvinceName' (${issuerAuth.stateOrProvince}) in the subject field within the issuer certificate` : void 0
              });
            }
          }
        }));
      }
      /**
       * Parse and validate a DeviceResponse as specified in ISO/IEC 18013-5 (Device Retrieval section).
       *
       * @param encodedDeviceResponse
       * @param options.encodedSessionTranscript The CBOR encoded SessionTranscript.
       * @param options.ephemeralReaderKey The private part of the ephemeral key used in the session where the DeviceResponse was obtained. This is only required if the DeviceResponse is using the MAC method for device authentication.
       */
      async verify(encodedDeviceResponse, options = {}) {
        const onCheck = (0, checkCallback_1.buildCallback)(options.onCheck);
        const dr = await (0, parser_1.parse)(encodedDeviceResponse);
        onCheck({
          status: dr.version ? "PASSED" : "FAILED",
          check: 'Device Response must include "version" element.',
          category: "DOCUMENT_FORMAT"
        });
        onCheck({
          status: (0, compare_versions_1.compareVersions)(dr.version, "1.0") >= 0 ? "PASSED" : "FAILED",
          check: "Device Response version must be 1.0 or greater",
          category: "DOCUMENT_FORMAT"
        });
        onCheck({
          status: dr.documents && dr.documents.length > 0 ? "PASSED" : "FAILED",
          check: "Device Response must include at least one document.",
          category: "DOCUMENT_FORMAT"
        });
        for (const document2 of dr.documents) {
          const { issuerAuth } = document2.issuerSigned;
          const { deviceKeyInfo } = issuerAuth.decodedPayload;
          await this.verifyIssuerSignature(issuerAuth, options.disableCertificateChainValidation, onCheck);
          await this.verifyDeviceSignature(document2.deviceSigned.deviceAuth, {
            deviceKeyCoseKey: deviceKeyInfo?.deviceKey,
            ephemeralPrivateKey: options.ephemeralReaderKey,
            sessionTranscriptBytes: options.encodedSessionTranscript,
            docType: document2.docType,
            nameSpaces: document2.deviceSigned.nameSpaces,
            onCheck
          });
          await this.verifyData(document2, onCheck);
        }
        return dr;
      }
      async getDiagnosticInformation(encodedDeviceResponse, options) {
        const dr = [];
        const decoded = await this.verify(encodedDeviceResponse, {
          ...options,
          onCheck: (check2) => dr.push(check2)
        });
        const document2 = decoded.documents[0];
        const issuerCert = document2?.issuerSigned.issuerAuth.x5chain && document2.issuerSigned.issuerAuth.x5chain.length > 0 && new x509_1.X509Certificate(document2.issuerSigned.issuerAuth.x5chain[0]);
        const attributes = (await Promise.all(Object.keys(document2.issuerSigned.nameSpaces).map(async (ns) => {
          const items = document2.issuerSigned.nameSpaces[ns];
          return Promise.all(items.map(async (item) => {
            const isValid = await item.isValid();
            return {
              ns,
              id: item.elementIdentifier,
              value: item.elementValue,
              isValid,
              matchCertificate: item.matchCertificate()
            };
          }));
        }))).flat();
        const deviceAttributes = Array.from(document2.deviceSigned.nameSpaces.entries()).map(([ns, items]) => {
          return Array.from(items.entries()).map(([id, value]) => {
            return {
              ns,
              id,
              value
            };
          });
        }).flat();
        let deviceKey;
        if (document2?.issuerSigned.issuerAuth) {
          const { deviceKeyInfo } = document2.issuerSigned.issuerAuth.decodedPayload;
          if (deviceKeyInfo?.deviceKey) {
            deviceKey = (0, cose_1.COSEKeyToJWK)(deviceKeyInfo.deviceKey);
          }
        }
        const disclosedAttributes = attributes.filter((attr) => attr.isValid).length;
        const totalAttributes = Array.from(document2.issuerSigned.issuerAuth.decodedPayload.valueDigests.entries()).reduce((prev, [, digests]) => prev + digests.size, 0);
        return {
          general: {
            version: decoded.version,
            type: "DeviceResponse",
            status: decoded.status,
            documents: decoded.documents.length
          },
          validityInfo: document2.issuerSigned.issuerAuth.decodedPayload.validityInfo,
          issuerCertificate: issuerCert ? {
            subjectName: issuerCert.subjectName.toString(),
            pem: issuerCert.toString(),
            notBefore: issuerCert.notBefore,
            notAfter: issuerCert.notAfter,
            serialNumber: issuerCert.serialNumber,
            thumbprint: buffer_1.Buffer.from(await issuerCert.getThumbprint(uncrypto_1.default)).toString("hex")
          } : void 0,
          issuerSignature: {
            alg: document2.issuerSigned.issuerAuth.algName,
            isValid: dr.filter((check2) => check2.category === "ISSUER_AUTH").every((check2) => check2.status === "PASSED"),
            reasons: dr.filter((check2) => check2.category === "ISSUER_AUTH" && check2.status === "FAILED").map((check2) => check2.reason ?? check2.check),
            digests: Object.fromEntries(Array.from(document2.issuerSigned.issuerAuth.decodedPayload.valueDigests.entries()).map(([ns, digests]) => [ns, digests.size]))
          },
          deviceKey: {
            jwk: deviceKey
          },
          deviceSignature: {
            alg: document2.deviceSigned.deviceAuth.deviceSignature?.algName ?? document2.deviceSigned.deviceAuth.deviceMac?.algName,
            isValid: dr.filter((check2) => check2.category === "DEVICE_AUTH").every((check2) => check2.status === "PASSED"),
            reasons: dr.filter((check2) => check2.category === "DEVICE_AUTH" && check2.status === "FAILED").map((check2) => check2.reason ?? check2.check)
          },
          dataIntegrity: {
            disclosedAttributes: `${disclosedAttributes} of ${totalAttributes}`,
            isValid: dr.filter((check2) => check2.category === "DATA_INTEGRITY").every((check2) => check2.status === "PASSED"),
            reasons: dr.filter((check2) => check2.category === "DATA_INTEGRITY" && check2.status === "FAILED").map((check2) => check2.reason ?? check2.check)
          },
          attributes,
          deviceAttributes
        };
      }
    };
    exports.DeviceResponseVerifier = DeviceResponseVerifier;
  }
});

// node_modules/mdl/lib/index.js
var require_lib = __commonJS({
  "node_modules/mdl/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataItem = exports.parseDeviceResponse = exports.DeviceResponseVerifier = void 0;
    var verify_1 = require_verify();
    Object.defineProperty(exports, "DeviceResponseVerifier", { enumerable: true, get: function() {
      return verify_1.DeviceResponseVerifier;
    } });
    var parser_1 = require_parser2();
    Object.defineProperty(exports, "parseDeviceResponse", { enumerable: true, get: function() {
      return parser_1.parse;
    } });
    var DataItem_1 = require_DataItem();
    Object.defineProperty(exports, "DataItem", { enumerable: true, get: function() {
      return DataItem_1.DataItem;
    } });
  }
});

// node_modules/base64url/dist/pad-string.js
var require_pad_string = __commonJS({
  "node_modules/base64url/dist/pad-string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function padString(input) {
      var segmentLength = 4;
      var stringLength = input.length;
      var diff = stringLength % segmentLength;
      if (!diff) {
        return input;
      }
      var position3 = stringLength;
      var padLength = segmentLength - diff;
      var paddedStringLength = stringLength + padLength;
      var buffer = Buffer.alloc(paddedStringLength);
      buffer.write(input);
      while (padLength--) {
        buffer.write("=", position3++);
      }
      return buffer.toString();
    }
    exports.default = padString;
  }
});

// node_modules/base64url/dist/base64url.js
var require_base64url = __commonJS({
  "node_modules/base64url/dist/base64url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pad_string_1 = require_pad_string();
    function encode4(input, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      if (Buffer.isBuffer(input)) {
        return fromBase64(input.toString("base64"));
      }
      return fromBase64(Buffer.from(input, encoding).toString("base64"));
    }
    function decode4(base64url2, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      return Buffer.from(toBase64(base64url2), "base64").toString(encoding);
    }
    function toBase64(base64url2) {
      base64url2 = base64url2.toString();
      return pad_string_1.default(base64url2).replace(/\-/g, "+").replace(/_/g, "/");
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBuffer(base64url2) {
      return Buffer.from(toBase64(base64url2), "base64");
    }
    var base64url = encode4;
    base64url.encode = encode4;
    base64url.decode = decode4;
    base64url.toBase64 = toBase64;
    base64url.fromBase64 = fromBase64;
    base64url.toBuffer = toBuffer;
    exports.default = base64url;
  }
});

// node_modules/base64url/index.js
var require_base64url2 = __commonJS({
  "node_modules/base64url/index.js"(exports, module) {
    module.exports = require_base64url().default;
    module.exports.default = module.exports;
  }
});

// node_modules/str2ab/dist/str2ab.js
var require_str2ab = __commonJS({
  "node_modules/str2ab/dist/str2ab.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var base64url_1 = __importDefault3(require_base64url2());
    function string2arraybuffer(str) {
      var buf = new ArrayBuffer(str.length * 2);
      var bufView = new Uint16Array(buf);
      for (var i = 0; i < str.length; i++) {
        bufView[i] = str.charCodeAt(i);
      }
      return buf;
    }
    function string2buffer(str) {
      return Buffer.from(str);
    }
    function string2base64url(str) {
      return base64url_1.default.encode(str);
    }
    function string2base64(str) {
      return base64url_1.default.toBase64(base64url_1.default.encode(str));
    }
    function arraybuffer2string(ab) {
      var uarr;
      if (ab.byteLength % 2 === 0) {
        uarr = new Uint16Array(ab);
      } else {
        uarr = new Uint8Array(ab);
      }
      var str = "";
      for (var i = 0; i < uarr.length; i++) {
        str += String.fromCharCode(uarr[i]);
      }
      return str;
    }
    function buffer2string(buffer) {
      return buffer.toString("utf8");
    }
    function base64url2arraybuffer(b64u) {
      var buf = base64url_1.default.toBuffer(b64u);
      return buffer2arraybuffer(buf);
    }
    function base64url2buffer(b64u) {
      return base64url_1.default.toBuffer(b64u);
    }
    function base64url2string(b64u) {
      return base64url_1.default.decode(b64u);
    }
    function base64url2base64(b64u) {
      return base64url_1.default.toBase64(b64u);
    }
    function arraybuffer2base64url(ab) {
      return base64url_1.default.encode(Buffer.from(ab), "utf8");
    }
    function buffer2base64url(buffer) {
      return base64url_1.default.encode(buffer, "utf8");
    }
    function arraybuffer2base64(ab) {
      return Buffer.from(ab).toString("base64");
    }
    function buffer2base64(buffer) {
      return buffer.toString("base64");
    }
    function base642arraybuffer(base64) {
      var buf = base64url_1.default.toBuffer(base64);
      return buffer2arraybuffer(buf);
    }
    function base642buffer(base64) {
      return base64url_1.default.toBuffer(base64);
    }
    function base642string(base64) {
      return base64url_1.default.decode(base64url_1.default.fromBase64(base64));
    }
    function base642base64url(base64) {
      return base64url_1.default.fromBase64(base64);
    }
    function buffer2arraybuffer(buffer) {
      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    }
    function arraybuffer2buffer(ab) {
      return Buffer.from(ab);
    }
    function isBase64url(input) {
      return /^[A-Za-z0-9-_]+$/.test(input);
    }
    function isBase64(input) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(input);
    }
    var str2ab2 = {
      string2arraybuffer,
      string2base64url,
      string2base64,
      string2buffer,
      arraybuffer2string,
      buffer2string,
      base64url2string,
      base64url2arraybuffer,
      base64url2base64,
      base64url2buffer,
      arraybuffer2base64url,
      buffer2base64url,
      arraybuffer2base64,
      buffer2base64,
      base642string,
      base642arraybuffer,
      base642base64url,
      base642buffer,
      buffer2arraybuffer,
      arraybuffer2buffer,
      isBase64url,
      isBase64
    };
    exports.default = str2ab2;
  }
});

// node_modules/str2ab/index.js
var require_str2ab2 = __commonJS({
  "node_modules/str2ab/index.js"(exports, module) {
    module.exports = require_str2ab().default;
    module.exports.default = module.exports;
  }
});

// src/lib/config.ts
var MDL_FIELDS = [
  { id: "family_name", required: true, encoding: "tsrt" },
  { id: "given_name", required: true, encoding: "tsrt" },
  { id: "birth_date", required: true, encoding: "full-date" },
  {
    id: "issue_date",
    required: true,
    encoding: "full-date"
    /* or tdate */
  },
  {
    id: "expiry_date",
    required: true,
    encoding: "full-date"
    /* or tdate */
  },
  { id: "issuing_country", required: true, encoding: "tstr" },
  { id: "authority", required: true, encoding: "tstr" },
  { id: "document_number", required: true, encoding: "tstr" },
  { id: "portrait", required: true, encoding: "bstr" },
  { id: "driving_privileges", required: true, encoding: "DrivingPrivileges" },
  { id: "un_distinguishing_sign", required: true, encoding: "tsrt" },
  // ISO/IEC 18013-1:2018, Annex F
  // Optional
  { id: "administrative_number", required: false, encoding: "tsrt" },
  { id: "sex", required: false, encoding: "uint" },
  // ISO/IEC 5218
  { id: "height", required: false, encoding: "uint" },
  // in cm
  { id: "weight", required: false, encoding: "uint" },
  // in kg
  { id: "eye_colour", required: false, encoding: "tstr" },
  // black, blue, brown, dichromatic, grey, green, hazel, maroon, pink, unknown
  { id: "hair_colour", required: false, encoding: "tstr" },
  // bald, black, blond, brown, grey, red, auburn, sandy, white, unknown
  { id: "resident_address", required: false, encoding: "tstr" },
  { id: "portrait_capture_date", required: false, encoding: "tdate" },
  { id: "age_in_years", required: false, encoding: "uint" },
  { id: "age_birth_year", required: false, encoding: "uint" },
  { id: "age_over_NN", required: false, encoding: "bool" },
  { id: "issuing_jurisdiction", required: false, encoding: "tstr" },
  // ISO 3166-2:2020, Clause 8
  { id: "nationality", required: false, encoding: "tstr" },
  // ISO 3166-1
  { id: "resident_city", required: false, encoding: "tstr" },
  { id: "resident_state", required: false, encoding: "tstr" },
  { id: "resident_postal_code", required: false, encoding: "tstr" },
  { id: "resident_country", required: false, encoding: "tstr" },
  { id: "biometric_template_xx", required: false, encoding: "bstr" },
  { id: "family_name_national_character", required: false, encoding: "tstr" }
];
var TAG_MAP = {
  birth_date: 1004,
  issue_date: 1004,
  expiry_date: 1004
};

// src/lib/cbor/index.ts
init_cbor_x();
var import_mdl = __toESM(require_lib());

// src/lib/cbor/StringDate.ts
init_cbor_x();
var StringDate = class {
  date;
  formattedDate;
  constructor(date) {
    this.date = date;
    this.formattedDate = this.date.toISOString().split(".")[0] + "Z";
  }
  toBuffer() {
    return cborEncode(this.formattedDate);
  }
};
addExtension2({
  Class: StringDate,
  tag: 0,
  encode: (instance, encode4) => encode4(instance.formattedDate),
  decode: (stringDate) => new Date(stringDate)
});

// src/lib/cbor/index.ts
var encoderDefaults = {
  tagUint8Array: false,
  useRecords: false,
  mapsAsObjects: false,
  // @ts-ignore
  useTag259ForMaps: false
};
addExtension2({
  Class: Date,
  tag: 1004,
  encode: (instance, encode4) => {
    const str = instance.toISOString().split("T")[0];
    return encode4(str);
  },
  decode: (val) => {
    return new Date(val);
  }
});
var cborDecode2 = (input, options = encoderDefaults) => {
  const params = { ...encoderDefaults, ...options, variableMapSize: true };
  const enc = new Encoder(params);
  return enc.decode(input);
};
var cborEncode = (obj, options = encoderDefaults) => {
  const params = { ...encoderDefaults, ...options, variableMapSize: true };
  const enc = new Encoder(params);
  return enc.encode(obj);
};

// src/lib/MDOC.ts
var blocker = {};
var MDOC = class _MDOC {
  defaultNamespace = "org.iso.18013.5.1";
  mdoc;
  attributes = {};
  static async from(data) {
    const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data, "hex");
    const mdoc = new _MDOC(_MDOC.decode(buffer), blocker);
    const proxy = new Proxy(mdoc, {
      get(target2, prop, receiver) {
        if (target2.hasOwnProperty(prop)) {
          return target2[prop];
        }
        if (target2.attributes.hasOwnProperty(prop)) {
          return target2.attributes[prop];
        }
        return void 0;
      }
    });
    return proxy;
  }
  static decode(data) {
    const mdoc = cborDecode2(data);
    return mdoc;
  }
  constructor(mdoc, b) {
    if (b !== blocker)
      throw new Error("Cannot use constructor directly. Use MDOC.from()");
    this.mdoc = mdoc;
    this.buildAttributeMap();
  }
  // TODO: how do we handle multiple mdoc.documents, if each one has the default namespace?
  buildAttributeMap() {
    const nsAttrs = this.mdoc?.get("documents")?.[0]?.get("issuerSigned")?.get("nameSpaces")?.get(this.defaultNamespace);
    if (!nsAttrs)
      throw new Error(`Document does not contain the core namespace "${this.defaultNamespace}"`);
    this.loadAttributes(this.defaultNamespace);
    const namespaces = this.mdoc?.get("documents")?.[0]?.get("issuerSigned")?.get("nameSpaces").keys();
    for (const ns of namespaces) {
      if (ns === this.defaultNamespace)
        continue;
      this.loadAttributes(ns);
    }
  }
  loadAttributes(namespace) {
    const nsAttrs = this.mdoc?.get("documents")?.[0]?.get("issuerSigned")?.get("nameSpaces")?.get(namespace);
    if (namespace === this.defaultNamespace) {
      for (const field of MDL_FIELDS) {
        const attributeName = field.id;
        const attributeValue = this.getElementValue(attributeName, nsAttrs);
        if (attributeValue) {
          this.attributes[attributeName] = attributeValue;
        }
      }
      for (let i = 1; i <= 150; i++) {
        const age = i < 10 ? `0${i}` : i;
        const attributeName = `age_over_${age}`;
        const attributeValue = this.getElementValue(attributeName, nsAttrs);
        if (attributeValue) {
          this.attributes[attributeName] = attributeValue;
        }
      }
    } else {
      for (const item of nsAttrs) {
        const attributeName = item.data?.get("elementIdentifier");
        const attributeValue = this.parseValue(item.data?.get("elementValue"));
        if (attributeValue) {
          this.attributes[attributeName] = attributeValue;
        }
      }
    }
  }
  getElementValue(key, list) {
    const item = list.find((i) => i.data?.get("elementIdentifier") === key);
    const value = item?.data?.get("elementValue");
    return this.parseValue(value);
  }
  parseValue(value) {
    if (Array.isArray(value)) {
      return value.map((item) => {
        return item instanceof Map ? Object.fromEntries(item) : item;
      });
    }
    return value instanceof Map ? Object.fromEntries(value) : value;
  }
};

// src/lib/MDOCBuilder.ts
init_browser();

// src/lib/cose/keyconverter/keyconvert.ts
var import_str2ab = __toESM(require_str2ab2());

// src/lib/cose/keyconverter/coseKey.ts
var COSEKeyParameterValue = class {
};
var COSEKeyType = class _COSEKeyType extends COSEKeyParameterValue {
  constructor(_name, _value, _description) {
    super();
    this._name = _name;
    this._value = _value;
    this._description = _description;
    _COSEKeyType._values.push(this);
  }
  static _values = [];
  static OKP = new _COSEKeyType("OKP", 1, "Octet Key Pair");
  static EC2 = new _COSEKeyType("EC2", 2, "Elliptic Curve Keys w/ x- and y-coordinate pair");
  static RSA = new _COSEKeyType("RSA", 3, "RSA Key");
  static SYMMETRIC = new _COSEKeyType("Symmetric", 4, "Symmetric Keys");
  static HSS_LMS = new _COSEKeyType("HSS-LMS", 5, "Public key for HSS/LMS hash-based digital signature");
  static WALNUT_DSA = new _COSEKeyType("WalnutDSA", 6, "WalnutDSA	public key");
  get name() {
    return this._name;
  }
  get value() {
    return this._value;
  }
  get description() {
    return this._description;
  }
  static values() {
    return _COSEKeyType._values;
  }
  static fromValue(value) {
    const found = _COSEKeyType.values().find((c) => {
      return c.value === value;
    });
    return found || null;
  }
  static fromName(name) {
    const found = _COSEKeyType.values().find((c) => {
      return c.name === name;
    });
    return found || null;
  }
};
var COSEKeyParameter = class {
};
var COSEKeyCommonParameter = class _COSEKeyCommonParameter extends COSEKeyParameter {
  constructor(_name, _label, _description) {
    super();
    this._name = _name;
    this._label = _label;
    this._description = _description;
    _COSEKeyCommonParameter._values.push(this);
  }
  static _values = [];
  static KTY = new _COSEKeyCommonParameter("kty", 1, "Identification of the key type");
  static KID = new _COSEKeyCommonParameter("kid", 2, "Key identification value -- match to kid in message");
  static ALG = new _COSEKeyCommonParameter("alg", 3, "Key usage restriction to this algorithm");
  static KEY_OPS = new _COSEKeyCommonParameter("key_ops", 4, "Restrict set of permissible operations");
  static BASE_IV = new _COSEKeyCommonParameter("Base IV", 5, "Base IV to be xor-ed with Partial IVs");
  get name() {
    return this._name;
  }
  get label() {
    return this._label;
  }
  get description() {
    return this._description;
  }
  static values() {
    return _COSEKeyCommonParameter._values;
  }
  static fromLabel(label) {
    const found = _COSEKeyCommonParameter.values().find((c) => {
      return c.label === label;
    });
    return found || null;
  }
  static fromName(name) {
    const found = _COSEKeyCommonParameter.values().find((c) => {
      return c.name === name;
    });
    return found || null;
  }
};
var COSEKeyTypeParameter = class _COSEKeyTypeParameter extends COSEKeyParameter {
  constructor(_keyType, _name, _label, _description) {
    super();
    this._keyType = _keyType;
    this._name = _name;
    this._label = _label;
    this._description = _description;
    _COSEKeyTypeParameter._values.push(this);
  }
  static _values = [];
  static OKP_CRV = new _COSEKeyTypeParameter(
    COSEKeyType.OKP,
    "crv",
    -1,
    'EC identifier - Taken from the "COSE Elliptic Curves" registry'
  );
  static OKP_X = new _COSEKeyTypeParameter(COSEKeyType.OKP, "x", -2, "x-coordinate");
  static OKP_D = new _COSEKeyTypeParameter(COSEKeyType.OKP, "d", -4, "Private key");
  static EC2_CRV = new _COSEKeyTypeParameter(
    COSEKeyType.EC2,
    "crv",
    -1,
    'EC identifier - Taken from the "COSE Elliptic Curves" registry'
  );
  static EC2_X = new _COSEKeyTypeParameter(COSEKeyType.EC2, "x", -2, "Public Key");
  static EC2_Y = new _COSEKeyTypeParameter(COSEKeyType.EC2, "y", -3, "y-coordinate");
  static EC2_D = new _COSEKeyTypeParameter(COSEKeyType.EC2, "d", -4, "Private key");
  static RSA_N = new _COSEKeyTypeParameter(COSEKeyType.RSA, "n", -1, "the RSA modulus n");
  static RSA_E = new _COSEKeyTypeParameter(COSEKeyType.RSA, "e", -2, "the RSA public exponent e");
  static RSA_D = new _COSEKeyTypeParameter(COSEKeyType.RSA, "d", -3, "the RSA private exponent d");
  static RSA_P = new _COSEKeyTypeParameter(COSEKeyType.RSA, "p", -4, "the prime factor p of n");
  static RSA_Q = new _COSEKeyTypeParameter(COSEKeyType.RSA, "q", -5, "the prime factor q of n");
  static RSA_DP = new _COSEKeyTypeParameter(COSEKeyType.RSA, "dP", -6, "dP is d mod (p - 1)");
  static RSA_DQ = new _COSEKeyTypeParameter(COSEKeyType.RSA, "dQ", -7, "dQ is d mod (q - 1)");
  static RSA_QINV = new _COSEKeyTypeParameter(
    COSEKeyType.RSA,
    "qInv",
    -8,
    "qInv is the CRT coefficient q^(-1) mod p"
  );
  static OTHER = new _COSEKeyTypeParameter(COSEKeyType.RSA, "other", -9, "other prime infos, an array");
  static R_I = new _COSEKeyTypeParameter(COSEKeyType.RSA, "r_i", -10, "a prime factor r_i of n, where i >= 3");
  static D_I = new _COSEKeyTypeParameter(COSEKeyType.RSA, "d_i", -11, "d_i = d mod (r_i - 1)");
  static T_I = new _COSEKeyTypeParameter(
    COSEKeyType.RSA,
    "t_i",
    -12,
    "the CRT coefficient t_i = (r_1 * r_2 * ... * r_(i-1))^(-1) mod r_i"
  );
  static SYMMETRIC_K = new _COSEKeyTypeParameter(COSEKeyType.SYMMETRIC, "k", -1, "Key Value");
  static PUB = new _COSEKeyTypeParameter(
    COSEKeyType.HSS_LMS,
    "pub",
    -1,
    "Public key for HSS/LMS hash-based digital signature"
  );
  static WALNUTRSA_N = new _COSEKeyTypeParameter(
    COSEKeyType.WALNUT_DSA,
    "N",
    -1,
    "Group and Matrix (NxN) size"
  );
  static WALNUTRSA_Q = new _COSEKeyTypeParameter(COSEKeyType.WALNUT_DSA, "q", -2, "Finite field F_q");
  static T_VALUES = new _COSEKeyTypeParameter(
    COSEKeyType.WALNUT_DSA,
    "t-values",
    -3,
    "List of T-values, entries in F_q"
  );
  static MATRIX_1 = new _COSEKeyTypeParameter(
    COSEKeyType.WALNUT_DSA,
    "matrix 1",
    -4,
    "NxN Matrix of entries in F_q in column-major form"
  );
  static PERMUTATION_1 = new _COSEKeyTypeParameter(
    COSEKeyType.WALNUT_DSA,
    "permutation",
    -5,
    "Permutation associated with matrix 1"
  );
  static MATRIX_2 = new _COSEKeyTypeParameter(
    COSEKeyType.WALNUT_DSA,
    "matrix 2",
    -6,
    "NxN Matrix of entries in F_q in column-major form"
  );
  get keyType() {
    return this._keyType;
  }
  get name() {
    return this._name;
  }
  get label() {
    return this._label;
  }
  get description() {
    return this._description;
  }
  static values() {
    return _COSEKeyTypeParameter._values;
  }
  static fromLabel(keyType, label) {
    const found = _COSEKeyTypeParameter.values().find((c) => {
      return c.keyType === keyType && c.label === label;
    });
    return found || null;
  }
  static fromName(keyType, name) {
    const found = _COSEKeyTypeParameter.values().find((c) => {
      return c.keyType === keyType && c.name === name;
    });
    return found || null;
  }
};
var COSEKeyOperationValue = class _COSEKeyOperationValue extends COSEKeyParameterValue {
  constructor(_name, _value, _description) {
    super();
    this._name = _name;
    this._value = _value;
    this._description = _description;
    _COSEKeyOperationValue._values.push(this);
  }
  static _values = [];
  static SIGN = new _COSEKeyOperationValue(
    "sign",
    1,
    "The key is used to create signatures.  Requires private key fields."
  );
  static VERIFY = new _COSEKeyOperationValue("verify", 2, "The key is used for verification of signatures.");
  static ENCRYPT = new _COSEKeyOperationValue("encrypt", 3, "The key is used for key transport encryption.");
  static DECRYPT = new _COSEKeyOperationValue(
    "decrypt",
    4,
    "The key is used for key transport decryption.  Requires private key fields."
  );
  static WRAP_KEY = new _COSEKeyOperationValue("wrap key", 5, "The key is used for key wrap encryption.");
  static UNWRAP_KEY = new _COSEKeyOperationValue(
    "unwrap key",
    6,
    "The key is used for key wrap decryption.  Requires private key fields."
  );
  static DERIVE_KEY = new _COSEKeyOperationValue(
    "derive key",
    7,
    "The key is used for deriving keys.  Requires private key fields."
  );
  static DERIVE_BITS = new _COSEKeyOperationValue(
    "derive bits",
    8,
    "The key is used for deriving bits not to be used as a key.  Requires private key fields."
  );
  static MAC_CREATE = new _COSEKeyOperationValue("MAC create", 9, "The key is used for creating MACs.");
  static MAC_VERIFY = new _COSEKeyOperationValue("MAC verify", 10, "The key is used for validating MACs.");
  get name() {
    return this._name;
  }
  get value() {
    return this._value;
  }
  get description() {
    return this._description;
  }
  static values() {
    return _COSEKeyOperationValue._values;
  }
  static fromValue(value) {
    const found = _COSEKeyOperationValue.values().find((c) => {
      return c.value === value;
    });
    return found || null;
  }
  static fromName(name) {
    const found = _COSEKeyOperationValue.values().find((c) => {
      return c.name === name;
    });
    return found || null;
  }
};
var COSEEllipticCurve = class _COSEEllipticCurve extends COSEKeyParameterValue {
  constructor(_name, _value, _keyType, _description) {
    super();
    this._name = _name;
    this._value = _value;
    this._keyType = _keyType;
    this._description = _description;
    _COSEEllipticCurve._values.push(this);
  }
  static _values = [];
  static P_256 = new _COSEEllipticCurve("P-256", 1, COSEKeyType.EC2, "NIST P-256 also known as secp256r1");
  static P_384 = new _COSEEllipticCurve("P-384", 2, COSEKeyType.EC2, "NIST P-384 also known as secp384r1");
  static P_512 = new _COSEEllipticCurve("P-512", 3, COSEKeyType.EC2, "NIST P-512 also known as secp512r1");
  static X25519 = new _COSEEllipticCurve("X25519", 4, COSEKeyType.OKP, "X25519 for use w/ ECDH only");
  static X448 = new _COSEEllipticCurve("X448", 5, COSEKeyType.OKP, "X448 for use w/ ECDH only");
  static ED25519 = new _COSEEllipticCurve("Ed25519", 6, COSEKeyType.OKP, "Ed25519 for use w/ EdDSA only");
  static ED448 = new _COSEEllipticCurve("Ed448", 7, COSEKeyType.OKP, "Ed448 for use w/ EdDSA only");
  static SECP256K1 = new _COSEEllipticCurve("secp256k1", 8, COSEKeyType.EC2, "SECG secp256k1 curve");
  get name() {
    return this._name;
  }
  get value() {
    return this._value;
  }
  get keyType() {
    return this._keyType;
  }
  get description() {
    return this._description;
  }
  static values() {
    return _COSEEllipticCurve._values;
  }
  static fromValue(keyType, value) {
    const found = _COSEEllipticCurve.values().find((c) => {
      return c.keyType === keyType && c.value === value;
    });
    return found || null;
  }
  static fromName(keyType, name) {
    const found = _COSEEllipticCurve.values().find((c) => {
      return c.keyType === keyType && c.name === name;
    });
    return found || null;
  }
};
var COSEAlgorithm = class _COSEAlgorithm extends COSEKeyParameterValue {
  constructor(_name, _value, _description, _nodeCryptoHashAlg) {
    super();
    this._name = _name;
    this._value = _value;
    this._description = _description;
    this._nodeCryptoHashAlg = _nodeCryptoHashAlg;
    _COSEAlgorithm._values.push(this);
  }
  static _values = [];
  static RS1 = new _COSEAlgorithm("RS1", -65535, "RSASSA-PKCS1-v1_5 using SHA-1", "sha1");
  static WALNUT_DSA = new _COSEAlgorithm("WalnutDSA", -260, "WalnutDSA signature", null);
  static RS512 = new _COSEAlgorithm("RS512", -259, "RSASSA-PKCS1-v1_5 using SHA-512", "sha512");
  static RS384 = new _COSEAlgorithm("RS384", -258, "RSASSA-PKCS1-v1_5 using SHA-384", "sha384");
  static RS256 = new _COSEAlgorithm("RS256", -257, "RSASSA-PKCS1-v1_5 using SHA-256", "sha256");
  static ES256K = new _COSEAlgorithm("ES256K", -47, "ECDSA using secp256k1 curve and SHA-256", "sha256");
  static HSS_LMS = new _COSEAlgorithm("HSS-LMS", -46, "HSS/LMS hash-based digital signature", null);
  static SHAKE256 = new _COSEAlgorithm("SHAKE256", -45, "SHAKE-256 512-bit Hash Value", null);
  static SHA_512 = new _COSEAlgorithm("SHA-512", -44, "SHA-2 512-bit Hash", null);
  static SHA_384 = new _COSEAlgorithm("SHA-384", -43, "SHA-2 384-bit Hash", null);
  static RSAES_OAEP_w_SHA_512 = new _COSEAlgorithm(
    "RSAES-OAEP w/ SHA-512",
    -42,
    "RSAES-OAEP w/ SHA-512",
    "sha512"
  );
  static RSAES_OAEP_w_SHA_256 = new _COSEAlgorithm(
    "RSAES-OAEP w/ SHA-256",
    -41,
    "RSAES-OAEP w/ SHA-256",
    "sha256"
  );
  static RSAES_OAEP_w_RFC8017_DEFAULT_PARAMETERS = new _COSEAlgorithm(
    "RSAES-OAEP w/ RFC 8017 default parameters",
    -40,
    "RSAES-OAEP w/ SHA-1",
    null
  );
  static PS512 = new _COSEAlgorithm("PS512", -39, "RSASSA-PSS w/ SHA-512", "sha512");
  static PS384 = new _COSEAlgorithm("PS384", -38, "RSASSA-PSS w/ SHA-384", "sha384");
  static PS256 = new _COSEAlgorithm("PS256", -37, "RSASSA-PSS w/ SHA-256", "sha256");
  static ES512 = new _COSEAlgorithm("ES512", -36, "ECDSA w/ SHA-512", "sha512");
  static ES384 = new _COSEAlgorithm("ES384", -35, "ECDSA w/ SHA-384", "sha384");
  static ECDH_SS_A256KW = new _COSEAlgorithm(
    "ECDH-SS + A256KW",
    -34,
    "ECDH SS w/ Concat KDF and AES Key Wrap w/ 256-bit key",
    null
  );
  static ECDH_SS_A192KW = new _COSEAlgorithm(
    "ECDH-SS + A256KW",
    -33,
    "ECDH SS w/ Concat KDF and AES Key Wrap w/ 192-bit key",
    null
  );
  static ECDH_SS_A128KW = new _COSEAlgorithm(
    "ECDH-SS + A128KW",
    -32,
    "ECDH SS w/ Concat KDF and AES Key Wrap w/ 128-bit key",
    null
  );
  static ECDH_ES_A256KW = new _COSEAlgorithm(
    "ECDH-ES + A256KW",
    -31,
    "ECDH ES w/ Concat KDF and AES Key Wrap w/ 256-bit key",
    null
  );
  static ECDH_ES_A192KW = new _COSEAlgorithm(
    "ECDH-ES + A192KW",
    -30,
    "ECDH ES w/ Concat KDF and AES Key Wrap w/ 192-bit key",
    null
  );
  static ECDH_ES_A128KW = new _COSEAlgorithm(
    "ECDH-ES + A128KW",
    -29,
    "ECDH ES w/ Concat KDF and AES Key Wrap w/ 128-bit key",
    null
  );
  static ECDH_SS_HKDF_512 = new _COSEAlgorithm(
    "ECDH-SS + HKDF-512",
    -28,
    "ECDH SS w/ HKDF - generate key directly",
    null
  );
  static ECDH_SS_HKDF_256 = new _COSEAlgorithm(
    "ECDH-SS + HKDF-256",
    -27,
    "ECDH SS w/ HKDF - generate key directly",
    null
  );
  static ECDH_ES_HKDF_512 = new _COSEAlgorithm(
    "ECDH-ES + HKDF-512",
    -26,
    "ECDH ES w/ HKDF - generate key directly",
    null
  );
  static ECDH_ES_HKDF_256 = new _COSEAlgorithm(
    "ECDH-ES + HKDF-256",
    -25,
    "ECDH ES w/ HKDF - generate key directly",
    null
  );
  static SHAKE128 = new _COSEAlgorithm("SHAKE128", -18, "SHAKE-128 512-bit Hash Value", null);
  static SHA_512_256 = new _COSEAlgorithm("SHA-512/256", -17, "SHA-2 512-bit Hash truncated to 256-bits", null);
  static SHA_256 = new _COSEAlgorithm("SHA-256", -16, "SHA-2 256-bit Hash", null);
  static SHA_256_64 = new _COSEAlgorithm("SHA-256/64", -15, "SHA-2 256-bit Hash truncated to 64-bits", null);
  static SHA_1 = new _COSEAlgorithm("SHA-1", -14, "SHA-1 Hash", null);
  static DIRECT_HKDF_AES_256 = new _COSEAlgorithm(
    "direct+HKDF-AES-256",
    -13,
    "Shared secret w/ AES-MAC 256-bit key",
    null
  );
  static DIRECT_HKDF_AES_128 = new _COSEAlgorithm(
    "direct+HKDF-AES-128",
    -12,
    "Shared secret w/ AES-MAC 128-bit key",
    null
  );
  static DIRECT_HKDF_SHA_512 = new _COSEAlgorithm(
    "direct+HKDF-SHA-512",
    -11,
    "Shared secret w/ HKDF and SHA-512",
    null
  );
  static DIRECT_HKDF_SHA_256 = new _COSEAlgorithm(
    "direct+HKDF-SHA-256",
    -10,
    "Shared secret w/ HKDF and SHA-256",
    null
  );
  static EdDSA = new _COSEAlgorithm("EdDSA", -8, "EdDSA", "sha512");
  static ES256 = new _COSEAlgorithm("ES256", -7, "ECDSA w/ SHA-256", "sha256");
  static DIRECT = new _COSEAlgorithm("direct", -6, "Direct use of CEK", null);
  static A256KW = new _COSEAlgorithm("A256KW", -5, "AES Key Wrap w/ 256-bit key", null);
  static A192KW = new _COSEAlgorithm("A192KW", -4, "AES Key Wrap w/ 192-bit key", null);
  static A128KW = new _COSEAlgorithm("A128KW", -3, "AES Key Wrap w/ 128-bit key", null);
  static A128GCM = new _COSEAlgorithm("A128GCM", 1, "AES-GCM mode w/ 128-bit key, 128-bit tag", null);
  static A192GCM = new _COSEAlgorithm("A192GCM", 2, "AES-GCM mode w/ 192-bit key, 128-bit tag", null);
  static A256GCM = new _COSEAlgorithm("A256GCM", 3, "AES-GCM mode w/ 256-bit key, 128-bit tag", null);
  static HMAC_256_64 = new _COSEAlgorithm("HMAC 256/64", 4, "HMAC w/ SHA-256 truncated to 64 bits", "sha256");
  static HMAC_256_256 = new _COSEAlgorithm("HMAC 256/256", 5, "HMAC w/ SHA-256", "sha256");
  static HMAC_384_384 = new _COSEAlgorithm("HMAC 384/384", 6, "HMAC w/ SHA-384", "sha384");
  static HMAC_512_512 = new _COSEAlgorithm("HMAC 512/512", 7, "HMAC w/ SHA-512", "sha512");
  static AES_CCM_16_64_128 = new _COSEAlgorithm(
    "AES-CCM-16-64-128",
    10,
    "AES-CCM mode 128-bit key, 64-bit tag, 13-byte nonce",
    null
  );
  static AES_CCM_16_64_256 = new _COSEAlgorithm(
    "AES-CCM-16-64-256",
    11,
    "AES-CCM mode 256-bit key, 64-bit tag, 13-byte nonce",
    null
  );
  static AES_CCM_64_64_128 = new _COSEAlgorithm(
    "AES-CCM-64-64-128",
    12,
    "AES-CCM mode 128-bit key, 64-bit tag, 7-byte nonce",
    null
  );
  static AES_CCM_64_64_256 = new _COSEAlgorithm(
    "AES-CCM-64-64-256",
    13,
    "AES-CCM mode 256-bit key, 64-bit tag, 7-byte nonce",
    null
  );
  static AES_MAC_128_64 = new _COSEAlgorithm("AES-MAC 128/64", 14, "AES-MAC 128-bit key, 64-bit tag", null);
  static AES_MAC_256_64 = new _COSEAlgorithm("AES-MAC 256/64", 15, "AES-MAC 256-bit key, 64-bit tag", null);
  static CHACHA20_POLY1305 = new _COSEAlgorithm(
    "ChaCha20/Poly1305",
    24,
    "ChaCha20/Poly1305 w/ 256-bit key, 128-bit tag",
    null
  );
  static AES_MAC_128_128 = new _COSEAlgorithm("AES-MAC 128/128", 25, "AES-MAC 128-bit key, 128-bit tag", null);
  static AES_MAC_256_128 = new _COSEAlgorithm("AES-MAC 256/128", 26, "AES-MAC 256-bit key, 128-bit tag", null);
  static AES_CCM_16_128_128 = new _COSEAlgorithm(
    "AES-CCM-16-128-128",
    30,
    "AES-CCM mode 128-bit key, 128-bit tag, 13-byte nonce",
    null
  );
  static AES_CCM_16_128_256 = new _COSEAlgorithm(
    "AES-CCM-16-128-256",
    31,
    "AES-CCM mode 256-bit key, 128-bit tag, 13-byte nonce",
    null
  );
  static AES_CCM_64_128_128 = new _COSEAlgorithm(
    "AES-CCM-64-128-128",
    32,
    "AES-CCM mode 128-bit key, 128-bit tag, 7-byte nonce",
    null
  );
  static AES_CCM_64_128_256 = new _COSEAlgorithm(
    "AES-CCM-64-128-256",
    33,
    "AES-CCM mode 256-bit key, 128-bit tag, 7-byte nonce",
    null
  );
  static IV_GENERATION = new _COSEAlgorithm(
    "IV-GENERATION",
    34,
    "For doing IV generation for symmetric algorithms.",
    null
  );
  get name() {
    return this._name;
  }
  get value() {
    return this._value;
  }
  get description() {
    return this._description;
  }
  get nodeCryptoHashAlg() {
    return this._nodeCryptoHashAlg;
  }
  static values() {
    return _COSEAlgorithm._values;
  }
  static fromValue(value) {
    const found = _COSEAlgorithm.values().find((c) => {
      return c.value === value;
    });
    return found || null;
  }
  static fromName(name) {
    const found = _COSEAlgorithm.values().find((c) => {
      return c.name === name;
    });
    return found || null;
  }
};
var COSEKeyParameterValueMapping = class _COSEKeyParameterValueMapping {
  constructor(_parameter, _value) {
    this._parameter = _parameter;
    this._value = _value;
    _COSEKeyParameterValueMapping._values.push(this);
  }
  static _values = [];
  static KTY = new _COSEKeyParameterValueMapping(COSEKeyCommonParameter.KTY, COSEKeyType);
  static ALG = new _COSEKeyParameterValueMapping(COSEKeyCommonParameter.ALG, COSEAlgorithm);
  static KEY_OPS = new _COSEKeyParameterValueMapping(COSEKeyCommonParameter.KEY_OPS, COSEKeyOperationValue);
  static OKP_CRV = new _COSEKeyParameterValueMapping(COSEKeyTypeParameter.OKP_CRV, COSEEllipticCurve);
  static EC2_CRV = new _COSEKeyParameterValueMapping(COSEKeyTypeParameter.EC2_CRV, COSEEllipticCurve);
  get parameter() {
    return this._parameter;
  }
  get value() {
    return this._value;
  }
  static values() {
    return _COSEKeyParameterValueMapping._values;
  }
  static fromParameter(parameter) {
    const found = _COSEKeyParameterValueMapping.values().find((c) => {
      return c.parameter == parameter;
    });
    return found || null;
  }
  fromParameterLabel(label, keyType) {
    const parameter = COSEKeyCommonParameter.fromLabel(label) || COSEKeyTypeParameter.fromLabel(keyType || COSEKeyType.OKP, label) || null;
    if (!parameter) {
      return null;
    }
    return _COSEKeyParameterValueMapping.fromParameter(parameter);
  }
  fromValueLabel(label) {
    if (this._value === COSEKeyType) {
      return COSEKeyType.fromValue(label);
    } else if (this._value === COSEKeyOperationValue) {
      return COSEKeyOperationValue.fromValue(label);
    } else if (this._value === COSEEllipticCurve) {
      if (this === _COSEKeyParameterValueMapping.OKP_CRV) {
        return COSEEllipticCurve.fromValue(COSEKeyType.OKP, label);
      } else if (this === _COSEKeyParameterValueMapping.EC2_CRV) {
        return COSEEllipticCurve.fromValue(COSEKeyType.EC2, label);
      }
    } else if (this._value === COSEAlgorithm) {
      return COSEAlgorithm.fromValue(label);
    }
    return null;
  }
  fromValueName(name) {
    if (this._value === COSEKeyType) {
      return COSEKeyType.fromName(name);
    } else if (this._value === COSEKeyOperationValue) {
      return COSEKeyOperationValue.fromName(name);
    } else if (this._value === COSEEllipticCurve) {
      if (this === _COSEKeyParameterValueMapping.OKP_CRV) {
        return COSEEllipticCurve.fromName(COSEKeyType.OKP, name);
      } else if (this === _COSEKeyParameterValueMapping.EC2_CRV) {
        return COSEEllipticCurve.fromName(COSEKeyType.EC2, name);
      }
    } else if (this._value === COSEAlgorithm) {
      return COSEAlgorithm.fromName(name);
    }
    return null;
  }
};

// src/lib/cose/keyconverter/joseKey.ts
var JSONWebKeyType = class _JSONWebKeyType {
  /**
   * Private constructor.
   *
   * @param _value key type.key type.
   * @param _description Key type description
   */
  constructor(_value, _description) {
    this._value = _value;
    this._description = _description;
    _JSONWebKeyType._values.push(this);
  }
  static _values = [];
  static EC = new _JSONWebKeyType("EC", "Elliptic Curve");
  static RSA = new _JSONWebKeyType("RSA", "RSA");
  static OCT = new _JSONWebKeyType("oct", "Octet sequence");
  static OKP = new _JSONWebKeyType("OKP", "Octet string key pairs");
  /**
   * Returns key type.
   *
   * @returns Key type
   */
  get value() {
    return this._value;
  }
  /**
   * Returns key type description.
   *
   * @returns Key type description
   */
  get description() {
    return this._description;
  }
  /**
   * Returns all JWK key type class.
   *
   * @returns All JWK key type class
   */
  static values() {
    return _JSONWebKeyType._values;
  }
  /**
   * Returns JWK key type class which has same key type to function's parameter.
   *
   * @param value Target key type
   * @returns JWK key type class, if not found returns null
   */
  static fromValue(value) {
    const found = _JSONWebKeyType.values().find((j) => {
      return j.value === value;
    });
    return found || null;
  }
};
var JSONWebSignatureAndEncryptionAlgorithm = class _JSONWebSignatureAndEncryptionAlgorithm {
  /**
   * Private constructor.
   *
   * @param _name Algorithm name
   * @param _description Algorithm description
   * @param _nodeCryptoHashAlg Node.js crypto module's algorithm name
   */
  constructor(_name, _description, _nodeCryptoHashAlg) {
    this._name = _name;
    this._description = _description;
    this._nodeCryptoHashAlg = _nodeCryptoHashAlg;
    _JSONWebSignatureAndEncryptionAlgorithm._values.push(this);
  }
  static _values = [];
  static HS256 = new _JSONWebSignatureAndEncryptionAlgorithm("HS256", "HMAC using SHA-256", "sha256");
  static HS384 = new _JSONWebSignatureAndEncryptionAlgorithm("HS384", "HMAC using SHA-384", "sha384");
  static HS512 = new _JSONWebSignatureAndEncryptionAlgorithm("HS512", "HMAC using SHA-512", "sha512");
  static RS256 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "RS256",
    "RSASSA-PKCS1-v1_5 using SHA-256",
    "sha256"
  );
  static RS384 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "RS384",
    "RSASSA-PKCS1-v1_5 using SHA-384",
    "sha384"
  );
  static RS512 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "RS512",
    "RSASSA-PKCS1-v1_5 using SHA-512",
    "sha512"
  );
  static ES256 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "ES256",
    "ECDSA using P-256 and SHA-256",
    "sha256"
  );
  static ES384 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "ES384",
    "ECDSA using P-384 and SHA-384",
    "sha384"
  );
  static ES512 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "ES512",
    "ECDSA using P-512 and SHA-512",
    "sha512"
  );
  static PS256 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "PS256",
    "RSASSA-PSS using SHA-256 and MGF1 with SHA-256",
    "sha256"
  );
  static PS384 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "PS384",
    "RSASSA-PSS using SHA-384 and MGF1 with SHA-384",
    "sha384"
  );
  static PS512 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "PS512",
    "RSASSA-PSS using SHA-512 and MGF1 with SHA-512",
    "sha512"
  );
  static NONE = new _JSONWebSignatureAndEncryptionAlgorithm(
    "none",
    "No digital signature or MAC performed",
    null
  );
  static RSA1_5 = new _JSONWebSignatureAndEncryptionAlgorithm("RSA1_5", "RSAES-PKCS1-v1_5", null);
  static RSA_OAEP = new _JSONWebSignatureAndEncryptionAlgorithm(
    "RSA-OAEP",
    "RSAES OAEP using default parameters",
    null
  );
  static RSA_OAEP_256 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "RSA-OAEP-256",
    "RSAES OAEP using SHA-256 and MGF1 with SHA-256",
    "sha256"
  );
  static A128KW = new _JSONWebSignatureAndEncryptionAlgorithm("A128KW", "AES Key Wrap using 128-bit key", null);
  static A192KW = new _JSONWebSignatureAndEncryptionAlgorithm("A192KW", "AES Key Wrap using 192-bit key", null);
  static A256KW = new _JSONWebSignatureAndEncryptionAlgorithm("A256KW", "AES Key Wrap using 256-bit key", null);
  static DIR = new _JSONWebSignatureAndEncryptionAlgorithm("dir", "Direct use of a shared symmetric key", null);
  static ECDH_ES = new _JSONWebSignatureAndEncryptionAlgorithm("ECDH-ES", "ECDH-ES using Concat KDF", null);
  static ECDH_ES_A128KW = new _JSONWebSignatureAndEncryptionAlgorithm(
    "ECDH-ES+A128KW",
    'ECDH-ES using Concat KDF and "A128KW" wrapping',
    null
  );
  static ECDH_ES_A192KW = new _JSONWebSignatureAndEncryptionAlgorithm(
    "ECDH-ES+A192KW",
    'ECDH-ES using Concat KDF and "A192KW" wrapping',
    null
  );
  static ECDH_ES_A256KW = new _JSONWebSignatureAndEncryptionAlgorithm(
    "ECDH-ES+A256KW",
    'ECDH-ES using Concat KDF and "A256KW" wrapping',
    null
  );
  static A128GCMKW = new _JSONWebSignatureAndEncryptionAlgorithm(
    "A128GCMKW",
    "Key wrapping with AES GCM using 128-bit key",
    null
  );
  static A192GCMKW = new _JSONWebSignatureAndEncryptionAlgorithm(
    "A192GCMKW",
    "Key wrapping with AES GCM using 192-bit key",
    null
  );
  static A256GCMKW = new _JSONWebSignatureAndEncryptionAlgorithm(
    "A256GCMKW",
    "Key wrapping with AES GCM using 256-bit key",
    null
  );
  static PBES2_HS256_A128KW = new _JSONWebSignatureAndEncryptionAlgorithm(
    "PBES2-HS256+A128KW",
    'PBES2 with HMAC SHA-256 and "A128KW" wrapping',
    null
  );
  static PBES2_HS384_A192KW = new _JSONWebSignatureAndEncryptionAlgorithm(
    "PBES2-HS384+A192KW",
    'PBES2 with HMAC SHA-384 and "A192KW" wrapping',
    null
  );
  static PBES2_HS512_A256KW = new _JSONWebSignatureAndEncryptionAlgorithm(
    "PBES2-HS512+A256KW",
    'PBES2 with HMAC SHA-512 and "A256KW" wrapping',
    null
  );
  static A128CBC_HS256 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "A128CBC-HS256",
    "AES_128_CBC_HMAC_SHA_256 authenticated encryption algorithm",
    null
  );
  static A192CBC_HS384 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "A192CBC-HS384",
    "AES_192_CBC_HMAC_SHA_384 authenticated encryption algorithm",
    null
  );
  static A256CBC_HS512 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "A256CBC-HS512",
    "AES_256_CBC_HMAC_SHA_512 authenticated encryption algorithm",
    null
  );
  static A128GCM = new _JSONWebSignatureAndEncryptionAlgorithm("A128GCM", "AES GCM using 128-bit key", null);
  static A192GCM = new _JSONWebSignatureAndEncryptionAlgorithm("A192GCM", "AES GCM using 192-bit key", null);
  static A256GCM = new _JSONWebSignatureAndEncryptionAlgorithm("A256GCM", "AES GCM using 256-bit key", null);
  static EdDSA = new _JSONWebSignatureAndEncryptionAlgorithm("EdDSA", "EdDSA signature algorithms", "sha512");
  static RS1 = new _JSONWebSignatureAndEncryptionAlgorithm("RS1", "RSASSA-PKCS1-v1_5 with SHA-1", "sha1");
  static RSA_OAEP_384 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "RSA-OAEP-384",
    "RSA-OAEP using SHA-384 and MGF1 with SHA-384",
    "sha384"
  );
  static RSA_OAEP_512 = new _JSONWebSignatureAndEncryptionAlgorithm(
    "RSA-OAEP-512",
    "RSA-OAEP using SHA-512 and MGF1 with SHA-512",
    "sha512"
  );
  static A128CBC = new _JSONWebSignatureAndEncryptionAlgorithm("A128CBC", "AES CBC using 128 bit key", null);
  static A192CBC = new _JSONWebSignatureAndEncryptionAlgorithm("A192CBC", "AES CBC using 192 bit key", null);
  static A256CBC = new _JSONWebSignatureAndEncryptionAlgorithm("A256CBC", "AES CBC using 256 bit key", null);
  static A128CTR = new _JSONWebSignatureAndEncryptionAlgorithm("A128CTR", "AES CTR using 128 bit key", null);
  static A192CTR = new _JSONWebSignatureAndEncryptionAlgorithm("A192CTR", "AES CTR using 192 bit key", null);
  static A256CTR = new _JSONWebSignatureAndEncryptionAlgorithm("A256CTR", "AES CTR using 256 bit key", null);
  static HS1 = new _JSONWebSignatureAndEncryptionAlgorithm("HS1", "HMAC using SHA-1", "sha1");
  static ES256K = new _JSONWebSignatureAndEncryptionAlgorithm(
    "ES256K",
    "ECDSA using secp256k1 curve and SHA-256",
    "sha256"
  );
  /**
   * Returns algorithm name.
   *
   * @returns Algorithm name
   */
  get name() {
    return this._name;
  }
  /**
   * Returns algorithm description.
   *
   * @returns Algorithm description
   */
  get description() {
    return this._description;
  }
  /**
   * Returns Node.js crypto module's algorithm name.
   *
   * @returns Node.js crypto module's algorithm name
   */
  get nodeCryptoHashAlg() {
    return this._nodeCryptoHashAlg;
  }
  /**
   * Returns all JSON Web Signature and Encryption Algorithms class.
   *
   * @returns All JSON Web Signature and Encryption Algorithms class
   */
  static values() {
    return _JSONWebSignatureAndEncryptionAlgorithm._values;
  }
  /**
   * Returns JSON Web Signature and Encryption Algorithms class which has same algorithm name to function's parameter.
   *
   * @param name Target algorithm name
   * @returns JSON Web Signature and Encryption Algorithms class, if not found returns null
   */
  static fromName(name) {
    const found = _JSONWebSignatureAndEncryptionAlgorithm.values().find((j) => {
      return j.name === name;
    });
    return found || null;
  }
};
var JSONWebKeyEllipticCurve = class _JSONWebKeyEllipticCurve {
  /**
   * Private constructor.
   *
   * @param _name Curve name
   * @param _description Curve description
   */
  constructor(_name, _description) {
    this._name = _name;
    this._description = _description;
    _JSONWebKeyEllipticCurve._values.push(this);
  }
  static _values = [];
  static P_256 = new _JSONWebKeyEllipticCurve("P-256", "P-256 Curve");
  static P_384 = new _JSONWebKeyEllipticCurve("P-384", "P-384 Curve");
  static P_521 = new _JSONWebKeyEllipticCurve("P-521", "P-521 Curve");
  static ED25519 = new _JSONWebKeyEllipticCurve("Ed25519", "Ed25519 signature algorithm key pairs");
  static ED448 = new _JSONWebKeyEllipticCurve("Ed448", "Ed448 signature algorithm key pairs");
  static X25519 = new _JSONWebKeyEllipticCurve("X25519", "X25519 function key pairs");
  static X448 = new _JSONWebKeyEllipticCurve("X448", "X448 function key pairs");
  static SECP256K1 = new _JSONWebKeyEllipticCurve("secp256k1", "SECG secp256k1 curve");
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  static values() {
    return _JSONWebKeyEllipticCurve._values;
  }
  static fromName(name) {
    const found = _JSONWebKeyEllipticCurve.values().find((j) => {
      return j.name === name;
    });
    return found || null;
  }
};
var JSONWebKeyParameter = class _JSONWebKeyParameter {
  constructor(_name, _description, _usedWith) {
    this._name = _name;
    this._description = _description;
    this._usedWith = _usedWith;
    _JSONWebKeyParameter._values.push(this);
  }
  static _values = [];
  static KTY = new _JSONWebKeyParameter("kty", "Key Type", [
    JSONWebKeyType.EC,
    JSONWebKeyType.RSA,
    JSONWebKeyType.OCT,
    JSONWebKeyType.OKP
  ]);
  static USE = new _JSONWebKeyParameter("use", "Public Key Use", [
    JSONWebKeyType.EC,
    JSONWebKeyType.RSA,
    JSONWebKeyType.OCT,
    JSONWebKeyType.OKP
  ]);
  static KEY_OPS = new _JSONWebKeyParameter("key_ops", "Key Operations", [
    JSONWebKeyType.EC,
    JSONWebKeyType.RSA,
    JSONWebKeyType.OCT,
    JSONWebKeyType.OKP
  ]);
  static ALG = new _JSONWebKeyParameter("alg", "Algorithm", [
    JSONWebKeyType.EC,
    JSONWebKeyType.RSA,
    JSONWebKeyType.OCT,
    JSONWebKeyType.OKP
  ]);
  static KID = new _JSONWebKeyParameter("kid", "Key ID", [
    JSONWebKeyType.EC,
    JSONWebKeyType.RSA,
    JSONWebKeyType.OCT,
    JSONWebKeyType.OKP
  ]);
  static X5U = new _JSONWebKeyParameter("x5u", "X.509 URL", [
    JSONWebKeyType.EC,
    JSONWebKeyType.RSA,
    JSONWebKeyType.OCT,
    JSONWebKeyType.OKP
  ]);
  static X5C = new _JSONWebKeyParameter("x5c", "X.509 Certificate Chain", [
    JSONWebKeyType.EC,
    JSONWebKeyType.RSA,
    JSONWebKeyType.OCT,
    JSONWebKeyType.OKP
  ]);
  static X5T = new _JSONWebKeyParameter("x5t", "X.509 Certificate SHA-1 Thumbprint", [
    JSONWebKeyType.EC,
    JSONWebKeyType.RSA,
    JSONWebKeyType.OCT,
    JSONWebKeyType.OKP
  ]);
  static X5T_SHARP_S256 = new _JSONWebKeyParameter("x5t#S256", "X.509 Certificate SHA-256 Thumbprint", [
    JSONWebKeyType.EC,
    JSONWebKeyType.RSA,
    JSONWebKeyType.OCT,
    JSONWebKeyType.OKP
  ]);
  static EC_CRV = new _JSONWebKeyParameter("crv", "Curve", [JSONWebKeyType.EC]);
  static EC_X = new _JSONWebKeyParameter("x", "X Coordinate", [JSONWebKeyType.EC]);
  static EC_Y = new _JSONWebKeyParameter("y", "Y Coordinate", [JSONWebKeyType.EC]);
  static EC_D = new _JSONWebKeyParameter("d", "ECC Private Key", [JSONWebKeyType.EC]);
  static N = new _JSONWebKeyParameter("n", "Modulus", [JSONWebKeyType.RSA]);
  static E = new _JSONWebKeyParameter("e", "Exponent", [JSONWebKeyType.RSA]);
  static RSA_D = new _JSONWebKeyParameter("d", "Private Exponent", [JSONWebKeyType.RSA]);
  static P = new _JSONWebKeyParameter("p", "First Prime Factor", [JSONWebKeyType.RSA]);
  static Q = new _JSONWebKeyParameter("q", "Second Prime Factor", [JSONWebKeyType.RSA]);
  static DP = new _JSONWebKeyParameter("dp", "First Factor CRT Exponent", [JSONWebKeyType.RSA]);
  static DQ = new _JSONWebKeyParameter("dq", "Second Factor CRT Exponent", [JSONWebKeyType.RSA]);
  static QI = new _JSONWebKeyParameter("qi", "First CRT Coefficient", [JSONWebKeyType.RSA]);
  static OTH = new _JSONWebKeyParameter("oth", "Other Primes Info", [JSONWebKeyType.RSA]);
  static K = new _JSONWebKeyParameter("k", "Key Value", [JSONWebKeyType.OCT]);
  static OKP_CRV = new _JSONWebKeyParameter("crv", "The subtype of key pair", [JSONWebKeyType.OKP]);
  static OKP_D = new _JSONWebKeyParameter("d", "The private key", [JSONWebKeyType.OKP]);
  static OKP_X = new _JSONWebKeyParameter("x", "The public key", [JSONWebKeyType.OKP]);
  static EXT = new _JSONWebKeyParameter("ext", "Extractable", [
    JSONWebKeyType.EC,
    JSONWebKeyType.RSA,
    JSONWebKeyType.OCT,
    JSONWebKeyType.OKP
  ]);
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  get usedWith() {
    return this._usedWith;
  }
  static values() {
    return _JSONWebKeyParameter._values;
  }
  static fromName(usedWith, name) {
    const found = _JSONWebKeyParameter.values().find((j) => {
      return j.usedWith.includes(usedWith) && j.name === name;
    });
    return found || null;
  }
};
var JSONWebKeyUse = class _JSONWebKeyUse {
  constructor(_value, _description) {
    this._value = _value;
    this._description = _description;
    _JSONWebKeyUse._values.push(this);
  }
  static _values = [];
  static SIG = new _JSONWebKeyUse("sig", "Digital Signature or MAC");
  static ENC = new _JSONWebKeyUse("enc", "Encryption");
  get value() {
    return this._value;
  }
  get description() {
    return this._description;
  }
  static values() {
    return _JSONWebKeyUse._values;
  }
  static fromValue(value) {
    const found = _JSONWebKeyUse.values().find((j) => {
      return j.value === value;
    });
    return found || null;
  }
};
var JSONWebKeyOperation = class _JSONWebKeyOperation {
  constructor(_value, _description) {
    this._value = _value;
    this._description = _description;
    _JSONWebKeyOperation._values.push(this);
  }
  static _values = [];
  static SIGN = new _JSONWebKeyOperation("sign", "Compute digital signature or MAC");
  static VERIFY = new _JSONWebKeyOperation("verify", "Verify digital signature or MAC");
  static ENCRYPT = new _JSONWebKeyOperation("encrypt", "Encrypt content");
  static DECRYPT = new _JSONWebKeyOperation(
    "decrypt",
    "Decrypt content and validate decryption, if applicable"
  );
  static WRAP_KEY = new _JSONWebKeyOperation("wrapKey", "Encrypt key");
  static UNWRAP_KEY = new _JSONWebKeyOperation(
    "unwrapKey",
    "Decrypt key and validate decryption, if applicable"
  );
  static DERIVE_KEY = new _JSONWebKeyOperation("deriveKey", "Derive key");
  static DERIVE_BITS = new _JSONWebKeyOperation("deriveBits", "Derive bits not to be used as a key");
  get value() {
    return this._value;
  }
  get description() {
    return this._description;
  }
  static values() {
    return _JSONWebKeyOperation._values;
  }
  static fromValue(value) {
    const found = _JSONWebKeyOperation.values().find((j) => {
      return j.value === value;
    });
    return found || null;
  }
};

// src/lib/cose/keyconverter/coseJoseMapping.ts
var KeyTypeMapping = class _KeyTypeMapping {
  constructor(_coseKeyType, _jsonWebKeyType) {
    this._coseKeyType = _coseKeyType;
    this._jsonWebKeyType = _jsonWebKeyType;
    _KeyTypeMapping._values.push(this);
  }
  static _values = [];
  static OKP = new _KeyTypeMapping(COSEKeyType.OKP, JSONWebKeyType.OKP);
  static EC2 = new _KeyTypeMapping(COSEKeyType.EC2, JSONWebKeyType.EC);
  static RSA = new _KeyTypeMapping(COSEKeyType.RSA, JSONWebKeyType.RSA);
  get coseKeyType() {
    return this._coseKeyType;
  }
  get jsonWebKeyType() {
    return this._jsonWebKeyType;
  }
  static values() {
    return _KeyTypeMapping._values;
  }
  static fromCOSEKeyType(coseKeyType) {
    const found = _KeyTypeMapping.values().find((m) => {
      return m.coseKeyType === coseKeyType;
    });
    if (found == null) {
      return null;
    }
    return found.jsonWebKeyType;
  }
  static fromCOSEKeyTypeValue(coseKeyTypeValue) {
    const found = _KeyTypeMapping.values().find((m) => {
      return m.coseKeyType.value === coseKeyTypeValue;
    });
    if (found == null) {
      return null;
    }
    return found.jsonWebKeyType;
  }
  static fromJSONWebKeyType(jsonWebKeyType) {
    const found = _KeyTypeMapping.values().find((m) => {
      return m.jsonWebKeyType === jsonWebKeyType;
    });
    if (found == null) {
      return null;
    }
    return found.coseKeyType;
  }
  static fromJSONWebKeyTypeValue(jsonWebKeyTypeValue) {
    const found = _KeyTypeMapping.values().find((m) => {
      return m.jsonWebKeyType.value === jsonWebKeyTypeValue;
    });
    if (found == null) {
      return null;
    }
    return found.coseKeyType;
  }
};
var KeyAlgorithmMapping = class _KeyAlgorithmMapping {
  constructor(_coseAlgorithm, _joseAlgorithm) {
    this._coseAlgorithm = _coseAlgorithm;
    this._joseAlgorithm = _joseAlgorithm;
    _KeyAlgorithmMapping._values.push(this);
  }
  static _values = [];
  static RS1 = new _KeyAlgorithmMapping(
    COSEAlgorithm.RS1,
    JSONWebSignatureAndEncryptionAlgorithm.RS1
  );
  static RS512 = new _KeyAlgorithmMapping(
    COSEAlgorithm.RS512,
    JSONWebSignatureAndEncryptionAlgorithm.RS512
  );
  static RS384 = new _KeyAlgorithmMapping(
    COSEAlgorithm.RS384,
    JSONWebSignatureAndEncryptionAlgorithm.RS384
  );
  static RS256 = new _KeyAlgorithmMapping(
    COSEAlgorithm.RS256,
    JSONWebSignatureAndEncryptionAlgorithm.RS256
  );
  static ES256K = new _KeyAlgorithmMapping(
    COSEAlgorithm.ES256K,
    JSONWebSignatureAndEncryptionAlgorithm.ES256K
  );
  static RSAES_OAEP_SHA512 = new _KeyAlgorithmMapping(
    COSEAlgorithm.RSAES_OAEP_w_SHA_512,
    JSONWebSignatureAndEncryptionAlgorithm.RSA_OAEP_512
  );
  static RSAES_OAEP_SHA256 = new _KeyAlgorithmMapping(
    COSEAlgorithm.RSAES_OAEP_w_SHA_256,
    JSONWebSignatureAndEncryptionAlgorithm.RSA_OAEP_256
  );
  static PS512 = new _KeyAlgorithmMapping(
    COSEAlgorithm.PS512,
    JSONWebSignatureAndEncryptionAlgorithm.PS512
  );
  static PS384 = new _KeyAlgorithmMapping(
    COSEAlgorithm.PS384,
    JSONWebSignatureAndEncryptionAlgorithm.PS384
  );
  static PS256 = new _KeyAlgorithmMapping(
    COSEAlgorithm.PS256,
    JSONWebSignatureAndEncryptionAlgorithm.PS256
  );
  static ES512 = new _KeyAlgorithmMapping(
    COSEAlgorithm.ES512,
    JSONWebSignatureAndEncryptionAlgorithm.ES512
  );
  static ES384 = new _KeyAlgorithmMapping(
    COSEAlgorithm.ES384,
    JSONWebSignatureAndEncryptionAlgorithm.ES384
  );
  static ECDH_ES_A256KW = new _KeyAlgorithmMapping(
    COSEAlgorithm.ECDH_ES_A256KW,
    JSONWebSignatureAndEncryptionAlgorithm.ECDH_ES_A256KW
  );
  static ECDH_ES_A192KW = new _KeyAlgorithmMapping(
    COSEAlgorithm.ECDH_ES_A192KW,
    JSONWebSignatureAndEncryptionAlgorithm.ECDH_ES_A192KW
  );
  static ECDH_ES_A128KW = new _KeyAlgorithmMapping(
    COSEAlgorithm.ECDH_ES_A128KW,
    JSONWebSignatureAndEncryptionAlgorithm.ECDH_ES_A128KW
  );
  static EdDSA = new _KeyAlgorithmMapping(
    COSEAlgorithm.EdDSA,
    JSONWebSignatureAndEncryptionAlgorithm.EdDSA
  );
  static ES256 = new _KeyAlgorithmMapping(
    COSEAlgorithm.ES256,
    JSONWebSignatureAndEncryptionAlgorithm.ES256
  );
  static DIRECT = new _KeyAlgorithmMapping(
    COSEAlgorithm.DIRECT,
    JSONWebSignatureAndEncryptionAlgorithm.DIR
  );
  static A256KW = new _KeyAlgorithmMapping(
    COSEAlgorithm.A256KW,
    JSONWebSignatureAndEncryptionAlgorithm.A256KW
  );
  static A192KW = new _KeyAlgorithmMapping(
    COSEAlgorithm.A192KW,
    JSONWebSignatureAndEncryptionAlgorithm.A192KW
  );
  static A128KW = new _KeyAlgorithmMapping(
    COSEAlgorithm.A128KW,
    JSONWebSignatureAndEncryptionAlgorithm.A128KW
  );
  static A128GCM = new _KeyAlgorithmMapping(
    COSEAlgorithm.A128GCM,
    JSONWebSignatureAndEncryptionAlgorithm.A128GCM
  );
  static A192GCM = new _KeyAlgorithmMapping(
    COSEAlgorithm.A192GCM,
    JSONWebSignatureAndEncryptionAlgorithm.A192GCM
  );
  static A256GCM = new _KeyAlgorithmMapping(
    COSEAlgorithm.A256GCM,
    JSONWebSignatureAndEncryptionAlgorithm.A256GCM
  );
  get coseAlgorithm() {
    return this._coseAlgorithm;
  }
  get joseAlgorithm() {
    return this._joseAlgorithm;
  }
  static values() {
    return _KeyAlgorithmMapping._values;
  }
  static fromCOSEAlgorithm(coseAlgorithm) {
    const found = _KeyAlgorithmMapping.values().find((m) => {
      return m.coseAlgorithm === coseAlgorithm;
    });
    if (found == null) {
      return null;
    }
    return found.joseAlgorithm;
  }
  static fromCOSEAlgorithmValue(coseAlgorithmValue) {
    const found = _KeyAlgorithmMapping.values().find((m) => {
      return m.coseAlgorithm.value === coseAlgorithmValue;
    });
    if (found == null) {
      return null;
    }
    return found.joseAlgorithm;
  }
  static fromJoseAlgorithm(joseAlgorithm) {
    const found = _KeyAlgorithmMapping.values().find((m) => {
      return m.joseAlgorithm === joseAlgorithm;
    });
    if (found == null) {
      return null;
    }
    return found.coseAlgorithm;
  }
  static fromJoseAlgorithmName(joseAlgorithmName) {
    const found = _KeyAlgorithmMapping.values().find((m) => {
      return m.joseAlgorithm.name === joseAlgorithmName;
    });
    if (found == null) {
      return null;
    }
    return found.coseAlgorithm;
  }
};
var KeyParameterMapping = class _KeyParameterMapping {
  constructor(_coseKeyParameter, _jsonWebKeyParameter) {
    this._coseKeyParameter = _coseKeyParameter;
    this._jsonWebKeyParameter = _jsonWebKeyParameter;
    _KeyParameterMapping._values.push(this);
  }
  static _values = [];
  static KTY = new _KeyParameterMapping(COSEKeyCommonParameter.KTY, JSONWebKeyParameter.KTY);
  static KID = new _KeyParameterMapping(COSEKeyCommonParameter.KID, JSONWebKeyParameter.KID);
  static ALG = new _KeyParameterMapping(COSEKeyCommonParameter.ALG, JSONWebKeyParameter.ALG);
  static KEY_OPS = new _KeyParameterMapping(
    COSEKeyCommonParameter.KEY_OPS,
    JSONWebKeyParameter.KEY_OPS
  );
  static OKP_CRV = new _KeyParameterMapping(
    COSEKeyTypeParameter.OKP_CRV,
    JSONWebKeyParameter.OKP_CRV
  );
  static OKP_X = new _KeyParameterMapping(
    COSEKeyTypeParameter.OKP_X,
    JSONWebKeyParameter.OKP_X
  );
  static OKP_D = new _KeyParameterMapping(
    COSEKeyTypeParameter.OKP_D,
    JSONWebKeyParameter.OKP_D
  );
  static EC2_CRV = new _KeyParameterMapping(
    COSEKeyTypeParameter.EC2_CRV,
    JSONWebKeyParameter.EC_CRV
  );
  static EC2_X = new _KeyParameterMapping(COSEKeyTypeParameter.EC2_X, JSONWebKeyParameter.EC_X);
  static EC2_Y = new _KeyParameterMapping(COSEKeyTypeParameter.EC2_Y, JSONWebKeyParameter.EC_Y);
  static EC2_D = new _KeyParameterMapping(COSEKeyTypeParameter.EC2_D, JSONWebKeyParameter.EC_D);
  static RSA_N = new _KeyParameterMapping(COSEKeyTypeParameter.RSA_N, JSONWebKeyParameter.N);
  static RSA_E = new _KeyParameterMapping(COSEKeyTypeParameter.RSA_E, JSONWebKeyParameter.E);
  static RSA_D = new _KeyParameterMapping(
    COSEKeyTypeParameter.RSA_D,
    JSONWebKeyParameter.RSA_D
  );
  static RSA_P = new _KeyParameterMapping(COSEKeyTypeParameter.RSA_P, JSONWebKeyParameter.P);
  static RSA_Q = new _KeyParameterMapping(COSEKeyTypeParameter.RSA_Q, JSONWebKeyParameter.Q);
  static RSA_DP = new _KeyParameterMapping(COSEKeyTypeParameter.RSA_DP, JSONWebKeyParameter.DP);
  static RSA_DQ = new _KeyParameterMapping(COSEKeyTypeParameter.RSA_DQ, JSONWebKeyParameter.DQ);
  static OTHER = new _KeyParameterMapping(COSEKeyTypeParameter.OTHER, JSONWebKeyParameter.OTH);
  get coseKeyParameter() {
    return this._coseKeyParameter;
  }
  get jsonWebKeyParameter() {
    return this._jsonWebKeyParameter;
  }
  static values() {
    return _KeyParameterMapping._values;
  }
  static fromCOSEKeyParameter(coseKeyParameter) {
    const found = _KeyParameterMapping.values().find((m) => {
      return m.coseKeyParameter === coseKeyParameter;
    });
    if (found == null) {
      return null;
    }
    return found.jsonWebKeyParameter;
  }
  static fromCOSEKeyParameterLabel(coseKeyParameterLabel) {
    const found = _KeyParameterMapping.values().find((m) => {
      return m.coseKeyParameter.label === coseKeyParameterLabel;
    });
    if (found == null) {
      return null;
    }
    return found.jsonWebKeyParameter;
  }
  static fromJSONWebKeyParameter(jsonWebKeyParameter) {
    const found = _KeyParameterMapping.values().find((m) => {
      return m.jsonWebKeyParameter === jsonWebKeyParameter;
    });
    if (found == null) {
      return null;
    }
    return found.coseKeyParameter;
  }
  static fromJSONWebKeyParameterName(jsonWebKeyParameterName) {
    const found = _KeyParameterMapping.values().find((m) => {
      return m.jsonWebKeyParameter.name === jsonWebKeyParameterName;
    });
    if (found == null) {
      return null;
    }
    return found.coseKeyParameter;
  }
};
var KeyOperationMapping = class _KeyOperationMapping {
  constructor(_coseKeyOperation, _jsonWebKeyOperation) {
    this._coseKeyOperation = _coseKeyOperation;
    this._jsonWebKeyOperation = _jsonWebKeyOperation;
    _KeyOperationMapping._values.push(this);
  }
  static _values = [];
  static SIGN = new _KeyOperationMapping(COSEKeyOperationValue.SIGN, JSONWebKeyOperation.SIGN);
  static VERIFY = new _KeyOperationMapping(
    COSEKeyOperationValue.VERIFY,
    JSONWebKeyOperation.VERIFY
  );
  static ENCRYPT = new _KeyOperationMapping(
    COSEKeyOperationValue.ENCRYPT,
    JSONWebKeyOperation.ENCRYPT
  );
  static DECRYPT = new _KeyOperationMapping(
    COSEKeyOperationValue.DECRYPT,
    JSONWebKeyOperation.DECRYPT
  );
  static WRAP_KEY = new _KeyOperationMapping(
    COSEKeyOperationValue.WRAP_KEY,
    JSONWebKeyOperation.WRAP_KEY
  );
  static UNWRAP_KEY = new _KeyOperationMapping(
    COSEKeyOperationValue.UNWRAP_KEY,
    JSONWebKeyOperation.UNWRAP_KEY
  );
  static DERIVE_KEY = new _KeyOperationMapping(
    COSEKeyOperationValue.DERIVE_KEY,
    JSONWebKeyOperation.DERIVE_KEY
  );
  static DERIVE_BITS = new _KeyOperationMapping(
    COSEKeyOperationValue.DERIVE_BITS,
    JSONWebKeyOperation.DERIVE_BITS
  );
  get coseKeyOperation() {
    return this._coseKeyOperation;
  }
  get jsonWebKeyOperation() {
    return this._jsonWebKeyOperation;
  }
  static values() {
    return _KeyOperationMapping._values;
  }
  static fromCOSEKeyOperation(coseKeyOperation) {
    const found = _KeyOperationMapping.values().find((m) => {
      return m.coseKeyOperation === coseKeyOperation;
    });
    if (found == null) {
      return null;
    }
    return found.jsonWebKeyOperation;
  }
  static fromCOSEKeyOperationValue(coseKeyOperationValue) {
    const found = _KeyOperationMapping.values().find((m) => {
      return m.coseKeyOperation.value === coseKeyOperationValue;
    });
    if (found == null) {
      return null;
    }
    return found.jsonWebKeyOperation;
  }
  static fromJSONWebKeyOperation(jsonWebKeyOperation) {
    const found = _KeyOperationMapping.values().find((m) => {
      return m.jsonWebKeyOperation === jsonWebKeyOperation;
    });
    if (found == null) {
      return null;
    }
    return found.coseKeyOperation;
  }
  static fromJSONWebKeyOperationValue(jsonWebKeyOperationValue) {
    const found = _KeyOperationMapping.values().find((m) => {
      return m.jsonWebKeyOperation.value === jsonWebKeyOperationValue;
    });
    if (found == null) {
      return null;
    }
    return found.coseKeyOperation;
  }
};
var EllipticCurveMapping = class _EllipticCurveMapping {
  constructor(_coseEllipticCurve, _jsonWebKeyEllipticCurve) {
    this._coseEllipticCurve = _coseEllipticCurve;
    this._jsonWebKeyEllipticCurve = _jsonWebKeyEllipticCurve;
    _EllipticCurveMapping._values.push(this);
  }
  static _values = [];
  static P_256 = new _EllipticCurveMapping(
    COSEEllipticCurve.P_256,
    JSONWebKeyEllipticCurve.P_256
  );
  static P_384 = new _EllipticCurveMapping(
    COSEEllipticCurve.P_384,
    JSONWebKeyEllipticCurve.P_384
  );
  static P_512 = new _EllipticCurveMapping(
    COSEEllipticCurve.P_512,
    JSONWebKeyEllipticCurve.P_521
  );
  static X25519 = new _EllipticCurveMapping(
    COSEEllipticCurve.X25519,
    JSONWebKeyEllipticCurve.X25519
  );
  static X448 = new _EllipticCurveMapping(COSEEllipticCurve.X448, JSONWebKeyEllipticCurve.X448);
  static ED25519 = new _EllipticCurveMapping(
    COSEEllipticCurve.ED25519,
    JSONWebKeyEllipticCurve.ED25519
  );
  static ED448 = new _EllipticCurveMapping(
    COSEEllipticCurve.ED448,
    JSONWebKeyEllipticCurve.ED448
  );
  static SECP256K1 = new _EllipticCurveMapping(
    COSEEllipticCurve.SECP256K1,
    JSONWebKeyEllipticCurve.SECP256K1
  );
  get coseEllipticCurve() {
    return this._coseEllipticCurve;
  }
  get jsonWebKeyEllipticCurve() {
    return this._jsonWebKeyEllipticCurve;
  }
  static values() {
    return _EllipticCurveMapping._values;
  }
  static fromCOSEEllipticCurve(coseEllipticCurve) {
    const found = _EllipticCurveMapping.values().find((m) => {
      return m.coseEllipticCurve === coseEllipticCurve;
    });
    if (found == null) {
      return null;
    }
    return found.jsonWebKeyEllipticCurve;
  }
  static fromCOSEEllipticCurveValue(coseEllipticCurveValue) {
    const found = _EllipticCurveMapping.values().find((m) => {
      return m.coseEllipticCurve.value === coseEllipticCurveValue;
    });
    if (found == null) {
      return null;
    }
    return found.jsonWebKeyEllipticCurve;
  }
  static fromJSONWebKeyEllipticCurve(jsonWebKeyEllipticCurve) {
    const found = _EllipticCurveMapping.values().find((m) => {
      return m.jsonWebKeyEllipticCurve === jsonWebKeyEllipticCurve;
    });
    if (found == null) {
      return null;
    }
    return found.coseEllipticCurve;
  }
  static fromJSONWebKeyEllipticCurveName(jsonWebKeyEllipticCurveValue) {
    const found = _EllipticCurveMapping.values().find((m) => {
      return m.jsonWebKeyEllipticCurve.name === jsonWebKeyEllipticCurveValue;
    });
    if (found == null) {
      return null;
    }
    return found.coseEllipticCurve;
  }
};

// src/lib/cose/keyconverter/utils.ts
function convertJoseCoseValue(parameterValue) {
  if (parameterValue instanceof JSONWebKeyType) {
    return KeyTypeMapping.fromJSONWebKeyType(parameterValue);
  } else if (parameterValue instanceof JSONWebKeyEllipticCurve) {
    return EllipticCurveMapping.fromJSONWebKeyEllipticCurve(parameterValue);
  } else if (parameterValue instanceof JSONWebKeyUse) {
    return parameterValue;
  } else if (parameterValue instanceof JSONWebKeyOperation) {
    return KeyOperationMapping.fromJSONWebKeyOperation(parameterValue);
  } else if (parameterValue instanceof JSONWebSignatureAndEncryptionAlgorithm) {
    return KeyAlgorithmMapping.fromJoseAlgorithm(parameterValue);
  }
  return null;
}

// src/lib/cose/keyconverter/keyconvert.ts
var BUFFER_TYPE_COSE_KEY_PARAMETER_NAME = [
  "kid",
  "Base IV",
  "x",
  "d",
  "y",
  "n",
  "e",
  "p",
  "q",
  "dP",
  "dQ",
  "qInv",
  "r_i",
  "d_i",
  "t_i",
  "k",
  "pub"
];
function jwk2cose(jwk) {
  const keyTypeValue = jwk.kty;
  if (!keyTypeValue) {
    throw new Error('jwk does not have "kty".');
  }
  const keyType = JSONWebKeyType.fromValue(keyTypeValue);
  if (keyType == null) {
    throw new Error("Cannot convert key type.");
  }
  const coseMap = /* @__PURE__ */ new Map();
  for (const [key, value] of Object.entries(jwk)) {
    const keyParameter = findJSONWebKeyParameterFromName(key, keyType);
    const coseKeyParameter = keyParameter != null ? convertJoseCoseKey(keyParameter) : null;
    if (coseKeyParameter == null) {
      continue;
    }
    const parameterValue = typeof value === "string" ? findJSONWebKeyParameterValueFromValue(value) : null;
    const coseParameterValue = parameterValue != null ? convertJoseCoseValue(parameterValue) : null;
    if (coseParameterValue != null) {
      coseMap.set(Number(coseKeyParameter.label), coseParameterValue.value);
    } else {
      if (typeof value === "string" && /[a-zA-Z0-9\-_]+/.test(value) && BUFFER_TYPE_COSE_KEY_PARAMETER_NAME.includes(coseKeyParameter.name)) {
        coseMap.set(Number(coseKeyParameter.label), import_str2ab.default.base64url2buffer(value));
      } else {
        coseMap.set(Number(coseKeyParameter.label), value);
      }
    }
  }
  return coseMap;
}
function findJSONWebKeyParameterFromName(name, keyType) {
  return JSONWebKeyParameter.fromName(keyType, name);
}
function convertJoseCoseKey(keyParameter) {
  return KeyParameterMapping.fromJSONWebKeyParameter(keyParameter);
}
function findJSONWebKeyParameterValueFromValue(value) {
  if (typeof value !== "string") {
    return null;
  }
  const param = JSONWebKeyType.fromValue(value) || JSONWebKeyEllipticCurve.fromName(value) || JSONWebKeyUse.fromValue(value) || JSONWebKeyOperation.fromValue(value) || JSONWebSignatureAndEncryptionAlgorithm.fromName(value);
  return param;
}

// src/lib/utils.ts
function maybeEncodeValue(key, value) {
  const tag = TAG_MAP[key];
  if (!tag)
    return value;
  if (tag === 1004)
    return new Date(value);
  throw new Error(`Unknown tag "${tag}"`);
}
function fromPEM(pem) {
  const base64 = pem.replace(/-{5}(BEGIN|END) .*-{5}/gm, "").replace(/\s/gm, "");
  return Buffer.from(base64, "base64");
}
function jwk2COSE_Key(jwk) {
  const coseMap = jwk2cose(jwk);
  return coseMap;
}

// src/lib/cose/index.ts
init_browser2();
var createCoseSignature = async (protectedHeaders, unprotectedHeaders, payload, key) => {
  const sign1 = await Sign1.sign(protectedHeaders, unprotectedHeaders, payload, key);
  const tes = sign1.getContentForEncoding();
  return sign1.getContentForEncoding();
};

// src/lib/crypto/web/webcrypto.ts
var webcrypto_default3 = crypto;

// src/lib/crypto/web/web.ts
function getRandomBytes(len) {
  return webcrypto_default3.getRandomValues(new Uint8Array(len));
}
async function hash(data, algo) {
  return new Uint8Array(await webcrypto_default3.subtle.digest(algo, data));
}

// src/lib/MDOCBuilder.ts
var MDOCBuilder = class {
  defaultDocType = "org.iso.18013.5.1.mDL";
  defaultNamespace = "org.iso.18013.5.1";
  digestAlgo = "SHA-256";
  namespaces = /* @__PURE__ */ new Set();
  mapOfDigests = {};
  mapOfHashes = {};
  issuerCertificatePem;
  issuerPrivateKeyPem;
  devicePublicKey;
  constructor(issuerCertificatePem, issuerPrivateKeyPem, devicePublicKey) {
    this.issuerCertificatePem = issuerCertificatePem;
    this.issuerPrivateKeyPem = issuerPrivateKeyPem;
    this.devicePublicKey = devicePublicKey;
  }
  async addNameSpace(namespace, values) {
    if (namespace === this.defaultNamespace) {
      this.validateValues(values);
    }
    this.namespaces.add(namespace);
    this.mapOfDigests[namespace] = {};
    this.mapOfHashes[namespace] = /* @__PURE__ */ new Map();
    let digestCounter = 0;
    for (const [key, value] of Object.entries(values)) {
      const { itemBytes, hash: hash2 } = await this.processAttribute(key, value, digestCounter);
      this.mapOfDigests[namespace][digestCounter] = itemBytes;
      this.mapOfHashes[namespace].set(digestCounter, hash2);
      digestCounter++;
      if (key === "birth_date") {
        const ageInYears = this.getAgeInYears(value);
        {
          const over21 = ageInYears >= 21;
          const { itemBytes: itemBytes2, hash: hash3 } = await this.processAttribute("age_over_21", over21, digestCounter);
          this.mapOfDigests[namespace][digestCounter] = itemBytes2;
          this.mapOfHashes[namespace].set(digestCounter, hash3);
          digestCounter++;
        }
        {
          const { itemBytes: itemBytes2, hash: hash3 } = await this.processAttribute(
            `age_over_${Math.floor(ageInYears)}`,
            true,
            digestCounter
          );
          this.mapOfDigests[namespace][digestCounter] = itemBytes2;
          this.mapOfHashes[namespace].set(digestCounter, hash3);
          digestCounter++;
        }
      }
    }
  }
  async save() {
    const issuerAuth = await this.buildMSO();
    const nameSpaces = {};
    for (const ns of this.namespaces.values()) {
      nameSpaces[ns] = [];
      for (const [_, val] of Object.entries(this.mapOfDigests[ns])) {
        nameSpaces[ns].push(val);
      }
    }
    const mdl = {
      version: "1.0",
      documents: [
        {
          docType: this.defaultDocType,
          issuerSigned: {
            nameSpaces,
            issuerAuth
          }
        }
      ],
      status: 0
    };
    const mdlCbor = cborEncode(mdl);
    return mdlCbor;
  }
  /**  ---- Internal ----  */
  async processAttribute(key, value, digestID) {
    const salt = getRandomBytes(32);
    const encodedValue = maybeEncodeValue(key, value);
    const digest2 = {
      digestID,
      random: salt,
      elementIdentifier: key,
      elementValue: encodedValue
    };
    const itemBytes = import_mdl.DataItem.fromData(digest2);
    const hash2 = await this.hashDigest(itemBytes);
    return { itemBytes, hash: hash2 };
  }
  async hashDigest(itemBytes) {
    const encoded = cborEncode(itemBytes);
    const sha256Hash = await hash(encoded, this.digestAlgo);
    return sha256Hash;
  }
  validateValues(values) {
  }
  formatDate(date) {
    return date.toISOString().split(".")[0] + "Z";
  }
  async buildMSO() {
    const issuerPrivateKey = await importPKCS8(this.issuerPrivateKeyPem, "");
    const devicePublicKeyJwk = await exportJWK(this.devicePublicKey);
    const issuerPublicKeyBuffer = fromPEM(this.issuerCertificatePem);
    const utcNow = /* @__PURE__ */ new Date();
    const expTime = /* @__PURE__ */ new Date();
    expTime.setFullYear(expTime.getFullYear() + 4);
    const signedDate = new StringDate(utcNow);
    const validFromDate = new StringDate(utcNow);
    const validUntilDate = new StringDate(expTime);
    const deviceKey = jwk2COSE_Key(devicePublicKeyJwk);
    const mso = {
      version: "1.0",
      digestAlgorithm: this.digestAlgo,
      valueDigests: this.mapOfHashes,
      deviceKeyInfo: {
        deviceKey
      },
      docType: this.defaultDocType,
      validityInfo: {
        signed: signedDate,
        validFrom: validFromDate,
        validUntil: validUntilDate
      }
    };
    const msoCbor = cborEncode(import_mdl.DataItem.fromData(mso));
    const protectedHeader = { alg: "ES256" };
    const unprotectedHeader = { kid: "11", x5chain: [issuerPublicKeyBuffer] };
    return createCoseSignature(protectedHeader, unprotectedHeader, msoCbor, issuerPrivateKey);
  }
  /**
   * This is not a proper way to calculate year diff, only used as quick demo.
   * Does not take into account time zones, leap years, and other weird date things
   */
  getAgeInYears(birth) {
    const birthDate = new Date(birth);
    const today = /* @__PURE__ */ new Date();
    const ONE_YEAR_MILLI = 1e3 * 60 * 60 * 24 * 365;
    const age = (today.getTime() - birthDate.getTime()) / ONE_YEAR_MILLI;
    return age;
  }
};

// src/lib/DeviceResponse.ts
var DOC_TYPE = "org.iso.18013.5.1.mDL";
var DeviceResponse = class _DeviceResponse {
  mdoc;
  pd;
  handover;
  useMac = true;
  devicePrivateKey;
  readerPublicKey;
  deviceResponseJson;
  deviceResponseCbor;
  static from(mdoc) {
    return new _DeviceResponse(mdoc);
  }
  constructor(mdoc) {
    this.mdoc = mdoc;
  }
  usingPresentationDefinition(pd) {
    this.pd = pd;
    return this;
  }
  usingHandover(handover) {
    this.handover = handover;
    return this;
  }
  authenticateWithMac(readerPublicKey, devicePrivateKey) {
    throw new Error("Not implemented");
    this.readerPublicKey = readerPublicKey;
    this.devicePrivateKey = devicePrivateKey;
    this.useMac = true;
    return this;
  }
  authenticateWithSignature(devicePrivateKey) {
    this.devicePrivateKey = devicePrivateKey;
    this.useMac = false;
    return this;
  }
  async generate() {
    if (!this.pd)
      throw new Error("Must provide a presentation definition with .usingPresentationDefinition()");
    if (!this.handover)
      throw new Error("Must provide handover data with .usingHandover()");
    const inputDescriptor = this.pd.input_descriptors.find((id) => id.id === DOC_TYPE);
    if (!inputDescriptor)
      throw new Error(
        `The presentation definition does not include an input descriptor for the default DocType "${DOC_TYPE}"`
      );
    if (this.pd.input_descriptors.length > 1) {
      console.warn(
        `Presentation definition includes input_descriptors for unsupported DocTypes. Only "${DOC_TYPE}" is supported`
      );
    }
    const { doc } = await this.handleInputDescriptor(inputDescriptor);
    this.deviceResponseJson = {
      version: "1.0",
      documents: [doc],
      status: 0
    };
    this.deviceResponseCbor = await cborEncode(this.deviceResponseJson);
    return this.deviceResponseCbor;
  }
  async handleInputDescriptor(id) {
    const mdocDocument = (this.mdoc.mdoc?.get("documents") || []).find((d) => d.get("docType") === id.id);
    if (!mdocDocument) {
      throw new Error(`The mdoc does not have a document with DocType "${id.id}"`);
    }
    const nameSpaces = await this.prepareNamespaces(id, mdocDocument);
    const doc = {
      docType: mdocDocument.get("docType"),
      issuerSigned: {
        nameSpaces,
        issuerAuth: mdocDocument.get("issuerSigned")?.get("issuerAuth")
      },
      deviceSigned: await this.getdeviceSigned(mdocDocument.get("docType"))
    };
    return { doc };
  }
  /**
   * empty for now, but if we wanted to later, this is where we can
   * add processing for device data
   */
  async getDeviceNameSpaceBytes() {
    return import_mdl.DataItem.fromData(/* @__PURE__ */ new Map());
  }
  async getdeviceSigned(docType) {
    const sessionTranscript = [
      null,
      // deviceEngagementBytes
      null,
      // eReaderKeyBytes,
      this.handover
    ];
    const deviceAuthentication = [
      "DeviceAuthentication",
      sessionTranscript,
      docType,
      await this.getDeviceNameSpaceBytes()
    ];
    const deviceAuthenticationBytes = cborEncode(import_mdl.DataItem.fromData(deviceAuthentication));
    const deviceSigned = {
      nameSpaces: await this.getDeviceNameSpaceBytes(),
      deviceAuth: this.useMac ? await this.getDeviceAuthMac(deviceAuthenticationBytes) : await this.getDeviceAuthSign(deviceAuthenticationBytes)
    };
    return deviceSigned;
  }
  async getDeviceAuthMac(data) {
    if (!this.devicePrivateKey)
      throw new Error("Missing devicePrivateKey");
    if (!this.readerPublicKey)
      throw new Error("Missing readerPublicKey");
    const ephemeralPrivateKey = "";
    const ephemeralPublicKey = "";
    return {
      deviceMac: "todo"
    };
  }
  async getDeviceAuthSign(cborData) {
    if (!this.devicePrivateKey)
      throw new Error("Missing devicePrivateKey");
    const protectedHeader = { alg: "ES256" };
    const unprotectedHeader = { kid: "11" };
    const signedCbor = await createCoseSignature(
      protectedHeader,
      unprotectedHeader,
      Buffer.from(cborData),
      this.devicePrivateKey
    );
    return {
      deviceSignature: signedCbor
    };
  }
  async prepareNamespaces(id, mdocDocument) {
    const requestedFields = id.constraints.fields;
    const nameSpaces = {};
    for await (const field of requestedFields) {
      const result = await this.prepareDigest(field.path, mdocDocument);
      if (!result) {
        console.log(`No matching field found for ${field.path}`);
        continue;
      }
      const { nameSpace, digest: digest2 } = result;
      if (!nameSpaces[nameSpace])
        nameSpaces[nameSpace] = [];
      nameSpaces[nameSpace].push(digest2);
    }
    return nameSpaces;
  }
  /**
   * path looks like this: "$['org.iso.18013.5.1']['family_name']"
   * the regex creates two groups with contents between "['" and "']"
   * the second entry in each group contains the result without the "'[" or "']"
   */
  async prepareDigest(paths, mdocDocument) {
    for (const path of paths) {
      const [[_1, nameSpace], [_2, elementIdentifier]] = [...path.matchAll(/\['(.*?)'\]/g)];
      if (!nameSpace)
        throw new Error(`Failed to parse namespace from path "${path}"`);
      if (!elementIdentifier)
        throw new Error(`Failed to parse elementIdentifier from path "${path}"`);
      const nsAttrs = mdocDocument.get("issuerSigned")?.get("nameSpaces")?.get(nameSpace) || [];
      const digest2 = nsAttrs.find((d) => d.data?.get("elementIdentifier") === elementIdentifier);
      if (elementIdentifier.startsWith("age_over_")) {
        return this.handleAgeOverNN(elementIdentifier, nameSpace, nsAttrs);
      }
      if (digest2)
        return {
          nameSpace,
          digest: digest2
        };
    }
    return null;
  }
  handleAgeOverNN(request, nameSpace, attributes) {
    const ageOverList = attributes.map((a, i) => {
      const data = a.data;
      const key = data.get("elementIdentifier");
      const value = data.get("elementValue");
      return { key, value, index: i };
    }).filter((i) => i.key.startsWith("age_over_")).map((i) => ({
      nn: parseInt(i.key.replace("age_over_", "")),
      ...i
    })).sort((a, b) => a.nn - b.nn);
    const reqNN = parseInt(request.replace("age_over_", ""));
    let item;
    item = ageOverList.filter((i) => i.value === true && i.nn >= reqNN)?.[0];
    if (!item) {
      item = ageOverList.sort((a, b) => b.nn - a.nn).filter((i) => i.value === false && i.nn <= reqNN)?.[0];
    }
    if (!item) {
      return null;
    }
    return {
      nameSpace,
      digest: attributes[item.index]
    };
  }
};
export {
  DeviceResponse,
  MDOC,
  MDOCBuilder
};
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

pvtsutils/build/index.js:
  (*!
   * MIT License
   * 
   * Copyright (c) 2017-2022 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

pvutils/build/utils.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

asn1js/build/index.js:
  (*!
   * Copyright (c) 2014, GMO GlobalSign
   * Copyright (c) 2015-2022, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the copyright holder nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@peculiar/x509/build/x509.cjs.js:
  (*!
   * MIT License
   * 
   * Copyright (c) Peculiar Ventures. All rights reserved.
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

pkijs/build/index.js:
  (*!
   * Copyright (c) 2014, GlobalSign
   * Copyright (c) 2015-2019, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the {organization} nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
